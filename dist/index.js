"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);

// node_modules/@actions/core/lib/utils.js
var require_utils = __commonJS({
  "node_modules/@actions/core/lib/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.toCommandProperties = exports2.toCommandValue = void 0;
    function toCommandValue(input) {
      return input == null ? "" : typeof input == "string" || input instanceof String ? input : JSON.stringify(input);
    }
    exports2.toCommandValue = toCommandValue;
    function toCommandProperties(annotationProperties) {
      return Object.keys(annotationProperties).length ? {
        title: annotationProperties.title,
        file: annotationProperties.file,
        line: annotationProperties.startLine,
        endLine: annotationProperties.endLine,
        col: annotationProperties.startColumn,
        endColumn: annotationProperties.endColumn
      } : {};
    }
    exports2.toCommandProperties = toCommandProperties;
  }
});

// node_modules/@actions/core/lib/command.js
var require_command = __commonJS({
  "node_modules/@actions/core/lib/command.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k);
      var desc = Object.getOwnPropertyDescriptor(m, k);
      (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = { enumerable: !0, get: function() {
        return m[k];
      } }), Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: !0, value: v });
    } : function(o, v) {
      o.default = v;
    }), __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) k !== "default" && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
      return __setModuleDefault(result, mod), result;
    };
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.issue = exports2.issueCommand = void 0;
    var os = __importStar(require("os")), utils_1 = require_utils();
    function issueCommand(command, properties, message) {
      let cmd = new Command(command, properties, message);
      process.stdout.write(cmd.toString() + os.EOL);
    }
    exports2.issueCommand = issueCommand;
    function issue(name2, message = "") {
      issueCommand(name2, {}, message);
    }
    exports2.issue = issue;
    var CMD_STRING = "::", Command = class {
      constructor(command, properties, message) {
        command || (command = "missing.command"), this.command = command, this.properties = properties, this.message = message;
      }
      toString() {
        let cmdStr = CMD_STRING + this.command;
        if (this.properties && Object.keys(this.properties).length > 0) {
          cmdStr += " ";
          let first = !0;
          for (let key in this.properties)
            if (this.properties.hasOwnProperty(key)) {
              let val = this.properties[key];
              val && (first ? first = !1 : cmdStr += ",", cmdStr += `${key}=${escapeProperty(val)}`);
            }
        }
        return cmdStr += `${CMD_STRING}${escapeData(this.message)}`, cmdStr;
      }
    };
    function escapeData(s) {
      return (0, utils_1.toCommandValue)(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A");
    }
    function escapeProperty(s) {
      return (0, utils_1.toCommandValue)(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/:/g, "%3A").replace(/,/g, "%2C");
    }
  }
});

// node_modules/@actions/core/lib/file-command.js
var require_file_command = __commonJS({
  "node_modules/@actions/core/lib/file-command.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k);
      var desc = Object.getOwnPropertyDescriptor(m, k);
      (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = { enumerable: !0, get: function() {
        return m[k];
      } }), Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: !0, value: v });
    } : function(o, v) {
      o.default = v;
    }), __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) k !== "default" && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
      return __setModuleDefault(result, mod), result;
    };
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.prepareKeyValueMessage = exports2.issueFileCommand = void 0;
    var crypto = __importStar(require("crypto")), fs11 = __importStar(require("fs")), os = __importStar(require("os")), utils_1 = require_utils();
    function issueFileCommand(command, message) {
      let filePath = process.env[`GITHUB_${command}`];
      if (!filePath)
        throw new Error(`Unable to find environment variable for file command ${command}`);
      if (!fs11.existsSync(filePath))
        throw new Error(`Missing file at path: ${filePath}`);
      fs11.appendFileSync(filePath, `${(0, utils_1.toCommandValue)(message)}${os.EOL}`, {
        encoding: "utf8"
      });
    }
    exports2.issueFileCommand = issueFileCommand;
    function prepareKeyValueMessage(key, value) {
      let delimiter = `ghadelimiter_${crypto.randomUUID()}`, convertedValue = (0, utils_1.toCommandValue)(value);
      if (key.includes(delimiter))
        throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
      if (convertedValue.includes(delimiter))
        throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
      return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;
    }
    exports2.prepareKeyValueMessage = prepareKeyValueMessage;
  }
});

// node_modules/@actions/http-client/lib/proxy.js
var require_proxy = __commonJS({
  "node_modules/@actions/http-client/lib/proxy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.checkBypass = exports2.getProxyUrl = void 0;
    function getProxyUrl(reqUrl) {
      let usingSsl = reqUrl.protocol === "https:";
      if (checkBypass(reqUrl))
        return;
      let proxyVar = usingSsl ? process.env.https_proxy || process.env.HTTPS_PROXY : process.env.http_proxy || process.env.HTTP_PROXY;
      if (proxyVar)
        try {
          return new DecodedURL(proxyVar);
        } catch {
          if (!proxyVar.startsWith("http://") && !proxyVar.startsWith("https://"))
            return new DecodedURL(`http://${proxyVar}`);
        }
      else
        return;
    }
    exports2.getProxyUrl = getProxyUrl;
    function checkBypass(reqUrl) {
      if (!reqUrl.hostname)
        return !1;
      let reqHost = reqUrl.hostname;
      if (isLoopbackAddress(reqHost))
        return !0;
      let noProxy = process.env.no_proxy || process.env.NO_PROXY || "";
      if (!noProxy)
        return !1;
      let reqPort;
      reqUrl.port ? reqPort = Number(reqUrl.port) : reqUrl.protocol === "http:" ? reqPort = 80 : reqUrl.protocol === "https:" && (reqPort = 443);
      let upperReqHosts = [reqUrl.hostname.toUpperCase()];
      typeof reqPort == "number" && upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
      for (let upperNoProxyItem of noProxy.split(",").map((x) => x.trim().toUpperCase()).filter((x) => x))
        if (upperNoProxyItem === "*" || upperReqHosts.some((x) => x === upperNoProxyItem || x.endsWith(`.${upperNoProxyItem}`) || upperNoProxyItem.startsWith(".") && x.endsWith(`${upperNoProxyItem}`)))
          return !0;
      return !1;
    }
    exports2.checkBypass = checkBypass;
    function isLoopbackAddress(host) {
      let hostLower = host.toLowerCase();
      return hostLower === "localhost" || hostLower.startsWith("127.") || hostLower.startsWith("[::1]") || hostLower.startsWith("[0:0:0:0:0:0:0:1]");
    }
    var DecodedURL = class extends URL {
      constructor(url, base) {
        super(url, base), this._decodedUsername = decodeURIComponent(super.username), this._decodedPassword = decodeURIComponent(super.password);
      }
      get username() {
        return this._decodedUsername;
      }
      get password() {
        return this._decodedPassword;
      }
    };
  }
});

// node_modules/tunnel/lib/tunnel.js
var require_tunnel = __commonJS({
  "node_modules/tunnel/lib/tunnel.js"(exports2) {
    "use strict";
    var net = require("net"), tls = require("tls"), http = require("http"), https = require("https"), events = require("events"), assert3 = require("assert"), util = require("util");
    exports2.httpOverHttp = httpOverHttp;
    exports2.httpsOverHttp = httpsOverHttp;
    exports2.httpOverHttps = httpOverHttps;
    exports2.httpsOverHttps = httpsOverHttps;
    function httpOverHttp(options) {
      var agent = new TunnelingAgent(options);
      return agent.request = http.request, agent;
    }
    function httpsOverHttp(options) {
      var agent = new TunnelingAgent(options);
      return agent.request = http.request, agent.createSocket = createSecureSocket, agent.defaultPort = 443, agent;
    }
    function httpOverHttps(options) {
      var agent = new TunnelingAgent(options);
      return agent.request = https.request, agent;
    }
    function httpsOverHttps(options) {
      var agent = new TunnelingAgent(options);
      return agent.request = https.request, agent.createSocket = createSecureSocket, agent.defaultPort = 443, agent;
    }
    function TunnelingAgent(options) {
      var self2 = this;
      self2.options = options || {}, self2.proxyOptions = self2.options.proxy || {}, self2.maxSockets = self2.options.maxSockets || http.Agent.defaultMaxSockets, self2.requests = [], self2.sockets = [], self2.on("free", function(socket, host, port, localAddress) {
        for (var options2 = toOptions(host, port, localAddress), i = 0, len = self2.requests.length; i < len; ++i) {
          var pending = self2.requests[i];
          if (pending.host === options2.host && pending.port === options2.port) {
            self2.requests.splice(i, 1), pending.request.onSocket(socket);
            return;
          }
        }
        socket.destroy(), self2.removeSocket(socket);
      });
    }
    util.inherits(TunnelingAgent, events.EventEmitter);
    TunnelingAgent.prototype.addRequest = function(req, host, port, localAddress) {
      var self2 = this, options = mergeOptions({ request: req }, self2.options, toOptions(host, port, localAddress));
      if (self2.sockets.length >= this.maxSockets) {
        self2.requests.push(options);
        return;
      }
      self2.createSocket(options, function(socket) {
        socket.on("free", onFree), socket.on("close", onCloseOrRemove), socket.on("agentRemove", onCloseOrRemove), req.onSocket(socket);
        function onFree() {
          self2.emit("free", socket, options);
        }
        function onCloseOrRemove(err) {
          self2.removeSocket(socket), socket.removeListener("free", onFree), socket.removeListener("close", onCloseOrRemove), socket.removeListener("agentRemove", onCloseOrRemove);
        }
      });
    };
    TunnelingAgent.prototype.createSocket = function(options, cb) {
      var self2 = this, placeholder = {};
      self2.sockets.push(placeholder);
      var connectOptions = mergeOptions({}, self2.proxyOptions, {
        method: "CONNECT",
        path: options.host + ":" + options.port,
        agent: !1,
        headers: {
          host: options.host + ":" + options.port
        }
      });
      options.localAddress && (connectOptions.localAddress = options.localAddress), connectOptions.proxyAuth && (connectOptions.headers = connectOptions.headers || {}, connectOptions.headers["Proxy-Authorization"] = "Basic " + new Buffer(connectOptions.proxyAuth).toString("base64")), debug("making CONNECT request");
      var connectReq = self2.request(connectOptions);
      connectReq.useChunkedEncodingByDefault = !1, connectReq.once("response", onResponse), connectReq.once("upgrade", onUpgrade), connectReq.once("connect", onConnect), connectReq.once("error", onError), connectReq.end();
      function onResponse(res) {
        res.upgrade = !0;
      }
      function onUpgrade(res, socket, head) {
        process.nextTick(function() {
          onConnect(res, socket, head);
        });
      }
      function onConnect(res, socket, head) {
        if (connectReq.removeAllListeners(), socket.removeAllListeners(), res.statusCode !== 200) {
          debug(
            "tunneling socket could not be established, statusCode=%d",
            res.statusCode
          ), socket.destroy();
          var error = new Error("tunneling socket could not be established, statusCode=" + res.statusCode);
          error.code = "ECONNRESET", options.request.emit("error", error), self2.removeSocket(placeholder);
          return;
        }
        if (head.length > 0) {
          debug("got illegal response body from proxy"), socket.destroy();
          var error = new Error("got illegal response body from proxy");
          error.code = "ECONNRESET", options.request.emit("error", error), self2.removeSocket(placeholder);
          return;
        }
        return debug("tunneling connection has established"), self2.sockets[self2.sockets.indexOf(placeholder)] = socket, cb(socket);
      }
      function onError(cause) {
        connectReq.removeAllListeners(), debug(
          `tunneling socket could not be established, cause=%s
`,
          cause.message,
          cause.stack
        );
        var error = new Error("tunneling socket could not be established, cause=" + cause.message);
        error.code = "ECONNRESET", options.request.emit("error", error), self2.removeSocket(placeholder);
      }
    };
    TunnelingAgent.prototype.removeSocket = function(socket) {
      var pos2 = this.sockets.indexOf(socket);
      if (pos2 !== -1) {
        this.sockets.splice(pos2, 1);
        var pending = this.requests.shift();
        pending && this.createSocket(pending, function(socket2) {
          pending.request.onSocket(socket2);
        });
      }
    };
    function createSecureSocket(options, cb) {
      var self2 = this;
      TunnelingAgent.prototype.createSocket.call(self2, options, function(socket) {
        var hostHeader = options.request.getHeader("host"), tlsOptions = mergeOptions({}, self2.options, {
          socket,
          servername: hostHeader ? hostHeader.replace(/:.*$/, "") : options.host
        }), secureSocket = tls.connect(0, tlsOptions);
        self2.sockets[self2.sockets.indexOf(socket)] = secureSocket, cb(secureSocket);
      });
    }
    function toOptions(host, port, localAddress) {
      return typeof host == "string" ? {
        host,
        port,
        localAddress
      } : host;
    }
    function mergeOptions(target) {
      for (var i = 1, len = arguments.length; i < len; ++i) {
        var overrides = arguments[i];
        if (typeof overrides == "object")
          for (var keys = Object.keys(overrides), j = 0, keyLen = keys.length; j < keyLen; ++j) {
            var k = keys[j];
            overrides[k] !== void 0 && (target[k] = overrides[k]);
          }
      }
      return target;
    }
    var debug;
    process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG) ? debug = function() {
      var args = Array.prototype.slice.call(arguments);
      typeof args[0] == "string" ? args[0] = "TUNNEL: " + args[0] : args.unshift("TUNNEL:"), console.error.apply(console, args);
    } : debug = function() {
    };
    exports2.debug = debug;
  }
});

// node_modules/tunnel/index.js
var require_tunnel2 = __commonJS({
  "node_modules/tunnel/index.js"(exports2, module2) {
    module2.exports = require_tunnel();
  }
});

// node_modules/undici/lib/core/symbols.js
var require_symbols = __commonJS({
  "node_modules/undici/lib/core/symbols.js"(exports2, module2) {
    module2.exports = {
      kClose: Symbol("close"),
      kDestroy: Symbol("destroy"),
      kDispatch: Symbol("dispatch"),
      kUrl: Symbol("url"),
      kWriting: Symbol("writing"),
      kResuming: Symbol("resuming"),
      kQueue: Symbol("queue"),
      kConnect: Symbol("connect"),
      kConnecting: Symbol("connecting"),
      kHeadersList: Symbol("headers list"),
      kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
      kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
      kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
      kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
      kKeepAlive: Symbol("keep alive"),
      kHeadersTimeout: Symbol("headers timeout"),
      kBodyTimeout: Symbol("body timeout"),
      kServerName: Symbol("server name"),
      kLocalAddress: Symbol("local address"),
      kHost: Symbol("host"),
      kNoRef: Symbol("no ref"),
      kBodyUsed: Symbol("used"),
      kRunning: Symbol("running"),
      kBlocking: Symbol("blocking"),
      kPending: Symbol("pending"),
      kSize: Symbol("size"),
      kBusy: Symbol("busy"),
      kQueued: Symbol("queued"),
      kFree: Symbol("free"),
      kConnected: Symbol("connected"),
      kClosed: Symbol("closed"),
      kNeedDrain: Symbol("need drain"),
      kReset: Symbol("reset"),
      kDestroyed: Symbol.for("nodejs.stream.destroyed"),
      kMaxHeadersSize: Symbol("max headers size"),
      kRunningIdx: Symbol("running index"),
      kPendingIdx: Symbol("pending index"),
      kError: Symbol("error"),
      kClients: Symbol("clients"),
      kClient: Symbol("client"),
      kParser: Symbol("parser"),
      kOnDestroyed: Symbol("destroy callbacks"),
      kPipelining: Symbol("pipelining"),
      kSocket: Symbol("socket"),
      kHostHeader: Symbol("host header"),
      kConnector: Symbol("connector"),
      kStrictContentLength: Symbol("strict content length"),
      kMaxRedirections: Symbol("maxRedirections"),
      kMaxRequests: Symbol("maxRequestsPerClient"),
      kProxy: Symbol("proxy agent options"),
      kCounter: Symbol("socket request counter"),
      kInterceptors: Symbol("dispatch interceptors"),
      kMaxResponseSize: Symbol("max response size"),
      kHTTP2Session: Symbol("http2Session"),
      kHTTP2SessionState: Symbol("http2Session state"),
      kHTTP2BuildRequest: Symbol("http2 build request"),
      kHTTP1BuildRequest: Symbol("http1 build request"),
      kHTTP2CopyHeaders: Symbol("http2 copy headers"),
      kHTTPConnVersion: Symbol("http connection version"),
      kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
      kConstruct: Symbol("constructable")
    };
  }
});

// node_modules/undici/lib/core/errors.js
var require_errors = __commonJS({
  "node_modules/undici/lib/core/errors.js"(exports2, module2) {
    "use strict";
    var UndiciError = class extends Error {
      constructor(message) {
        super(message), this.name = "UndiciError", this.code = "UND_ERR";
      }
    }, ConnectTimeoutError = class _ConnectTimeoutError extends UndiciError {
      constructor(message) {
        super(message), Error.captureStackTrace(this, _ConnectTimeoutError), this.name = "ConnectTimeoutError", this.message = message || "Connect Timeout Error", this.code = "UND_ERR_CONNECT_TIMEOUT";
      }
    }, HeadersTimeoutError = class _HeadersTimeoutError extends UndiciError {
      constructor(message) {
        super(message), Error.captureStackTrace(this, _HeadersTimeoutError), this.name = "HeadersTimeoutError", this.message = message || "Headers Timeout Error", this.code = "UND_ERR_HEADERS_TIMEOUT";
      }
    }, HeadersOverflowError = class _HeadersOverflowError extends UndiciError {
      constructor(message) {
        super(message), Error.captureStackTrace(this, _HeadersOverflowError), this.name = "HeadersOverflowError", this.message = message || "Headers Overflow Error", this.code = "UND_ERR_HEADERS_OVERFLOW";
      }
    }, BodyTimeoutError = class _BodyTimeoutError extends UndiciError {
      constructor(message) {
        super(message), Error.captureStackTrace(this, _BodyTimeoutError), this.name = "BodyTimeoutError", this.message = message || "Body Timeout Error", this.code = "UND_ERR_BODY_TIMEOUT";
      }
    }, ResponseStatusCodeError = class _ResponseStatusCodeError extends UndiciError {
      constructor(message, statusCode, headers, body) {
        super(message), Error.captureStackTrace(this, _ResponseStatusCodeError), this.name = "ResponseStatusCodeError", this.message = message || "Response Status Code Error", this.code = "UND_ERR_RESPONSE_STATUS_CODE", this.body = body, this.status = statusCode, this.statusCode = statusCode, this.headers = headers;
      }
    }, InvalidArgumentError = class _InvalidArgumentError extends UndiciError {
      constructor(message) {
        super(message), Error.captureStackTrace(this, _InvalidArgumentError), this.name = "InvalidArgumentError", this.message = message || "Invalid Argument Error", this.code = "UND_ERR_INVALID_ARG";
      }
    }, InvalidReturnValueError = class _InvalidReturnValueError extends UndiciError {
      constructor(message) {
        super(message), Error.captureStackTrace(this, _InvalidReturnValueError), this.name = "InvalidReturnValueError", this.message = message || "Invalid Return Value Error", this.code = "UND_ERR_INVALID_RETURN_VALUE";
      }
    }, RequestAbortedError = class _RequestAbortedError extends UndiciError {
      constructor(message) {
        super(message), Error.captureStackTrace(this, _RequestAbortedError), this.name = "AbortError", this.message = message || "Request aborted", this.code = "UND_ERR_ABORTED";
      }
    }, InformationalError = class _InformationalError extends UndiciError {
      constructor(message) {
        super(message), Error.captureStackTrace(this, _InformationalError), this.name = "InformationalError", this.message = message || "Request information", this.code = "UND_ERR_INFO";
      }
    }, RequestContentLengthMismatchError = class _RequestContentLengthMismatchError extends UndiciError {
      constructor(message) {
        super(message), Error.captureStackTrace(this, _RequestContentLengthMismatchError), this.name = "RequestContentLengthMismatchError", this.message = message || "Request body length does not match content-length header", this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
      }
    }, ResponseContentLengthMismatchError = class _ResponseContentLengthMismatchError extends UndiciError {
      constructor(message) {
        super(message), Error.captureStackTrace(this, _ResponseContentLengthMismatchError), this.name = "ResponseContentLengthMismatchError", this.message = message || "Response body length does not match content-length header", this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
      }
    }, ClientDestroyedError = class _ClientDestroyedError extends UndiciError {
      constructor(message) {
        super(message), Error.captureStackTrace(this, _ClientDestroyedError), this.name = "ClientDestroyedError", this.message = message || "The client is destroyed", this.code = "UND_ERR_DESTROYED";
      }
    }, ClientClosedError = class _ClientClosedError extends UndiciError {
      constructor(message) {
        super(message), Error.captureStackTrace(this, _ClientClosedError), this.name = "ClientClosedError", this.message = message || "The client is closed", this.code = "UND_ERR_CLOSED";
      }
    }, SocketError = class _SocketError extends UndiciError {
      constructor(message, socket) {
        super(message), Error.captureStackTrace(this, _SocketError), this.name = "SocketError", this.message = message || "Socket error", this.code = "UND_ERR_SOCKET", this.socket = socket;
      }
    }, NotSupportedError = class _NotSupportedError extends UndiciError {
      constructor(message) {
        super(message), Error.captureStackTrace(this, _NotSupportedError), this.name = "NotSupportedError", this.message = message || "Not supported error", this.code = "UND_ERR_NOT_SUPPORTED";
      }
    }, BalancedPoolMissingUpstreamError = class extends UndiciError {
      constructor(message) {
        super(message), Error.captureStackTrace(this, NotSupportedError), this.name = "MissingUpstreamError", this.message = message || "No upstream has been added to the BalancedPool", this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
      }
    }, HTTPParserError = class _HTTPParserError extends Error {
      constructor(message, code2, data) {
        super(message), Error.captureStackTrace(this, _HTTPParserError), this.name = "HTTPParserError", this.code = code2 ? `HPE_${code2}` : void 0, this.data = data ? data.toString() : void 0;
      }
    }, ResponseExceededMaxSizeError = class _ResponseExceededMaxSizeError extends UndiciError {
      constructor(message) {
        super(message), Error.captureStackTrace(this, _ResponseExceededMaxSizeError), this.name = "ResponseExceededMaxSizeError", this.message = message || "Response content exceeded max size", this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
      }
    }, RequestRetryError = class _RequestRetryError extends UndiciError {
      constructor(message, code2, { headers, data }) {
        super(message), Error.captureStackTrace(this, _RequestRetryError), this.name = "RequestRetryError", this.message = message || "Request retry error", this.code = "UND_ERR_REQ_RETRY", this.statusCode = code2, this.data = data, this.headers = headers;
      }
    };
    module2.exports = {
      HTTPParserError,
      UndiciError,
      HeadersTimeoutError,
      HeadersOverflowError,
      BodyTimeoutError,
      RequestContentLengthMismatchError,
      ConnectTimeoutError,
      ResponseStatusCodeError,
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError,
      ClientDestroyedError,
      ClientClosedError,
      InformationalError,
      SocketError,
      NotSupportedError,
      ResponseContentLengthMismatchError,
      BalancedPoolMissingUpstreamError,
      ResponseExceededMaxSizeError,
      RequestRetryError
    };
  }
});

// node_modules/undici/lib/core/constants.js
var require_constants = __commonJS({
  "node_modules/undici/lib/core/constants.js"(exports2, module2) {
    "use strict";
    var headerNameLowerCasedRecord = {}, wellknownHeaderNames = [
      "Accept",
      "Accept-Encoding",
      "Accept-Language",
      "Accept-Ranges",
      "Access-Control-Allow-Credentials",
      "Access-Control-Allow-Headers",
      "Access-Control-Allow-Methods",
      "Access-Control-Allow-Origin",
      "Access-Control-Expose-Headers",
      "Access-Control-Max-Age",
      "Access-Control-Request-Headers",
      "Access-Control-Request-Method",
      "Age",
      "Allow",
      "Alt-Svc",
      "Alt-Used",
      "Authorization",
      "Cache-Control",
      "Clear-Site-Data",
      "Connection",
      "Content-Disposition",
      "Content-Encoding",
      "Content-Language",
      "Content-Length",
      "Content-Location",
      "Content-Range",
      "Content-Security-Policy",
      "Content-Security-Policy-Report-Only",
      "Content-Type",
      "Cookie",
      "Cross-Origin-Embedder-Policy",
      "Cross-Origin-Opener-Policy",
      "Cross-Origin-Resource-Policy",
      "Date",
      "Device-Memory",
      "Downlink",
      "ECT",
      "ETag",
      "Expect",
      "Expect-CT",
      "Expires",
      "Forwarded",
      "From",
      "Host",
      "If-Match",
      "If-Modified-Since",
      "If-None-Match",
      "If-Range",
      "If-Unmodified-Since",
      "Keep-Alive",
      "Last-Modified",
      "Link",
      "Location",
      "Max-Forwards",
      "Origin",
      "Permissions-Policy",
      "Pragma",
      "Proxy-Authenticate",
      "Proxy-Authorization",
      "RTT",
      "Range",
      "Referer",
      "Referrer-Policy",
      "Refresh",
      "Retry-After",
      "Sec-WebSocket-Accept",
      "Sec-WebSocket-Extensions",
      "Sec-WebSocket-Key",
      "Sec-WebSocket-Protocol",
      "Sec-WebSocket-Version",
      "Server",
      "Server-Timing",
      "Service-Worker-Allowed",
      "Service-Worker-Navigation-Preload",
      "Set-Cookie",
      "SourceMap",
      "Strict-Transport-Security",
      "Supports-Loading-Mode",
      "TE",
      "Timing-Allow-Origin",
      "Trailer",
      "Transfer-Encoding",
      "Upgrade",
      "Upgrade-Insecure-Requests",
      "User-Agent",
      "Vary",
      "Via",
      "WWW-Authenticate",
      "X-Content-Type-Options",
      "X-DNS-Prefetch-Control",
      "X-Frame-Options",
      "X-Permitted-Cross-Domain-Policies",
      "X-Powered-By",
      "X-Requested-With",
      "X-XSS-Protection"
    ];
    for (let i = 0; i < wellknownHeaderNames.length; ++i) {
      let key = wellknownHeaderNames[i], lowerCasedKey = key.toLowerCase();
      headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[lowerCasedKey] = lowerCasedKey;
    }
    Object.setPrototypeOf(headerNameLowerCasedRecord, null);
    module2.exports = {
      wellknownHeaderNames,
      headerNameLowerCasedRecord
    };
  }
});

// node_modules/undici/lib/core/util.js
var require_util = __commonJS({
  "node_modules/undici/lib/core/util.js"(exports2, module2) {
    "use strict";
    var assert3 = require("assert"), { kDestroyed, kBodyUsed } = require_symbols(), { IncomingMessage } = require("http"), stream = require("stream"), net = require("net"), { InvalidArgumentError } = require_errors(), { Blob: Blob2 } = require("buffer"), nodeUtil = require("util"), { stringify } = require("querystring"), { headerNameLowerCasedRecord } = require_constants(), [nodeMajor, nodeMinor] = process.versions.node.split(".").map((v) => Number(v));
    function nop() {
    }
    function isStream2(obj) {
      return obj && typeof obj == "object" && typeof obj.pipe == "function" && typeof obj.on == "function";
    }
    function isBlobLike(object) {
      return Blob2 && object instanceof Blob2 || object && typeof object == "object" && (typeof object.stream == "function" || typeof object.arrayBuffer == "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
    }
    function buildURL(url, queryParams) {
      if (url.includes("?") || url.includes("#"))
        throw new Error('Query params cannot be passed when url already contains "?" or "#".');
      let stringified = stringify(queryParams);
      return stringified && (url += "?" + stringified), url;
    }
    function parseURL(url) {
      if (typeof url == "string") {
        if (url = new URL(url), !/^https?:/.test(url.origin || url.protocol))
          throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
        return url;
      }
      if (!url || typeof url != "object")
        throw new InvalidArgumentError("Invalid URL: The URL argument must be a non-null object.");
      if (!/^https?:/.test(url.origin || url.protocol))
        throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      if (!(url instanceof URL)) {
        if (url.port != null && url.port !== "" && !Number.isFinite(parseInt(url.port)))
          throw new InvalidArgumentError("Invalid URL: port must be a valid integer or a string representation of an integer.");
        if (url.path != null && typeof url.path != "string")
          throw new InvalidArgumentError("Invalid URL path: the path must be a string or null/undefined.");
        if (url.pathname != null && typeof url.pathname != "string")
          throw new InvalidArgumentError("Invalid URL pathname: the pathname must be a string or null/undefined.");
        if (url.hostname != null && typeof url.hostname != "string")
          throw new InvalidArgumentError("Invalid URL hostname: the hostname must be a string or null/undefined.");
        if (url.origin != null && typeof url.origin != "string")
          throw new InvalidArgumentError("Invalid URL origin: the origin must be a string or null/undefined.");
        let port = url.port != null ? url.port : url.protocol === "https:" ? 443 : 80, origin = url.origin != null ? url.origin : `${url.protocol}//${url.hostname}:${port}`, path8 = url.path != null ? url.path : `${url.pathname || ""}${url.search || ""}`;
        origin.endsWith("/") && (origin = origin.substring(0, origin.length - 1)), path8 && !path8.startsWith("/") && (path8 = `/${path8}`), url = new URL(origin + path8);
      }
      return url;
    }
    function parseOrigin(url) {
      if (url = parseURL(url), url.pathname !== "/" || url.search || url.hash)
        throw new InvalidArgumentError("invalid url");
      return url;
    }
    function getHostname(host) {
      if (host[0] === "[") {
        let idx2 = host.indexOf("]");
        return assert3(idx2 !== -1), host.substring(1, idx2);
      }
      let idx = host.indexOf(":");
      return idx === -1 ? host : host.substring(0, idx);
    }
    function getServerName(host) {
      if (!host)
        return null;
      assert3.strictEqual(typeof host, "string");
      let servername = getHostname(host);
      return net.isIP(servername) ? "" : servername;
    }
    function deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
    function isAsyncIterable(obj) {
      return obj != null && typeof obj[Symbol.asyncIterator] == "function";
    }
    function isIterable(obj) {
      return obj != null && (typeof obj[Symbol.iterator] == "function" || typeof obj[Symbol.asyncIterator] == "function");
    }
    function bodyLength(body) {
      if (body == null)
        return 0;
      if (isStream2(body)) {
        let state = body._readableState;
        return state && state.objectMode === !1 && state.ended === !0 && Number.isFinite(state.length) ? state.length : null;
      } else {
        if (isBlobLike(body))
          return body.size != null ? body.size : null;
        if (isBuffer(body))
          return body.byteLength;
      }
      return null;
    }
    function isDestroyed(stream2) {
      return !stream2 || !!(stream2.destroyed || stream2[kDestroyed]);
    }
    function isReadableAborted(stream2) {
      let state = stream2 && stream2._readableState;
      return isDestroyed(stream2) && state && !state.endEmitted;
    }
    function destroy(stream2, err) {
      stream2 == null || !isStream2(stream2) || isDestroyed(stream2) || (typeof stream2.destroy == "function" ? (Object.getPrototypeOf(stream2).constructor === IncomingMessage && (stream2.socket = null), stream2.destroy(err)) : err && process.nextTick((stream3, err2) => {
        stream3.emit("error", err2);
      }, stream2, err), stream2.destroyed !== !0 && (stream2[kDestroyed] = !0));
    }
    var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
    function parseKeepAliveTimeout(val) {
      let m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
      return m ? parseInt(m[1], 10) * 1e3 : null;
    }
    function headerNameToString(value) {
      return headerNameLowerCasedRecord[value] || value.toLowerCase();
    }
    function parseHeaders(headers, obj = {}) {
      if (!Array.isArray(headers)) return headers;
      for (let i = 0; i < headers.length; i += 2) {
        let key = headers[i].toString().toLowerCase(), val = obj[key];
        val ? (Array.isArray(val) || (val = [val], obj[key] = val), val.push(headers[i + 1].toString("utf8"))) : Array.isArray(headers[i + 1]) ? obj[key] = headers[i + 1].map((x) => x.toString("utf8")) : obj[key] = headers[i + 1].toString("utf8");
      }
      return "content-length" in obj && "content-disposition" in obj && (obj["content-disposition"] = Buffer.from(obj["content-disposition"]).toString("latin1")), obj;
    }
    function parseRawHeaders(headers) {
      let ret = [], hasContentLength = !1, contentDispositionIdx = -1;
      for (let n = 0; n < headers.length; n += 2) {
        let key = headers[n + 0].toString(), val = headers[n + 1].toString("utf8");
        key.length === 14 && (key === "content-length" || key.toLowerCase() === "content-length") ? (ret.push(key, val), hasContentLength = !0) : key.length === 19 && (key === "content-disposition" || key.toLowerCase() === "content-disposition") ? contentDispositionIdx = ret.push(key, val) - 1 : ret.push(key, val);
      }
      return hasContentLength && contentDispositionIdx !== -1 && (ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString("latin1")), ret;
    }
    function isBuffer(buffer) {
      return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
    }
    function validateHandler(handler, method, upgrade) {
      if (!handler || typeof handler != "object")
        throw new InvalidArgumentError("handler must be an object");
      if (typeof handler.onConnect != "function")
        throw new InvalidArgumentError("invalid onConnect method");
      if (typeof handler.onError != "function")
        throw new InvalidArgumentError("invalid onError method");
      if (typeof handler.onBodySent != "function" && handler.onBodySent !== void 0)
        throw new InvalidArgumentError("invalid onBodySent method");
      if (upgrade || method === "CONNECT") {
        if (typeof handler.onUpgrade != "function")
          throw new InvalidArgumentError("invalid onUpgrade method");
      } else {
        if (typeof handler.onHeaders != "function")
          throw new InvalidArgumentError("invalid onHeaders method");
        if (typeof handler.onData != "function")
          throw new InvalidArgumentError("invalid onData method");
        if (typeof handler.onComplete != "function")
          throw new InvalidArgumentError("invalid onComplete method");
      }
    }
    function isDisturbed(body) {
      return !!(body && (stream.isDisturbed ? stream.isDisturbed(body) || body[kBodyUsed] : body[kBodyUsed] || body.readableDidRead || body._readableState && body._readableState.dataEmitted || isReadableAborted(body)));
    }
    function isErrored(body) {
      return !!(body && (stream.isErrored ? stream.isErrored(body) : /state: 'errored'/.test(
        nodeUtil.inspect(body)
      )));
    }
    function isReadable2(body) {
      return !!(body && (stream.isReadable ? stream.isReadable(body) : /state: 'readable'/.test(
        nodeUtil.inspect(body)
      )));
    }
    function getSocketInfo(socket) {
      return {
        localAddress: socket.localAddress,
        localPort: socket.localPort,
        remoteAddress: socket.remoteAddress,
        remotePort: socket.remotePort,
        remoteFamily: socket.remoteFamily,
        timeout: socket.timeout,
        bytesWritten: socket.bytesWritten,
        bytesRead: socket.bytesRead
      };
    }
    async function* convertIterableToBuffer(iterable) {
      for await (let chunk of iterable)
        yield Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
    }
    var ReadableStream;
    function ReadableStreamFrom(iterable) {
      if (ReadableStream || (ReadableStream = require("stream/web").ReadableStream), ReadableStream.from)
        return ReadableStream.from(convertIterableToBuffer(iterable));
      let iterator;
      return new ReadableStream(
        {
          async start() {
            iterator = iterable[Symbol.asyncIterator]();
          },
          async pull(controller) {
            let { done, value } = await iterator.next();
            if (done)
              queueMicrotask(() => {
                controller.close();
              });
            else {
              let buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
              controller.enqueue(new Uint8Array(buf));
            }
            return controller.desiredSize > 0;
          },
          async cancel(reason) {
            await iterator.return();
          }
        },
        0
      );
    }
    function isFormDataLike(object) {
      return object && typeof object == "object" && typeof object.append == "function" && typeof object.delete == "function" && typeof object.get == "function" && typeof object.getAll == "function" && typeof object.has == "function" && typeof object.set == "function" && object[Symbol.toStringTag] === "FormData";
    }
    function throwIfAborted(signal) {
      if (signal) {
        if (typeof signal.throwIfAborted == "function")
          signal.throwIfAborted();
        else if (signal.aborted) {
          let err = new Error("The operation was aborted");
          throw err.name = "AbortError", err;
        }
      }
    }
    function addAbortListener(signal, listener) {
      return "addEventListener" in signal ? (signal.addEventListener("abort", listener, { once: !0 }), () => signal.removeEventListener("abort", listener)) : (signal.addListener("abort", listener), () => signal.removeListener("abort", listener));
    }
    var hasToWellFormed = !!String.prototype.toWellFormed;
    function toUSVString(val) {
      return hasToWellFormed ? `${val}`.toWellFormed() : nodeUtil.toUSVString ? nodeUtil.toUSVString(val) : `${val}`;
    }
    function parseRangeHeader(range) {
      if (range == null || range === "") return { start: 0, end: null, size: null };
      let m = range ? range.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
      return m ? {
        start: parseInt(m[1]),
        end: m[2] ? parseInt(m[2]) : null,
        size: m[3] ? parseInt(m[3]) : null
      } : null;
    }
    var kEnumerableProperty = /* @__PURE__ */ Object.create(null);
    kEnumerableProperty.enumerable = !0;
    module2.exports = {
      kEnumerableProperty,
      nop,
      isDisturbed,
      isErrored,
      isReadable: isReadable2,
      toUSVString,
      isReadableAborted,
      isBlobLike,
      parseOrigin,
      parseURL,
      getServerName,
      isStream: isStream2,
      isIterable,
      isAsyncIterable,
      isDestroyed,
      headerNameToString,
      parseRawHeaders,
      parseHeaders,
      parseKeepAliveTimeout,
      destroy,
      bodyLength,
      deepClone,
      ReadableStreamFrom,
      isBuffer,
      validateHandler,
      getSocketInfo,
      isFormDataLike,
      buildURL,
      throwIfAborted,
      addAbortListener,
      parseRangeHeader,
      nodeMajor,
      nodeMinor,
      nodeHasAutoSelectFamily: nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 13,
      safeHTTPMethods: ["GET", "HEAD", "OPTIONS", "TRACE"]
    };
  }
});

// node_modules/undici/lib/timers.js
var require_timers = __commonJS({
  "node_modules/undici/lib/timers.js"(exports2, module2) {
    "use strict";
    var fastNow = Date.now(), fastNowTimeout, fastTimers = [];
    function onTimeout() {
      fastNow = Date.now();
      let len = fastTimers.length, idx = 0;
      for (; idx < len; ) {
        let timer = fastTimers[idx];
        timer.state === 0 ? timer.state = fastNow + timer.delay : timer.state > 0 && fastNow >= timer.state && (timer.state = -1, timer.callback(timer.opaque)), timer.state === -1 ? (timer.state = -2, idx !== len - 1 ? fastTimers[idx] = fastTimers.pop() : fastTimers.pop(), len -= 1) : idx += 1;
      }
      fastTimers.length > 0 && refreshTimeout();
    }
    function refreshTimeout() {
      fastNowTimeout && fastNowTimeout.refresh ? fastNowTimeout.refresh() : (clearTimeout(fastNowTimeout), fastNowTimeout = setTimeout(onTimeout, 1e3), fastNowTimeout.unref && fastNowTimeout.unref());
    }
    var Timeout = class {
      constructor(callback, delay, opaque) {
        this.callback = callback, this.delay = delay, this.opaque = opaque, this.state = -2, this.refresh();
      }
      refresh() {
        this.state === -2 && (fastTimers.push(this), (!fastNowTimeout || fastTimers.length === 1) && refreshTimeout()), this.state = 0;
      }
      clear() {
        this.state = -1;
      }
    };
    module2.exports = {
      setTimeout(callback, delay, opaque) {
        return delay < 1e3 ? setTimeout(callback, delay, opaque) : new Timeout(callback, delay, opaque);
      },
      clearTimeout(timeout) {
        timeout instanceof Timeout ? timeout.clear() : clearTimeout(timeout);
      }
    };
  }
});

// node_modules/@fastify/busboy/deps/streamsearch/sbmh.js
var require_sbmh = __commonJS({
  "node_modules/@fastify/busboy/deps/streamsearch/sbmh.js"(exports2, module2) {
    "use strict";
    var EventEmitter2 = require("node:events").EventEmitter, inherits = require("node:util").inherits;
    function SBMH(needle) {
      if (typeof needle == "string" && (needle = Buffer.from(needle)), !Buffer.isBuffer(needle))
        throw new TypeError("The needle has to be a String or a Buffer.");
      let needleLength = needle.length;
      if (needleLength === 0)
        throw new Error("The needle cannot be an empty String/Buffer.");
      if (needleLength > 256)
        throw new Error("The needle cannot have a length bigger than 256.");
      this.maxMatches = 1 / 0, this.matches = 0, this._occ = new Array(256).fill(needleLength), this._lookbehind_size = 0, this._needle = needle, this._bufpos = 0, this._lookbehind = Buffer.alloc(needleLength);
      for (var i = 0; i < needleLength - 1; ++i)
        this._occ[needle[i]] = needleLength - 1 - i;
    }
    inherits(SBMH, EventEmitter2);
    SBMH.prototype.reset = function() {
      this._lookbehind_size = 0, this.matches = 0, this._bufpos = 0;
    };
    SBMH.prototype.push = function(chunk, pos2) {
      Buffer.isBuffer(chunk) || (chunk = Buffer.from(chunk, "binary"));
      let chlen = chunk.length;
      this._bufpos = pos2 || 0;
      let r;
      for (; r !== chlen && this.matches < this.maxMatches; )
        r = this._sbmh_feed(chunk);
      return r;
    };
    SBMH.prototype._sbmh_feed = function(data) {
      let len = data.length, needle = this._needle, needleLength = needle.length, lastNeedleChar = needle[needleLength - 1], pos2 = -this._lookbehind_size, ch;
      if (pos2 < 0) {
        for (; pos2 < 0 && pos2 <= len - needleLength; ) {
          if (ch = this._sbmh_lookup_char(data, pos2 + needleLength - 1), ch === lastNeedleChar && this._sbmh_memcmp(data, pos2, needleLength - 1))
            return this._lookbehind_size = 0, ++this.matches, this.emit("info", !0), this._bufpos = pos2 + needleLength;
          pos2 += this._occ[ch];
        }
        if (pos2 < 0)
          for (; pos2 < 0 && !this._sbmh_memcmp(data, pos2, len - pos2); )
            ++pos2;
        if (pos2 >= 0)
          this.emit("info", !1, this._lookbehind, 0, this._lookbehind_size), this._lookbehind_size = 0;
        else {
          let bytesToCutOff = this._lookbehind_size + pos2;
          return bytesToCutOff > 0 && this.emit("info", !1, this._lookbehind, 0, bytesToCutOff), this._lookbehind.copy(
            this._lookbehind,
            0,
            bytesToCutOff,
            this._lookbehind_size - bytesToCutOff
          ), this._lookbehind_size -= bytesToCutOff, data.copy(this._lookbehind, this._lookbehind_size), this._lookbehind_size += len, this._bufpos = len, len;
        }
      }
      if (pos2 += (pos2 >= 0) * this._bufpos, data.indexOf(needle, pos2) !== -1)
        return pos2 = data.indexOf(needle, pos2), ++this.matches, pos2 > 0 ? this.emit("info", !0, data, this._bufpos, pos2) : this.emit("info", !0), this._bufpos = pos2 + needleLength;
      for (pos2 = len - needleLength; pos2 < len && (data[pos2] !== needle[0] || Buffer.compare(
        data.subarray(pos2, pos2 + len - pos2),
        needle.subarray(0, len - pos2)
      ) !== 0); )
        ++pos2;
      return pos2 < len && (data.copy(this._lookbehind, 0, pos2, pos2 + (len - pos2)), this._lookbehind_size = len - pos2), pos2 > 0 && this.emit("info", !1, data, this._bufpos, pos2 < len ? pos2 : len), this._bufpos = len, len;
    };
    SBMH.prototype._sbmh_lookup_char = function(data, pos2) {
      return pos2 < 0 ? this._lookbehind[this._lookbehind_size + pos2] : data[pos2];
    };
    SBMH.prototype._sbmh_memcmp = function(data, pos2, len) {
      for (var i = 0; i < len; ++i)
        if (this._sbmh_lookup_char(data, pos2 + i) !== this._needle[i])
          return !1;
      return !0;
    };
    module2.exports = SBMH;
  }
});

// node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js
var require_PartStream = __commonJS({
  "node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js"(exports2, module2) {
    "use strict";
    var inherits = require("node:util").inherits, ReadableStream = require("node:stream").Readable;
    function PartStream(opts) {
      ReadableStream.call(this, opts);
    }
    inherits(PartStream, ReadableStream);
    PartStream.prototype._read = function(n) {
    };
    module2.exports = PartStream;
  }
});

// node_modules/@fastify/busboy/lib/utils/getLimit.js
var require_getLimit = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/getLimit.js"(exports2, module2) {
    "use strict";
    module2.exports = function(limits, name2, defaultLimit) {
      if (!limits || limits[name2] === void 0 || limits[name2] === null)
        return defaultLimit;
      if (typeof limits[name2] != "number" || isNaN(limits[name2]))
        throw new TypeError("Limit " + name2 + " is not a valid number");
      return limits[name2];
    };
  }
});

// node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js
var require_HeaderParser = __commonJS({
  "node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js"(exports2, module2) {
    "use strict";
    var EventEmitter2 = require("node:events").EventEmitter, inherits = require("node:util").inherits, getLimit = require_getLimit(), StreamSearch = require_sbmh(), B_DCRLF = Buffer.from(`\r
\r
`), RE_CRLF = /\r\n/g, RE_HDR = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/;
    function HeaderParser(cfg) {
      EventEmitter2.call(this), cfg = cfg || {};
      let self2 = this;
      this.nread = 0, this.maxed = !1, this.npairs = 0, this.maxHeaderPairs = getLimit(cfg, "maxHeaderPairs", 2e3), this.maxHeaderSize = getLimit(cfg, "maxHeaderSize", 80 * 1024), this.buffer = "", this.header = {}, this.finished = !1, this.ss = new StreamSearch(B_DCRLF), this.ss.on("info", function(isMatch, data, start, end) {
        data && !self2.maxed && (self2.nread + end - start >= self2.maxHeaderSize ? (end = self2.maxHeaderSize - self2.nread + start, self2.nread = self2.maxHeaderSize, self2.maxed = !0) : self2.nread += end - start, self2.buffer += data.toString("binary", start, end)), isMatch && self2._finish();
      });
    }
    inherits(HeaderParser, EventEmitter2);
    HeaderParser.prototype.push = function(data) {
      let r = this.ss.push(data);
      if (this.finished)
        return r;
    };
    HeaderParser.prototype.reset = function() {
      this.finished = !1, this.buffer = "", this.header = {}, this.ss.reset();
    };
    HeaderParser.prototype._finish = function() {
      this.buffer && this._parseHeader(), this.ss.matches = this.ss.maxMatches;
      let header = this.header;
      this.header = {}, this.buffer = "", this.finished = !0, this.nread = this.npairs = 0, this.maxed = !1, this.emit("header", header);
    };
    HeaderParser.prototype._parseHeader = function() {
      if (this.npairs === this.maxHeaderPairs)
        return;
      let lines = this.buffer.split(RE_CRLF), len = lines.length, m, h;
      for (var i = 0; i < len; ++i) {
        if (lines[i].length === 0)
          continue;
        if ((lines[i][0] === "	" || lines[i][0] === " ") && h) {
          this.header[h][this.header[h].length - 1] += lines[i];
          continue;
        }
        let posColon = lines[i].indexOf(":");
        if (posColon === -1 || posColon === 0)
          return;
        if (m = RE_HDR.exec(lines[i]), h = m[1].toLowerCase(), this.header[h] = this.header[h] || [], this.header[h].push(m[2] || ""), ++this.npairs === this.maxHeaderPairs)
          break;
      }
    };
    module2.exports = HeaderParser;
  }
});

// node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js
var require_Dicer = __commonJS({
  "node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js"(exports2, module2) {
    "use strict";
    var WritableStream = require("node:stream").Writable, inherits = require("node:util").inherits, StreamSearch = require_sbmh(), PartStream = require_PartStream(), HeaderParser = require_HeaderParser(), DASH = 45, B_ONEDASH = Buffer.from("-"), B_CRLF = Buffer.from(`\r
`), EMPTY_FN = function() {
    };
    function Dicer(cfg) {
      if (!(this instanceof Dicer))
        return new Dicer(cfg);
      if (WritableStream.call(this, cfg), !cfg || !cfg.headerFirst && typeof cfg.boundary != "string")
        throw new TypeError("Boundary required");
      typeof cfg.boundary == "string" ? this.setBoundary(cfg.boundary) : this._bparser = void 0, this._headerFirst = cfg.headerFirst, this._dashes = 0, this._parts = 0, this._finished = !1, this._realFinish = !1, this._isPreamble = !0, this._justMatched = !1, this._firstWrite = !0, this._inHeader = !0, this._part = void 0, this._cb = void 0, this._ignoreData = !1, this._partOpts = { highWaterMark: cfg.partHwm }, this._pause = !1;
      let self2 = this;
      this._hparser = new HeaderParser(cfg), this._hparser.on("header", function(header) {
        self2._inHeader = !1, self2._part.emit("header", header);
      });
    }
    inherits(Dicer, WritableStream);
    Dicer.prototype.emit = function(ev) {
      if (ev === "finish" && !this._realFinish) {
        if (!this._finished) {
          let self2 = this;
          process.nextTick(function() {
            if (self2.emit("error", new Error("Unexpected end of multipart data")), self2._part && !self2._ignoreData) {
              let type = self2._isPreamble ? "Preamble" : "Part";
              self2._part.emit("error", new Error(type + " terminated early due to unexpected end of multipart data")), self2._part.push(null), process.nextTick(function() {
                self2._realFinish = !0, self2.emit("finish"), self2._realFinish = !1;
              });
              return;
            }
            self2._realFinish = !0, self2.emit("finish"), self2._realFinish = !1;
          });
        }
      } else
        WritableStream.prototype.emit.apply(this, arguments);
    };
    Dicer.prototype._write = function(data, encoding, cb) {
      if (!this._hparser && !this._bparser)
        return cb();
      if (this._headerFirst && this._isPreamble) {
        this._part || (this._part = new PartStream(this._partOpts), this.listenerCount("preamble") !== 0 ? this.emit("preamble", this._part) : this._ignore());
        let r = this._hparser.push(data);
        if (!this._inHeader && r !== void 0 && r < data.length)
          data = data.slice(r);
        else
          return cb();
      }
      this._firstWrite && (this._bparser.push(B_CRLF), this._firstWrite = !1), this._bparser.push(data), this._pause ? this._cb = cb : cb();
    };
    Dicer.prototype.reset = function() {
      this._part = void 0, this._bparser = void 0, this._hparser = void 0;
    };
    Dicer.prototype.setBoundary = function(boundary) {
      let self2 = this;
      this._bparser = new StreamSearch(`\r
--` + boundary), this._bparser.on("info", function(isMatch, data, start, end) {
        self2._oninfo(isMatch, data, start, end);
      });
    };
    Dicer.prototype._ignore = function() {
      this._part && !this._ignoreData && (this._ignoreData = !0, this._part.on("error", EMPTY_FN), this._part.resume());
    };
    Dicer.prototype._oninfo = function(isMatch, data, start, end) {
      let buf, self2 = this, i = 0, r, shouldWriteMore = !0;
      if (!this._part && this._justMatched && data) {
        for (; this._dashes < 2 && start + i < end; )
          if (data[start + i] === DASH)
            ++i, ++this._dashes;
          else {
            this._dashes && (buf = B_ONEDASH), this._dashes = 0;
            break;
          }
        if (this._dashes === 2 && (start + i < end && this.listenerCount("trailer") !== 0 && this.emit("trailer", data.slice(start + i, end)), this.reset(), this._finished = !0, self2._parts === 0 && (self2._realFinish = !0, self2.emit("finish"), self2._realFinish = !1)), this._dashes)
          return;
      }
      this._justMatched && (this._justMatched = !1), this._part || (this._part = new PartStream(this._partOpts), this._part._read = function(n) {
        self2._unpause();
      }, this._isPreamble && this.listenerCount("preamble") !== 0 ? this.emit("preamble", this._part) : this._isPreamble !== !0 && this.listenerCount("part") !== 0 ? this.emit("part", this._part) : this._ignore(), this._isPreamble || (this._inHeader = !0)), data && start < end && !this._ignoreData && (this._isPreamble || !this._inHeader ? (buf && (shouldWriteMore = this._part.push(buf)), shouldWriteMore = this._part.push(data.slice(start, end)), shouldWriteMore || (this._pause = !0)) : !this._isPreamble && this._inHeader && (buf && this._hparser.push(buf), r = this._hparser.push(data.slice(start, end)), !this._inHeader && r !== void 0 && r < end && this._oninfo(!1, data, start + r, end))), isMatch && (this._hparser.reset(), this._isPreamble ? this._isPreamble = !1 : start !== end && (++this._parts, this._part.on("end", function() {
        --self2._parts === 0 && (self2._finished ? (self2._realFinish = !0, self2.emit("finish"), self2._realFinish = !1) : self2._unpause());
      })), this._part.push(null), this._part = void 0, this._ignoreData = !1, this._justMatched = !0, this._dashes = 0);
    };
    Dicer.prototype._unpause = function() {
      if (this._pause && (this._pause = !1, this._cb)) {
        let cb = this._cb;
        this._cb = void 0, cb();
      }
    };
    module2.exports = Dicer;
  }
});

// node_modules/@fastify/busboy/lib/utils/decodeText.js
var require_decodeText = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/decodeText.js"(exports2, module2) {
    "use strict";
    var utf8Decoder = new TextDecoder("utf-8"), textDecoders = /* @__PURE__ */ new Map([
      ["utf-8", utf8Decoder],
      ["utf8", utf8Decoder]
    ]);
    function getDecoder(charset) {
      let lc;
      for (; ; )
        switch (charset) {
          case "utf-8":
          case "utf8":
            return decoders.utf8;
          case "latin1":
          case "ascii":
          // TODO: Make these a separate, strict decoder?
          case "us-ascii":
          case "iso-8859-1":
          case "iso8859-1":
          case "iso88591":
          case "iso_8859-1":
          case "windows-1252":
          case "iso_8859-1:1987":
          case "cp1252":
          case "x-cp1252":
            return decoders.latin1;
          case "utf16le":
          case "utf-16le":
          case "ucs2":
          case "ucs-2":
            return decoders.utf16le;
          case "base64":
            return decoders.base64;
          default:
            if (lc === void 0) {
              lc = !0, charset = charset.toLowerCase();
              continue;
            }
            return decoders.other.bind(charset);
        }
    }
    var decoders = {
      utf8: (data, sourceEncoding) => data.length === 0 ? "" : (typeof data == "string" && (data = Buffer.from(data, sourceEncoding)), data.utf8Slice(0, data.length)),
      latin1: (data, sourceEncoding) => data.length === 0 ? "" : typeof data == "string" ? data : data.latin1Slice(0, data.length),
      utf16le: (data, sourceEncoding) => data.length === 0 ? "" : (typeof data == "string" && (data = Buffer.from(data, sourceEncoding)), data.ucs2Slice(0, data.length)),
      base64: (data, sourceEncoding) => data.length === 0 ? "" : (typeof data == "string" && (data = Buffer.from(data, sourceEncoding)), data.base64Slice(0, data.length)),
      other: (data, sourceEncoding) => {
        if (data.length === 0)
          return "";
        if (typeof data == "string" && (data = Buffer.from(data, sourceEncoding)), textDecoders.has(exports2.toString()))
          try {
            return textDecoders.get(exports2).decode(data);
          } catch {
          }
        return typeof data == "string" ? data : data.toString();
      }
    };
    function decodeText(text, sourceEncoding, destEncoding) {
      return text && getDecoder(destEncoding)(text, sourceEncoding);
    }
    module2.exports = decodeText;
  }
});

// node_modules/@fastify/busboy/lib/utils/parseParams.js
var require_parseParams = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/parseParams.js"(exports2, module2) {
    "use strict";
    var decodeText = require_decodeText(), RE_ENCODED = /%[a-fA-F0-9][a-fA-F0-9]/g, EncodedLookup = {
      "%00": "\0",
      "%01": "",
      "%02": "",
      "%03": "",
      "%04": "",
      "%05": "",
      "%06": "",
      "%07": "\x07",
      "%08": "\b",
      "%09": "	",
      "%0a": `
`,
      "%0A": `
`,
      "%0b": "\v",
      "%0B": "\v",
      "%0c": "\f",
      "%0C": "\f",
      "%0d": "\r",
      "%0D": "\r",
      "%0e": "",
      "%0E": "",
      "%0f": "",
      "%0F": "",
      "%10": "",
      "%11": "",
      "%12": "",
      "%13": "",
      "%14": "",
      "%15": "",
      "%16": "",
      "%17": "",
      "%18": "",
      "%19": "",
      "%1a": "",
      "%1A": "",
      "%1b": "\x1B",
      "%1B": "\x1B",
      "%1c": "",
      "%1C": "",
      "%1d": "",
      "%1D": "",
      "%1e": "",
      "%1E": "",
      "%1f": "",
      "%1F": "",
      "%20": " ",
      "%21": "!",
      "%22": '"',
      "%23": "#",
      "%24": "$",
      "%25": "%",
      "%26": "&",
      "%27": "'",
      "%28": "(",
      "%29": ")",
      "%2a": "*",
      "%2A": "*",
      "%2b": "+",
      "%2B": "+",
      "%2c": ",",
      "%2C": ",",
      "%2d": "-",
      "%2D": "-",
      "%2e": ".",
      "%2E": ".",
      "%2f": "/",
      "%2F": "/",
      "%30": "0",
      "%31": "1",
      "%32": "2",
      "%33": "3",
      "%34": "4",
      "%35": "5",
      "%36": "6",
      "%37": "7",
      "%38": "8",
      "%39": "9",
      "%3a": ":",
      "%3A": ":",
      "%3b": ";",
      "%3B": ";",
      "%3c": "<",
      "%3C": "<",
      "%3d": "=",
      "%3D": "=",
      "%3e": ">",
      "%3E": ">",
      "%3f": "?",
      "%3F": "?",
      "%40": "@",
      "%41": "A",
      "%42": "B",
      "%43": "C",
      "%44": "D",
      "%45": "E",
      "%46": "F",
      "%47": "G",
      "%48": "H",
      "%49": "I",
      "%4a": "J",
      "%4A": "J",
      "%4b": "K",
      "%4B": "K",
      "%4c": "L",
      "%4C": "L",
      "%4d": "M",
      "%4D": "M",
      "%4e": "N",
      "%4E": "N",
      "%4f": "O",
      "%4F": "O",
      "%50": "P",
      "%51": "Q",
      "%52": "R",
      "%53": "S",
      "%54": "T",
      "%55": "U",
      "%56": "V",
      "%57": "W",
      "%58": "X",
      "%59": "Y",
      "%5a": "Z",
      "%5A": "Z",
      "%5b": "[",
      "%5B": "[",
      "%5c": "\\",
      "%5C": "\\",
      "%5d": "]",
      "%5D": "]",
      "%5e": "^",
      "%5E": "^",
      "%5f": "_",
      "%5F": "_",
      "%60": "`",
      "%61": "a",
      "%62": "b",
      "%63": "c",
      "%64": "d",
      "%65": "e",
      "%66": "f",
      "%67": "g",
      "%68": "h",
      "%69": "i",
      "%6a": "j",
      "%6A": "j",
      "%6b": "k",
      "%6B": "k",
      "%6c": "l",
      "%6C": "l",
      "%6d": "m",
      "%6D": "m",
      "%6e": "n",
      "%6E": "n",
      "%6f": "o",
      "%6F": "o",
      "%70": "p",
      "%71": "q",
      "%72": "r",
      "%73": "s",
      "%74": "t",
      "%75": "u",
      "%76": "v",
      "%77": "w",
      "%78": "x",
      "%79": "y",
      "%7a": "z",
      "%7A": "z",
      "%7b": "{",
      "%7B": "{",
      "%7c": "|",
      "%7C": "|",
      "%7d": "}",
      "%7D": "}",
      "%7e": "~",
      "%7E": "~",
      "%7f": "\x7F",
      "%7F": "\x7F",
      "%80": "\x80",
      "%81": "\x81",
      "%82": "\x82",
      "%83": "\x83",
      "%84": "\x84",
      "%85": "\x85",
      "%86": "\x86",
      "%87": "\x87",
      "%88": "\x88",
      "%89": "\x89",
      "%8a": "\x8A",
      "%8A": "\x8A",
      "%8b": "\x8B",
      "%8B": "\x8B",
      "%8c": "\x8C",
      "%8C": "\x8C",
      "%8d": "\x8D",
      "%8D": "\x8D",
      "%8e": "\x8E",
      "%8E": "\x8E",
      "%8f": "\x8F",
      "%8F": "\x8F",
      "%90": "\x90",
      "%91": "\x91",
      "%92": "\x92",
      "%93": "\x93",
      "%94": "\x94",
      "%95": "\x95",
      "%96": "\x96",
      "%97": "\x97",
      "%98": "\x98",
      "%99": "\x99",
      "%9a": "\x9A",
      "%9A": "\x9A",
      "%9b": "\x9B",
      "%9B": "\x9B",
      "%9c": "\x9C",
      "%9C": "\x9C",
      "%9d": "\x9D",
      "%9D": "\x9D",
      "%9e": "\x9E",
      "%9E": "\x9E",
      "%9f": "\x9F",
      "%9F": "\x9F",
      "%a0": "\xA0",
      "%A0": "\xA0",
      "%a1": "\xA1",
      "%A1": "\xA1",
      "%a2": "\xA2",
      "%A2": "\xA2",
      "%a3": "\xA3",
      "%A3": "\xA3",
      "%a4": "\xA4",
      "%A4": "\xA4",
      "%a5": "\xA5",
      "%A5": "\xA5",
      "%a6": "\xA6",
      "%A6": "\xA6",
      "%a7": "\xA7",
      "%A7": "\xA7",
      "%a8": "\xA8",
      "%A8": "\xA8",
      "%a9": "\xA9",
      "%A9": "\xA9",
      "%aa": "\xAA",
      "%Aa": "\xAA",
      "%aA": "\xAA",
      "%AA": "\xAA",
      "%ab": "\xAB",
      "%Ab": "\xAB",
      "%aB": "\xAB",
      "%AB": "\xAB",
      "%ac": "\xAC",
      "%Ac": "\xAC",
      "%aC": "\xAC",
      "%AC": "\xAC",
      "%ad": "\xAD",
      "%Ad": "\xAD",
      "%aD": "\xAD",
      "%AD": "\xAD",
      "%ae": "\xAE",
      "%Ae": "\xAE",
      "%aE": "\xAE",
      "%AE": "\xAE",
      "%af": "\xAF",
      "%Af": "\xAF",
      "%aF": "\xAF",
      "%AF": "\xAF",
      "%b0": "\xB0",
      "%B0": "\xB0",
      "%b1": "\xB1",
      "%B1": "\xB1",
      "%b2": "\xB2",
      "%B2": "\xB2",
      "%b3": "\xB3",
      "%B3": "\xB3",
      "%b4": "\xB4",
      "%B4": "\xB4",
      "%b5": "\xB5",
      "%B5": "\xB5",
      "%b6": "\xB6",
      "%B6": "\xB6",
      "%b7": "\xB7",
      "%B7": "\xB7",
      "%b8": "\xB8",
      "%B8": "\xB8",
      "%b9": "\xB9",
      "%B9": "\xB9",
      "%ba": "\xBA",
      "%Ba": "\xBA",
      "%bA": "\xBA",
      "%BA": "\xBA",
      "%bb": "\xBB",
      "%Bb": "\xBB",
      "%bB": "\xBB",
      "%BB": "\xBB",
      "%bc": "\xBC",
      "%Bc": "\xBC",
      "%bC": "\xBC",
      "%BC": "\xBC",
      "%bd": "\xBD",
      "%Bd": "\xBD",
      "%bD": "\xBD",
      "%BD": "\xBD",
      "%be": "\xBE",
      "%Be": "\xBE",
      "%bE": "\xBE",
      "%BE": "\xBE",
      "%bf": "\xBF",
      "%Bf": "\xBF",
      "%bF": "\xBF",
      "%BF": "\xBF",
      "%c0": "\xC0",
      "%C0": "\xC0",
      "%c1": "\xC1",
      "%C1": "\xC1",
      "%c2": "\xC2",
      "%C2": "\xC2",
      "%c3": "\xC3",
      "%C3": "\xC3",
      "%c4": "\xC4",
      "%C4": "\xC4",
      "%c5": "\xC5",
      "%C5": "\xC5",
      "%c6": "\xC6",
      "%C6": "\xC6",
      "%c7": "\xC7",
      "%C7": "\xC7",
      "%c8": "\xC8",
      "%C8": "\xC8",
      "%c9": "\xC9",
      "%C9": "\xC9",
      "%ca": "\xCA",
      "%Ca": "\xCA",
      "%cA": "\xCA",
      "%CA": "\xCA",
      "%cb": "\xCB",
      "%Cb": "\xCB",
      "%cB": "\xCB",
      "%CB": "\xCB",
      "%cc": "\xCC",
      "%Cc": "\xCC",
      "%cC": "\xCC",
      "%CC": "\xCC",
      "%cd": "\xCD",
      "%Cd": "\xCD",
      "%cD": "\xCD",
      "%CD": "\xCD",
      "%ce": "\xCE",
      "%Ce": "\xCE",
      "%cE": "\xCE",
      "%CE": "\xCE",
      "%cf": "\xCF",
      "%Cf": "\xCF",
      "%cF": "\xCF",
      "%CF": "\xCF",
      "%d0": "\xD0",
      "%D0": "\xD0",
      "%d1": "\xD1",
      "%D1": "\xD1",
      "%d2": "\xD2",
      "%D2": "\xD2",
      "%d3": "\xD3",
      "%D3": "\xD3",
      "%d4": "\xD4",
      "%D4": "\xD4",
      "%d5": "\xD5",
      "%D5": "\xD5",
      "%d6": "\xD6",
      "%D6": "\xD6",
      "%d7": "\xD7",
      "%D7": "\xD7",
      "%d8": "\xD8",
      "%D8": "\xD8",
      "%d9": "\xD9",
      "%D9": "\xD9",
      "%da": "\xDA",
      "%Da": "\xDA",
      "%dA": "\xDA",
      "%DA": "\xDA",
      "%db": "\xDB",
      "%Db": "\xDB",
      "%dB": "\xDB",
      "%DB": "\xDB",
      "%dc": "\xDC",
      "%Dc": "\xDC",
      "%dC": "\xDC",
      "%DC": "\xDC",
      "%dd": "\xDD",
      "%Dd": "\xDD",
      "%dD": "\xDD",
      "%DD": "\xDD",
      "%de": "\xDE",
      "%De": "\xDE",
      "%dE": "\xDE",
      "%DE": "\xDE",
      "%df": "\xDF",
      "%Df": "\xDF",
      "%dF": "\xDF",
      "%DF": "\xDF",
      "%e0": "\xE0",
      "%E0": "\xE0",
      "%e1": "\xE1",
      "%E1": "\xE1",
      "%e2": "\xE2",
      "%E2": "\xE2",
      "%e3": "\xE3",
      "%E3": "\xE3",
      "%e4": "\xE4",
      "%E4": "\xE4",
      "%e5": "\xE5",
      "%E5": "\xE5",
      "%e6": "\xE6",
      "%E6": "\xE6",
      "%e7": "\xE7",
      "%E7": "\xE7",
      "%e8": "\xE8",
      "%E8": "\xE8",
      "%e9": "\xE9",
      "%E9": "\xE9",
      "%ea": "\xEA",
      "%Ea": "\xEA",
      "%eA": "\xEA",
      "%EA": "\xEA",
      "%eb": "\xEB",
      "%Eb": "\xEB",
      "%eB": "\xEB",
      "%EB": "\xEB",
      "%ec": "\xEC",
      "%Ec": "\xEC",
      "%eC": "\xEC",
      "%EC": "\xEC",
      "%ed": "\xED",
      "%Ed": "\xED",
      "%eD": "\xED",
      "%ED": "\xED",
      "%ee": "\xEE",
      "%Ee": "\xEE",
      "%eE": "\xEE",
      "%EE": "\xEE",
      "%ef": "\xEF",
      "%Ef": "\xEF",
      "%eF": "\xEF",
      "%EF": "\xEF",
      "%f0": "\xF0",
      "%F0": "\xF0",
      "%f1": "\xF1",
      "%F1": "\xF1",
      "%f2": "\xF2",
      "%F2": "\xF2",
      "%f3": "\xF3",
      "%F3": "\xF3",
      "%f4": "\xF4",
      "%F4": "\xF4",
      "%f5": "\xF5",
      "%F5": "\xF5",
      "%f6": "\xF6",
      "%F6": "\xF6",
      "%f7": "\xF7",
      "%F7": "\xF7",
      "%f8": "\xF8",
      "%F8": "\xF8",
      "%f9": "\xF9",
      "%F9": "\xF9",
      "%fa": "\xFA",
      "%Fa": "\xFA",
      "%fA": "\xFA",
      "%FA": "\xFA",
      "%fb": "\xFB",
      "%Fb": "\xFB",
      "%fB": "\xFB",
      "%FB": "\xFB",
      "%fc": "\xFC",
      "%Fc": "\xFC",
      "%fC": "\xFC",
      "%FC": "\xFC",
      "%fd": "\xFD",
      "%Fd": "\xFD",
      "%fD": "\xFD",
      "%FD": "\xFD",
      "%fe": "\xFE",
      "%Fe": "\xFE",
      "%fE": "\xFE",
      "%FE": "\xFE",
      "%ff": "\xFF",
      "%Ff": "\xFF",
      "%fF": "\xFF",
      "%FF": "\xFF"
    };
    function encodedReplacer(match) {
      return EncodedLookup[match];
    }
    var STATE_KEY = 0, STATE_VALUE = 1, STATE_CHARSET = 2, STATE_LANG = 3;
    function parseParams(str) {
      let res = [], state = STATE_KEY, charset = "", inquote = !1, escaping = !1, p = 0, tmp = "", len = str.length;
      for (var i = 0; i < len; ++i) {
        let char = str[i];
        if (char === "\\" && inquote)
          if (escaping)
            escaping = !1;
          else {
            escaping = !0;
            continue;
          }
        else if (char === '"')
          if (escaping)
            escaping = !1;
          else {
            inquote ? (inquote = !1, state = STATE_KEY) : inquote = !0;
            continue;
          }
        else if (escaping && inquote && (tmp += "\\"), escaping = !1, (state === STATE_CHARSET || state === STATE_LANG) && char === "'") {
          state === STATE_CHARSET ? (state = STATE_LANG, charset = tmp.substring(1)) : state = STATE_VALUE, tmp = "";
          continue;
        } else if (state === STATE_KEY && (char === "*" || char === "=") && res.length) {
          state = char === "*" ? STATE_CHARSET : STATE_VALUE, res[p] = [tmp, void 0], tmp = "";
          continue;
        } else if (!inquote && char === ";") {
          state = STATE_KEY, charset ? (tmp.length && (tmp = decodeText(
            tmp.replace(RE_ENCODED, encodedReplacer),
            "binary",
            charset
          )), charset = "") : tmp.length && (tmp = decodeText(tmp, "binary", "utf8")), res[p] === void 0 ? res[p] = tmp : res[p][1] = tmp, tmp = "", ++p;
          continue;
        } else if (!inquote && (char === " " || char === "	"))
          continue;
        tmp += char;
      }
      return charset && tmp.length ? tmp = decodeText(
        tmp.replace(RE_ENCODED, encodedReplacer),
        "binary",
        charset
      ) : tmp && (tmp = decodeText(tmp, "binary", "utf8")), res[p] === void 0 ? tmp && (res[p] = tmp) : res[p][1] = tmp, res;
    }
    module2.exports = parseParams;
  }
});

// node_modules/@fastify/busboy/lib/utils/basename.js
var require_basename = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/basename.js"(exports2, module2) {
    "use strict";
    module2.exports = function(path8) {
      if (typeof path8 != "string")
        return "";
      for (var i = path8.length - 1; i >= 0; --i)
        switch (path8.charCodeAt(i)) {
          case 47:
          // '/'
          case 92:
            return path8 = path8.slice(i + 1), path8 === ".." || path8 === "." ? "" : path8;
        }
      return path8 === ".." || path8 === "." ? "" : path8;
    };
  }
});

// node_modules/@fastify/busboy/lib/types/multipart.js
var require_multipart = __commonJS({
  "node_modules/@fastify/busboy/lib/types/multipart.js"(exports2, module2) {
    "use strict";
    var { Readable } = require("node:stream"), { inherits } = require("node:util"), Dicer = require_Dicer(), parseParams = require_parseParams(), decodeText = require_decodeText(), basename2 = require_basename(), getLimit = require_getLimit(), RE_BOUNDARY = /^boundary$/i, RE_FIELD = /^form-data$/i, RE_CHARSET = /^charset$/i, RE_FILENAME = /^filename$/i, RE_NAME = /^name$/i;
    Multipart.detect = /^multipart\/form-data/i;
    function Multipart(boy, cfg) {
      let i, len, self2 = this, boundary, limits = cfg.limits, isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName) => contentType === "application/octet-stream" || fileName !== void 0), parsedConType = cfg.parsedConType || [], defCharset = cfg.defCharset || "utf8", preservePath = cfg.preservePath, fileOpts = { highWaterMark: cfg.fileHwm };
      for (i = 0, len = parsedConType.length; i < len; ++i)
        if (Array.isArray(parsedConType[i]) && RE_BOUNDARY.test(parsedConType[i][0])) {
          boundary = parsedConType[i][1];
          break;
        }
      function checkFinished() {
        nends === 0 && finished && !boy._done && (finished = !1, self2.end());
      }
      if (typeof boundary != "string")
        throw new Error("Multipart: Boundary not found");
      let fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024), fileSizeLimit = getLimit(limits, "fileSize", 1 / 0), filesLimit = getLimit(limits, "files", 1 / 0), fieldsLimit = getLimit(limits, "fields", 1 / 0), partsLimit = getLimit(limits, "parts", 1 / 0), headerPairsLimit = getLimit(limits, "headerPairs", 2e3), headerSizeLimit = getLimit(limits, "headerSize", 80 * 1024), nfiles = 0, nfields = 0, nends = 0, curFile, curField, finished = !1;
      this._needDrain = !1, this._pause = !1, this._cb = void 0, this._nparts = 0, this._boy = boy;
      let parserCfg = {
        boundary,
        maxHeaderPairs: headerPairsLimit,
        maxHeaderSize: headerSizeLimit,
        partHwm: fileOpts.highWaterMark,
        highWaterMark: cfg.highWaterMark
      };
      this.parser = new Dicer(parserCfg), this.parser.on("drain", function() {
        if (self2._needDrain = !1, self2._cb && !self2._pause) {
          let cb = self2._cb;
          self2._cb = void 0, cb();
        }
      }).on("part", function onPart(part) {
        if (++self2._nparts > partsLimit)
          return self2.parser.removeListener("part", onPart), self2.parser.on("part", skipPart), boy.hitPartsLimit = !0, boy.emit("partsLimit"), skipPart(part);
        if (curField) {
          let field = curField;
          field.emit("end"), field.removeAllListeners("end");
        }
        part.on("header", function(header) {
          let contype, fieldname, parsed, charset, encoding, filename, nsize = 0;
          if (header["content-type"] && (parsed = parseParams(header["content-type"][0]), parsed[0])) {
            for (contype = parsed[0].toLowerCase(), i = 0, len = parsed.length; i < len; ++i)
              if (RE_CHARSET.test(parsed[i][0])) {
                charset = parsed[i][1].toLowerCase();
                break;
              }
          }
          if (contype === void 0 && (contype = "text/plain"), charset === void 0 && (charset = defCharset), header["content-disposition"]) {
            if (parsed = parseParams(header["content-disposition"][0]), !RE_FIELD.test(parsed[0]))
              return skipPart(part);
            for (i = 0, len = parsed.length; i < len; ++i)
              RE_NAME.test(parsed[i][0]) ? fieldname = parsed[i][1] : RE_FILENAME.test(parsed[i][0]) && (filename = parsed[i][1], preservePath || (filename = basename2(filename)));
          } else
            return skipPart(part);
          header["content-transfer-encoding"] ? encoding = header["content-transfer-encoding"][0].toLowerCase() : encoding = "7bit";
          let onData, onEnd;
          if (isPartAFile(fieldname, contype, filename)) {
            if (nfiles === filesLimit)
              return boy.hitFilesLimit || (boy.hitFilesLimit = !0, boy.emit("filesLimit")), skipPart(part);
            if (++nfiles, boy.listenerCount("file") === 0) {
              self2.parser._ignore();
              return;
            }
            ++nends;
            let file = new FileStream(fileOpts);
            curFile = file, file.on("end", function() {
              if (--nends, self2._pause = !1, checkFinished(), self2._cb && !self2._needDrain) {
                let cb = self2._cb;
                self2._cb = void 0, cb();
              }
            }), file._read = function(n) {
              if (self2._pause && (self2._pause = !1, self2._cb && !self2._needDrain)) {
                let cb = self2._cb;
                self2._cb = void 0, cb();
              }
            }, boy.emit("file", fieldname, file, filename, encoding, contype), onData = function(data) {
              if ((nsize += data.length) > fileSizeLimit) {
                let extralen = fileSizeLimit - nsize + data.length;
                extralen > 0 && file.push(data.slice(0, extralen)), file.truncated = !0, file.bytesRead = fileSizeLimit, part.removeAllListeners("data"), file.emit("limit");
                return;
              } else file.push(data) || (self2._pause = !0);
              file.bytesRead = nsize;
            }, onEnd = function() {
              curFile = void 0, file.push(null);
            };
          } else {
            if (nfields === fieldsLimit)
              return boy.hitFieldsLimit || (boy.hitFieldsLimit = !0, boy.emit("fieldsLimit")), skipPart(part);
            ++nfields, ++nends;
            let buffer = "", truncated = !1;
            curField = part, onData = function(data) {
              if ((nsize += data.length) > fieldSizeLimit) {
                let extralen = fieldSizeLimit - (nsize - data.length);
                buffer += data.toString("binary", 0, extralen), truncated = !0, part.removeAllListeners("data");
              } else
                buffer += data.toString("binary");
            }, onEnd = function() {
              curField = void 0, buffer.length && (buffer = decodeText(buffer, "binary", charset)), boy.emit("field", fieldname, buffer, !1, truncated, encoding, contype), --nends, checkFinished();
            };
          }
          part._readableState.sync = !1, part.on("data", onData), part.on("end", onEnd);
        }).on("error", function(err) {
          curFile && curFile.emit("error", err);
        });
      }).on("error", function(err) {
        boy.emit("error", err);
      }).on("finish", function() {
        finished = !0, checkFinished();
      });
    }
    Multipart.prototype.write = function(chunk, cb) {
      let r = this.parser.write(chunk);
      r && !this._pause ? cb() : (this._needDrain = !r, this._cb = cb);
    };
    Multipart.prototype.end = function() {
      let self2 = this;
      self2.parser.writable ? self2.parser.end() : self2._boy._done || process.nextTick(function() {
        self2._boy._done = !0, self2._boy.emit("finish");
      });
    };
    function skipPart(part) {
      part.resume();
    }
    function FileStream(opts) {
      Readable.call(this, opts), this.bytesRead = 0, this.truncated = !1;
    }
    inherits(FileStream, Readable);
    FileStream.prototype._read = function(n) {
    };
    module2.exports = Multipart;
  }
});

// node_modules/@fastify/busboy/lib/utils/Decoder.js
var require_Decoder = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/Decoder.js"(exports2, module2) {
    "use strict";
    var RE_PLUS = /\+/g, HEX = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ];
    function Decoder() {
      this.buffer = void 0;
    }
    Decoder.prototype.write = function(str) {
      str = str.replace(RE_PLUS, " ");
      let res = "", i = 0, p = 0, len = str.length;
      for (; i < len; ++i)
        this.buffer !== void 0 ? HEX[str.charCodeAt(i)] ? (this.buffer += str[i], ++p, this.buffer.length === 2 && (res += String.fromCharCode(parseInt(this.buffer, 16)), this.buffer = void 0)) : (res += "%" + this.buffer, this.buffer = void 0, --i) : str[i] === "%" && (i > p && (res += str.substring(p, i), p = i), this.buffer = "", ++p);
      return p < len && this.buffer === void 0 && (res += str.substring(p)), res;
    };
    Decoder.prototype.reset = function() {
      this.buffer = void 0;
    };
    module2.exports = Decoder;
  }
});

// node_modules/@fastify/busboy/lib/types/urlencoded.js
var require_urlencoded = __commonJS({
  "node_modules/@fastify/busboy/lib/types/urlencoded.js"(exports2, module2) {
    "use strict";
    var Decoder = require_Decoder(), decodeText = require_decodeText(), getLimit = require_getLimit(), RE_CHARSET = /^charset$/i;
    UrlEncoded.detect = /^application\/x-www-form-urlencoded/i;
    function UrlEncoded(boy, cfg) {
      let limits = cfg.limits, parsedConType = cfg.parsedConType;
      this.boy = boy, this.fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024), this.fieldNameSizeLimit = getLimit(limits, "fieldNameSize", 100), this.fieldsLimit = getLimit(limits, "fields", 1 / 0);
      let charset;
      for (var i = 0, len = parsedConType.length; i < len; ++i)
        if (Array.isArray(parsedConType[i]) && RE_CHARSET.test(parsedConType[i][0])) {
          charset = parsedConType[i][1].toLowerCase();
          break;
        }
      charset === void 0 && (charset = cfg.defCharset || "utf8"), this.decoder = new Decoder(), this.charset = charset, this._fields = 0, this._state = "key", this._checkingBytes = !0, this._bytesKey = 0, this._bytesVal = 0, this._key = "", this._val = "", this._keyTrunc = !1, this._valTrunc = !1, this._hitLimit = !1;
    }
    UrlEncoded.prototype.write = function(data, cb) {
      if (this._fields === this.fieldsLimit)
        return this.boy.hitFieldsLimit || (this.boy.hitFieldsLimit = !0, this.boy.emit("fieldsLimit")), cb();
      let idxeq, idxamp, i, p = 0, len = data.length;
      for (; p < len; )
        if (this._state === "key") {
          for (idxeq = idxamp = void 0, i = p; i < len; ++i) {
            if (this._checkingBytes || ++p, data[i] === 61) {
              idxeq = i;
              break;
            } else if (data[i] === 38) {
              idxamp = i;
              break;
            }
            if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {
              this._hitLimit = !0;
              break;
            } else this._checkingBytes && ++this._bytesKey;
          }
          if (idxeq !== void 0)
            idxeq > p && (this._key += this.decoder.write(data.toString("binary", p, idxeq))), this._state = "val", this._hitLimit = !1, this._checkingBytes = !0, this._val = "", this._bytesVal = 0, this._valTrunc = !1, this.decoder.reset(), p = idxeq + 1;
          else if (idxamp !== void 0) {
            ++this._fields;
            let key, keyTrunc = this._keyTrunc;
            if (idxamp > p ? key = this._key += this.decoder.write(data.toString("binary", p, idxamp)) : key = this._key, this._hitLimit = !1, this._checkingBytes = !0, this._key = "", this._bytesKey = 0, this._keyTrunc = !1, this.decoder.reset(), key.length && this.boy.emit(
              "field",
              decodeText(key, "binary", this.charset),
              "",
              keyTrunc,
              !1
            ), p = idxamp + 1, this._fields === this.fieldsLimit)
              return cb();
          } else this._hitLimit ? (i > p && (this._key += this.decoder.write(data.toString("binary", p, i))), p = i, (this._bytesKey = this._key.length) === this.fieldNameSizeLimit && (this._checkingBytes = !1, this._keyTrunc = !0)) : (p < len && (this._key += this.decoder.write(data.toString("binary", p))), p = len);
        } else {
          for (idxamp = void 0, i = p; i < len; ++i) {
            if (this._checkingBytes || ++p, data[i] === 38) {
              idxamp = i;
              break;
            }
            if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {
              this._hitLimit = !0;
              break;
            } else this._checkingBytes && ++this._bytesVal;
          }
          if (idxamp !== void 0) {
            if (++this._fields, idxamp > p && (this._val += this.decoder.write(data.toString("binary", p, idxamp))), this.boy.emit(
              "field",
              decodeText(this._key, "binary", this.charset),
              decodeText(this._val, "binary", this.charset),
              this._keyTrunc,
              this._valTrunc
            ), this._state = "key", this._hitLimit = !1, this._checkingBytes = !0, this._key = "", this._bytesKey = 0, this._keyTrunc = !1, this.decoder.reset(), p = idxamp + 1, this._fields === this.fieldsLimit)
              return cb();
          } else this._hitLimit ? (i > p && (this._val += this.decoder.write(data.toString("binary", p, i))), p = i, (this._val === "" && this.fieldSizeLimit === 0 || (this._bytesVal = this._val.length) === this.fieldSizeLimit) && (this._checkingBytes = !1, this._valTrunc = !0)) : (p < len && (this._val += this.decoder.write(data.toString("binary", p))), p = len);
        }
      cb();
    };
    UrlEncoded.prototype.end = function() {
      this.boy._done || (this._state === "key" && this._key.length > 0 ? this.boy.emit(
        "field",
        decodeText(this._key, "binary", this.charset),
        "",
        this._keyTrunc,
        !1
      ) : this._state === "val" && this.boy.emit(
        "field",
        decodeText(this._key, "binary", this.charset),
        decodeText(this._val, "binary", this.charset),
        this._keyTrunc,
        this._valTrunc
      ), this.boy._done = !0, this.boy.emit("finish"));
    };
    module2.exports = UrlEncoded;
  }
});

// node_modules/@fastify/busboy/lib/main.js
var require_main = __commonJS({
  "node_modules/@fastify/busboy/lib/main.js"(exports2, module2) {
    "use strict";
    var WritableStream = require("node:stream").Writable, { inherits } = require("node:util"), Dicer = require_Dicer(), MultipartParser = require_multipart(), UrlencodedParser = require_urlencoded(), parseParams = require_parseParams();
    function Busboy(opts) {
      if (!(this instanceof Busboy))
        return new Busboy(opts);
      if (typeof opts != "object")
        throw new TypeError("Busboy expected an options-Object.");
      if (typeof opts.headers != "object")
        throw new TypeError("Busboy expected an options-Object with headers-attribute.");
      if (typeof opts.headers["content-type"] != "string")
        throw new TypeError("Missing Content-Type-header.");
      let {
        headers,
        ...streamOptions
      } = opts;
      this.opts = {
        autoDestroy: !1,
        ...streamOptions
      }, WritableStream.call(this, this.opts), this._done = !1, this._parser = this.getParserByHeaders(headers), this._finished = !1;
    }
    inherits(Busboy, WritableStream);
    Busboy.prototype.emit = function(ev) {
      if (ev === "finish") {
        if (this._done) {
          if (this._finished)
            return;
        } else {
          this._parser?.end();
          return;
        }
        this._finished = !0;
      }
      WritableStream.prototype.emit.apply(this, arguments);
    };
    Busboy.prototype.getParserByHeaders = function(headers) {
      let parsed = parseParams(headers["content-type"]), cfg = {
        defCharset: this.opts.defCharset,
        fileHwm: this.opts.fileHwm,
        headers,
        highWaterMark: this.opts.highWaterMark,
        isPartAFile: this.opts.isPartAFile,
        limits: this.opts.limits,
        parsedConType: parsed,
        preservePath: this.opts.preservePath
      };
      if (MultipartParser.detect.test(parsed[0]))
        return new MultipartParser(this, cfg);
      if (UrlencodedParser.detect.test(parsed[0]))
        return new UrlencodedParser(this, cfg);
      throw new Error("Unsupported Content-Type.");
    };
    Busboy.prototype._write = function(chunk, encoding, cb) {
      this._parser.write(chunk, cb);
    };
    module2.exports = Busboy;
    module2.exports.default = Busboy;
    module2.exports.Busboy = Busboy;
    module2.exports.Dicer = Dicer;
  }
});

// node_modules/undici/lib/fetch/constants.js
var require_constants2 = __commonJS({
  "node_modules/undici/lib/fetch/constants.js"(exports2, module2) {
    "use strict";
    var { MessageChannel, receiveMessageOnPort } = require("worker_threads"), corsSafeListedMethods = ["GET", "HEAD", "POST"], corsSafeListedMethodsSet = new Set(corsSafeListedMethods), nullBodyStatus = [101, 204, 205, 304], redirectStatus = [301, 302, 303, 307, 308], redirectStatusSet = new Set(redirectStatus), badPorts = [
      "1",
      "7",
      "9",
      "11",
      "13",
      "15",
      "17",
      "19",
      "20",
      "21",
      "22",
      "23",
      "25",
      "37",
      "42",
      "43",
      "53",
      "69",
      "77",
      "79",
      "87",
      "95",
      "101",
      "102",
      "103",
      "104",
      "109",
      "110",
      "111",
      "113",
      "115",
      "117",
      "119",
      "123",
      "135",
      "137",
      "139",
      "143",
      "161",
      "179",
      "389",
      "427",
      "465",
      "512",
      "513",
      "514",
      "515",
      "526",
      "530",
      "531",
      "532",
      "540",
      "548",
      "554",
      "556",
      "563",
      "587",
      "601",
      "636",
      "989",
      "990",
      "993",
      "995",
      "1719",
      "1720",
      "1723",
      "2049",
      "3659",
      "4045",
      "5060",
      "5061",
      "6000",
      "6566",
      "6665",
      "6666",
      "6667",
      "6668",
      "6669",
      "6697",
      "10080"
    ], badPortsSet = new Set(badPorts), referrerPolicy = [
      "",
      "no-referrer",
      "no-referrer-when-downgrade",
      "same-origin",
      "origin",
      "strict-origin",
      "origin-when-cross-origin",
      "strict-origin-when-cross-origin",
      "unsafe-url"
    ], referrerPolicySet = new Set(referrerPolicy), requestRedirect = ["follow", "manual", "error"], safeMethods = ["GET", "HEAD", "OPTIONS", "TRACE"], safeMethodsSet = new Set(safeMethods), requestMode = ["navigate", "same-origin", "no-cors", "cors"], requestCredentials = ["omit", "same-origin", "include"], requestCache = [
      "default",
      "no-store",
      "reload",
      "no-cache",
      "force-cache",
      "only-if-cached"
    ], requestBodyHeader = [
      "content-encoding",
      "content-language",
      "content-location",
      "content-type",
      // See https://github.com/nodejs/undici/issues/2021
      // 'Content-Length' is a forbidden header name, which is typically
      // removed in the Headers implementation. However, undici doesn't
      // filter out headers, so we add it here.
      "content-length"
    ], requestDuplex = [
      "half"
    ], forbiddenMethods = ["CONNECT", "TRACE", "TRACK"], forbiddenMethodsSet = new Set(forbiddenMethods), subresource = [
      "audio",
      "audioworklet",
      "font",
      "image",
      "manifest",
      "paintworklet",
      "script",
      "style",
      "track",
      "video",
      "xslt",
      ""
    ], subresourceSet = new Set(subresource), DOMException2 = globalThis.DOMException ?? (() => {
      try {
        atob("~");
      } catch (err) {
        return Object.getPrototypeOf(err).constructor;
      }
    })(), channel, structuredClone = globalThis.structuredClone ?? // https://github.com/nodejs/node/blob/b27ae24dcc4251bad726d9d84baf678d1f707fed/lib/internal/structured_clone.js
    // structuredClone was added in v17.0.0, but fetch supports v16.8
    function(value, options = void 0) {
      if (arguments.length === 0)
        throw new TypeError("missing argument");
      return channel || (channel = new MessageChannel()), channel.port1.unref(), channel.port2.unref(), channel.port1.postMessage(value, options?.transfer), receiveMessageOnPort(channel.port2).message;
    };
    module2.exports = {
      DOMException: DOMException2,
      structuredClone,
      subresource,
      forbiddenMethods,
      requestBodyHeader,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache,
      redirectStatus,
      corsSafeListedMethods,
      nullBodyStatus,
      safeMethods,
      badPorts,
      requestDuplex,
      subresourceSet,
      badPortsSet,
      redirectStatusSet,
      corsSafeListedMethodsSet,
      safeMethodsSet,
      forbiddenMethodsSet,
      referrerPolicySet
    };
  }
});

// node_modules/undici/lib/fetch/global.js
var require_global = __commonJS({
  "node_modules/undici/lib/fetch/global.js"(exports2, module2) {
    "use strict";
    var globalOrigin = Symbol.for("undici.globalOrigin.1");
    function getGlobalOrigin() {
      return globalThis[globalOrigin];
    }
    function setGlobalOrigin(newOrigin) {
      if (newOrigin === void 0) {
        Object.defineProperty(globalThis, globalOrigin, {
          value: void 0,
          writable: !0,
          enumerable: !1,
          configurable: !1
        });
        return;
      }
      let parsedURL = new URL(newOrigin);
      if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:")
        throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
      Object.defineProperty(globalThis, globalOrigin, {
        value: parsedURL,
        writable: !0,
        enumerable: !1,
        configurable: !1
      });
    }
    module2.exports = {
      getGlobalOrigin,
      setGlobalOrigin
    };
  }
});

// node_modules/undici/lib/fetch/util.js
var require_util2 = __commonJS({
  "node_modules/undici/lib/fetch/util.js"(exports2, module2) {
    "use strict";
    var { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = require_constants2(), { getGlobalOrigin } = require_global(), { performance: performance2 } = require("perf_hooks"), { isBlobLike, toUSVString, ReadableStreamFrom } = require_util(), assert3 = require("assert"), { isUint8Array } = require("util/types"), supportedHashes = [], crypto;
    try {
      crypto = require("crypto");
      let possibleRelevantHashes = ["sha256", "sha384", "sha512"];
      supportedHashes = crypto.getHashes().filter((hash) => possibleRelevantHashes.includes(hash));
    } catch {
    }
    function responseURL(response) {
      let urlList = response.urlList, length = urlList.length;
      return length === 0 ? null : urlList[length - 1].toString();
    }
    function responseLocationURL(response, requestFragment) {
      if (!redirectStatusSet.has(response.status))
        return null;
      let location = response.headersList.get("location");
      return location !== null && isValidHeaderValue(location) && (location = new URL(location, responseURL(response))), location && !location.hash && (location.hash = requestFragment), location;
    }
    function requestCurrentURL(request) {
      return request.urlList[request.urlList.length - 1];
    }
    function requestBadPort(request) {
      let url = requestCurrentURL(request);
      return urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port) ? "blocked" : "allowed";
    }
    function isErrorLike(object) {
      return object instanceof Error || object?.constructor?.name === "Error" || object?.constructor?.name === "DOMException";
    }
    function isValidReasonPhrase(statusText) {
      for (let i = 0; i < statusText.length; ++i) {
        let c = statusText.charCodeAt(i);
        if (!(c === 9 || // HTAB
        c >= 32 && c <= 126 || // SP / VCHAR
        c >= 128 && c <= 255))
          return !1;
      }
      return !0;
    }
    function isTokenCharCode(c) {
      switch (c) {
        case 34:
        case 40:
        case 41:
        case 44:
        case 47:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 91:
        case 92:
        case 93:
        case 123:
        case 125:
          return !1;
        default:
          return c >= 33 && c <= 126;
      }
    }
    function isValidHTTPToken(characters) {
      if (characters.length === 0)
        return !1;
      for (let i = 0; i < characters.length; ++i)
        if (!isTokenCharCode(characters.charCodeAt(i)))
          return !1;
      return !0;
    }
    function isValidHeaderName(potentialValue) {
      return isValidHTTPToken(potentialValue);
    }
    function isValidHeaderValue(potentialValue) {
      return !(potentialValue.startsWith("	") || potentialValue.startsWith(" ") || potentialValue.endsWith("	") || potentialValue.endsWith(" ") || potentialValue.includes("\0") || potentialValue.includes("\r") || potentialValue.includes(`
`));
    }
    function setRequestReferrerPolicyOnRedirect(request, actualResponse) {
      let { headersList } = actualResponse, policyHeader = (headersList.get("referrer-policy") ?? "").split(","), policy = "";
      if (policyHeader.length > 0)
        for (let i = policyHeader.length; i !== 0; i--) {
          let token = policyHeader[i - 1].trim();
          if (referrerPolicyTokens.has(token)) {
            policy = token;
            break;
          }
        }
      policy !== "" && (request.referrerPolicy = policy);
    }
    function crossOriginResourcePolicyCheck() {
      return "allowed";
    }
    function corsCheck() {
      return "success";
    }
    function TAOCheck() {
      return "success";
    }
    function appendFetchMetadata(httpRequest) {
      let header = null;
      header = httpRequest.mode, httpRequest.headersList.set("sec-fetch-mode", header);
    }
    function appendRequestOriginHeader(request) {
      let serializedOrigin = request.origin;
      if (request.responseTainting === "cors" || request.mode === "websocket")
        serializedOrigin && request.headersList.append("origin", serializedOrigin);
      else if (request.method !== "GET" && request.method !== "HEAD") {
        switch (request.referrerPolicy) {
          case "no-referrer":
            serializedOrigin = null;
            break;
          case "no-referrer-when-downgrade":
          case "strict-origin":
          case "strict-origin-when-cross-origin":
            request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request)) && (serializedOrigin = null);
            break;
          case "same-origin":
            sameOrigin(request, requestCurrentURL(request)) || (serializedOrigin = null);
            break;
          default:
        }
        serializedOrigin && request.headersList.append("origin", serializedOrigin);
      }
    }
    function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
      return performance2.now();
    }
    function createOpaqueTimingInfo(timingInfo) {
      return {
        startTime: timingInfo.startTime ?? 0,
        redirectStartTime: 0,
        redirectEndTime: 0,
        postRedirectStartTime: timingInfo.startTime ?? 0,
        finalServiceWorkerStartTime: 0,
        finalNetworkResponseStartTime: 0,
        finalNetworkRequestStartTime: 0,
        endTime: 0,
        encodedBodySize: 0,
        decodedBodySize: 0,
        finalConnectionTimingInfo: null
      };
    }
    function makePolicyContainer() {
      return {
        referrerPolicy: "strict-origin-when-cross-origin"
      };
    }
    function clonePolicyContainer(policyContainer) {
      return {
        referrerPolicy: policyContainer.referrerPolicy
      };
    }
    function determineRequestsReferrer(request) {
      let policy = request.referrerPolicy;
      assert3(policy);
      let referrerSource = null;
      if (request.referrer === "client") {
        let globalOrigin = getGlobalOrigin();
        if (!globalOrigin || globalOrigin.origin === "null")
          return "no-referrer";
        referrerSource = new URL(globalOrigin);
      } else request.referrer instanceof URL && (referrerSource = request.referrer);
      let referrerURL = stripURLForReferrer(referrerSource), referrerOrigin = stripURLForReferrer(referrerSource, !0);
      referrerURL.toString().length > 4096 && (referrerURL = referrerOrigin);
      let areSameOrigin = sameOrigin(request, referrerURL), isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request.url);
      switch (policy) {
        case "origin":
          return referrerOrigin ?? stripURLForReferrer(referrerSource, !0);
        case "unsafe-url":
          return referrerURL;
        case "same-origin":
          return areSameOrigin ? referrerOrigin : "no-referrer";
        case "origin-when-cross-origin":
          return areSameOrigin ? referrerURL : referrerOrigin;
        case "strict-origin-when-cross-origin": {
          let currentURL = requestCurrentURL(request);
          return sameOrigin(referrerURL, currentURL) ? referrerURL : isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL) ? "no-referrer" : referrerOrigin;
        }
        case "strict-origin":
        // eslint-disable-line
        /**
           * 1. If referrerURL is a potentially trustworthy URL and
           * request’s current URL is not a potentially trustworthy URL,
           * then return no referrer.
           * 2. Return referrerOrigin
          */
        case "no-referrer-when-downgrade":
        // eslint-disable-line
        /**
         * 1. If referrerURL is a potentially trustworthy URL and
         * request’s current URL is not a potentially trustworthy URL,
         * then return no referrer.
         * 2. Return referrerOrigin
        */
        default:
          return isNonPotentiallyTrustWorthy ? "no-referrer" : referrerOrigin;
      }
    }
    function stripURLForReferrer(url, originOnly) {
      return assert3(url instanceof URL), url.protocol === "file:" || url.protocol === "about:" || url.protocol === "blank:" ? "no-referrer" : (url.username = "", url.password = "", url.hash = "", originOnly && (url.pathname = "", url.search = ""), url);
    }
    function isURLPotentiallyTrustworthy(url) {
      if (!(url instanceof URL))
        return !1;
      if (url.href === "about:blank" || url.href === "about:srcdoc" || url.protocol === "data:" || url.protocol === "file:") return !0;
      return isOriginPotentiallyTrustworthy(url.origin);
      function isOriginPotentiallyTrustworthy(origin) {
        if (origin == null || origin === "null") return !1;
        let originAsURL = new URL(origin);
        return !!(originAsURL.protocol === "https:" || originAsURL.protocol === "wss:" || /^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) || originAsURL.hostname === "localhost" || originAsURL.hostname.includes("localhost.") || originAsURL.hostname.endsWith(".localhost"));
      }
    }
    function bytesMatch(bytes, metadataList) {
      if (crypto === void 0)
        return !0;
      let parsedMetadata = parseMetadata(metadataList);
      if (parsedMetadata === "no metadata" || parsedMetadata.length === 0)
        return !0;
      let strongest = getStrongestMetadata(parsedMetadata), metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest);
      for (let item of metadata) {
        let algorithm = item.algo, expectedValue = item.hash, actualValue = crypto.createHash(algorithm).update(bytes).digest("base64");
        if (actualValue[actualValue.length - 1] === "=" && (actualValue[actualValue.length - 2] === "=" ? actualValue = actualValue.slice(0, -2) : actualValue = actualValue.slice(0, -1)), compareBase64Mixed(actualValue, expectedValue))
          return !0;
      }
      return !1;
    }
    var parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
    function parseMetadata(metadata) {
      let result = [], empty = !0;
      for (let token of metadata.split(" ")) {
        empty = !1;
        let parsedToken = parseHashWithOptions.exec(token);
        if (parsedToken === null || parsedToken.groups === void 0 || parsedToken.groups.algo === void 0)
          continue;
        let algorithm = parsedToken.groups.algo.toLowerCase();
        supportedHashes.includes(algorithm) && result.push(parsedToken.groups);
      }
      return empty === !0 ? "no metadata" : result;
    }
    function getStrongestMetadata(metadataList) {
      let algorithm = metadataList[0].algo;
      if (algorithm[3] === "5")
        return algorithm;
      for (let i = 1; i < metadataList.length; ++i) {
        let metadata = metadataList[i];
        if (metadata.algo[3] === "5") {
          algorithm = "sha512";
          break;
        } else {
          if (algorithm[3] === "3")
            continue;
          metadata.algo[3] === "3" && (algorithm = "sha384");
        }
      }
      return algorithm;
    }
    function filterMetadataListByAlgorithm(metadataList, algorithm) {
      if (metadataList.length === 1)
        return metadataList;
      let pos2 = 0;
      for (let i = 0; i < metadataList.length; ++i)
        metadataList[i].algo === algorithm && (metadataList[pos2++] = metadataList[i]);
      return metadataList.length = pos2, metadataList;
    }
    function compareBase64Mixed(actualValue, expectedValue) {
      if (actualValue.length !== expectedValue.length)
        return !1;
      for (let i = 0; i < actualValue.length; ++i)
        if (actualValue[i] !== expectedValue[i]) {
          if (actualValue[i] === "+" && expectedValue[i] === "-" || actualValue[i] === "/" && expectedValue[i] === "_")
            continue;
          return !1;
        }
      return !0;
    }
    function tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {
    }
    function sameOrigin(A, B) {
      return A.origin === B.origin && A.origin === "null" || A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port;
    }
    function createDeferredPromise() {
      let res, rej;
      return { promise: new Promise((resolve2, reject) => {
        res = resolve2, rej = reject;
      }), resolve: res, reject: rej };
    }
    function isAborted(fetchParams) {
      return fetchParams.controller.state === "aborted";
    }
    function isCancelled(fetchParams) {
      return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
    }
    var normalizeMethodRecord = {
      delete: "DELETE",
      DELETE: "DELETE",
      get: "GET",
      GET: "GET",
      head: "HEAD",
      HEAD: "HEAD",
      options: "OPTIONS",
      OPTIONS: "OPTIONS",
      post: "POST",
      POST: "POST",
      put: "PUT",
      PUT: "PUT"
    };
    Object.setPrototypeOf(normalizeMethodRecord, null);
    function normalizeMethod(method) {
      return normalizeMethodRecord[method.toLowerCase()] ?? method;
    }
    function serializeJavascriptValueToJSONString(value) {
      let result = JSON.stringify(value);
      if (result === void 0)
        throw new TypeError("Value is not JSON serializable");
      return assert3(typeof result == "string"), result;
    }
    var esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
    function makeIterator(iterator, name2, kind) {
      let object = {
        index: 0,
        kind,
        target: iterator
      }, i = {
        next() {
          if (Object.getPrototypeOf(this) !== i)
            throw new TypeError(
              `'next' called on an object that does not implement interface ${name2} Iterator.`
            );
          let { index, kind: kind2, target } = object, values = target(), len = values.length;
          if (index >= len)
            return { value: void 0, done: !0 };
          let pair = values[index];
          return object.index = index + 1, iteratorResult(pair, kind2);
        },
        // The class string of an iterator prototype object for a given interface is the
        // result of concatenating the identifier of the interface and the string " Iterator".
        [Symbol.toStringTag]: `${name2} Iterator`
      };
      return Object.setPrototypeOf(i, esIteratorPrototype), Object.setPrototypeOf({}, i);
    }
    function iteratorResult(pair, kind) {
      let result;
      switch (kind) {
        case "key": {
          result = pair[0];
          break;
        }
        case "value": {
          result = pair[1];
          break;
        }
        case "key+value": {
          result = pair;
          break;
        }
      }
      return { value: result, done: !1 };
    }
    async function fullyReadBody(body, processBody, processBodyError) {
      let successSteps = processBody, errorSteps = processBodyError, reader;
      try {
        reader = body.stream.getReader();
      } catch (e) {
        errorSteps(e);
        return;
      }
      try {
        let result = await readAllBytes(reader);
        successSteps(result);
      } catch (e) {
        errorSteps(e);
      }
    }
    var ReadableStream = globalThis.ReadableStream;
    function isReadableStreamLike(stream) {
      return ReadableStream || (ReadableStream = require("stream/web").ReadableStream), stream instanceof ReadableStream || stream[Symbol.toStringTag] === "ReadableStream" && typeof stream.tee == "function";
    }
    var MAXIMUM_ARGUMENT_LENGTH = 65535;
    function isomorphicDecode(input) {
      return input.length < MAXIMUM_ARGUMENT_LENGTH ? String.fromCharCode(...input) : input.reduce((previous, current) => previous + String.fromCharCode(current), "");
    }
    function readableStreamClose(controller) {
      try {
        controller.close();
      } catch (err) {
        if (!err.message.includes("Controller is already closed"))
          throw err;
      }
    }
    function isomorphicEncode(input) {
      for (let i = 0; i < input.length; i++)
        assert3(input.charCodeAt(i) <= 255);
      return input;
    }
    async function readAllBytes(reader) {
      let bytes = [], byteLength = 0;
      for (; ; ) {
        let { done, value: chunk } = await reader.read();
        if (done)
          return Buffer.concat(bytes, byteLength);
        if (!isUint8Array(chunk))
          throw new TypeError("Received non-Uint8Array chunk");
        bytes.push(chunk), byteLength += chunk.length;
      }
    }
    function urlIsLocal(url) {
      assert3("protocol" in url);
      let protocol = url.protocol;
      return protocol === "about:" || protocol === "blob:" || protocol === "data:";
    }
    function urlHasHttpsScheme(url) {
      return typeof url == "string" ? url.startsWith("https:") : url.protocol === "https:";
    }
    function urlIsHttpHttpsScheme(url) {
      assert3("protocol" in url);
      let protocol = url.protocol;
      return protocol === "http:" || protocol === "https:";
    }
    var hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));
    module2.exports = {
      isAborted,
      isCancelled,
      createDeferredPromise,
      ReadableStreamFrom,
      toUSVString,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      coarsenedSharedCurrentTime,
      determineRequestsReferrer,
      makePolicyContainer,
      clonePolicyContainer,
      appendFetchMetadata,
      appendRequestOriginHeader,
      TAOCheck,
      corsCheck,
      crossOriginResourcePolicyCheck,
      createOpaqueTimingInfo,
      setRequestReferrerPolicyOnRedirect,
      isValidHTTPToken,
      requestBadPort,
      requestCurrentURL,
      responseURL,
      responseLocationURL,
      isBlobLike,
      isURLPotentiallyTrustworthy,
      isValidReasonPhrase,
      sameOrigin,
      normalizeMethod,
      serializeJavascriptValueToJSONString,
      makeIterator,
      isValidHeaderName,
      isValidHeaderValue,
      hasOwn,
      isErrorLike,
      fullyReadBody,
      bytesMatch,
      isReadableStreamLike,
      readableStreamClose,
      isomorphicEncode,
      isomorphicDecode,
      urlIsLocal,
      urlHasHttpsScheme,
      urlIsHttpHttpsScheme,
      readAllBytes,
      normalizeMethodRecord,
      parseMetadata
    };
  }
});

// node_modules/undici/lib/fetch/symbols.js
var require_symbols2 = __commonJS({
  "node_modules/undici/lib/fetch/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kUrl: Symbol("url"),
      kHeaders: Symbol("headers"),
      kSignal: Symbol("signal"),
      kState: Symbol("state"),
      kGuard: Symbol("guard"),
      kRealm: Symbol("realm")
    };
  }
});

// node_modules/undici/lib/fetch/webidl.js
var require_webidl = __commonJS({
  "node_modules/undici/lib/fetch/webidl.js"(exports2, module2) {
    "use strict";
    var { types } = require("util"), { hasOwn, toUSVString } = require_util2(), webidl = {};
    webidl.converters = {};
    webidl.util = {};
    webidl.errors = {};
    webidl.errors.exception = function(message) {
      return new TypeError(`${message.header}: ${message.message}`);
    };
    webidl.errors.conversionFailed = function(context) {
      let plural = context.types.length === 1 ? "" : " one of", message = `${context.argument} could not be converted to${plural}: ${context.types.join(", ")}.`;
      return webidl.errors.exception({
        header: context.prefix,
        message
      });
    };
    webidl.errors.invalidArgument = function(context) {
      return webidl.errors.exception({
        header: context.prefix,
        message: `"${context.value}" is an invalid ${context.type}.`
      });
    };
    webidl.brandCheck = function(V, I, opts = void 0) {
      if (opts?.strict !== !1 && !(V instanceof I))
        throw new TypeError("Illegal invocation");
      return V?.[Symbol.toStringTag] === I.prototype[Symbol.toStringTag];
    };
    webidl.argumentLengthCheck = function({ length }, min, ctx) {
      if (length < min)
        throw webidl.errors.exception({
          message: `${min} argument${min !== 1 ? "s" : ""} required, but${length ? " only" : ""} ${length} found.`,
          ...ctx
        });
    };
    webidl.illegalConstructor = function() {
      throw webidl.errors.exception({
        header: "TypeError",
        message: "Illegal constructor"
      });
    };
    webidl.util.Type = function(V) {
      switch (typeof V) {
        case "undefined":
          return "Undefined";
        case "boolean":
          return "Boolean";
        case "string":
          return "String";
        case "symbol":
          return "Symbol";
        case "number":
          return "Number";
        case "bigint":
          return "BigInt";
        case "function":
        case "object":
          return V === null ? "Null" : "Object";
      }
    };
    webidl.util.ConvertToInt = function(V, bitLength, signedness, opts = {}) {
      let upperBound, lowerBound;
      bitLength === 64 ? (upperBound = Math.pow(2, 53) - 1, signedness === "unsigned" ? lowerBound = 0 : lowerBound = Math.pow(-2, 53) + 1) : signedness === "unsigned" ? (lowerBound = 0, upperBound = Math.pow(2, bitLength) - 1) : (lowerBound = Math.pow(-2, bitLength) - 1, upperBound = Math.pow(2, bitLength - 1) - 1);
      let x = Number(V);
      if (x === 0 && (x = 0), opts.enforceRange === !0) {
        if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY)
          throw webidl.errors.exception({
            header: "Integer conversion",
            message: `Could not convert ${V} to an integer.`
          });
        if (x = webidl.util.IntegerPart(x), x < lowerBound || x > upperBound)
          throw webidl.errors.exception({
            header: "Integer conversion",
            message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
          });
        return x;
      }
      return !Number.isNaN(x) && opts.clamp === !0 ? (x = Math.min(Math.max(x, lowerBound), upperBound), Math.floor(x) % 2 === 0 ? x = Math.floor(x) : x = Math.ceil(x), x) : Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY ? 0 : (x = webidl.util.IntegerPart(x), x = x % Math.pow(2, bitLength), signedness === "signed" && x >= Math.pow(2, bitLength) - 1 ? x - Math.pow(2, bitLength) : x);
    };
    webidl.util.IntegerPart = function(n) {
      let r = Math.floor(Math.abs(n));
      return n < 0 ? -1 * r : r;
    };
    webidl.sequenceConverter = function(converter) {
      return (V) => {
        if (webidl.util.Type(V) !== "Object")
          throw webidl.errors.exception({
            header: "Sequence",
            message: `Value of type ${webidl.util.Type(V)} is not an Object.`
          });
        let method = V?.[Symbol.iterator]?.(), seq = [];
        if (method === void 0 || typeof method.next != "function")
          throw webidl.errors.exception({
            header: "Sequence",
            message: "Object is not an iterator."
          });
        for (; ; ) {
          let { done, value } = method.next();
          if (done)
            break;
          seq.push(converter(value));
        }
        return seq;
      };
    };
    webidl.recordConverter = function(keyConverter, valueConverter) {
      return (O) => {
        if (webidl.util.Type(O) !== "Object")
          throw webidl.errors.exception({
            header: "Record",
            message: `Value of type ${webidl.util.Type(O)} is not an Object.`
          });
        let result = {};
        if (!types.isProxy(O)) {
          let keys2 = Object.keys(O);
          for (let key of keys2) {
            let typedKey = keyConverter(key), typedValue = valueConverter(O[key]);
            result[typedKey] = typedValue;
          }
          return result;
        }
        let keys = Reflect.ownKeys(O);
        for (let key of keys)
          if (Reflect.getOwnPropertyDescriptor(O, key)?.enumerable) {
            let typedKey = keyConverter(key), typedValue = valueConverter(O[key]);
            result[typedKey] = typedValue;
          }
        return result;
      };
    };
    webidl.interfaceConverter = function(i) {
      return (V, opts = {}) => {
        if (opts.strict !== !1 && !(V instanceof i))
          throw webidl.errors.exception({
            header: i.name,
            message: `Expected ${V} to be an instance of ${i.name}.`
          });
        return V;
      };
    };
    webidl.dictionaryConverter = function(converters) {
      return (dictionary) => {
        let type = webidl.util.Type(dictionary), dict = {};
        if (type === "Null" || type === "Undefined")
          return dict;
        if (type !== "Object")
          throw webidl.errors.exception({
            header: "Dictionary",
            message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
          });
        for (let options of converters) {
          let { key, defaultValue, required, converter } = options;
          if (required === !0 && !hasOwn(dictionary, key))
            throw webidl.errors.exception({
              header: "Dictionary",
              message: `Missing required key "${key}".`
            });
          let value = dictionary[key], hasDefault = hasOwn(options, "defaultValue");
          if (hasDefault && value !== null && (value = value ?? defaultValue), required || hasDefault || value !== void 0) {
            if (value = converter(value), options.allowedValues && !options.allowedValues.includes(value))
              throw webidl.errors.exception({
                header: "Dictionary",
                message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
              });
            dict[key] = value;
          }
        }
        return dict;
      };
    };
    webidl.nullableConverter = function(converter) {
      return (V) => V === null ? V : converter(V);
    };
    webidl.converters.DOMString = function(V, opts = {}) {
      if (V === null && opts.legacyNullToEmptyString)
        return "";
      if (typeof V == "symbol")
        throw new TypeError("Could not convert argument of type symbol to string.");
      return String(V);
    };
    webidl.converters.ByteString = function(V) {
      let x = webidl.converters.DOMString(V);
      for (let index = 0; index < x.length; index++)
        if (x.charCodeAt(index) > 255)
          throw new TypeError(
            `Cannot convert argument to a ByteString because the character at index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`
          );
      return x;
    };
    webidl.converters.USVString = toUSVString;
    webidl.converters.boolean = function(V) {
      return !!V;
    };
    webidl.converters.any = function(V) {
      return V;
    };
    webidl.converters["long long"] = function(V) {
      return webidl.util.ConvertToInt(V, 64, "signed");
    };
    webidl.converters["unsigned long long"] = function(V) {
      return webidl.util.ConvertToInt(V, 64, "unsigned");
    };
    webidl.converters["unsigned long"] = function(V) {
      return webidl.util.ConvertToInt(V, 32, "unsigned");
    };
    webidl.converters["unsigned short"] = function(V, opts) {
      return webidl.util.ConvertToInt(V, 16, "unsigned", opts);
    };
    webidl.converters.ArrayBuffer = function(V, opts = {}) {
      if (webidl.util.Type(V) !== "Object" || !types.isAnyArrayBuffer(V))
        throw webidl.errors.conversionFailed({
          prefix: `${V}`,
          argument: `${V}`,
          types: ["ArrayBuffer"]
        });
      if (opts.allowShared === !1 && types.isSharedArrayBuffer(V))
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      return V;
    };
    webidl.converters.TypedArray = function(V, T, opts = {}) {
      if (webidl.util.Type(V) !== "Object" || !types.isTypedArray(V) || V.constructor.name !== T.name)
        throw webidl.errors.conversionFailed({
          prefix: `${T.name}`,
          argument: `${V}`,
          types: [T.name]
        });
      if (opts.allowShared === !1 && types.isSharedArrayBuffer(V.buffer))
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      return V;
    };
    webidl.converters.DataView = function(V, opts = {}) {
      if (webidl.util.Type(V) !== "Object" || !types.isDataView(V))
        throw webidl.errors.exception({
          header: "DataView",
          message: "Object is not a DataView."
        });
      if (opts.allowShared === !1 && types.isSharedArrayBuffer(V.buffer))
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      return V;
    };
    webidl.converters.BufferSource = function(V, opts = {}) {
      if (types.isAnyArrayBuffer(V))
        return webidl.converters.ArrayBuffer(V, opts);
      if (types.isTypedArray(V))
        return webidl.converters.TypedArray(V, V.constructor);
      if (types.isDataView(V))
        return webidl.converters.DataView(V, opts);
      throw new TypeError(`Could not convert ${V} to a BufferSource.`);
    };
    webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(
      webidl.converters.ByteString
    );
    webidl.converters["sequence<sequence<ByteString>>"] = webidl.sequenceConverter(
      webidl.converters["sequence<ByteString>"]
    );
    webidl.converters["record<ByteString, ByteString>"] = webidl.recordConverter(
      webidl.converters.ByteString,
      webidl.converters.ByteString
    );
    module2.exports = {
      webidl
    };
  }
});

// node_modules/undici/lib/fetch/dataURL.js
var require_dataURL = __commonJS({
  "node_modules/undici/lib/fetch/dataURL.js"(exports2, module2) {
    var assert3 = require("assert"), { atob: atob2 } = require("buffer"), { isomorphicDecode } = require_util2(), encoder = new TextEncoder(), HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/, HTTP_WHITESPACE_REGEX = /(\u000A|\u000D|\u0009|\u0020)/, HTTP_QUOTED_STRING_TOKENS = /[\u0009|\u0020-\u007E|\u0080-\u00FF]/;
    function dataURLProcessor(dataURL) {
      assert3(dataURL.protocol === "data:");
      let input = URLSerializer(dataURL, !0);
      input = input.slice(5);
      let position = { position: 0 }, mimeType = collectASequenceOfCodePointsFast(
        ",",
        input,
        position
      ), mimeTypeLength = mimeType.length;
      if (mimeType = removeASCIIWhitespace(mimeType, !0, !0), position.position >= input.length)
        return "failure";
      position.position++;
      let encodedBody = input.slice(mimeTypeLength + 1), body = stringPercentDecode(encodedBody);
      if (/;(\u0020){0,}base64$/i.test(mimeType)) {
        let stringBody = isomorphicDecode(body);
        if (body = forgivingBase64(stringBody), body === "failure")
          return "failure";
        mimeType = mimeType.slice(0, -6), mimeType = mimeType.replace(/(\u0020)+$/, ""), mimeType = mimeType.slice(0, -1);
      }
      mimeType.startsWith(";") && (mimeType = "text/plain" + mimeType);
      let mimeTypeRecord = parseMIMEType(mimeType);
      return mimeTypeRecord === "failure" && (mimeTypeRecord = parseMIMEType("text/plain;charset=US-ASCII")), { mimeType: mimeTypeRecord, body };
    }
    function URLSerializer(url, excludeFragment = !1) {
      if (!excludeFragment)
        return url.href;
      let href = url.href, hashLength = url.hash.length;
      return hashLength === 0 ? href : href.substring(0, href.length - hashLength);
    }
    function collectASequenceOfCodePoints(condition, input, position) {
      let result = "";
      for (; position.position < input.length && condition(input[position.position]); )
        result += input[position.position], position.position++;
      return result;
    }
    function collectASequenceOfCodePointsFast(char, input, position) {
      let idx = input.indexOf(char, position.position), start = position.position;
      return idx === -1 ? (position.position = input.length, input.slice(start)) : (position.position = idx, input.slice(start, position.position));
    }
    function stringPercentDecode(input) {
      let bytes = encoder.encode(input);
      return percentDecode(bytes);
    }
    function percentDecode(input) {
      let output = [];
      for (let i = 0; i < input.length; i++) {
        let byte = input[i];
        if (byte !== 37)
          output.push(byte);
        else if (byte === 37 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2])))
          output.push(37);
        else {
          let nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]), bytePoint = Number.parseInt(nextTwoBytes, 16);
          output.push(bytePoint), i += 2;
        }
      }
      return Uint8Array.from(output);
    }
    function parseMIMEType(input) {
      input = removeHTTPWhitespace(input, !0, !0);
      let position = { position: 0 }, type = collectASequenceOfCodePointsFast(
        "/",
        input,
        position
      );
      if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type) || position.position > input.length)
        return "failure";
      position.position++;
      let subtype = collectASequenceOfCodePointsFast(
        ";",
        input,
        position
      );
      if (subtype = removeHTTPWhitespace(subtype, !1, !0), subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype))
        return "failure";
      let typeLowercase = type.toLowerCase(), subtypeLowercase = subtype.toLowerCase(), mimeType = {
        type: typeLowercase,
        subtype: subtypeLowercase,
        /** @type {Map<string, string>} */
        parameters: /* @__PURE__ */ new Map(),
        // https://mimesniff.spec.whatwg.org/#mime-type-essence
        essence: `${typeLowercase}/${subtypeLowercase}`
      };
      for (; position.position < input.length; ) {
        position.position++, collectASequenceOfCodePoints(
          // https://fetch.spec.whatwg.org/#http-whitespace
          (char) => HTTP_WHITESPACE_REGEX.test(char),
          input,
          position
        );
        let parameterName = collectASequenceOfCodePoints(
          (char) => char !== ";" && char !== "=",
          input,
          position
        );
        if (parameterName = parameterName.toLowerCase(), position.position < input.length) {
          if (input[position.position] === ";")
            continue;
          position.position++;
        }
        if (position.position > input.length)
          break;
        let parameterValue = null;
        if (input[position.position] === '"')
          parameterValue = collectAnHTTPQuotedString(input, position, !0), collectASequenceOfCodePointsFast(
            ";",
            input,
            position
          );
        else if (parameterValue = collectASequenceOfCodePointsFast(
          ";",
          input,
          position
        ), parameterValue = removeHTTPWhitespace(parameterValue, !1, !0), parameterValue.length === 0)
          continue;
        parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName) && mimeType.parameters.set(parameterName, parameterValue);
      }
      return mimeType;
    }
    function forgivingBase64(data) {
      if (data = data.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, ""), data.length % 4 === 0 && (data = data.replace(/=?=$/, "")), data.length % 4 === 1 || /[^+/0-9A-Za-z]/.test(data))
        return "failure";
      let binary = atob2(data), bytes = new Uint8Array(binary.length);
      for (let byte = 0; byte < binary.length; byte++)
        bytes[byte] = binary.charCodeAt(byte);
      return bytes;
    }
    function collectAnHTTPQuotedString(input, position, extractValue) {
      let positionStart = position.position, value = "";
      for (assert3(input[position.position] === '"'), position.position++; value += collectASequenceOfCodePoints(
        (char) => char !== '"' && char !== "\\",
        input,
        position
      ), !(position.position >= input.length); ) {
        let quoteOrBackslash = input[position.position];
        if (position.position++, quoteOrBackslash === "\\") {
          if (position.position >= input.length) {
            value += "\\";
            break;
          }
          value += input[position.position], position.position++;
        } else {
          assert3(quoteOrBackslash === '"');
          break;
        }
      }
      return extractValue ? value : input.slice(positionStart, position.position);
    }
    function serializeAMimeType(mimeType) {
      assert3(mimeType !== "failure");
      let { parameters, essence } = mimeType, serialization = essence;
      for (let [name2, value] of parameters.entries())
        serialization += ";", serialization += name2, serialization += "=", HTTP_TOKEN_CODEPOINTS.test(value) || (value = value.replace(/(\\|")/g, "\\$1"), value = '"' + value, value += '"'), serialization += value;
      return serialization;
    }
    function isHTTPWhiteSpace(char) {
      return char === "\r" || char === `
` || char === "	" || char === " ";
    }
    function removeHTTPWhitespace(str, leading = !0, trailing = !0) {
      let lead = 0, trail = str.length - 1;
      if (leading)
        for (; lead < str.length && isHTTPWhiteSpace(str[lead]); lead++) ;
      if (trailing)
        for (; trail > 0 && isHTTPWhiteSpace(str[trail]); trail--) ;
      return str.slice(lead, trail + 1);
    }
    function isASCIIWhitespace(char) {
      return char === "\r" || char === `
` || char === "	" || char === "\f" || char === " ";
    }
    function removeASCIIWhitespace(str, leading = !0, trailing = !0) {
      let lead = 0, trail = str.length - 1;
      if (leading)
        for (; lead < str.length && isASCIIWhitespace(str[lead]); lead++) ;
      if (trailing)
        for (; trail > 0 && isASCIIWhitespace(str[trail]); trail--) ;
      return str.slice(lead, trail + 1);
    }
    module2.exports = {
      dataURLProcessor,
      URLSerializer,
      collectASequenceOfCodePoints,
      collectASequenceOfCodePointsFast,
      stringPercentDecode,
      parseMIMEType,
      collectAnHTTPQuotedString,
      serializeAMimeType
    };
  }
});

// node_modules/undici/lib/fetch/file.js
var require_file = __commonJS({
  "node_modules/undici/lib/fetch/file.js"(exports2, module2) {
    "use strict";
    var { Blob: Blob2, File: NativeFile } = require("buffer"), { types } = require("util"), { kState } = require_symbols2(), { isBlobLike } = require_util2(), { webidl } = require_webidl(), { parseMIMEType, serializeAMimeType } = require_dataURL(), { kEnumerableProperty } = require_util(), encoder = new TextEncoder(), File = class _File extends Blob2 {
      constructor(fileBits, fileName, options = {}) {
        webidl.argumentLengthCheck(arguments, 2, { header: "File constructor" }), fileBits = webidl.converters["sequence<BlobPart>"](fileBits), fileName = webidl.converters.USVString(fileName), options = webidl.converters.FilePropertyBag(options);
        let n = fileName, t = options.type, d;
        substep: {
          if (t) {
            if (t = parseMIMEType(t), t === "failure") {
              t = "";
              break substep;
            }
            t = serializeAMimeType(t).toLowerCase();
          }
          d = options.lastModified;
        }
        super(processBlobParts(fileBits, options), { type: t }), this[kState] = {
          name: n,
          lastModified: d,
          type: t
        };
      }
      get name() {
        return webidl.brandCheck(this, _File), this[kState].name;
      }
      get lastModified() {
        return webidl.brandCheck(this, _File), this[kState].lastModified;
      }
      get type() {
        return webidl.brandCheck(this, _File), this[kState].type;
      }
    }, FileLike = class _FileLike {
      constructor(blobLike, fileName, options = {}) {
        let n = fileName, t = options.type, d = options.lastModified ?? Date.now();
        this[kState] = {
          blobLike,
          name: n,
          type: t,
          lastModified: d
        };
      }
      stream(...args) {
        return webidl.brandCheck(this, _FileLike), this[kState].blobLike.stream(...args);
      }
      arrayBuffer(...args) {
        return webidl.brandCheck(this, _FileLike), this[kState].blobLike.arrayBuffer(...args);
      }
      slice(...args) {
        return webidl.brandCheck(this, _FileLike), this[kState].blobLike.slice(...args);
      }
      text(...args) {
        return webidl.brandCheck(this, _FileLike), this[kState].blobLike.text(...args);
      }
      get size() {
        return webidl.brandCheck(this, _FileLike), this[kState].blobLike.size;
      }
      get type() {
        return webidl.brandCheck(this, _FileLike), this[kState].blobLike.type;
      }
      get name() {
        return webidl.brandCheck(this, _FileLike), this[kState].name;
      }
      get lastModified() {
        return webidl.brandCheck(this, _FileLike), this[kState].lastModified;
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
    };
    Object.defineProperties(File.prototype, {
      [Symbol.toStringTag]: {
        value: "File",
        configurable: !0
      },
      name: kEnumerableProperty,
      lastModified: kEnumerableProperty
    });
    webidl.converters.Blob = webidl.interfaceConverter(Blob2);
    webidl.converters.BlobPart = function(V, opts) {
      if (webidl.util.Type(V) === "Object") {
        if (isBlobLike(V))
          return webidl.converters.Blob(V, { strict: !1 });
        if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V))
          return webidl.converters.BufferSource(V, opts);
      }
      return webidl.converters.USVString(V, opts);
    };
    webidl.converters["sequence<BlobPart>"] = webidl.sequenceConverter(
      webidl.converters.BlobPart
    );
    webidl.converters.FilePropertyBag = webidl.dictionaryConverter([
      {
        key: "lastModified",
        converter: webidl.converters["long long"],
        get defaultValue() {
          return Date.now();
        }
      },
      {
        key: "type",
        converter: webidl.converters.DOMString,
        defaultValue: ""
      },
      {
        key: "endings",
        converter: (value) => (value = webidl.converters.DOMString(value), value = value.toLowerCase(), value !== "native" && (value = "transparent"), value),
        defaultValue: "transparent"
      }
    ]);
    function processBlobParts(parts, options) {
      let bytes = [];
      for (let element of parts)
        if (typeof element == "string") {
          let s = element;
          options.endings === "native" && (s = convertLineEndingsNative(s)), bytes.push(encoder.encode(s));
        } else types.isAnyArrayBuffer(element) || types.isTypedArray(element) ? element.buffer ? bytes.push(
          new Uint8Array(element.buffer, element.byteOffset, element.byteLength)
        ) : bytes.push(new Uint8Array(element)) : isBlobLike(element) && bytes.push(element);
      return bytes;
    }
    function convertLineEndingsNative(s) {
      let nativeLineEnding = `
`;
      return process.platform === "win32" && (nativeLineEnding = `\r
`), s.replace(/\r?\n/g, nativeLineEnding);
    }
    function isFileLike(object) {
      return NativeFile && object instanceof NativeFile || object instanceof File || object && (typeof object.stream == "function" || typeof object.arrayBuffer == "function") && object[Symbol.toStringTag] === "File";
    }
    module2.exports = { File, FileLike, isFileLike };
  }
});

// node_modules/undici/lib/fetch/formdata.js
var require_formdata = __commonJS({
  "node_modules/undici/lib/fetch/formdata.js"(exports2, module2) {
    "use strict";
    var { isBlobLike, toUSVString, makeIterator } = require_util2(), { kState } = require_symbols2(), { File: UndiciFile, FileLike, isFileLike } = require_file(), { webidl } = require_webidl(), { Blob: Blob2, File: NativeFile } = require("buffer"), File = NativeFile ?? UndiciFile, FormData = class _FormData {
      constructor(form) {
        if (form !== void 0)
          throw webidl.errors.conversionFailed({
            prefix: "FormData constructor",
            argument: "Argument 1",
            types: ["undefined"]
          });
        this[kState] = [];
      }
      append(name2, value, filename = void 0) {
        if (webidl.brandCheck(this, _FormData), webidl.argumentLengthCheck(arguments, 2, { header: "FormData.append" }), arguments.length === 3 && !isBlobLike(value))
          throw new TypeError(
            "Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'"
          );
        name2 = webidl.converters.USVString(name2), value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: !1 }) : webidl.converters.USVString(value), filename = arguments.length === 3 ? webidl.converters.USVString(filename) : void 0;
        let entry = makeEntry(name2, value, filename);
        this[kState].push(entry);
      }
      delete(name2) {
        webidl.brandCheck(this, _FormData), webidl.argumentLengthCheck(arguments, 1, { header: "FormData.delete" }), name2 = webidl.converters.USVString(name2), this[kState] = this[kState].filter((entry) => entry.name !== name2);
      }
      get(name2) {
        webidl.brandCheck(this, _FormData), webidl.argumentLengthCheck(arguments, 1, { header: "FormData.get" }), name2 = webidl.converters.USVString(name2);
        let idx = this[kState].findIndex((entry) => entry.name === name2);
        return idx === -1 ? null : this[kState][idx].value;
      }
      getAll(name2) {
        return webidl.brandCheck(this, _FormData), webidl.argumentLengthCheck(arguments, 1, { header: "FormData.getAll" }), name2 = webidl.converters.USVString(name2), this[kState].filter((entry) => entry.name === name2).map((entry) => entry.value);
      }
      has(name2) {
        return webidl.brandCheck(this, _FormData), webidl.argumentLengthCheck(arguments, 1, { header: "FormData.has" }), name2 = webidl.converters.USVString(name2), this[kState].findIndex((entry) => entry.name === name2) !== -1;
      }
      set(name2, value, filename = void 0) {
        if (webidl.brandCheck(this, _FormData), webidl.argumentLengthCheck(arguments, 2, { header: "FormData.set" }), arguments.length === 3 && !isBlobLike(value))
          throw new TypeError(
            "Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'"
          );
        name2 = webidl.converters.USVString(name2), value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: !1 }) : webidl.converters.USVString(value), filename = arguments.length === 3 ? toUSVString(filename) : void 0;
        let entry = makeEntry(name2, value, filename), idx = this[kState].findIndex((entry2) => entry2.name === name2);
        idx !== -1 ? this[kState] = [
          ...this[kState].slice(0, idx),
          entry,
          ...this[kState].slice(idx + 1).filter((entry2) => entry2.name !== name2)
        ] : this[kState].push(entry);
      }
      entries() {
        return webidl.brandCheck(this, _FormData), makeIterator(
          () => this[kState].map((pair) => [pair.name, pair.value]),
          "FormData",
          "key+value"
        );
      }
      keys() {
        return webidl.brandCheck(this, _FormData), makeIterator(
          () => this[kState].map((pair) => [pair.name, pair.value]),
          "FormData",
          "key"
        );
      }
      values() {
        return webidl.brandCheck(this, _FormData), makeIterator(
          () => this[kState].map((pair) => [pair.name, pair.value]),
          "FormData",
          "value"
        );
      }
      /**
       * @param {(value: string, key: string, self: FormData) => void} callbackFn
       * @param {unknown} thisArg
       */
      forEach(callbackFn, thisArg = globalThis) {
        if (webidl.brandCheck(this, _FormData), webidl.argumentLengthCheck(arguments, 1, { header: "FormData.forEach" }), typeof callbackFn != "function")
          throw new TypeError(
            "Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'."
          );
        for (let [key, value] of this)
          callbackFn.apply(thisArg, [value, key, this]);
      }
    };
    FormData.prototype[Symbol.iterator] = FormData.prototype.entries;
    Object.defineProperties(FormData.prototype, {
      [Symbol.toStringTag]: {
        value: "FormData",
        configurable: !0
      }
    });
    function makeEntry(name2, value, filename) {
      if (name2 = Buffer.from(name2).toString("utf8"), typeof value == "string")
        value = Buffer.from(value).toString("utf8");
      else if (isFileLike(value) || (value = value instanceof Blob2 ? new File([value], "blob", { type: value.type }) : new FileLike(value, "blob", { type: value.type })), filename !== void 0) {
        let options = {
          type: value.type,
          lastModified: value.lastModified
        };
        value = NativeFile && value instanceof NativeFile || value instanceof UndiciFile ? new File([value], filename, options) : new FileLike(value, filename, options);
      }
      return { name: name2, value };
    }
    module2.exports = { FormData };
  }
});

// node_modules/undici/lib/fetch/body.js
var require_body = __commonJS({
  "node_modules/undici/lib/fetch/body.js"(exports2, module2) {
    "use strict";
    var Busboy = require_main(), util = require_util(), {
      ReadableStreamFrom,
      isBlobLike,
      isReadableStreamLike,
      readableStreamClose,
      createDeferredPromise,
      fullyReadBody
    } = require_util2(), { FormData } = require_formdata(), { kState } = require_symbols2(), { webidl } = require_webidl(), { DOMException: DOMException2, structuredClone } = require_constants2(), { Blob: Blob2, File: NativeFile } = require("buffer"), { kBodyUsed } = require_symbols(), assert3 = require("assert"), { isErrored } = require_util(), { isUint8Array, isArrayBuffer } = require("util/types"), { File: UndiciFile } = require_file(), { parseMIMEType, serializeAMimeType } = require_dataURL(), random;
    try {
      let crypto = require("node:crypto");
      random = (max) => crypto.randomInt(0, max);
    } catch {
      random = (max) => Math.floor(Math.random(max));
    }
    var ReadableStream = globalThis.ReadableStream, File = NativeFile ?? UndiciFile, textEncoder = new TextEncoder(), textDecoder = new TextDecoder();
    function extractBody(object, keepalive = !1) {
      ReadableStream || (ReadableStream = require("stream/web").ReadableStream);
      let stream = null;
      object instanceof ReadableStream ? stream = object : isBlobLike(object) ? stream = object.stream() : stream = new ReadableStream({
        async pull(controller) {
          controller.enqueue(
            typeof source == "string" ? textEncoder.encode(source) : source
          ), queueMicrotask(() => readableStreamClose(controller));
        },
        start() {
        },
        type: void 0
      }), assert3(isReadableStreamLike(stream));
      let action = null, source = null, length = null, type = null;
      if (typeof object == "string")
        source = object, type = "text/plain;charset=UTF-8";
      else if (object instanceof URLSearchParams)
        source = object.toString(), type = "application/x-www-form-urlencoded;charset=UTF-8";
      else if (isArrayBuffer(object))
        source = new Uint8Array(object.slice());
      else if (ArrayBuffer.isView(object))
        source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
      else if (util.isFormDataLike(object)) {
        let boundary = `----formdata-undici-0${`${random(1e11)}`.padStart(11, "0")}`, prefix = `--${boundary}\r
Content-Disposition: form-data`;
        let escape = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22"), normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, `\r
`), blobParts = [], rn = new Uint8Array([13, 10]);
        length = 0;
        let hasUnknownSizeValue = !1;
        for (let [name2, value] of object)
          if (typeof value == "string") {
            let chunk2 = textEncoder.encode(prefix + `; name="${escape(normalizeLinefeeds(name2))}"\r
\r
${normalizeLinefeeds(value)}\r
`);
            blobParts.push(chunk2), length += chunk2.byteLength;
          } else {
            let chunk2 = textEncoder.encode(`${prefix}; name="${escape(normalizeLinefeeds(name2))}"` + (value.name ? `; filename="${escape(value.name)}"` : "") + `\r
Content-Type: ${value.type || "application/octet-stream"}\r
\r
`);
            blobParts.push(chunk2, value, rn), typeof value.size == "number" ? length += chunk2.byteLength + value.size + rn.byteLength : hasUnknownSizeValue = !0;
          }
        let chunk = textEncoder.encode(`--${boundary}--`);
        blobParts.push(chunk), length += chunk.byteLength, hasUnknownSizeValue && (length = null), source = object, action = async function* () {
          for (let part of blobParts)
            part.stream ? yield* part.stream() : yield part;
        }, type = "multipart/form-data; boundary=" + boundary;
      } else if (isBlobLike(object))
        source = object, length = object.size, object.type && (type = object.type);
      else if (typeof object[Symbol.asyncIterator] == "function") {
        if (keepalive)
          throw new TypeError("keepalive");
        if (util.isDisturbed(object) || object.locked)
          throw new TypeError(
            "Response body object should not be disturbed or locked"
          );
        stream = object instanceof ReadableStream ? object : ReadableStreamFrom(object);
      }
      if ((typeof source == "string" || util.isBuffer(source)) && (length = Buffer.byteLength(source)), action != null) {
        let iterator;
        stream = new ReadableStream({
          async start() {
            iterator = action(object)[Symbol.asyncIterator]();
          },
          async pull(controller) {
            let { value, done } = await iterator.next();
            return done ? queueMicrotask(() => {
              controller.close();
            }) : isErrored(stream) || controller.enqueue(new Uint8Array(value)), controller.desiredSize > 0;
          },
          async cancel(reason) {
            await iterator.return();
          },
          type: void 0
        });
      }
      return [{ stream, source, length }, type];
    }
    function safelyExtractBody(object, keepalive = !1) {
      return ReadableStream || (ReadableStream = require("stream/web").ReadableStream), object instanceof ReadableStream && (assert3(!util.isDisturbed(object), "The body has already been consumed."), assert3(!object.locked, "The stream is locked.")), extractBody(object, keepalive);
    }
    function cloneBody(body) {
      let [out1, out2] = body.stream.tee(), out2Clone = structuredClone(out2, { transfer: [out2] }), [, finalClone] = out2Clone.tee();
      return body.stream = out1, {
        stream: finalClone,
        length: body.length,
        source: body.source
      };
    }
    async function* consumeBody(body) {
      if (body)
        if (isUint8Array(body))
          yield body;
        else {
          let stream = body.stream;
          if (util.isDisturbed(stream))
            throw new TypeError("The body has already been consumed.");
          if (stream.locked)
            throw new TypeError("The stream is locked.");
          stream[kBodyUsed] = !0, yield* stream;
        }
    }
    function throwIfAborted(state) {
      if (state.aborted)
        throw new DOMException2("The operation was aborted.", "AbortError");
    }
    function bodyMixinMethods(instance) {
      return {
        blob() {
          return specConsumeBody(this, (bytes) => {
            let mimeType = bodyMimeType(this);
            return mimeType === "failure" ? mimeType = "" : mimeType && (mimeType = serializeAMimeType(mimeType)), new Blob2([bytes], { type: mimeType });
          }, instance);
        },
        arrayBuffer() {
          return specConsumeBody(this, (bytes) => new Uint8Array(bytes).buffer, instance);
        },
        text() {
          return specConsumeBody(this, utf8DecodeBytes, instance);
        },
        json() {
          return specConsumeBody(this, parseJSONFromBytes, instance);
        },
        async formData() {
          webidl.brandCheck(this, instance), throwIfAborted(this[kState]);
          let contentType = this.headers.get("Content-Type");
          if (/multipart\/form-data/.test(contentType)) {
            let headers = {};
            for (let [key, value] of this.headers) headers[key.toLowerCase()] = value;
            let responseFormData = new FormData(), busboy;
            try {
              busboy = new Busboy({
                headers,
                preservePath: !0
              });
            } catch (err) {
              throw new DOMException2(`${err}`, "AbortError");
            }
            busboy.on("field", (name2, value) => {
              responseFormData.append(name2, value);
            }), busboy.on("file", (name2, value, filename, encoding, mimeType) => {
              let chunks = [];
              if (encoding === "base64" || encoding.toLowerCase() === "base64") {
                let base64chunk = "";
                value.on("data", (chunk) => {
                  base64chunk += chunk.toString().replace(/[\r\n]/gm, "");
                  let end = base64chunk.length - base64chunk.length % 4;
                  chunks.push(Buffer.from(base64chunk.slice(0, end), "base64")), base64chunk = base64chunk.slice(end);
                }), value.on("end", () => {
                  chunks.push(Buffer.from(base64chunk, "base64")), responseFormData.append(name2, new File(chunks, filename, { type: mimeType }));
                });
              } else
                value.on("data", (chunk) => {
                  chunks.push(chunk);
                }), value.on("end", () => {
                  responseFormData.append(name2, new File(chunks, filename, { type: mimeType }));
                });
            });
            let busboyResolve = new Promise((resolve2, reject) => {
              busboy.on("finish", resolve2), busboy.on("error", (err) => reject(new TypeError(err)));
            });
            if (this.body !== null) for await (let chunk of consumeBody(this[kState].body)) busboy.write(chunk);
            return busboy.end(), await busboyResolve, responseFormData;
          } else if (/application\/x-www-form-urlencoded/.test(contentType)) {
            let entries;
            try {
              let text = "", streamingDecoder = new TextDecoder("utf-8", { ignoreBOM: !0 });
              for await (let chunk of consumeBody(this[kState].body)) {
                if (!isUint8Array(chunk))
                  throw new TypeError("Expected Uint8Array chunk");
                text += streamingDecoder.decode(chunk, { stream: !0 });
              }
              text += streamingDecoder.decode(), entries = new URLSearchParams(text);
            } catch (err) {
              throw Object.assign(new TypeError(), { cause: err });
            }
            let formData = new FormData();
            for (let [name2, value] of entries)
              formData.append(name2, value);
            return formData;
          } else
            throw await Promise.resolve(), throwIfAborted(this[kState]), webidl.errors.exception({
              header: `${instance.name}.formData`,
              message: "Could not parse content as FormData."
            });
        }
      };
    }
    function mixinBody(prototype) {
      Object.assign(prototype.prototype, bodyMixinMethods(prototype));
    }
    async function specConsumeBody(object, convertBytesToJSValue, instance) {
      if (webidl.brandCheck(object, instance), throwIfAborted(object[kState]), bodyUnusable(object[kState].body))
        throw new TypeError("Body is unusable");
      let promise = createDeferredPromise(), errorSteps = (error) => promise.reject(error), successSteps = (data) => {
        try {
          promise.resolve(convertBytesToJSValue(data));
        } catch (e) {
          errorSteps(e);
        }
      };
      return object[kState].body == null ? (successSteps(new Uint8Array()), promise.promise) : (await fullyReadBody(object[kState].body, successSteps, errorSteps), promise.promise);
    }
    function bodyUnusable(body) {
      return body != null && (body.stream.locked || util.isDisturbed(body.stream));
    }
    function utf8DecodeBytes(buffer) {
      return buffer.length === 0 ? "" : (buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191 && (buffer = buffer.subarray(3)), textDecoder.decode(buffer));
    }
    function parseJSONFromBytes(bytes) {
      return JSON.parse(utf8DecodeBytes(bytes));
    }
    function bodyMimeType(object) {
      let { headersList } = object[kState], contentType = headersList.get("content-type");
      return contentType === null ? "failure" : parseMIMEType(contentType);
    }
    module2.exports = {
      extractBody,
      safelyExtractBody,
      cloneBody,
      mixinBody
    };
  }
});

// node_modules/undici/lib/core/request.js
var require_request = __commonJS({
  "node_modules/undici/lib/core/request.js"(exports2, module2) {
    "use strict";
    var {
      InvalidArgumentError,
      NotSupportedError
    } = require_errors(), assert3 = require("assert"), { kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = require_symbols(), util = require_util(), tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/, headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/, invalidPathRegex = /[^\u0021-\u00ff]/, kHandler = Symbol("handler"), channels = {}, extractBody;
    try {
      let diagnosticsChannel = require("diagnostics_channel");
      channels.create = diagnosticsChannel.channel("undici:request:create"), channels.bodySent = diagnosticsChannel.channel("undici:request:bodySent"), channels.headers = diagnosticsChannel.channel("undici:request:headers"), channels.trailers = diagnosticsChannel.channel("undici:request:trailers"), channels.error = diagnosticsChannel.channel("undici:request:error");
    } catch {
      channels.create = { hasSubscribers: !1 }, channels.bodySent = { hasSubscribers: !1 }, channels.headers = { hasSubscribers: !1 }, channels.trailers = { hasSubscribers: !1 }, channels.error = { hasSubscribers: !1 };
    }
    var Request = class _Request {
      constructor(origin, {
        path: path8,
        method,
        body,
        headers,
        query,
        idempotent,
        blocking,
        upgrade,
        headersTimeout,
        bodyTimeout,
        reset,
        throwOnError,
        expectContinue
      }, handler) {
        if (typeof path8 != "string")
          throw new InvalidArgumentError("path must be a string");
        if (path8[0] !== "/" && !(path8.startsWith("http://") || path8.startsWith("https://")) && method !== "CONNECT")
          throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
        if (invalidPathRegex.exec(path8) !== null)
          throw new InvalidArgumentError("invalid request path");
        if (typeof method != "string")
          throw new InvalidArgumentError("method must be a string");
        if (tokenRegExp.exec(method) === null)
          throw new InvalidArgumentError("invalid request method");
        if (upgrade && typeof upgrade != "string")
          throw new InvalidArgumentError("upgrade must be a string");
        if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0))
          throw new InvalidArgumentError("invalid headersTimeout");
        if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0))
          throw new InvalidArgumentError("invalid bodyTimeout");
        if (reset != null && typeof reset != "boolean")
          throw new InvalidArgumentError("invalid reset");
        if (expectContinue != null && typeof expectContinue != "boolean")
          throw new InvalidArgumentError("invalid expectContinue");
        if (this.headersTimeout = headersTimeout, this.bodyTimeout = bodyTimeout, this.throwOnError = throwOnError === !0, this.method = method, this.abort = null, body == null)
          this.body = null;
        else if (util.isStream(body)) {
          this.body = body;
          let rState = this.body._readableState;
          (!rState || !rState.autoDestroy) && (this.endHandler = function() {
            util.destroy(this);
          }, this.body.on("end", this.endHandler)), this.errorHandler = (err) => {
            this.abort ? this.abort(err) : this.error = err;
          }, this.body.on("error", this.errorHandler);
        } else if (util.isBuffer(body))
          this.body = body.byteLength ? body : null;
        else if (ArrayBuffer.isView(body))
          this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
        else if (body instanceof ArrayBuffer)
          this.body = body.byteLength ? Buffer.from(body) : null;
        else if (typeof body == "string")
          this.body = body.length ? Buffer.from(body) : null;
        else if (util.isFormDataLike(body) || util.isIterable(body) || util.isBlobLike(body))
          this.body = body;
        else
          throw new InvalidArgumentError("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
        if (this.completed = !1, this.aborted = !1, this.upgrade = upgrade || null, this.path = query ? util.buildURL(path8, query) : path8, this.origin = origin, this.idempotent = idempotent ?? (method === "HEAD" || method === "GET"), this.blocking = blocking ?? !1, this.reset = reset ?? null, this.host = null, this.contentLength = null, this.contentType = null, this.headers = "", this.expectContinue = expectContinue ?? !1, Array.isArray(headers)) {
          if (headers.length % 2 !== 0)
            throw new InvalidArgumentError("headers array must be even");
          for (let i = 0; i < headers.length; i += 2)
            processHeader(this, headers[i], headers[i + 1]);
        } else if (headers && typeof headers == "object") {
          let keys = Object.keys(headers);
          for (let i = 0; i < keys.length; i++) {
            let key = keys[i];
            processHeader(this, key, headers[key]);
          }
        } else if (headers != null)
          throw new InvalidArgumentError("headers must be an object or an array");
        if (util.isFormDataLike(this.body)) {
          if (util.nodeMajor < 16 || util.nodeMajor === 16 && util.nodeMinor < 8)
            throw new InvalidArgumentError("Form-Data bodies are only supported in node v16.8 and newer.");
          extractBody || (extractBody = require_body().extractBody);
          let [bodyStream, contentType] = extractBody(body);
          this.contentType == null && (this.contentType = contentType, this.headers += `content-type: ${contentType}\r
`), this.body = bodyStream.stream, this.contentLength = bodyStream.length;
        } else util.isBlobLike(body) && this.contentType == null && body.type && (this.contentType = body.type, this.headers += `content-type: ${body.type}\r
`);
        util.validateHandler(handler, method, upgrade), this.servername = util.getServerName(this.host), this[kHandler] = handler, channels.create.hasSubscribers && channels.create.publish({ request: this });
      }
      onBodySent(chunk) {
        if (this[kHandler].onBodySent)
          try {
            return this[kHandler].onBodySent(chunk);
          } catch (err) {
            this.abort(err);
          }
      }
      onRequestSent() {
        if (channels.bodySent.hasSubscribers && channels.bodySent.publish({ request: this }), this[kHandler].onRequestSent)
          try {
            return this[kHandler].onRequestSent();
          } catch (err) {
            this.abort(err);
          }
      }
      onConnect(abort) {
        if (assert3(!this.aborted), assert3(!this.completed), this.error)
          abort(this.error);
        else
          return this.abort = abort, this[kHandler].onConnect(abort);
      }
      onHeaders(statusCode, headers, resume, statusText) {
        assert3(!this.aborted), assert3(!this.completed), channels.headers.hasSubscribers && channels.headers.publish({ request: this, response: { statusCode, headers, statusText } });
        try {
          return this[kHandler].onHeaders(statusCode, headers, resume, statusText);
        } catch (err) {
          this.abort(err);
        }
      }
      onData(chunk) {
        assert3(!this.aborted), assert3(!this.completed);
        try {
          return this[kHandler].onData(chunk);
        } catch (err) {
          return this.abort(err), !1;
        }
      }
      onUpgrade(statusCode, headers, socket) {
        return assert3(!this.aborted), assert3(!this.completed), this[kHandler].onUpgrade(statusCode, headers, socket);
      }
      onComplete(trailers) {
        this.onFinally(), assert3(!this.aborted), this.completed = !0, channels.trailers.hasSubscribers && channels.trailers.publish({ request: this, trailers });
        try {
          return this[kHandler].onComplete(trailers);
        } catch (err) {
          this.onError(err);
        }
      }
      onError(error) {
        if (this.onFinally(), channels.error.hasSubscribers && channels.error.publish({ request: this, error }), !this.aborted)
          return this.aborted = !0, this[kHandler].onError(error);
      }
      onFinally() {
        this.errorHandler && (this.body.off("error", this.errorHandler), this.errorHandler = null), this.endHandler && (this.body.off("end", this.endHandler), this.endHandler = null);
      }
      // TODO: adjust to support H2
      addHeader(key, value) {
        return processHeader(this, key, value), this;
      }
      static [kHTTP1BuildRequest](origin, opts, handler) {
        return new _Request(origin, opts, handler);
      }
      static [kHTTP2BuildRequest](origin, opts, handler) {
        let headers = opts.headers;
        opts = { ...opts, headers: null };
        let request = new _Request(origin, opts, handler);
        if (request.headers = {}, Array.isArray(headers)) {
          if (headers.length % 2 !== 0)
            throw new InvalidArgumentError("headers array must be even");
          for (let i = 0; i < headers.length; i += 2)
            processHeader(request, headers[i], headers[i + 1], !0);
        } else if (headers && typeof headers == "object") {
          let keys = Object.keys(headers);
          for (let i = 0; i < keys.length; i++) {
            let key = keys[i];
            processHeader(request, key, headers[key], !0);
          }
        } else if (headers != null)
          throw new InvalidArgumentError("headers must be an object or an array");
        return request;
      }
      static [kHTTP2CopyHeaders](raw2) {
        let rawHeaders = raw2.split(`\r
`), headers = {};
        for (let header of rawHeaders) {
          let [key, value] = header.split(": ");
          value == null || value.length === 0 || (headers[key] ? headers[key] += `,${value}` : headers[key] = value);
        }
        return headers;
      }
    };
    function processHeaderValue(key, val, skipAppend) {
      if (val && typeof val == "object")
        throw new InvalidArgumentError(`invalid ${key} header`);
      if (val = val != null ? `${val}` : "", headerCharRegex.exec(val) !== null)
        throw new InvalidArgumentError(`invalid ${key} header`);
      return skipAppend ? val : `${key}: ${val}\r
`;
    }
    function processHeader(request, key, val, skipAppend = !1) {
      if (val && typeof val == "object" && !Array.isArray(val))
        throw new InvalidArgumentError(`invalid ${key} header`);
      if (val === void 0)
        return;
      if (request.host === null && key.length === 4 && key.toLowerCase() === "host") {
        if (headerCharRegex.exec(val) !== null)
          throw new InvalidArgumentError(`invalid ${key} header`);
        request.host = val;
      } else if (request.contentLength === null && key.length === 14 && key.toLowerCase() === "content-length") {
        if (request.contentLength = parseInt(val, 10), !Number.isFinite(request.contentLength))
          throw new InvalidArgumentError("invalid content-length header");
      } else if (request.contentType === null && key.length === 12 && key.toLowerCase() === "content-type")
        request.contentType = val, skipAppend ? request.headers[key] = processHeaderValue(key, val, skipAppend) : request.headers += processHeaderValue(key, val);
      else {
        if (key.length === 17 && key.toLowerCase() === "transfer-encoding")
          throw new InvalidArgumentError("invalid transfer-encoding header");
        if (key.length === 10 && key.toLowerCase() === "connection") {
          let value = typeof val == "string" ? val.toLowerCase() : null;
          if (value !== "close" && value !== "keep-alive")
            throw new InvalidArgumentError("invalid connection header");
          value === "close" && (request.reset = !0);
        } else {
          if (key.length === 10 && key.toLowerCase() === "keep-alive")
            throw new InvalidArgumentError("invalid keep-alive header");
          if (key.length === 7 && key.toLowerCase() === "upgrade")
            throw new InvalidArgumentError("invalid upgrade header");
          if (key.length === 6 && key.toLowerCase() === "expect")
            throw new NotSupportedError("expect header not supported");
          if (tokenRegExp.exec(key) === null)
            throw new InvalidArgumentError("invalid header key");
          if (Array.isArray(val))
            for (let i = 0; i < val.length; i++)
              skipAppend ? request.headers[key] ? request.headers[key] += `,${processHeaderValue(key, val[i], skipAppend)}` : request.headers[key] = processHeaderValue(key, val[i], skipAppend) : request.headers += processHeaderValue(key, val[i]);
          else
            skipAppend ? request.headers[key] = processHeaderValue(key, val, skipAppend) : request.headers += processHeaderValue(key, val);
        }
      }
    }
    module2.exports = Request;
  }
});

// node_modules/undici/lib/dispatcher.js
var require_dispatcher = __commonJS({
  "node_modules/undici/lib/dispatcher.js"(exports2, module2) {
    "use strict";
    var EventEmitter2 = require("events"), Dispatcher = class extends EventEmitter2 {
      dispatch() {
        throw new Error("not implemented");
      }
      close() {
        throw new Error("not implemented");
      }
      destroy() {
        throw new Error("not implemented");
      }
    };
    module2.exports = Dispatcher;
  }
});

// node_modules/undici/lib/dispatcher-base.js
var require_dispatcher_base = __commonJS({
  "node_modules/undici/lib/dispatcher-base.js"(exports2, module2) {
    "use strict";
    var Dispatcher = require_dispatcher(), {
      ClientDestroyedError,
      ClientClosedError,
      InvalidArgumentError
    } = require_errors(), { kDestroy, kClose, kDispatch, kInterceptors } = require_symbols(), kDestroyed = Symbol("destroyed"), kClosed = Symbol("closed"), kOnDestroyed = Symbol("onDestroyed"), kOnClosed = Symbol("onClosed"), kInterceptedDispatch = Symbol("Intercepted Dispatch"), DispatcherBase = class extends Dispatcher {
      constructor() {
        super(), this[kDestroyed] = !1, this[kOnDestroyed] = null, this[kClosed] = !1, this[kOnClosed] = [];
      }
      get destroyed() {
        return this[kDestroyed];
      }
      get closed() {
        return this[kClosed];
      }
      get interceptors() {
        return this[kInterceptors];
      }
      set interceptors(newInterceptors) {
        if (newInterceptors) {
          for (let i = newInterceptors.length - 1; i >= 0; i--)
            if (typeof this[kInterceptors][i] != "function")
              throw new InvalidArgumentError("interceptor must be an function");
        }
        this[kInterceptors] = newInterceptors;
      }
      close(callback) {
        if (callback === void 0)
          return new Promise((resolve2, reject) => {
            this.close((err, data) => err ? reject(err) : resolve2(data));
          });
        if (typeof callback != "function")
          throw new InvalidArgumentError("invalid callback");
        if (this[kDestroyed]) {
          queueMicrotask(() => callback(new ClientDestroyedError(), null));
          return;
        }
        if (this[kClosed]) {
          this[kOnClosed] ? this[kOnClosed].push(callback) : queueMicrotask(() => callback(null, null));
          return;
        }
        this[kClosed] = !0, this[kOnClosed].push(callback);
        let onClosed = () => {
          let callbacks = this[kOnClosed];
          this[kOnClosed] = null;
          for (let i = 0; i < callbacks.length; i++)
            callbacks[i](null, null);
        };
        this[kClose]().then(() => this.destroy()).then(() => {
          queueMicrotask(onClosed);
        });
      }
      destroy(err, callback) {
        if (typeof err == "function" && (callback = err, err = null), callback === void 0)
          return new Promise((resolve2, reject) => {
            this.destroy(err, (err2, data) => err2 ? (
              /* istanbul ignore next: should never error */
              reject(err2)
            ) : resolve2(data));
          });
        if (typeof callback != "function")
          throw new InvalidArgumentError("invalid callback");
        if (this[kDestroyed]) {
          this[kOnDestroyed] ? this[kOnDestroyed].push(callback) : queueMicrotask(() => callback(null, null));
          return;
        }
        err || (err = new ClientDestroyedError()), this[kDestroyed] = !0, this[kOnDestroyed] = this[kOnDestroyed] || [], this[kOnDestroyed].push(callback);
        let onDestroyed = () => {
          let callbacks = this[kOnDestroyed];
          this[kOnDestroyed] = null;
          for (let i = 0; i < callbacks.length; i++)
            callbacks[i](null, null);
        };
        this[kDestroy](err).then(() => {
          queueMicrotask(onDestroyed);
        });
      }
      [kInterceptedDispatch](opts, handler) {
        if (!this[kInterceptors] || this[kInterceptors].length === 0)
          return this[kInterceptedDispatch] = this[kDispatch], this[kDispatch](opts, handler);
        let dispatch = this[kDispatch].bind(this);
        for (let i = this[kInterceptors].length - 1; i >= 0; i--)
          dispatch = this[kInterceptors][i](dispatch);
        return this[kInterceptedDispatch] = dispatch, dispatch(opts, handler);
      }
      dispatch(opts, handler) {
        if (!handler || typeof handler != "object")
          throw new InvalidArgumentError("handler must be an object");
        try {
          if (!opts || typeof opts != "object")
            throw new InvalidArgumentError("opts must be an object.");
          if (this[kDestroyed] || this[kOnDestroyed])
            throw new ClientDestroyedError();
          if (this[kClosed])
            throw new ClientClosedError();
          return this[kInterceptedDispatch](opts, handler);
        } catch (err) {
          if (typeof handler.onError != "function")
            throw new InvalidArgumentError("invalid onError method");
          return handler.onError(err), !1;
        }
      }
    };
    module2.exports = DispatcherBase;
  }
});

// node_modules/undici/lib/core/connect.js
var require_connect = __commonJS({
  "node_modules/undici/lib/core/connect.js"(exports2, module2) {
    "use strict";
    var net = require("net"), assert3 = require("assert"), util = require_util(), { InvalidArgumentError, ConnectTimeoutError } = require_errors(), tls, SessionCache;
    global.FinalizationRegistry && !process.env.NODE_V8_COVERAGE ? SessionCache = class {
      constructor(maxCachedSessions) {
        this._maxCachedSessions = maxCachedSessions, this._sessionCache = /* @__PURE__ */ new Map(), this._sessionRegistry = new global.FinalizationRegistry((key) => {
          if (this._sessionCache.size < this._maxCachedSessions)
            return;
          let ref = this._sessionCache.get(key);
          ref !== void 0 && ref.deref() === void 0 && this._sessionCache.delete(key);
        });
      }
      get(sessionKey) {
        let ref = this._sessionCache.get(sessionKey);
        return ref ? ref.deref() : null;
      }
      set(sessionKey, session) {
        this._maxCachedSessions !== 0 && (this._sessionCache.set(sessionKey, new WeakRef(session)), this._sessionRegistry.register(session, sessionKey));
      }
    } : SessionCache = class {
      constructor(maxCachedSessions) {
        this._maxCachedSessions = maxCachedSessions, this._sessionCache = /* @__PURE__ */ new Map();
      }
      get(sessionKey) {
        return this._sessionCache.get(sessionKey);
      }
      set(sessionKey, session) {
        if (this._maxCachedSessions !== 0) {
          if (this._sessionCache.size >= this._maxCachedSessions) {
            let { value: oldestKey } = this._sessionCache.keys().next();
            this._sessionCache.delete(oldestKey);
          }
          this._sessionCache.set(sessionKey, session);
        }
      }
    };
    function buildConnector({ allowH2, maxCachedSessions, socketPath, timeout, ...opts }) {
      if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0))
        throw new InvalidArgumentError("maxCachedSessions must be a positive integer or zero");
      let options = { path: socketPath, ...opts }, sessionCache = new SessionCache(maxCachedSessions ?? 100);
      return timeout = timeout ?? 1e4, allowH2 = allowH2 ?? !1, function({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
        let socket;
        if (protocol === "https:") {
          tls || (tls = require("tls")), servername = servername || options.servername || util.getServerName(host) || null;
          let sessionKey = servername || hostname, session = sessionCache.get(sessionKey) || null;
          assert3(sessionKey), socket = tls.connect({
            highWaterMark: 16384,
            // TLS in node can't have bigger HWM anyway...
            ...options,
            servername,
            session,
            localAddress,
            // TODO(HTTP/2): Add support for h2c
            ALPNProtocols: allowH2 ? ["http/1.1", "h2"] : ["http/1.1"],
            socket: httpSocket,
            // upgrade socket connection
            port: port || 443,
            host: hostname
          }), socket.on("session", function(session2) {
            sessionCache.set(sessionKey, session2);
          });
        } else
          assert3(!httpSocket, "httpSocket can only be sent on TLS update"), socket = net.connect({
            highWaterMark: 64 * 1024,
            // Same as nodejs fs streams.
            ...options,
            localAddress,
            port: port || 80,
            host: hostname
          });
        if (options.keepAlive == null || options.keepAlive) {
          let keepAliveInitialDelay = options.keepAliveInitialDelay === void 0 ? 6e4 : options.keepAliveInitialDelay;
          socket.setKeepAlive(!0, keepAliveInitialDelay);
        }
        let cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);
        return socket.setNoDelay(!0).once(protocol === "https:" ? "secureConnect" : "connect", function() {
          if (cancelTimeout(), callback) {
            let cb = callback;
            callback = null, cb(null, this);
          }
        }).on("error", function(err) {
          if (cancelTimeout(), callback) {
            let cb = callback;
            callback = null, cb(err);
          }
        }), socket;
      };
    }
    function setupTimeout(onConnectTimeout2, timeout) {
      if (!timeout)
        return () => {
        };
      let s1 = null, s2 = null, timeoutId = setTimeout(() => {
        s1 = setImmediate(() => {
          process.platform === "win32" ? s2 = setImmediate(() => onConnectTimeout2()) : onConnectTimeout2();
        });
      }, timeout);
      return () => {
        clearTimeout(timeoutId), clearImmediate(s1), clearImmediate(s2);
      };
    }
    function onConnectTimeout(socket) {
      util.destroy(socket, new ConnectTimeoutError());
    }
    module2.exports = buildConnector;
  }
});

// node_modules/undici/lib/llhttp/utils.js
var require_utils2 = __commonJS({
  "node_modules/undici/lib/llhttp/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.enumToMap = void 0;
    function enumToMap(obj) {
      let res = {};
      return Object.keys(obj).forEach((key) => {
        let value = obj[key];
        typeof value == "number" && (res[key] = value);
      }), res;
    }
    exports2.enumToMap = enumToMap;
  }
});

// node_modules/undici/lib/llhttp/constants.js
var require_constants3 = __commonJS({
  "node_modules/undici/lib/llhttp/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.SPECIAL_HEADERS = exports2.HEADER_STATE = exports2.MINOR = exports2.MAJOR = exports2.CONNECTION_TOKEN_CHARS = exports2.HEADER_CHARS = exports2.TOKEN = exports2.STRICT_TOKEN = exports2.HEX = exports2.URL_CHAR = exports2.STRICT_URL_CHAR = exports2.USERINFO_CHARS = exports2.MARK = exports2.ALPHANUM = exports2.NUM = exports2.HEX_MAP = exports2.NUM_MAP = exports2.ALPHA = exports2.FINISH = exports2.H_METHOD_MAP = exports2.METHOD_MAP = exports2.METHODS_RTSP = exports2.METHODS_ICE = exports2.METHODS_HTTP = exports2.METHODS = exports2.LENIENT_FLAGS = exports2.FLAGS = exports2.TYPE = exports2.ERROR = void 0;
    var utils_1 = require_utils2(), ERROR2;
    (function(ERROR3) {
      ERROR3[ERROR3.OK = 0] = "OK", ERROR3[ERROR3.INTERNAL = 1] = "INTERNAL", ERROR3[ERROR3.STRICT = 2] = "STRICT", ERROR3[ERROR3.LF_EXPECTED = 3] = "LF_EXPECTED", ERROR3[ERROR3.UNEXPECTED_CONTENT_LENGTH = 4] = "UNEXPECTED_CONTENT_LENGTH", ERROR3[ERROR3.CLOSED_CONNECTION = 5] = "CLOSED_CONNECTION", ERROR3[ERROR3.INVALID_METHOD = 6] = "INVALID_METHOD", ERROR3[ERROR3.INVALID_URL = 7] = "INVALID_URL", ERROR3[ERROR3.INVALID_CONSTANT = 8] = "INVALID_CONSTANT", ERROR3[ERROR3.INVALID_VERSION = 9] = "INVALID_VERSION", ERROR3[ERROR3.INVALID_HEADER_TOKEN = 10] = "INVALID_HEADER_TOKEN", ERROR3[ERROR3.INVALID_CONTENT_LENGTH = 11] = "INVALID_CONTENT_LENGTH", ERROR3[ERROR3.INVALID_CHUNK_SIZE = 12] = "INVALID_CHUNK_SIZE", ERROR3[ERROR3.INVALID_STATUS = 13] = "INVALID_STATUS", ERROR3[ERROR3.INVALID_EOF_STATE = 14] = "INVALID_EOF_STATE", ERROR3[ERROR3.INVALID_TRANSFER_ENCODING = 15] = "INVALID_TRANSFER_ENCODING", ERROR3[ERROR3.CB_MESSAGE_BEGIN = 16] = "CB_MESSAGE_BEGIN", ERROR3[ERROR3.CB_HEADERS_COMPLETE = 17] = "CB_HEADERS_COMPLETE", ERROR3[ERROR3.CB_MESSAGE_COMPLETE = 18] = "CB_MESSAGE_COMPLETE", ERROR3[ERROR3.CB_CHUNK_HEADER = 19] = "CB_CHUNK_HEADER", ERROR3[ERROR3.CB_CHUNK_COMPLETE = 20] = "CB_CHUNK_COMPLETE", ERROR3[ERROR3.PAUSED = 21] = "PAUSED", ERROR3[ERROR3.PAUSED_UPGRADE = 22] = "PAUSED_UPGRADE", ERROR3[ERROR3.PAUSED_H2_UPGRADE = 23] = "PAUSED_H2_UPGRADE", ERROR3[ERROR3.USER = 24] = "USER";
    })(ERROR2 = exports2.ERROR || (exports2.ERROR = {}));
    var TYPE;
    (function(TYPE2) {
      TYPE2[TYPE2.BOTH = 0] = "BOTH", TYPE2[TYPE2.REQUEST = 1] = "REQUEST", TYPE2[TYPE2.RESPONSE = 2] = "RESPONSE";
    })(TYPE = exports2.TYPE || (exports2.TYPE = {}));
    var FLAGS;
    (function(FLAGS2) {
      FLAGS2[FLAGS2.CONNECTION_KEEP_ALIVE = 1] = "CONNECTION_KEEP_ALIVE", FLAGS2[FLAGS2.CONNECTION_CLOSE = 2] = "CONNECTION_CLOSE", FLAGS2[FLAGS2.CONNECTION_UPGRADE = 4] = "CONNECTION_UPGRADE", FLAGS2[FLAGS2.CHUNKED = 8] = "CHUNKED", FLAGS2[FLAGS2.UPGRADE = 16] = "UPGRADE", FLAGS2[FLAGS2.CONTENT_LENGTH = 32] = "CONTENT_LENGTH", FLAGS2[FLAGS2.SKIPBODY = 64] = "SKIPBODY", FLAGS2[FLAGS2.TRAILING = 128] = "TRAILING", FLAGS2[FLAGS2.TRANSFER_ENCODING = 512] = "TRANSFER_ENCODING";
    })(FLAGS = exports2.FLAGS || (exports2.FLAGS = {}));
    var LENIENT_FLAGS;
    (function(LENIENT_FLAGS2) {
      LENIENT_FLAGS2[LENIENT_FLAGS2.HEADERS = 1] = "HEADERS", LENIENT_FLAGS2[LENIENT_FLAGS2.CHUNKED_LENGTH = 2] = "CHUNKED_LENGTH", LENIENT_FLAGS2[LENIENT_FLAGS2.KEEP_ALIVE = 4] = "KEEP_ALIVE";
    })(LENIENT_FLAGS = exports2.LENIENT_FLAGS || (exports2.LENIENT_FLAGS = {}));
    var METHODS;
    (function(METHODS2) {
      METHODS2[METHODS2.DELETE = 0] = "DELETE", METHODS2[METHODS2.GET = 1] = "GET", METHODS2[METHODS2.HEAD = 2] = "HEAD", METHODS2[METHODS2.POST = 3] = "POST", METHODS2[METHODS2.PUT = 4] = "PUT", METHODS2[METHODS2.CONNECT = 5] = "CONNECT", METHODS2[METHODS2.OPTIONS = 6] = "OPTIONS", METHODS2[METHODS2.TRACE = 7] = "TRACE", METHODS2[METHODS2.COPY = 8] = "COPY", METHODS2[METHODS2.LOCK = 9] = "LOCK", METHODS2[METHODS2.MKCOL = 10] = "MKCOL", METHODS2[METHODS2.MOVE = 11] = "MOVE", METHODS2[METHODS2.PROPFIND = 12] = "PROPFIND", METHODS2[METHODS2.PROPPATCH = 13] = "PROPPATCH", METHODS2[METHODS2.SEARCH = 14] = "SEARCH", METHODS2[METHODS2.UNLOCK = 15] = "UNLOCK", METHODS2[METHODS2.BIND = 16] = "BIND", METHODS2[METHODS2.REBIND = 17] = "REBIND", METHODS2[METHODS2.UNBIND = 18] = "UNBIND", METHODS2[METHODS2.ACL = 19] = "ACL", METHODS2[METHODS2.REPORT = 20] = "REPORT", METHODS2[METHODS2.MKACTIVITY = 21] = "MKACTIVITY", METHODS2[METHODS2.CHECKOUT = 22] = "CHECKOUT", METHODS2[METHODS2.MERGE = 23] = "MERGE", METHODS2[METHODS2["M-SEARCH"] = 24] = "M-SEARCH", METHODS2[METHODS2.NOTIFY = 25] = "NOTIFY", METHODS2[METHODS2.SUBSCRIBE = 26] = "SUBSCRIBE", METHODS2[METHODS2.UNSUBSCRIBE = 27] = "UNSUBSCRIBE", METHODS2[METHODS2.PATCH = 28] = "PATCH", METHODS2[METHODS2.PURGE = 29] = "PURGE", METHODS2[METHODS2.MKCALENDAR = 30] = "MKCALENDAR", METHODS2[METHODS2.LINK = 31] = "LINK", METHODS2[METHODS2.UNLINK = 32] = "UNLINK", METHODS2[METHODS2.SOURCE = 33] = "SOURCE", METHODS2[METHODS2.PRI = 34] = "PRI", METHODS2[METHODS2.DESCRIBE = 35] = "DESCRIBE", METHODS2[METHODS2.ANNOUNCE = 36] = "ANNOUNCE", METHODS2[METHODS2.SETUP = 37] = "SETUP", METHODS2[METHODS2.PLAY = 38] = "PLAY", METHODS2[METHODS2.PAUSE = 39] = "PAUSE", METHODS2[METHODS2.TEARDOWN = 40] = "TEARDOWN", METHODS2[METHODS2.GET_PARAMETER = 41] = "GET_PARAMETER", METHODS2[METHODS2.SET_PARAMETER = 42] = "SET_PARAMETER", METHODS2[METHODS2.REDIRECT = 43] = "REDIRECT", METHODS2[METHODS2.RECORD = 44] = "RECORD", METHODS2[METHODS2.FLUSH = 45] = "FLUSH";
    })(METHODS = exports2.METHODS || (exports2.METHODS = {}));
    exports2.METHODS_HTTP = [
      METHODS.DELETE,
      METHODS.GET,
      METHODS.HEAD,
      METHODS.POST,
      METHODS.PUT,
      METHODS.CONNECT,
      METHODS.OPTIONS,
      METHODS.TRACE,
      METHODS.COPY,
      METHODS.LOCK,
      METHODS.MKCOL,
      METHODS.MOVE,
      METHODS.PROPFIND,
      METHODS.PROPPATCH,
      METHODS.SEARCH,
      METHODS.UNLOCK,
      METHODS.BIND,
      METHODS.REBIND,
      METHODS.UNBIND,
      METHODS.ACL,
      METHODS.REPORT,
      METHODS.MKACTIVITY,
      METHODS.CHECKOUT,
      METHODS.MERGE,
      METHODS["M-SEARCH"],
      METHODS.NOTIFY,
      METHODS.SUBSCRIBE,
      METHODS.UNSUBSCRIBE,
      METHODS.PATCH,
      METHODS.PURGE,
      METHODS.MKCALENDAR,
      METHODS.LINK,
      METHODS.UNLINK,
      METHODS.PRI,
      // TODO(indutny): should we allow it with HTTP?
      METHODS.SOURCE
    ];
    exports2.METHODS_ICE = [
      METHODS.SOURCE
    ];
    exports2.METHODS_RTSP = [
      METHODS.OPTIONS,
      METHODS.DESCRIBE,
      METHODS.ANNOUNCE,
      METHODS.SETUP,
      METHODS.PLAY,
      METHODS.PAUSE,
      METHODS.TEARDOWN,
      METHODS.GET_PARAMETER,
      METHODS.SET_PARAMETER,
      METHODS.REDIRECT,
      METHODS.RECORD,
      METHODS.FLUSH,
      // For AirPlay
      METHODS.GET,
      METHODS.POST
    ];
    exports2.METHOD_MAP = utils_1.enumToMap(METHODS);
    exports2.H_METHOD_MAP = {};
    Object.keys(exports2.METHOD_MAP).forEach((key) => {
      /^H/.test(key) && (exports2.H_METHOD_MAP[key] = exports2.METHOD_MAP[key]);
    });
    var FINISH;
    (function(FINISH2) {
      FINISH2[FINISH2.SAFE = 0] = "SAFE", FINISH2[FINISH2.SAFE_WITH_CB = 1] = "SAFE_WITH_CB", FINISH2[FINISH2.UNSAFE = 2] = "UNSAFE";
    })(FINISH = exports2.FINISH || (exports2.FINISH = {}));
    exports2.ALPHA = [];
    for (let i = 65; i <= 90; i++)
      exports2.ALPHA.push(String.fromCharCode(i)), exports2.ALPHA.push(String.fromCharCode(i + 32));
    exports2.NUM_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9
    };
    exports2.HEX_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      A: 10,
      B: 11,
      C: 12,
      D: 13,
      E: 14,
      F: 15,
      a: 10,
      b: 11,
      c: 12,
      d: 13,
      e: 14,
      f: 15
    };
    exports2.NUM = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9"
    ];
    exports2.ALPHANUM = exports2.ALPHA.concat(exports2.NUM);
    exports2.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"];
    exports2.USERINFO_CHARS = exports2.ALPHANUM.concat(exports2.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]);
    exports2.STRICT_URL_CHAR = [
      "!",
      '"',
      "$",
      "%",
      "&",
      "'",
      "(",
      ")",
      "*",
      "+",
      ",",
      "-",
      ".",
      "/",
      ":",
      ";",
      "<",
      "=",
      ">",
      "@",
      "[",
      "\\",
      "]",
      "^",
      "_",
      "`",
      "{",
      "|",
      "}",
      "~"
    ].concat(exports2.ALPHANUM);
    exports2.URL_CHAR = exports2.STRICT_URL_CHAR.concat(["	", "\f"]);
    for (let i = 128; i <= 255; i++)
      exports2.URL_CHAR.push(i);
    exports2.HEX = exports2.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]);
    exports2.STRICT_TOKEN = [
      "!",
      "#",
      "$",
      "%",
      "&",
      "'",
      "*",
      "+",
      "-",
      ".",
      "^",
      "_",
      "`",
      "|",
      "~"
    ].concat(exports2.ALPHANUM);
    exports2.TOKEN = exports2.STRICT_TOKEN.concat([" "]);
    exports2.HEADER_CHARS = ["	"];
    for (let i = 32; i <= 255; i++)
      i !== 127 && exports2.HEADER_CHARS.push(i);
    exports2.CONNECTION_TOKEN_CHARS = exports2.HEADER_CHARS.filter((c) => c !== 44);
    exports2.MAJOR = exports2.NUM_MAP;
    exports2.MINOR = exports2.MAJOR;
    var HEADER_STATE;
    (function(HEADER_STATE2) {
      HEADER_STATE2[HEADER_STATE2.GENERAL = 0] = "GENERAL", HEADER_STATE2[HEADER_STATE2.CONNECTION = 1] = "CONNECTION", HEADER_STATE2[HEADER_STATE2.CONTENT_LENGTH = 2] = "CONTENT_LENGTH", HEADER_STATE2[HEADER_STATE2.TRANSFER_ENCODING = 3] = "TRANSFER_ENCODING", HEADER_STATE2[HEADER_STATE2.UPGRADE = 4] = "UPGRADE", HEADER_STATE2[HEADER_STATE2.CONNECTION_KEEP_ALIVE = 5] = "CONNECTION_KEEP_ALIVE", HEADER_STATE2[HEADER_STATE2.CONNECTION_CLOSE = 6] = "CONNECTION_CLOSE", HEADER_STATE2[HEADER_STATE2.CONNECTION_UPGRADE = 7] = "CONNECTION_UPGRADE", HEADER_STATE2[HEADER_STATE2.TRANSFER_ENCODING_CHUNKED = 8] = "TRANSFER_ENCODING_CHUNKED";
    })(HEADER_STATE = exports2.HEADER_STATE || (exports2.HEADER_STATE = {}));
    exports2.SPECIAL_HEADERS = {
      connection: HEADER_STATE.CONNECTION,
      "content-length": HEADER_STATE.CONTENT_LENGTH,
      "proxy-connection": HEADER_STATE.CONNECTION,
      "transfer-encoding": HEADER_STATE.TRANSFER_ENCODING,
      upgrade: HEADER_STATE.UPGRADE
    };
  }
});

// node_modules/undici/lib/handler/RedirectHandler.js
var require_RedirectHandler = __commonJS({
  "node_modules/undici/lib/handler/RedirectHandler.js"(exports2, module2) {
    "use strict";
    var util = require_util(), { kBodyUsed } = require_symbols(), assert3 = require("assert"), { InvalidArgumentError } = require_errors(), EE3 = require("events"), redirectableStatusCodes = [300, 301, 302, 303, 307, 308], kBody = Symbol("body"), BodyAsyncIterable = class {
      constructor(body) {
        this[kBody] = body, this[kBodyUsed] = !1;
      }
      async *[Symbol.asyncIterator]() {
        assert3(!this[kBodyUsed], "disturbed"), this[kBodyUsed] = !0, yield* this[kBody];
      }
    }, RedirectHandler = class {
      constructor(dispatch, maxRedirections, opts, handler) {
        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0))
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        util.validateHandler(handler, opts.method, opts.upgrade), this.dispatch = dispatch, this.location = null, this.abort = null, this.opts = { ...opts, maxRedirections: 0 }, this.maxRedirections = maxRedirections, this.handler = handler, this.history = [], util.isStream(this.opts.body) ? (util.bodyLength(this.opts.body) === 0 && this.opts.body.on("data", function() {
          assert3(!1);
        }), typeof this.opts.body.readableDidRead != "boolean" && (this.opts.body[kBodyUsed] = !1, EE3.prototype.on.call(this.opts.body, "data", function() {
          this[kBodyUsed] = !0;
        }))) : this.opts.body && typeof this.opts.body.pipeTo == "function" ? this.opts.body = new BodyAsyncIterable(this.opts.body) : this.opts.body && typeof this.opts.body != "string" && !ArrayBuffer.isView(this.opts.body) && util.isIterable(this.opts.body) && (this.opts.body = new BodyAsyncIterable(this.opts.body));
      }
      onConnect(abort) {
        this.abort = abort, this.handler.onConnect(abort, { history: this.history });
      }
      onUpgrade(statusCode, headers, socket) {
        this.handler.onUpgrade(statusCode, headers, socket);
      }
      onError(error) {
        this.handler.onError(error);
      }
      onHeaders(statusCode, headers, resume, statusText) {
        if (this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers), this.opts.origin && this.history.push(new URL(this.opts.path, this.opts.origin)), !this.location)
          return this.handler.onHeaders(statusCode, headers, resume, statusText);
        let { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin))), path8 = search ? `${pathname}${search}` : pathname;
        this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin), this.opts.path = path8, this.opts.origin = origin, this.opts.maxRedirections = 0, this.opts.query = null, statusCode === 303 && this.opts.method !== "HEAD" && (this.opts.method = "GET", this.opts.body = null);
      }
      onData(chunk) {
        if (!this.location)
          return this.handler.onData(chunk);
      }
      onComplete(trailers) {
        this.location ? (this.location = null, this.abort = null, this.dispatch(this.opts, this)) : this.handler.onComplete(trailers);
      }
      onBodySent(chunk) {
        this.handler.onBodySent && this.handler.onBodySent(chunk);
      }
    };
    function parseLocation(statusCode, headers) {
      if (redirectableStatusCodes.indexOf(statusCode) === -1)
        return null;
      for (let i = 0; i < headers.length; i += 2)
        if (headers[i].toString().toLowerCase() === "location")
          return headers[i + 1];
    }
    function shouldRemoveHeader(header, removeContent, unknownOrigin) {
      if (header.length === 4)
        return util.headerNameToString(header) === "host";
      if (removeContent && util.headerNameToString(header).startsWith("content-"))
        return !0;
      if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {
        let name2 = util.headerNameToString(header);
        return name2 === "authorization" || name2 === "cookie" || name2 === "proxy-authorization";
      }
      return !1;
    }
    function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
      let ret = [];
      if (Array.isArray(headers))
        for (let i = 0; i < headers.length; i += 2)
          shouldRemoveHeader(headers[i], removeContent, unknownOrigin) || ret.push(headers[i], headers[i + 1]);
      else if (headers && typeof headers == "object")
        for (let key of Object.keys(headers))
          shouldRemoveHeader(key, removeContent, unknownOrigin) || ret.push(key, headers[key]);
      else
        assert3(headers == null, "headers must be an object or an array");
      return ret;
    }
    module2.exports = RedirectHandler;
  }
});

// node_modules/undici/lib/interceptor/redirectInterceptor.js
var require_redirectInterceptor = __commonJS({
  "node_modules/undici/lib/interceptor/redirectInterceptor.js"(exports2, module2) {
    "use strict";
    var RedirectHandler = require_RedirectHandler();
    function createRedirectInterceptor({ maxRedirections: defaultMaxRedirections }) {
      return (dispatch) => function(opts, handler) {
        let { maxRedirections = defaultMaxRedirections } = opts;
        if (!maxRedirections)
          return dispatch(opts, handler);
        let redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);
        return opts = { ...opts, maxRedirections: 0 }, dispatch(opts, redirectHandler);
      };
    }
    module2.exports = createRedirectInterceptor;
  }
});

// node_modules/undici/lib/llhttp/llhttp-wasm.js
var require_llhttp_wasm = __commonJS({
  "node_modules/undici/lib/llhttp/llhttp-wasm.js"(exports2, module2) {
    module2.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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ADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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FCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAU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YWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=";
  }
});

// node_modules/undici/lib/llhttp/llhttp_simd-wasm.js
var require_llhttp_simd_wasm = __commonJS({
  "node_modules/undici/lib/llhttp/llhttp_simd-wasm.js"(exports2, module2) {
    module2.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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IAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AcsBygG4AckBuQHIAboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBANwBC0EAIRAMxgELQQ4hEAzFAQtBDSEQDMQBC0EPIRAMwwELQRAhEAzCAQtBEyEQDMEBC0EUIRAMwAELQRUhEAy/AQtBFiEQDL4BC0EXIRAMvQELQRghEAy8AQtBGSEQDLsBC0EaIRAMugELQRshEAy5AQtBHCEQDLgBC0EIIRAMtwELQR0hEAy2AQtBICEQDLUBC0EfIRAMtAELQQchEAyzAQtBISEQDLIBC0EiIRAMsQELQR4hEAywAQtBIyEQDK8BC0ESIRAMrgELQREhEAytAQtBJCEQDKwBC0ElIRAMqwELQSYhEAyqAQtBJyEQDKkBC0HDASEQDKgBC0EpIRAMpwELQSshEAymAQtBLCEQDKUBC0EtIRAMpAELQS4hEAyjAQtBLyEQDKIBC0HEASEQDKEBC0EwIRAMoAELQTQhEAyfAQtBDCEQDJ4BC0ExIRAMnQELQTIhEAycAQtBMyEQDJsBC0E5IRAMmgELQTUhEAyZAQtBxQEhEAyYAQtBCyEQDJcBC0E6IRAMlgELQTYhEAyVAQtBCiEQDJQBC0E3IRAMkwELQTghEAySAQtBPCEQDJEBC0E7IRAMkAELQT0hEAyPAQtBCSEQDI4BC0EoIRAMjQELQT4hEAyMAQtBPyEQDIsBC0HAACEQDIoBC0HBACEQDIkBC0HCACEQDIgBC0HDACEQDIcBC0HEACEQDIYBC0HFACEQDIUBC0HGACEQDIQBC0EqIRAMgwELQccAIRAMggELQcgAIRAMgQELQckAIRAMgAELQcoAIRAMfwtBywAhEAx+C0HNACEQDH0LQcwAIRAMfAtBzgAhEAx7C0HPACEQDHoLQdAAIRAMeQtB0QAhEAx4C0HSACEQDHcLQdMAIRAMdgtB1AAhEAx1C0HWACEQDHQLQdUAIRAMcwtBBiEQDHILQdcAIRAMcQtBBSEQDHALQdgAIRAMbwtBBCEQDG4LQdkAIRAMbQtB2gAhEAxsC0HbACEQDGsLQdwAIRAMagtBAyEQDGkLQd0AIRAMaAtB3gAhEAxnC0HfACEQDGYLQeEAIRAMZQtB4AAhEAxkC0HiACEQDGMLQeMAIRAMYgtBAiEQDGELQeQAIRAMYAtB5QAhEAxfC0HmACEQDF4LQecAIRAMXQtB6AAhEAxcC0HpACEQDFsLQeoAIRAMWgtB6wAhEAxZC0HsACEQDFgLQe0AIRAMVwtB7gAhEAxWC0HvACEQDFULQfAAIRAMVAtB8QAhEAxTC0HyACEQDFILQfMAIRAMUQtB9AAhEAxQC0H1ACEQDE8LQfYAIRAMTgtB9wAhEAxNC0H4ACEQDEwLQfkAIRAMSwtB+gAhEAxKC0H7ACEQDEkLQfwAIRAMSAtB/QAhEAxHC0H+ACEQDEYLQf8AIRAMRQtBgAEhEAxEC0GBASEQDEMLQYIBIRAMQgtBgwEhEAxBC0GEASEQDEALQYUBIRAMPwtBhgEhEAw+C0GHASEQDD0LQYgBIRAMPAtBiQEhEAw7C0GKASEQDDoLQYsBIRAMOQtBjAEhEAw4C0GNASEQDDcLQY4BIRAMNgtBjwEhEAw1C0GQASEQDDQLQZEBIRAMMwtBkgEhEAwyC0GTASEQDDELQZQBIRAMMAtBlQEhEAwvC0GWASEQDC4LQZcBIRAMLQtBmAEhEAwsC0GZASEQDCsLQZoBIRAMKgtBmwEhEAwpC0GcASEQDCgLQZ0BIRAMJwtBngEhEAwmC0GfASEQDCULQaABIRAMJAtBoQEhEAwjC0GiASEQDCILQaMBIRAMIQtBpAEhEAwgC0GlASEQDB8LQaYBIRAMHgtBpwEhEAwdC0GoASEQDBwLQakBIRAMGwtBqgEhEAwaC0GrASEQDBkLQawBIRAMGAtBrQEhEAwXC0GuASEQDBYLQQEhEAwVC0GvASEQDBQLQbABIRAMEwtBsQEhEAwSC0GzASEQDBELQbIBIRAMEAtBtAEhEAwPC0G1ASEQDA4LQbYBIRAMDQtBtwEhEAwMC0G4ASEQDAsLQbkBIRAMCgtBugEhEAwJC0G7ASEQDAgLQcYBIRAMBwtBvAEhEAwGC0G9ASEQDAULQb4BIRAMBAtBvwEhEAwDC0HAASEQDAILQcIBIRAMAQtBwQEhEAsDQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQID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YWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==";
  }
});

// node_modules/undici/lib/client.js
var require_client = __commonJS({
  "node_modules/undici/lib/client.js"(exports2, module2) {
    "use strict";
    var assert3 = require("assert"), net = require("net"), http = require("http"), { pipeline } = require("stream"), util = require_util(), timers = require_timers(), Request = require_request(), DispatcherBase = require_dispatcher_base(), {
      RequestContentLengthMismatchError,
      ResponseContentLengthMismatchError,
      InvalidArgumentError,
      RequestAbortedError,
      HeadersTimeoutError,
      HeadersOverflowError,
      SocketError,
      InformationalError,
      BodyTimeoutError,
      HTTPParserError,
      ResponseExceededMaxSizeError,
      ClientDestroyedError
    } = require_errors(), buildConnector = require_connect(), {
      kUrl,
      kReset,
      kServerName,
      kClient,
      kBusy,
      kParser,
      kConnect,
      kBlocking,
      kResuming,
      kRunning,
      kPending,
      kSize,
      kWriting,
      kQueue,
      kConnected,
      kConnecting,
      kNeedDrain,
      kNoRef,
      kKeepAliveDefaultTimeout,
      kHostHeader,
      kPendingIdx,
      kRunningIdx,
      kError,
      kPipelining,
      kSocket,
      kKeepAliveTimeoutValue,
      kMaxHeadersSize,
      kKeepAliveMaxTimeout,
      kKeepAliveTimeoutThreshold,
      kHeadersTimeout,
      kBodyTimeout,
      kStrictContentLength,
      kConnector,
      kMaxRedirections,
      kMaxRequests,
      kCounter,
      kClose,
      kDestroy,
      kDispatch,
      kInterceptors,
      kLocalAddress,
      kMaxResponseSize,
      kHTTPConnVersion,
      // HTTP2
      kHost,
      kHTTP2Session,
      kHTTP2SessionState,
      kHTTP2BuildRequest,
      kHTTP2CopyHeaders,
      kHTTP1BuildRequest
    } = require_symbols(), http2;
    try {
      http2 = require("http2");
    } catch {
      http2 = { constants: {} };
    }
    var {
      constants: {
        HTTP2_HEADER_AUTHORITY,
        HTTP2_HEADER_METHOD,
        HTTP2_HEADER_PATH,
        HTTP2_HEADER_SCHEME,
        HTTP2_HEADER_CONTENT_LENGTH,
        HTTP2_HEADER_EXPECT,
        HTTP2_HEADER_STATUS
      }
    } = http2, h2ExperimentalWarned = !1, FastBuffer = Buffer[Symbol.species], kClosedResolve = Symbol("kClosedResolve"), channels = {};
    try {
      let diagnosticsChannel = require("diagnostics_channel");
      channels.sendHeaders = diagnosticsChannel.channel("undici:client:sendHeaders"), channels.beforeConnect = diagnosticsChannel.channel("undici:client:beforeConnect"), channels.connectError = diagnosticsChannel.channel("undici:client:connectError"), channels.connected = diagnosticsChannel.channel("undici:client:connected");
    } catch {
      channels.sendHeaders = { hasSubscribers: !1 }, channels.beforeConnect = { hasSubscribers: !1 }, channels.connectError = { hasSubscribers: !1 }, channels.connected = { hasSubscribers: !1 };
    }
    var Client = class extends DispatcherBase {
      /**
       *
       * @param {string|URL} url
       * @param {import('../types/client').Client.Options} options
       */
      constructor(url, {
        interceptors,
        maxHeaderSize,
        headersTimeout,
        socketTimeout,
        requestTimeout,
        connectTimeout,
        bodyTimeout,
        idleTimeout,
        keepAlive,
        keepAliveTimeout,
        maxKeepAliveTimeout,
        keepAliveMaxTimeout,
        keepAliveTimeoutThreshold,
        socketPath,
        pipelining,
        tls,
        strictContentLength,
        maxCachedSessions,
        maxRedirections,
        connect: connect2,
        maxRequestsPerClient,
        localAddress,
        maxResponseSize,
        autoSelectFamily,
        autoSelectFamilyAttemptTimeout,
        // h2
        allowH2,
        maxConcurrentStreams
      } = {}) {
        if (super(), keepAlive !== void 0)
          throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
        if (socketTimeout !== void 0)
          throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
        if (requestTimeout !== void 0)
          throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
        if (idleTimeout !== void 0)
          throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
        if (maxKeepAliveTimeout !== void 0)
          throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
        if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize))
          throw new InvalidArgumentError("invalid maxHeaderSize");
        if (socketPath != null && typeof socketPath != "string")
          throw new InvalidArgumentError("invalid socketPath");
        if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0))
          throw new InvalidArgumentError("invalid connectTimeout");
        if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0))
          throw new InvalidArgumentError("invalid keepAliveTimeout");
        if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0))
          throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
        if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold))
          throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
        if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0))
          throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
        if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0))
          throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
        if (connect2 != null && typeof connect2 != "function" && typeof connect2 != "object")
          throw new InvalidArgumentError("connect must be a function or an object");
        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0))
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0))
          throw new InvalidArgumentError("maxRequestsPerClient must be a positive number");
        if (localAddress != null && (typeof localAddress != "string" || net.isIP(localAddress) === 0))
          throw new InvalidArgumentError("localAddress must be valid string IP address");
        if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1))
          throw new InvalidArgumentError("maxResponseSize must be a positive number");
        if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1))
          throw new InvalidArgumentError("autoSelectFamilyAttemptTimeout must be a positive number");
        if (allowH2 != null && typeof allowH2 != "boolean")
          throw new InvalidArgumentError("allowH2 must be a valid boolean value");
        if (maxConcurrentStreams != null && (typeof maxConcurrentStreams != "number" || maxConcurrentStreams < 1))
          throw new InvalidArgumentError("maxConcurrentStreams must be a possitive integer, greater than 0");
        typeof connect2 != "function" && (connect2 = buildConnector({
          ...tls,
          maxCachedSessions,
          allowH2,
          socketPath,
          timeout: connectTimeout,
          ...util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
          ...connect2
        })), this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client) ? interceptors.Client : [createRedirectInterceptor({ maxRedirections })], this[kUrl] = util.parseOrigin(url), this[kConnector] = connect2, this[kSocket] = null, this[kPipelining] = pipelining ?? 1, this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize, this[kKeepAliveDefaultTimeout] = keepAliveTimeout ?? 4e3, this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout ?? 6e5, this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold ?? 1e3, this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout], this[kServerName] = null, this[kLocalAddress] = localAddress ?? null, this[kResuming] = 0, this[kNeedDrain] = 0, this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r
`, this[kBodyTimeout] = bodyTimeout ?? 3e5, this[kHeadersTimeout] = headersTimeout ?? 3e5, this[kStrictContentLength] = strictContentLength ?? !0, this[kMaxRedirections] = maxRedirections, this[kMaxRequests] = maxRequestsPerClient, this[kClosedResolve] = null, this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1, this[kHTTPConnVersion] = "h1", this[kHTTP2Session] = null, this[kHTTP2SessionState] = allowH2 ? {
          // streams: null, // Fixed queue of streams - For future support of `push`
          openStreams: 0,
          // Keep track of them to decide wether or not unref the session
          maxConcurrentStreams: maxConcurrentStreams ?? 100
          // Max peerConcurrentStreams for a Node h2 server
        } : null, this[kHost] = `${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}`, this[kQueue] = [], this[kRunningIdx] = 0, this[kPendingIdx] = 0;
      }
      get pipelining() {
        return this[kPipelining];
      }
      set pipelining(value) {
        this[kPipelining] = value, resume(this, !0);
      }
      get [kPending]() {
        return this[kQueue].length - this[kPendingIdx];
      }
      get [kRunning]() {
        return this[kPendingIdx] - this[kRunningIdx];
      }
      get [kSize]() {
        return this[kQueue].length - this[kRunningIdx];
      }
      get [kConnected]() {
        return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;
      }
      get [kBusy]() {
        let socket = this[kSocket];
        return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize] >= (this[kPipelining] || 1) || this[kPending] > 0;
      }
      /* istanbul ignore: only used for test */
      [kConnect](cb) {
        connect(this), this.once("connect", cb);
      }
      [kDispatch](opts, handler) {
        let origin = opts.origin || this[kUrl].origin, request = this[kHTTPConnVersion] === "h2" ? Request[kHTTP2BuildRequest](origin, opts, handler) : Request[kHTTP1BuildRequest](origin, opts, handler);
        return this[kQueue].push(request), this[kResuming] || (util.bodyLength(request.body) == null && util.isIterable(request.body) ? (this[kResuming] = 1, process.nextTick(resume, this)) : resume(this, !0)), this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy] && (this[kNeedDrain] = 2), this[kNeedDrain] < 2;
      }
      async [kClose]() {
        return new Promise((resolve2) => {
          this[kSize] ? this[kClosedResolve] = resolve2 : resolve2(null);
        });
      }
      async [kDestroy](err) {
        return new Promise((resolve2) => {
          let requests = this[kQueue].splice(this[kPendingIdx]);
          for (let i = 0; i < requests.length; i++) {
            let request = requests[i];
            errorRequest(this, request, err);
          }
          let callback = () => {
            this[kClosedResolve] && (this[kClosedResolve](), this[kClosedResolve] = null), resolve2();
          };
          this[kHTTP2Session] != null && (util.destroy(this[kHTTP2Session], err), this[kHTTP2Session] = null, this[kHTTP2SessionState] = null), this[kSocket] ? util.destroy(this[kSocket].on("close", callback), err) : queueMicrotask(callback), resume(this);
        });
      }
    };
    function onHttp2SessionError(err) {
      assert3(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID"), this[kSocket][kError] = err, onError(this[kClient], err);
    }
    function onHttp2FrameError(type, code2, id) {
      let err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code2}`);
      id === 0 && (this[kSocket][kError] = err, onError(this[kClient], err));
    }
    function onHttp2SessionEnd() {
      util.destroy(this, new SocketError("other side closed")), util.destroy(this[kSocket], new SocketError("other side closed"));
    }
    function onHTTP2GoAway(code2) {
      let client = this[kClient], err = new InformationalError(`HTTP/2: "GOAWAY" frame received with code ${code2}`);
      if (client[kSocket] = null, client[kHTTP2Session] = null, client.destroyed) {
        assert3(this[kPending] === 0);
        let requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          let request = requests[i];
          errorRequest(this, request, err);
        }
      } else if (client[kRunning] > 0) {
        let request = client[kQueue][client[kRunningIdx]];
        client[kQueue][client[kRunningIdx]++] = null, errorRequest(client, request, err);
      }
      client[kPendingIdx] = client[kRunningIdx], assert3(client[kRunning] === 0), client.emit(
        "disconnect",
        client[kUrl],
        [client],
        err
      ), resume(client);
    }
    var constants2 = require_constants3(), createRedirectInterceptor = require_redirectInterceptor(), EMPTY_BUF = Buffer.alloc(0);
    async function lazyllhttp() {
      let llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm() : void 0, mod;
      try {
        mod = await WebAssembly.compile(Buffer.from(require_llhttp_simd_wasm(), "base64"));
      } catch {
        mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require_llhttp_wasm(), "base64"));
      }
      return await WebAssembly.instantiate(mod, {
        env: {
          /* eslint-disable camelcase */
          wasm_on_url: (p, at, len) => 0,
          wasm_on_status: (p, at, len) => {
            assert3.strictEqual(currentParser.ptr, p);
            let start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_message_begin: (p) => (assert3.strictEqual(currentParser.ptr, p), currentParser.onMessageBegin() || 0),
          wasm_on_header_field: (p, at, len) => {
            assert3.strictEqual(currentParser.ptr, p);
            let start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_header_value: (p, at, len) => {
            assert3.strictEqual(currentParser.ptr, p);
            let start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => (assert3.strictEqual(currentParser.ptr, p), currentParser.onHeadersComplete(statusCode, !!upgrade, !!shouldKeepAlive) || 0),
          wasm_on_body: (p, at, len) => {
            assert3.strictEqual(currentParser.ptr, p);
            let start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_message_complete: (p) => (assert3.strictEqual(currentParser.ptr, p), currentParser.onMessageComplete() || 0)
          /* eslint-enable camelcase */
        }
      });
    }
    var llhttpInstance = null, llhttpPromise = lazyllhttp();
    llhttpPromise.catch();
    var currentParser = null, currentBufferRef = null, currentBufferSize = 0, currentBufferPtr = null, TIMEOUT_HEADERS = 1, TIMEOUT_BODY = 2, TIMEOUT_IDLE = 3, Parser2 = class {
      constructor(client, socket, { exports: exports3 }) {
        assert3(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0), this.llhttp = exports3, this.ptr = this.llhttp.llhttp_alloc(constants2.TYPE.RESPONSE), this.client = client, this.socket = socket, this.timeout = null, this.timeoutValue = null, this.timeoutType = null, this.statusCode = null, this.statusText = "", this.upgrade = !1, this.headers = [], this.headersSize = 0, this.headersMaxSize = client[kMaxHeadersSize], this.shouldKeepAlive = !1, this.paused = !1, this.resume = this.resume.bind(this), this.bytesRead = 0, this.keepAlive = "", this.contentLength = "", this.connection = "", this.maxResponseSize = client[kMaxResponseSize];
      }
      setTimeout(value, type) {
        this.timeoutType = type, value !== this.timeoutValue ? (timers.clearTimeout(this.timeout), value ? (this.timeout = timers.setTimeout(onParserTimeout, value, this), this.timeout.unref && this.timeout.unref()) : this.timeout = null, this.timeoutValue = value) : this.timeout && this.timeout.refresh && this.timeout.refresh();
      }
      resume() {
        this.socket.destroyed || !this.paused || (assert3(this.ptr != null), assert3(currentParser == null), this.llhttp.llhttp_resume(this.ptr), assert3(this.timeoutType === TIMEOUT_BODY), this.timeout && this.timeout.refresh && this.timeout.refresh(), this.paused = !1, this.execute(this.socket.read() || EMPTY_BUF), this.readMore());
      }
      readMore() {
        for (; !this.paused && this.ptr; ) {
          let chunk = this.socket.read();
          if (chunk === null)
            break;
          this.execute(chunk);
        }
      }
      execute(data) {
        assert3(this.ptr != null), assert3(currentParser == null), assert3(!this.paused);
        let { socket, llhttp } = this;
        data.length > currentBufferSize && (currentBufferPtr && llhttp.free(currentBufferPtr), currentBufferSize = Math.ceil(data.length / 4096) * 4096, currentBufferPtr = llhttp.malloc(currentBufferSize)), new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
        try {
          let ret;
          try {
            currentBufferRef = data, currentParser = this, ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
          } catch (err) {
            throw err;
          } finally {
            currentParser = null, currentBufferRef = null;
          }
          let offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
          if (ret === constants2.ERROR.PAUSED_UPGRADE)
            this.onUpgrade(data.slice(offset));
          else if (ret === constants2.ERROR.PAUSED)
            this.paused = !0, socket.unshift(data.slice(offset));
          else if (ret !== constants2.ERROR.OK) {
            let ptr = llhttp.llhttp_get_error_reason(this.ptr), message = "";
            if (ptr) {
              let len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
              message = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ")";
            }
            throw new HTTPParserError(message, constants2.ERROR[ret], data.slice(offset));
          }
        } catch (err) {
          util.destroy(socket, err);
        }
      }
      destroy() {
        assert3(this.ptr != null), assert3(currentParser == null), this.llhttp.llhttp_free(this.ptr), this.ptr = null, timers.clearTimeout(this.timeout), this.timeout = null, this.timeoutValue = null, this.timeoutType = null, this.paused = !1;
      }
      onStatus(buf) {
        this.statusText = buf.toString();
      }
      onMessageBegin() {
        let { socket, client } = this;
        if (socket.destroyed || !client[kQueue][client[kRunningIdx]])
          return -1;
      }
      onHeaderField(buf) {
        let len = this.headers.length;
        len & 1 ? this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]) : this.headers.push(buf), this.trackHeader(buf.length);
      }
      onHeaderValue(buf) {
        let len = this.headers.length;
        (len & 1) === 1 ? (this.headers.push(buf), len += 1) : this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        let key = this.headers[len - 2];
        key.length === 10 && key.toString().toLowerCase() === "keep-alive" ? this.keepAlive += buf.toString() : key.length === 10 && key.toString().toLowerCase() === "connection" ? this.connection += buf.toString() : key.length === 14 && key.toString().toLowerCase() === "content-length" && (this.contentLength += buf.toString()), this.trackHeader(buf.length);
      }
      trackHeader(len) {
        this.headersSize += len, this.headersSize >= this.headersMaxSize && util.destroy(this.socket, new HeadersOverflowError());
      }
      onUpgrade(head) {
        let { upgrade, client, socket, headers, statusCode } = this;
        assert3(upgrade);
        let request = client[kQueue][client[kRunningIdx]];
        assert3(request), assert3(!socket.destroyed), assert3(socket === client[kSocket]), assert3(!this.paused), assert3(request.upgrade || request.method === "CONNECT"), this.statusCode = null, this.statusText = "", this.shouldKeepAlive = null, assert3(this.headers.length % 2 === 0), this.headers = [], this.headersSize = 0, socket.unshift(head), socket[kParser].destroy(), socket[kParser] = null, socket[kClient] = null, socket[kError] = null, socket.removeListener("error", onSocketError).removeListener("readable", onSocketReadable).removeListener("end", onSocketEnd).removeListener("close", onSocketClose), client[kSocket] = null, client[kQueue][client[kRunningIdx]++] = null, client.emit("disconnect", client[kUrl], [client], new InformationalError("upgrade"));
        try {
          request.onUpgrade(statusCode, headers, socket);
        } catch (err) {
          util.destroy(socket, err);
        }
        resume(client);
      }
      onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
        let { client, socket, headers, statusText } = this;
        if (socket.destroyed)
          return -1;
        let request = client[kQueue][client[kRunningIdx]];
        if (!request)
          return -1;
        if (assert3(!this.upgrade), assert3(this.statusCode < 200), statusCode === 100)
          return util.destroy(socket, new SocketError("bad response", util.getSocketInfo(socket))), -1;
        if (upgrade && !request.upgrade)
          return util.destroy(socket, new SocketError("bad upgrade", util.getSocketInfo(socket))), -1;
        if (assert3.strictEqual(this.timeoutType, TIMEOUT_HEADERS), this.statusCode = statusCode, this.shouldKeepAlive = shouldKeepAlive || // Override llhttp value which does not allow keepAlive for HEAD.
        request.method === "HEAD" && !socket[kReset] && this.connection.toLowerCase() === "keep-alive", this.statusCode >= 200) {
          let bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];
          this.setTimeout(bodyTimeout, TIMEOUT_BODY);
        } else this.timeout && this.timeout.refresh && this.timeout.refresh();
        if (request.method === "CONNECT")
          return assert3(client[kRunning] === 1), this.upgrade = !0, 2;
        if (upgrade)
          return assert3(client[kRunning] === 1), this.upgrade = !0, 2;
        if (assert3(this.headers.length % 2 === 0), this.headers = [], this.headersSize = 0, this.shouldKeepAlive && client[kPipelining]) {
          let keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;
          if (keepAliveTimeout != null) {
            let timeout = Math.min(
              keepAliveTimeout - client[kKeepAliveTimeoutThreshold],
              client[kKeepAliveMaxTimeout]
            );
            timeout <= 0 ? socket[kReset] = !0 : client[kKeepAliveTimeoutValue] = timeout;
          } else
            client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
        } else
          socket[kReset] = !0;
        let pause = request.onHeaders(statusCode, headers, this.resume, statusText) === !1;
        return request.aborted ? -1 : request.method === "HEAD" || statusCode < 200 ? 1 : (socket[kBlocking] && (socket[kBlocking] = !1, resume(client)), pause ? constants2.ERROR.PAUSED : 0);
      }
      onBody(buf) {
        let { client, socket, statusCode, maxResponseSize } = this;
        if (socket.destroyed)
          return -1;
        let request = client[kQueue][client[kRunningIdx]];
        if (assert3(request), assert3.strictEqual(this.timeoutType, TIMEOUT_BODY), this.timeout && this.timeout.refresh && this.timeout.refresh(), assert3(statusCode >= 200), maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize)
          return util.destroy(socket, new ResponseExceededMaxSizeError()), -1;
        if (this.bytesRead += buf.length, request.onData(buf) === !1)
          return constants2.ERROR.PAUSED;
      }
      onMessageComplete() {
        let { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;
        if (socket.destroyed && (!statusCode || shouldKeepAlive))
          return -1;
        if (upgrade)
          return;
        let request = client[kQueue][client[kRunningIdx]];
        if (assert3(request), assert3(statusCode >= 100), this.statusCode = null, this.statusText = "", this.bytesRead = 0, this.contentLength = "", this.keepAlive = "", this.connection = "", assert3(this.headers.length % 2 === 0), this.headers = [], this.headersSize = 0, !(statusCode < 200)) {
          if (request.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10))
            return util.destroy(socket, new ResponseContentLengthMismatchError()), -1;
          if (request.onComplete(headers), client[kQueue][client[kRunningIdx]++] = null, socket[kWriting])
            return assert3.strictEqual(client[kRunning], 0), util.destroy(socket, new InformationalError("reset")), constants2.ERROR.PAUSED;
          if (shouldKeepAlive) {
            if (socket[kReset] && client[kRunning] === 0)
              return util.destroy(socket, new InformationalError("reset")), constants2.ERROR.PAUSED;
            client[kPipelining] === 1 ? setImmediate(resume, client) : resume(client);
          } else return util.destroy(socket, new InformationalError("reset")), constants2.ERROR.PAUSED;
        }
      }
    };
    function onParserTimeout(parser) {
      let { socket, timeoutType, client } = parser;
      timeoutType === TIMEOUT_HEADERS ? (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) && (assert3(!parser.paused, "cannot be paused while waiting for headers"), util.destroy(socket, new HeadersTimeoutError())) : timeoutType === TIMEOUT_BODY ? parser.paused || util.destroy(socket, new BodyTimeoutError()) : timeoutType === TIMEOUT_IDLE && (assert3(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]), util.destroy(socket, new InformationalError("socket idle timeout")));
    }
    function onSocketReadable() {
      let { [kParser]: parser } = this;
      parser && parser.readMore();
    }
    function onSocketError(err) {
      let { [kClient]: client, [kParser]: parser } = this;
      if (assert3(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID"), client[kHTTPConnVersion] !== "h2" && err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
        parser.onMessageComplete();
        return;
      }
      this[kError] = err, onError(this[kClient], err);
    }
    function onError(client, err) {
      if (client[kRunning] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
        assert3(client[kPendingIdx] === client[kRunningIdx]);
        let requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          let request = requests[i];
          errorRequest(client, request, err);
        }
        assert3(client[kSize] === 0);
      }
    }
    function onSocketEnd() {
      let { [kParser]: parser, [kClient]: client } = this;
      if (client[kHTTPConnVersion] !== "h2" && parser.statusCode && !parser.shouldKeepAlive) {
        parser.onMessageComplete();
        return;
      }
      util.destroy(this, new SocketError("other side closed", util.getSocketInfo(this)));
    }
    function onSocketClose() {
      let { [kClient]: client, [kParser]: parser } = this;
      client[kHTTPConnVersion] === "h1" && parser && (!this[kError] && parser.statusCode && !parser.shouldKeepAlive && parser.onMessageComplete(), this[kParser].destroy(), this[kParser] = null);
      let err = this[kError] || new SocketError("closed", util.getSocketInfo(this));
      if (client[kSocket] = null, client.destroyed) {
        assert3(client[kPending] === 0);
        let requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          let request = requests[i];
          errorRequest(client, request, err);
        }
      } else if (client[kRunning] > 0 && err.code !== "UND_ERR_INFO") {
        let request = client[kQueue][client[kRunningIdx]];
        client[kQueue][client[kRunningIdx]++] = null, errorRequest(client, request, err);
      }
      client[kPendingIdx] = client[kRunningIdx], assert3(client[kRunning] === 0), client.emit("disconnect", client[kUrl], [client], err), resume(client);
    }
    async function connect(client) {
      assert3(!client[kConnecting]), assert3(!client[kSocket]);
      let { host, hostname, protocol, port } = client[kUrl];
      if (hostname[0] === "[") {
        let idx = hostname.indexOf("]");
        assert3(idx !== -1);
        let ip = hostname.substring(1, idx);
        assert3(net.isIP(ip)), hostname = ip;
      }
      client[kConnecting] = !0, channels.beforeConnect.hasSubscribers && channels.beforeConnect.publish({
        connectParams: {
          host,
          hostname,
          protocol,
          port,
          servername: client[kServerName],
          localAddress: client[kLocalAddress]
        },
        connector: client[kConnector]
      });
      try {
        let socket = await new Promise((resolve2, reject) => {
          client[kConnector]({
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          }, (err, socket2) => {
            err ? reject(err) : resolve2(socket2);
          });
        });
        if (client.destroyed) {
          util.destroy(socket.on("error", () => {
          }), new ClientDestroyedError());
          return;
        }
        if (client[kConnecting] = !1, assert3(socket), socket.alpnProtocol === "h2") {
          h2ExperimentalWarned || (h2ExperimentalWarned = !0, process.emitWarning("H2 support is experimental, expect them to change at any time.", {
            code: "UNDICI-H2"
          }));
          let session = http2.connect(client[kUrl], {
            createConnection: () => socket,
            peerMaxConcurrentStreams: client[kHTTP2SessionState].maxConcurrentStreams
          });
          client[kHTTPConnVersion] = "h2", session[kClient] = client, session[kSocket] = socket, session.on("error", onHttp2SessionError), session.on("frameError", onHttp2FrameError), session.on("end", onHttp2SessionEnd), session.on("goaway", onHTTP2GoAway), session.on("close", onSocketClose), session.unref(), client[kHTTP2Session] = session, socket[kHTTP2Session] = session;
        } else
          llhttpInstance || (llhttpInstance = await llhttpPromise, llhttpPromise = null), socket[kNoRef] = !1, socket[kWriting] = !1, socket[kReset] = !1, socket[kBlocking] = !1, socket[kParser] = new Parser2(client, socket, llhttpInstance);
        socket[kCounter] = 0, socket[kMaxRequests] = client[kMaxRequests], socket[kClient] = client, socket[kError] = null, socket.on("error", onSocketError).on("readable", onSocketReadable).on("end", onSocketEnd).on("close", onSocketClose), client[kSocket] = socket, channels.connected.hasSubscribers && channels.connected.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          },
          connector: client[kConnector],
          socket
        }), client.emit("connect", client[kUrl], [client]);
      } catch (err) {
        if (client.destroyed)
          return;
        if (client[kConnecting] = !1, channels.connectError.hasSubscribers && channels.connectError.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          },
          connector: client[kConnector],
          error: err
        }), err.code === "ERR_TLS_CERT_ALTNAME_INVALID")
          for (assert3(client[kRunning] === 0); client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]; ) {
            let request = client[kQueue][client[kPendingIdx]++];
            errorRequest(client, request, err);
          }
        else
          onError(client, err);
        client.emit("connectionError", client[kUrl], [client], err);
      }
      resume(client);
    }
    function emitDrain(client) {
      client[kNeedDrain] = 0, client.emit("drain", client[kUrl], [client]);
    }
    function resume(client, sync) {
      client[kResuming] !== 2 && (client[kResuming] = 2, _resume(client, sync), client[kResuming] = 0, client[kRunningIdx] > 256 && (client[kQueue].splice(0, client[kRunningIdx]), client[kPendingIdx] -= client[kRunningIdx], client[kRunningIdx] = 0));
    }
    function _resume(client, sync) {
      for (; ; ) {
        if (client.destroyed) {
          assert3(client[kPending] === 0);
          return;
        }
        if (client[kClosedResolve] && !client[kSize]) {
          client[kClosedResolve](), client[kClosedResolve] = null;
          return;
        }
        let socket = client[kSocket];
        if (socket && !socket.destroyed && socket.alpnProtocol !== "h2") {
          if (client[kSize] === 0 ? !socket[kNoRef] && socket.unref && (socket.unref(), socket[kNoRef] = !0) : socket[kNoRef] && socket.ref && (socket.ref(), socket[kNoRef] = !1), client[kSize] === 0)
            socket[kParser].timeoutType !== TIMEOUT_IDLE && socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);
          else if (client[kRunning] > 0 && socket[kParser].statusCode < 200 && socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
            let request2 = client[kQueue][client[kRunningIdx]], headersTimeout = request2.headersTimeout != null ? request2.headersTimeout : client[kHeadersTimeout];
            socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
          }
        }
        if (client[kBusy])
          client[kNeedDrain] = 2;
        else if (client[kNeedDrain] === 2) {
          sync ? (client[kNeedDrain] = 1, process.nextTick(emitDrain, client)) : emitDrain(client);
          continue;
        }
        if (client[kPending] === 0 || client[kRunning] >= (client[kPipelining] || 1))
          return;
        let request = client[kQueue][client[kPendingIdx]];
        if (client[kUrl].protocol === "https:" && client[kServerName] !== request.servername) {
          if (client[kRunning] > 0)
            return;
          if (client[kServerName] = request.servername, socket && socket.servername !== request.servername) {
            util.destroy(socket, new InformationalError("servername changed"));
            return;
          }
        }
        if (client[kConnecting])
          return;
        if (!socket && !client[kHTTP2Session]) {
          connect(client);
          return;
        }
        if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking] || client[kRunning] > 0 && !request.idempotent || client[kRunning] > 0 && (request.upgrade || request.method === "CONNECT") || client[kRunning] > 0 && util.bodyLength(request.body) !== 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body)))
          return;
        !request.aborted && write(client, request) ? client[kPendingIdx]++ : client[kQueue].splice(client[kPendingIdx], 1);
      }
    }
    function shouldSendContentLength(method) {
      return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
    }
    function write(client, request) {
      if (client[kHTTPConnVersion] === "h2") {
        writeH2(client, client[kHTTP2Session], request);
        return;
      }
      let { body, method, path: path8, host, upgrade, headers, blocking, reset } = request, expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
      body && typeof body.read == "function" && body.read(0);
      let bodyLength = util.bodyLength(body), contentLength = bodyLength;
      if (contentLength === null && (contentLength = request.contentLength), contentLength === 0 && !expectsPayload && (contentLength = null), shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {
        if (client[kStrictContentLength])
          return errorRequest(client, request, new RequestContentLengthMismatchError()), !1;
        process.emitWarning(new RequestContentLengthMismatchError());
      }
      let socket = client[kSocket];
      try {
        request.onConnect((err) => {
          request.aborted || request.completed || (errorRequest(client, request, err || new RequestAbortedError()), util.destroy(socket, new InformationalError("aborted")));
        });
      } catch (err) {
        errorRequest(client, request, err);
      }
      if (request.aborted)
        return !1;
      method === "HEAD" && (socket[kReset] = !0), (upgrade || method === "CONNECT") && (socket[kReset] = !0), reset != null && (socket[kReset] = reset), client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests] && (socket[kReset] = !0), blocking && (socket[kBlocking] = !0);
      let header = `${method} ${path8} HTTP/1.1\r
`;
      return typeof host == "string" ? header += `host: ${host}\r
` : header += client[kHostHeader], upgrade ? header += `connection: upgrade\r
upgrade: ${upgrade}\r
` : client[kPipelining] && !socket[kReset] ? header += `connection: keep-alive\r
` : header += `connection: close\r
`, headers && (header += headers), channels.sendHeaders.hasSubscribers && channels.sendHeaders.publish({ request, headers: header, socket }), !body || bodyLength === 0 ? (contentLength === 0 ? socket.write(`${header}content-length: 0\r
\r
`, "latin1") : (assert3(contentLength === null, "no body must not have content length"), socket.write(`${header}\r
`, "latin1")), request.onRequestSent()) : util.isBuffer(body) ? (assert3(contentLength === body.byteLength, "buffer body must have content length"), socket.cork(), socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1"), socket.write(body), socket.uncork(), request.onBodySent(body), request.onRequestSent(), expectsPayload || (socket[kReset] = !0)) : util.isBlobLike(body) ? typeof body.stream == "function" ? writeIterable({ body: body.stream(), client, request, socket, contentLength, header, expectsPayload }) : writeBlob({ body, client, request, socket, contentLength, header, expectsPayload }) : util.isStream(body) ? writeStream({ body, client, request, socket, contentLength, header, expectsPayload }) : util.isIterable(body) ? writeIterable({ body, client, request, socket, contentLength, header, expectsPayload }) : assert3(!1), !0;
    }
    function writeH2(client, session, request) {
      let { body, method, path: path8, host, upgrade, expectContinue, signal, headers: reqHeaders } = request, headers;
      if (typeof reqHeaders == "string" ? headers = Request[kHTTP2CopyHeaders](reqHeaders.trim()) : headers = reqHeaders, upgrade)
        return errorRequest(client, request, new Error("Upgrade not supported for H2")), !1;
      try {
        request.onConnect((err) => {
          request.aborted || request.completed || errorRequest(client, request, err || new RequestAbortedError());
        });
      } catch (err) {
        errorRequest(client, request, err);
      }
      if (request.aborted)
        return !1;
      let stream, h2State = client[kHTTP2SessionState];
      if (headers[HTTP2_HEADER_AUTHORITY] = host || client[kHost], headers[HTTP2_HEADER_METHOD] = method, method === "CONNECT")
        return session.ref(), stream = session.request(headers, { endStream: !1, signal }), stream.id && !stream.pending ? (request.onUpgrade(null, null, stream), ++h2State.openStreams) : stream.once("ready", () => {
          request.onUpgrade(null, null, stream), ++h2State.openStreams;
        }), stream.once("close", () => {
          h2State.openStreams -= 1, h2State.openStreams === 0 && session.unref();
        }), !0;
      headers[HTTP2_HEADER_PATH] = path8, headers[HTTP2_HEADER_SCHEME] = "https";
      let expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
      body && typeof body.read == "function" && body.read(0);
      let contentLength = util.bodyLength(body);
      if (contentLength == null && (contentLength = request.contentLength), (contentLength === 0 || !expectsPayload) && (contentLength = null), shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {
        if (client[kStrictContentLength])
          return errorRequest(client, request, new RequestContentLengthMismatchError()), !1;
        process.emitWarning(new RequestContentLengthMismatchError());
      }
      contentLength != null && (assert3(body, "no body must not have content length"), headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`), session.ref();
      let shouldEndStream = method === "GET" || method === "HEAD";
      return expectContinue ? (headers[HTTP2_HEADER_EXPECT] = "100-continue", stream = session.request(headers, { endStream: shouldEndStream, signal }), stream.once("continue", writeBodyH2)) : (stream = session.request(headers, {
        endStream: shouldEndStream,
        signal
      }), writeBodyH2()), ++h2State.openStreams, stream.once("response", (headers2) => {
        let { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers2;
        request.onHeaders(Number(statusCode), realHeaders, stream.resume.bind(stream), "") === !1 && stream.pause();
      }), stream.once("end", () => {
        request.onComplete([]);
      }), stream.on("data", (chunk) => {
        request.onData(chunk) === !1 && stream.pause();
      }), stream.once("close", () => {
        h2State.openStreams -= 1, h2State.openStreams === 0 && session.unref();
      }), stream.once("error", function(err) {
        client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed && (h2State.streams -= 1, util.destroy(stream, err));
      }), stream.once("frameError", (type, code2) => {
        let err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code2}`);
        errorRequest(client, request, err), client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed && (h2State.streams -= 1, util.destroy(stream, err));
      }), !0;
      function writeBodyH2() {
        body ? util.isBuffer(body) ? (assert3(contentLength === body.byteLength, "buffer body must have content length"), stream.cork(), stream.write(body), stream.uncork(), stream.end(), request.onBodySent(body), request.onRequestSent()) : util.isBlobLike(body) ? typeof body.stream == "function" ? writeIterable({
          client,
          request,
          contentLength,
          h2stream: stream,
          expectsPayload,
          body: body.stream(),
          socket: client[kSocket],
          header: ""
        }) : writeBlob({
          body,
          client,
          request,
          contentLength,
          expectsPayload,
          h2stream: stream,
          header: "",
          socket: client[kSocket]
        }) : util.isStream(body) ? writeStream({
          body,
          client,
          request,
          contentLength,
          expectsPayload,
          socket: client[kSocket],
          h2stream: stream,
          header: ""
        }) : util.isIterable(body) ? writeIterable({
          body,
          client,
          request,
          contentLength,
          expectsPayload,
          header: "",
          h2stream: stream,
          socket: client[kSocket]
        }) : assert3(!1) : request.onRequestSent();
      }
    }
    function writeStream({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
      if (assert3(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined"), client[kHTTPConnVersion] === "h2") {
        let onPipeData = function(chunk) {
          request.onBodySent(chunk);
        }, pipe = pipeline(
          body,
          h2stream,
          (err) => {
            err ? (util.destroy(body, err), util.destroy(h2stream, err)) : request.onRequestSent();
          }
        );
        pipe.on("data", onPipeData), pipe.once("end", () => {
          pipe.removeListener("data", onPipeData), util.destroy(pipe);
        });
        return;
      }
      let finished = !1, writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header }), onData = function(chunk) {
        if (!finished)
          try {
            !writer.write(chunk) && this.pause && this.pause();
          } catch (err) {
            util.destroy(this, err);
          }
      }, onDrain = function() {
        finished || body.resume && body.resume();
      }, onAbort = function() {
        if (finished)
          return;
        let err = new RequestAbortedError();
        queueMicrotask(() => onFinished(err));
      }, onFinished = function(err) {
        if (!finished) {
          if (finished = !0, assert3(socket.destroyed || socket[kWriting] && client[kRunning] <= 1), socket.off("drain", onDrain).off("error", onFinished), body.removeListener("data", onData).removeListener("end", onFinished).removeListener("error", onFinished).removeListener("close", onAbort), !err)
            try {
              writer.end();
            } catch (er) {
              err = er;
            }
          writer.destroy(err), err && (err.code !== "UND_ERR_INFO" || err.message !== "reset") ? util.destroy(body, err) : util.destroy(body);
        }
      };
      body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onAbort), body.resume && body.resume(), socket.on("drain", onDrain).on("error", onFinished);
    }
    async function writeBlob({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
      assert3(contentLength === body.size, "blob body must have content length");
      let isH2 = client[kHTTPConnVersion] === "h2";
      try {
        if (contentLength != null && contentLength !== body.size)
          throw new RequestContentLengthMismatchError();
        let buffer = Buffer.from(await body.arrayBuffer());
        isH2 ? (h2stream.cork(), h2stream.write(buffer), h2stream.uncork()) : (socket.cork(), socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1"), socket.write(buffer), socket.uncork()), request.onBodySent(buffer), request.onRequestSent(), expectsPayload || (socket[kReset] = !0), resume(client);
      } catch (err) {
        util.destroy(isH2 ? h2stream : socket, err);
      }
    }
    async function writeIterable({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
      assert3(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
      let callback = null;
      function onDrain() {
        if (callback) {
          let cb = callback;
          callback = null, cb();
        }
      }
      let waitForDrain = () => new Promise((resolve2, reject) => {
        assert3(callback === null), socket[kError] ? reject(socket[kError]) : callback = resolve2;
      });
      if (client[kHTTPConnVersion] === "h2") {
        h2stream.on("close", onDrain).on("drain", onDrain);
        try {
          for await (let chunk of body) {
            if (socket[kError])
              throw socket[kError];
            let res = h2stream.write(chunk);
            request.onBodySent(chunk), res || await waitForDrain();
          }
        } catch (err) {
          h2stream.destroy(err);
        } finally {
          request.onRequestSent(), h2stream.end(), h2stream.off("close", onDrain).off("drain", onDrain);
        }
        return;
      }
      socket.on("close", onDrain).on("drain", onDrain);
      let writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
      try {
        for await (let chunk of body) {
          if (socket[kError])
            throw socket[kError];
          writer.write(chunk) || await waitForDrain();
        }
        writer.end();
      } catch (err) {
        writer.destroy(err);
      } finally {
        socket.off("close", onDrain).off("drain", onDrain);
      }
    }
    var AsyncWriter = class {
      constructor({ socket, request, contentLength, client, expectsPayload, header }) {
        this.socket = socket, this.request = request, this.contentLength = contentLength, this.client = client, this.bytesWritten = 0, this.expectsPayload = expectsPayload, this.header = header, socket[kWriting] = !0;
      }
      write(chunk) {
        let { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this;
        if (socket[kError])
          throw socket[kError];
        if (socket.destroyed)
          return !1;
        let len = Buffer.byteLength(chunk);
        if (!len)
          return !0;
        if (contentLength !== null && bytesWritten + len > contentLength) {
          if (client[kStrictContentLength])
            throw new RequestContentLengthMismatchError();
          process.emitWarning(new RequestContentLengthMismatchError());
        }
        socket.cork(), bytesWritten === 0 && (expectsPayload || (socket[kReset] = !0), contentLength === null ? socket.write(`${header}transfer-encoding: chunked\r
`, "latin1") : socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1")), contentLength === null && socket.write(`\r
${len.toString(16)}\r
`, "latin1"), this.bytesWritten += len;
        let ret = socket.write(chunk);
        return socket.uncork(), request.onBodySent(chunk), ret || socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS && socket[kParser].timeout.refresh && socket[kParser].timeout.refresh(), ret;
      }
      end() {
        let { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this;
        if (request.onRequestSent(), socket[kWriting] = !1, socket[kError])
          throw socket[kError];
        if (!socket.destroyed) {
          if (bytesWritten === 0 ? expectsPayload ? socket.write(`${header}content-length: 0\r
\r
`, "latin1") : socket.write(`${header}\r
`, "latin1") : contentLength === null && socket.write(`\r
0\r
\r
`, "latin1"), contentLength !== null && bytesWritten !== contentLength) {
            if (client[kStrictContentLength])
              throw new RequestContentLengthMismatchError();
            process.emitWarning(new RequestContentLengthMismatchError());
          }
          socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS && socket[kParser].timeout.refresh && socket[kParser].timeout.refresh(), resume(client);
        }
      }
      destroy(err) {
        let { socket, client } = this;
        socket[kWriting] = !1, err && (assert3(client[kRunning] <= 1, "pipeline should only contain this request"), util.destroy(socket, err));
      }
    };
    function errorRequest(client, request, err) {
      try {
        request.onError(err), assert3(request.aborted);
      } catch (err2) {
        client.emit("error", err2);
      }
    }
    module2.exports = Client;
  }
});

// node_modules/undici/lib/node/fixed-queue.js
var require_fixed_queue = __commonJS({
  "node_modules/undici/lib/node/fixed-queue.js"(exports2, module2) {
    "use strict";
    var FixedCircularBuffer = class {
      constructor() {
        this.bottom = 0, this.top = 0, this.list = new Array(2048), this.next = null;
      }
      isEmpty() {
        return this.top === this.bottom;
      }
      isFull() {
        return (this.top + 1 & 2047) === this.bottom;
      }
      push(data) {
        this.list[this.top] = data, this.top = this.top + 1 & 2047;
      }
      shift() {
        let nextItem = this.list[this.bottom];
        return nextItem === void 0 ? null : (this.list[this.bottom] = void 0, this.bottom = this.bottom + 1 & 2047, nextItem);
      }
    };
    module2.exports = class {
      constructor() {
        this.head = this.tail = new FixedCircularBuffer();
      }
      isEmpty() {
        return this.head.isEmpty();
      }
      push(data) {
        this.head.isFull() && (this.head = this.head.next = new FixedCircularBuffer()), this.head.push(data);
      }
      shift() {
        let tail = this.tail, next = tail.shift();
        return tail.isEmpty() && tail.next !== null && (this.tail = tail.next), next;
      }
    };
  }
});

// node_modules/undici/lib/pool-stats.js
var require_pool_stats = __commonJS({
  "node_modules/undici/lib/pool-stats.js"(exports2, module2) {
    var { kFree, kConnected, kPending, kQueued, kRunning, kSize } = require_symbols(), kPool = Symbol("pool"), PoolStats = class {
      constructor(pool) {
        this[kPool] = pool;
      }
      get connected() {
        return this[kPool][kConnected];
      }
      get free() {
        return this[kPool][kFree];
      }
      get pending() {
        return this[kPool][kPending];
      }
      get queued() {
        return this[kPool][kQueued];
      }
      get running() {
        return this[kPool][kRunning];
      }
      get size() {
        return this[kPool][kSize];
      }
    };
    module2.exports = PoolStats;
  }
});

// node_modules/undici/lib/pool-base.js
var require_pool_base = __commonJS({
  "node_modules/undici/lib/pool-base.js"(exports2, module2) {
    "use strict";
    var DispatcherBase = require_dispatcher_base(), FixedQueue = require_fixed_queue(), { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = require_symbols(), PoolStats = require_pool_stats(), kClients = Symbol("clients"), kNeedDrain = Symbol("needDrain"), kQueue = Symbol("queue"), kClosedResolve = Symbol("closed resolve"), kOnDrain = Symbol("onDrain"), kOnConnect = Symbol("onConnect"), kOnDisconnect = Symbol("onDisconnect"), kOnConnectionError = Symbol("onConnectionError"), kGetDispatcher = Symbol("get dispatcher"), kAddClient = Symbol("add client"), kRemoveClient = Symbol("remove client"), kStats = Symbol("stats"), PoolBase = class extends DispatcherBase {
      constructor() {
        super(), this[kQueue] = new FixedQueue(), this[kClients] = [], this[kQueued] = 0;
        let pool = this;
        this[kOnDrain] = function(origin, targets) {
          let queue = pool[kQueue], needDrain = !1;
          for (; !needDrain; ) {
            let item = queue.shift();
            if (!item)
              break;
            pool[kQueued]--, needDrain = !this.dispatch(item.opts, item.handler);
          }
          this[kNeedDrain] = needDrain, !this[kNeedDrain] && pool[kNeedDrain] && (pool[kNeedDrain] = !1, pool.emit("drain", origin, [pool, ...targets])), pool[kClosedResolve] && queue.isEmpty() && Promise.all(pool[kClients].map((c) => c.close())).then(pool[kClosedResolve]);
        }, this[kOnConnect] = (origin, targets) => {
          pool.emit("connect", origin, [pool, ...targets]);
        }, this[kOnDisconnect] = (origin, targets, err) => {
          pool.emit("disconnect", origin, [pool, ...targets], err);
        }, this[kOnConnectionError] = (origin, targets, err) => {
          pool.emit("connectionError", origin, [pool, ...targets], err);
        }, this[kStats] = new PoolStats(this);
      }
      get [kBusy]() {
        return this[kNeedDrain];
      }
      get [kConnected]() {
        return this[kClients].filter((client) => client[kConnected]).length;
      }
      get [kFree]() {
        return this[kClients].filter((client) => client[kConnected] && !client[kNeedDrain]).length;
      }
      get [kPending]() {
        let ret = this[kQueued];
        for (let { [kPending]: pending } of this[kClients])
          ret += pending;
        return ret;
      }
      get [kRunning]() {
        let ret = 0;
        for (let { [kRunning]: running } of this[kClients])
          ret += running;
        return ret;
      }
      get [kSize]() {
        let ret = this[kQueued];
        for (let { [kSize]: size } of this[kClients])
          ret += size;
        return ret;
      }
      get stats() {
        return this[kStats];
      }
      async [kClose]() {
        return this[kQueue].isEmpty() ? Promise.all(this[kClients].map((c) => c.close())) : new Promise((resolve2) => {
          this[kClosedResolve] = resolve2;
        });
      }
      async [kDestroy](err) {
        for (; ; ) {
          let item = this[kQueue].shift();
          if (!item)
            break;
          item.handler.onError(err);
        }
        return Promise.all(this[kClients].map((c) => c.destroy(err)));
      }
      [kDispatch](opts, handler) {
        let dispatcher = this[kGetDispatcher]();
        return dispatcher ? dispatcher.dispatch(opts, handler) || (dispatcher[kNeedDrain] = !0, this[kNeedDrain] = !this[kGetDispatcher]()) : (this[kNeedDrain] = !0, this[kQueue].push({ opts, handler }), this[kQueued]++), !this[kNeedDrain];
      }
      [kAddClient](client) {
        return client.on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]), this[kClients].push(client), this[kNeedDrain] && process.nextTick(() => {
          this[kNeedDrain] && this[kOnDrain](client[kUrl], [this, client]);
        }), this;
      }
      [kRemoveClient](client) {
        client.close(() => {
          let idx = this[kClients].indexOf(client);
          idx !== -1 && this[kClients].splice(idx, 1);
        }), this[kNeedDrain] = this[kClients].some((dispatcher) => !dispatcher[kNeedDrain] && dispatcher.closed !== !0 && dispatcher.destroyed !== !0);
      }
    };
    module2.exports = {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kRemoveClient,
      kGetDispatcher
    };
  }
});

// node_modules/undici/lib/pool.js
var require_pool = __commonJS({
  "node_modules/undici/lib/pool.js"(exports2, module2) {
    "use strict";
    var {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kGetDispatcher
    } = require_pool_base(), Client = require_client(), {
      InvalidArgumentError
    } = require_errors(), util = require_util(), { kUrl, kInterceptors } = require_symbols(), buildConnector = require_connect(), kOptions = Symbol("options"), kConnections = Symbol("connections"), kFactory = Symbol("factory");
    function defaultFactory(origin, opts) {
      return new Client(origin, opts);
    }
    var Pool = class extends PoolBase {
      constructor(origin, {
        connections,
        factory = defaultFactory,
        connect,
        connectTimeout,
        tls,
        maxCachedSessions,
        socketPath,
        autoSelectFamily,
        autoSelectFamilyAttemptTimeout,
        allowH2,
        ...options
      } = {}) {
        if (super(), connections != null && (!Number.isFinite(connections) || connections < 0))
          throw new InvalidArgumentError("invalid connections");
        if (typeof factory != "function")
          throw new InvalidArgumentError("factory must be a function.");
        if (connect != null && typeof connect != "function" && typeof connect != "object")
          throw new InvalidArgumentError("connect must be a function or an object");
        typeof connect != "function" && (connect = buildConnector({
          ...tls,
          maxCachedSessions,
          allowH2,
          socketPath,
          timeout: connectTimeout,
          ...util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
          ...connect
        })), this[kInterceptors] = options.interceptors && options.interceptors.Pool && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [], this[kConnections] = connections || null, this[kUrl] = util.parseOrigin(origin), this[kOptions] = { ...util.deepClone(options), connect, allowH2 }, this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0, this[kFactory] = factory;
      }
      [kGetDispatcher]() {
        let dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain]);
        return dispatcher || ((!this[kConnections] || this[kClients].length < this[kConnections]) && (dispatcher = this[kFactory](this[kUrl], this[kOptions]), this[kAddClient](dispatcher)), dispatcher);
      }
    };
    module2.exports = Pool;
  }
});

// node_modules/undici/lib/balanced-pool.js
var require_balanced_pool = __commonJS({
  "node_modules/undici/lib/balanced-pool.js"(exports2, module2) {
    "use strict";
    var {
      BalancedPoolMissingUpstreamError,
      InvalidArgumentError
    } = require_errors(), {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kRemoveClient,
      kGetDispatcher
    } = require_pool_base(), Pool = require_pool(), { kUrl, kInterceptors } = require_symbols(), { parseOrigin } = require_util(), kFactory = Symbol("factory"), kOptions = Symbol("options"), kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor"), kCurrentWeight = Symbol("kCurrentWeight"), kIndex = Symbol("kIndex"), kWeight = Symbol("kWeight"), kMaxWeightPerServer = Symbol("kMaxWeightPerServer"), kErrorPenalty = Symbol("kErrorPenalty");
    function getGreatestCommonDivisor(a, b) {
      return b === 0 ? a : getGreatestCommonDivisor(b, a % b);
    }
    function defaultFactory(origin, opts) {
      return new Pool(origin, opts);
    }
    var BalancedPool = class extends PoolBase {
      constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}) {
        if (super(), this[kOptions] = opts, this[kIndex] = -1, this[kCurrentWeight] = 0, this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100, this[kErrorPenalty] = this[kOptions].errorPenalty || 15, Array.isArray(upstreams) || (upstreams = [upstreams]), typeof factory != "function")
          throw new InvalidArgumentError("factory must be a function.");
        this[kInterceptors] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [], this[kFactory] = factory;
        for (let upstream of upstreams)
          this.addUpstream(upstream);
        this._updateBalancedPoolStats();
      }
      addUpstream(upstream) {
        let upstreamOrigin = parseOrigin(upstream).origin;
        if (this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== !0 && pool2.destroyed !== !0))
          return this;
        let pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));
        this[kAddClient](pool), pool.on("connect", () => {
          pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
        }), pool.on("connectionError", () => {
          pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]), this._updateBalancedPoolStats();
        }), pool.on("disconnect", (...args) => {
          let err = args[2];
          err && err.code === "UND_ERR_SOCKET" && (pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]), this._updateBalancedPoolStats());
        });
        for (let client of this[kClients])
          client[kWeight] = this[kMaxWeightPerServer];
        return this._updateBalancedPoolStats(), this;
      }
      _updateBalancedPoolStats() {
        this[kGreatestCommonDivisor] = this[kClients].map((p) => p[kWeight]).reduce(getGreatestCommonDivisor, 0);
      }
      removeUpstream(upstream) {
        let upstreamOrigin = parseOrigin(upstream).origin, pool = this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== !0 && pool2.destroyed !== !0);
        return pool && this[kRemoveClient](pool), this;
      }
      get upstreams() {
        return this[kClients].filter((dispatcher) => dispatcher.closed !== !0 && dispatcher.destroyed !== !0).map((p) => p[kUrl].origin);
      }
      [kGetDispatcher]() {
        if (this[kClients].length === 0)
          throw new BalancedPoolMissingUpstreamError();
        if (!this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain] && dispatcher2.closed !== !0 && dispatcher2.destroyed !== !0) || this[kClients].map((pool) => pool[kNeedDrain]).reduce((a, b) => a && b, !0))
          return;
        let counter = 0, maxWeightIndex = this[kClients].findIndex((pool) => !pool[kNeedDrain]);
        for (; counter++ < this[kClients].length; ) {
          this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
          let pool = this[kClients][this[kIndex]];
          if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain] && (maxWeightIndex = this[kIndex]), this[kIndex] === 0 && (this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor], this[kCurrentWeight] <= 0 && (this[kCurrentWeight] = this[kMaxWeightPerServer])), pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain])
            return pool;
        }
        return this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight], this[kIndex] = maxWeightIndex, this[kClients][maxWeightIndex];
      }
    };
    module2.exports = BalancedPool;
  }
});

// node_modules/undici/lib/compat/dispatcher-weakref.js
var require_dispatcher_weakref = __commonJS({
  "node_modules/undici/lib/compat/dispatcher-weakref.js"(exports2, module2) {
    "use strict";
    var { kConnected, kSize } = require_symbols(), CompatWeakRef = class {
      constructor(value) {
        this.value = value;
      }
      deref() {
        return this.value[kConnected] === 0 && this.value[kSize] === 0 ? void 0 : this.value;
      }
    }, CompatFinalizer = class {
      constructor(finalizer) {
        this.finalizer = finalizer;
      }
      register(dispatcher, key) {
        dispatcher.on && dispatcher.on("disconnect", () => {
          dispatcher[kConnected] === 0 && dispatcher[kSize] === 0 && this.finalizer(key);
        });
      }
    };
    module2.exports = function() {
      return process.env.NODE_V8_COVERAGE ? {
        WeakRef: CompatWeakRef,
        FinalizationRegistry: CompatFinalizer
      } : {
        WeakRef: global.WeakRef || CompatWeakRef,
        FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer
      };
    };
  }
});

// node_modules/undici/lib/agent.js
var require_agent = __commonJS({
  "node_modules/undici/lib/agent.js"(exports2, module2) {
    "use strict";
    var { InvalidArgumentError } = require_errors(), { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = require_symbols(), DispatcherBase = require_dispatcher_base(), Pool = require_pool(), Client = require_client(), util = require_util(), createRedirectInterceptor = require_redirectInterceptor(), { WeakRef: WeakRef2, FinalizationRegistry } = require_dispatcher_weakref()(), kOnConnect = Symbol("onConnect"), kOnDisconnect = Symbol("onDisconnect"), kOnConnectionError = Symbol("onConnectionError"), kMaxRedirections = Symbol("maxRedirections"), kOnDrain = Symbol("onDrain"), kFactory = Symbol("factory"), kFinalizer = Symbol("finalizer"), kOptions = Symbol("options");
    function defaultFactory(origin, opts) {
      return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);
    }
    var Agent = class extends DispatcherBase {
      constructor({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {
        if (super(), typeof factory != "function")
          throw new InvalidArgumentError("factory must be a function.");
        if (connect != null && typeof connect != "function" && typeof connect != "object")
          throw new InvalidArgumentError("connect must be a function or an object");
        if (!Number.isInteger(maxRedirections) || maxRedirections < 0)
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        connect && typeof connect != "function" && (connect = { ...connect }), this[kInterceptors] = options.interceptors && options.interceptors.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [createRedirectInterceptor({ maxRedirections })], this[kOptions] = { ...util.deepClone(options), connect }, this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0, this[kMaxRedirections] = maxRedirections, this[kFactory] = factory, this[kClients] = /* @__PURE__ */ new Map(), this[kFinalizer] = new FinalizationRegistry(
          /* istanbul ignore next: gc is undeterministic */
          (key) => {
            let ref = this[kClients].get(key);
            ref !== void 0 && ref.deref() === void 0 && this[kClients].delete(key);
          }
        );
        let agent = this;
        this[kOnDrain] = (origin, targets) => {
          agent.emit("drain", origin, [agent, ...targets]);
        }, this[kOnConnect] = (origin, targets) => {
          agent.emit("connect", origin, [agent, ...targets]);
        }, this[kOnDisconnect] = (origin, targets, err) => {
          agent.emit("disconnect", origin, [agent, ...targets], err);
        }, this[kOnConnectionError] = (origin, targets, err) => {
          agent.emit("connectionError", origin, [agent, ...targets], err);
        };
      }
      get [kRunning]() {
        let ret = 0;
        for (let ref of this[kClients].values()) {
          let client = ref.deref();
          client && (ret += client[kRunning]);
        }
        return ret;
      }
      [kDispatch](opts, handler) {
        let key;
        if (opts.origin && (typeof opts.origin == "string" || opts.origin instanceof URL))
          key = String(opts.origin);
        else
          throw new InvalidArgumentError("opts.origin must be a non-empty string or URL.");
        let ref = this[kClients].get(key), dispatcher = ref ? ref.deref() : null;
        return dispatcher || (dispatcher = this[kFactory](opts.origin, this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]), this[kClients].set(key, new WeakRef2(dispatcher)), this[kFinalizer].register(dispatcher, key)), dispatcher.dispatch(opts, handler);
      }
      async [kClose]() {
        let closePromises = [];
        for (let ref of this[kClients].values()) {
          let client = ref.deref();
          client && closePromises.push(client.close());
        }
        await Promise.all(closePromises);
      }
      async [kDestroy](err) {
        let destroyPromises = [];
        for (let ref of this[kClients].values()) {
          let client = ref.deref();
          client && destroyPromises.push(client.destroy(err));
        }
        await Promise.all(destroyPromises);
      }
    };
    module2.exports = Agent;
  }
});

// node_modules/undici/lib/api/readable.js
var require_readable = __commonJS({
  "node_modules/undici/lib/api/readable.js"(exports2, module2) {
    "use strict";
    var assert3 = require("assert"), { Readable } = require("stream"), { RequestAbortedError, NotSupportedError, InvalidArgumentError } = require_errors(), util = require_util(), { ReadableStreamFrom, toUSVString } = require_util(), Blob2, kConsume = Symbol("kConsume"), kReading = Symbol("kReading"), kBody = Symbol("kBody"), kAbort = Symbol("abort"), kContentType = Symbol("kContentType"), noop2 = () => {
    };
    module2.exports = class extends Readable {
      constructor({
        resume,
        abort,
        contentType = "",
        highWaterMark = 64 * 1024
        // Same as nodejs fs streams.
      }) {
        super({
          autoDestroy: !0,
          read: resume,
          highWaterMark
        }), this._readableState.dataEmitted = !1, this[kAbort] = abort, this[kConsume] = null, this[kBody] = null, this[kContentType] = contentType, this[kReading] = !1;
      }
      destroy(err) {
        return this.destroyed ? this : (!err && !this._readableState.endEmitted && (err = new RequestAbortedError()), err && this[kAbort](), super.destroy(err));
      }
      emit(ev, ...args) {
        return ev === "data" ? this._readableState.dataEmitted = !0 : ev === "error" && (this._readableState.errorEmitted = !0), super.emit(ev, ...args);
      }
      on(ev, ...args) {
        return (ev === "data" || ev === "readable") && (this[kReading] = !0), super.on(ev, ...args);
      }
      addListener(ev, ...args) {
        return this.on(ev, ...args);
      }
      off(ev, ...args) {
        let ret = super.off(ev, ...args);
        return (ev === "data" || ev === "readable") && (this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0), ret;
      }
      removeListener(ev, ...args) {
        return this.off(ev, ...args);
      }
      push(chunk) {
        return this[kConsume] && chunk !== null && this.readableLength === 0 ? (consumePush(this[kConsume], chunk), this[kReading] ? super.push(chunk) : !0) : super.push(chunk);
      }
      // https://fetch.spec.whatwg.org/#dom-body-text
      async text() {
        return consume(this, "text");
      }
      // https://fetch.spec.whatwg.org/#dom-body-json
      async json() {
        return consume(this, "json");
      }
      // https://fetch.spec.whatwg.org/#dom-body-blob
      async blob() {
        return consume(this, "blob");
      }
      // https://fetch.spec.whatwg.org/#dom-body-arraybuffer
      async arrayBuffer() {
        return consume(this, "arrayBuffer");
      }
      // https://fetch.spec.whatwg.org/#dom-body-formdata
      async formData() {
        throw new NotSupportedError();
      }
      // https://fetch.spec.whatwg.org/#dom-body-bodyused
      get bodyUsed() {
        return util.isDisturbed(this);
      }
      // https://fetch.spec.whatwg.org/#dom-body-body
      get body() {
        return this[kBody] || (this[kBody] = ReadableStreamFrom(this), this[kConsume] && (this[kBody].getReader(), assert3(this[kBody].locked))), this[kBody];
      }
      dump(opts) {
        let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144, signal = opts && opts.signal;
        if (signal)
          try {
            if (typeof signal != "object" || !("aborted" in signal))
              throw new InvalidArgumentError("signal must be an AbortSignal");
            util.throwIfAborted(signal);
          } catch (err) {
            return Promise.reject(err);
          }
        return this.closed ? Promise.resolve(null) : new Promise((resolve2, reject) => {
          let signalListenerCleanup = signal ? util.addAbortListener(signal, () => {
            this.destroy();
          }) : noop2;
          this.on("close", function() {
            signalListenerCleanup(), signal && signal.aborted ? reject(signal.reason || Object.assign(new Error("The operation was aborted"), { name: "AbortError" })) : resolve2(null);
          }).on("error", noop2).on("data", function(chunk) {
            limit -= chunk.length, limit <= 0 && this.destroy();
          }).resume();
        });
      }
    };
    function isLocked(self2) {
      return self2[kBody] && self2[kBody].locked === !0 || self2[kConsume];
    }
    function isUnusable(self2) {
      return util.isDisturbed(self2) || isLocked(self2);
    }
    async function consume(stream, type) {
      if (isUnusable(stream))
        throw new TypeError("unusable");
      return assert3(!stream[kConsume]), new Promise((resolve2, reject) => {
        stream[kConsume] = {
          type,
          stream,
          resolve: resolve2,
          reject,
          length: 0,
          body: []
        }, stream.on("error", function(err) {
          consumeFinish(this[kConsume], err);
        }).on("close", function() {
          this[kConsume].body !== null && consumeFinish(this[kConsume], new RequestAbortedError());
        }), process.nextTick(consumeStart, stream[kConsume]);
      });
    }
    function consumeStart(consume2) {
      if (consume2.body === null)
        return;
      let { _readableState: state } = consume2.stream;
      for (let chunk of state.buffer)
        consumePush(consume2, chunk);
      for (state.endEmitted ? consumeEnd(this[kConsume]) : consume2.stream.on("end", function() {
        consumeEnd(this[kConsume]);
      }), consume2.stream.resume(); consume2.stream.read() != null; )
        ;
    }
    function consumeEnd(consume2) {
      let { type, body, resolve: resolve2, stream, length } = consume2;
      try {
        if (type === "text")
          resolve2(toUSVString(Buffer.concat(body)));
        else if (type === "json")
          resolve2(JSON.parse(Buffer.concat(body)));
        else if (type === "arrayBuffer") {
          let dst = new Uint8Array(length), pos2 = 0;
          for (let buf of body)
            dst.set(buf, pos2), pos2 += buf.byteLength;
          resolve2(dst.buffer);
        } else type === "blob" && (Blob2 || (Blob2 = require("buffer").Blob), resolve2(new Blob2(body, { type: stream[kContentType] })));
        consumeFinish(consume2);
      } catch (err) {
        stream.destroy(err);
      }
    }
    function consumePush(consume2, chunk) {
      consume2.length += chunk.length, consume2.body.push(chunk);
    }
    function consumeFinish(consume2, err) {
      consume2.body !== null && (err ? consume2.reject(err) : consume2.resolve(), consume2.type = null, consume2.stream = null, consume2.resolve = null, consume2.reject = null, consume2.length = 0, consume2.body = null);
    }
  }
});

// node_modules/undici/lib/api/util.js
var require_util3 = __commonJS({
  "node_modules/undici/lib/api/util.js"(exports2, module2) {
    var assert3 = require("assert"), {
      ResponseStatusCodeError
    } = require_errors(), { toUSVString } = require_util();
    async function getResolveErrorBodyCallback({ callback, body, contentType, statusCode, statusMessage, headers }) {
      assert3(body);
      let chunks = [], limit = 0;
      for await (let chunk of body)
        if (chunks.push(chunk), limit += chunk.length, limit > 128 * 1024) {
          chunks = null;
          break;
        }
      if (statusCode === 204 || !contentType || !chunks) {
        process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
        return;
      }
      try {
        if (contentType.startsWith("application/json")) {
          let payload = JSON.parse(toUSVString(Buffer.concat(chunks)));
          process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
          return;
        }
        if (contentType.startsWith("text/")) {
          let payload = toUSVString(Buffer.concat(chunks));
          process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
          return;
        }
      } catch {
      }
      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
    }
    module2.exports = { getResolveErrorBodyCallback };
  }
});

// node_modules/undici/lib/api/abort-signal.js
var require_abort_signal = __commonJS({
  "node_modules/undici/lib/api/abort-signal.js"(exports2, module2) {
    var { addAbortListener } = require_util(), { RequestAbortedError } = require_errors(), kListener = Symbol("kListener"), kSignal = Symbol("kSignal");
    function abort(self2) {
      self2.abort ? self2.abort() : self2.onError(new RequestAbortedError());
    }
    function addSignal(self2, signal) {
      if (self2[kSignal] = null, self2[kListener] = null, !!signal) {
        if (signal.aborted) {
          abort(self2);
          return;
        }
        self2[kSignal] = signal, self2[kListener] = () => {
          abort(self2);
        }, addAbortListener(self2[kSignal], self2[kListener]);
      }
    }
    function removeSignal(self2) {
      self2[kSignal] && ("removeEventListener" in self2[kSignal] ? self2[kSignal].removeEventListener("abort", self2[kListener]) : self2[kSignal].removeListener("abort", self2[kListener]), self2[kSignal] = null, self2[kListener] = null);
    }
    module2.exports = {
      addSignal,
      removeSignal
    };
  }
});

// node_modules/undici/lib/api/api-request.js
var require_api_request = __commonJS({
  "node_modules/undici/lib/api/api-request.js"(exports2, module2) {
    "use strict";
    var Readable = require_readable(), {
      InvalidArgumentError,
      RequestAbortedError
    } = require_errors(), util = require_util(), { getResolveErrorBodyCallback } = require_util3(), { AsyncResource } = require("async_hooks"), { addSignal, removeSignal } = require_abort_signal(), RequestHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts != "object")
          throw new InvalidArgumentError("invalid opts");
        let { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;
        try {
          if (typeof callback != "function")
            throw new InvalidArgumentError("invalid callback");
          if (highWaterMark && (typeof highWaterMark != "number" || highWaterMark < 0))
            throw new InvalidArgumentError("invalid highWaterMark");
          if (signal && typeof signal.on != "function" && typeof signal.addEventListener != "function")
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          if (method === "CONNECT")
            throw new InvalidArgumentError("invalid method");
          if (onInfo && typeof onInfo != "function")
            throw new InvalidArgumentError("invalid onInfo callback");
          super("UNDICI_REQUEST");
        } catch (err) {
          throw util.isStream(body) && util.destroy(body.on("error", util.nop), err), err;
        }
        this.responseHeaders = responseHeaders || null, this.opaque = opaque || null, this.callback = callback, this.res = null, this.abort = null, this.body = body, this.trailers = {}, this.context = null, this.onInfo = onInfo || null, this.throwOnError = throwOnError, this.highWaterMark = highWaterMark, util.isStream(body) && body.on("error", (err) => {
          this.onError(err);
        }), addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback)
          throw new RequestAbortedError();
        this.abort = abort, this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        let { callback, opaque, abort, context, responseHeaders, highWaterMark } = this, headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        if (statusCode < 200) {
          this.onInfo && this.onInfo({ statusCode, headers });
          return;
        }
        let contentType = (responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers)["content-type"], body = new Readable({ resume, abort, contentType, highWaterMark });
        this.callback = null, this.res = body, callback !== null && (this.throwOnError && statusCode >= 400 ? this.runInAsyncScope(
          getResolveErrorBodyCallback,
          null,
          { callback, body, contentType, statusCode, statusMessage, headers }
        ) : this.runInAsyncScope(callback, null, null, {
          statusCode,
          headers,
          trailers: this.trailers,
          opaque,
          body,
          context
        }));
      }
      onData(chunk) {
        let { res } = this;
        return res.push(chunk);
      }
      onComplete(trailers) {
        let { res } = this;
        removeSignal(this), util.parseHeaders(trailers, this.trailers), res.push(null);
      }
      onError(err) {
        let { res, callback, body, opaque } = this;
        removeSignal(this), callback && (this.callback = null, queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        })), res && (this.res = null, queueMicrotask(() => {
          util.destroy(res, err);
        })), body && (this.body = null, util.destroy(body, err));
      }
    };
    function request(opts, callback) {
      if (callback === void 0)
        return new Promise((resolve2, reject) => {
          request.call(this, opts, (err, data) => err ? reject(err) : resolve2(data));
        });
      try {
        this.dispatch(opts, new RequestHandler(opts, callback));
      } catch (err) {
        if (typeof callback != "function")
          throw err;
        let opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = request;
    module2.exports.RequestHandler = RequestHandler;
  }
});

// node_modules/undici/lib/api/api-stream.js
var require_api_stream = __commonJS({
  "node_modules/undici/lib/api/api-stream.js"(exports2, module2) {
    "use strict";
    var { finished, PassThrough } = require("stream"), {
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError
    } = require_errors(), util = require_util(), { getResolveErrorBodyCallback } = require_util3(), { AsyncResource } = require("async_hooks"), { addSignal, removeSignal } = require_abort_signal(), StreamHandler = class extends AsyncResource {
      constructor(opts, factory, callback) {
        if (!opts || typeof opts != "object")
          throw new InvalidArgumentError("invalid opts");
        let { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;
        try {
          if (typeof callback != "function")
            throw new InvalidArgumentError("invalid callback");
          if (typeof factory != "function")
            throw new InvalidArgumentError("invalid factory");
          if (signal && typeof signal.on != "function" && typeof signal.addEventListener != "function")
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          if (method === "CONNECT")
            throw new InvalidArgumentError("invalid method");
          if (onInfo && typeof onInfo != "function")
            throw new InvalidArgumentError("invalid onInfo callback");
          super("UNDICI_STREAM");
        } catch (err) {
          throw util.isStream(body) && util.destroy(body.on("error", util.nop), err), err;
        }
        this.responseHeaders = responseHeaders || null, this.opaque = opaque || null, this.factory = factory, this.callback = callback, this.res = null, this.abort = null, this.context = null, this.trailers = null, this.body = body, this.onInfo = onInfo || null, this.throwOnError = throwOnError || !1, util.isStream(body) && body.on("error", (err) => {
          this.onError(err);
        }), addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback)
          throw new RequestAbortedError();
        this.abort = abort, this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        let { factory, opaque, context, callback, responseHeaders } = this, headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        if (statusCode < 200) {
          this.onInfo && this.onInfo({ statusCode, headers });
          return;
        }
        this.factory = null;
        let res;
        if (this.throwOnError && statusCode >= 400) {
          let contentType = (responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers)["content-type"];
          res = new PassThrough(), this.callback = null, this.runInAsyncScope(
            getResolveErrorBodyCallback,
            null,
            { callback, body: res, contentType, statusCode, statusMessage, headers }
          );
        } else {
          if (factory === null)
            return;
          if (res = this.runInAsyncScope(factory, null, {
            statusCode,
            headers,
            opaque,
            context
          }), !res || typeof res.write != "function" || typeof res.end != "function" || typeof res.on != "function")
            throw new InvalidReturnValueError("expected Writable");
          finished(res, { readable: !1 }, (err) => {
            let { callback: callback2, res: res2, opaque: opaque2, trailers, abort } = this;
            this.res = null, (err || !res2.readable) && util.destroy(res2, err), this.callback = null, this.runInAsyncScope(callback2, null, err || null, { opaque: opaque2, trailers }), err && abort();
          });
        }
        return res.on("drain", resume), this.res = res, (res.writableNeedDrain !== void 0 ? res.writableNeedDrain : res._writableState && res._writableState.needDrain) !== !0;
      }
      onData(chunk) {
        let { res } = this;
        return res ? res.write(chunk) : !0;
      }
      onComplete(trailers) {
        let { res } = this;
        removeSignal(this), res && (this.trailers = util.parseHeaders(trailers), res.end());
      }
      onError(err) {
        let { res, callback, opaque, body } = this;
        removeSignal(this), this.factory = null, res ? (this.res = null, util.destroy(res, err)) : callback && (this.callback = null, queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        })), body && (this.body = null, util.destroy(body, err));
      }
    };
    function stream(opts, factory, callback) {
      if (callback === void 0)
        return new Promise((resolve2, reject) => {
          stream.call(this, opts, factory, (err, data) => err ? reject(err) : resolve2(data));
        });
      try {
        this.dispatch(opts, new StreamHandler(opts, factory, callback));
      } catch (err) {
        if (typeof callback != "function")
          throw err;
        let opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = stream;
  }
});

// node_modules/undici/lib/api/api-pipeline.js
var require_api_pipeline = __commonJS({
  "node_modules/undici/lib/api/api-pipeline.js"(exports2, module2) {
    "use strict";
    var {
      Readable,
      Duplex,
      PassThrough
    } = require("stream"), {
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError
    } = require_errors(), util = require_util(), { AsyncResource } = require("async_hooks"), { addSignal, removeSignal } = require_abort_signal(), assert3 = require("assert"), kResume = Symbol("resume"), PipelineRequest = class extends Readable {
      constructor() {
        super({ autoDestroy: !0 }), this[kResume] = null;
      }
      _read() {
        let { [kResume]: resume } = this;
        resume && (this[kResume] = null, resume());
      }
      _destroy(err, callback) {
        this._read(), callback(err);
      }
    }, PipelineResponse = class extends Readable {
      constructor(resume) {
        super({ autoDestroy: !0 }), this[kResume] = resume;
      }
      _read() {
        this[kResume]();
      }
      _destroy(err, callback) {
        !err && !this._readableState.endEmitted && (err = new RequestAbortedError()), callback(err);
      }
    }, PipelineHandler = class extends AsyncResource {
      constructor(opts, handler) {
        if (!opts || typeof opts != "object")
          throw new InvalidArgumentError("invalid opts");
        if (typeof handler != "function")
          throw new InvalidArgumentError("invalid handler");
        let { signal, method, opaque, onInfo, responseHeaders } = opts;
        if (signal && typeof signal.on != "function" && typeof signal.addEventListener != "function")
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        if (method === "CONNECT")
          throw new InvalidArgumentError("invalid method");
        if (onInfo && typeof onInfo != "function")
          throw new InvalidArgumentError("invalid onInfo callback");
        super("UNDICI_PIPELINE"), this.opaque = opaque || null, this.responseHeaders = responseHeaders || null, this.handler = handler, this.abort = null, this.context = null, this.onInfo = onInfo || null, this.req = new PipelineRequest().on("error", util.nop), this.ret = new Duplex({
          readableObjectMode: opts.objectMode,
          autoDestroy: !0,
          read: () => {
            let { body } = this;
            body && body.resume && body.resume();
          },
          write: (chunk, encoding, callback) => {
            let { req } = this;
            req.push(chunk, encoding) || req._readableState.destroyed ? callback() : req[kResume] = callback;
          },
          destroy: (err, callback) => {
            let { body, req, res, ret, abort } = this;
            !err && !ret._readableState.endEmitted && (err = new RequestAbortedError()), abort && err && abort(), util.destroy(body, err), util.destroy(req, err), util.destroy(res, err), removeSignal(this), callback(err);
          }
        }).on("prefinish", () => {
          let { req } = this;
          req.push(null);
        }), this.res = null, addSignal(this, signal);
      }
      onConnect(abort, context) {
        let { ret, res } = this;
        if (assert3(!res, "pipeline cannot be retried"), ret.destroyed)
          throw new RequestAbortedError();
        this.abort = abort, this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume) {
        let { opaque, handler, context } = this;
        if (statusCode < 200) {
          if (this.onInfo) {
            let headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        this.res = new PipelineResponse(resume);
        let body;
        try {
          this.handler = null;
          let headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
          body = this.runInAsyncScope(handler, null, {
            statusCode,
            headers,
            opaque,
            body: this.res,
            context
          });
        } catch (err) {
          throw this.res.on("error", util.nop), err;
        }
        if (!body || typeof body.on != "function")
          throw new InvalidReturnValueError("expected Readable");
        body.on("data", (chunk) => {
          let { ret, body: body2 } = this;
          !ret.push(chunk) && body2.pause && body2.pause();
        }).on("error", (err) => {
          let { ret } = this;
          util.destroy(ret, err);
        }).on("end", () => {
          let { ret } = this;
          ret.push(null);
        }).on("close", () => {
          let { ret } = this;
          ret._readableState.ended || util.destroy(ret, new RequestAbortedError());
        }), this.body = body;
      }
      onData(chunk) {
        let { res } = this;
        return res.push(chunk);
      }
      onComplete(trailers) {
        let { res } = this;
        res.push(null);
      }
      onError(err) {
        let { ret } = this;
        this.handler = null, util.destroy(ret, err);
      }
    };
    function pipeline(opts, handler) {
      try {
        let pipelineHandler = new PipelineHandler(opts, handler);
        return this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler), pipelineHandler.ret;
      } catch (err) {
        return new PassThrough().destroy(err);
      }
    }
    module2.exports = pipeline;
  }
});

// node_modules/undici/lib/api/api-upgrade.js
var require_api_upgrade = __commonJS({
  "node_modules/undici/lib/api/api-upgrade.js"(exports2, module2) {
    "use strict";
    var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors(), { AsyncResource } = require("async_hooks"), util = require_util(), { addSignal, removeSignal } = require_abort_signal(), assert3 = require("assert"), UpgradeHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts != "object")
          throw new InvalidArgumentError("invalid opts");
        if (typeof callback != "function")
          throw new InvalidArgumentError("invalid callback");
        let { signal, opaque, responseHeaders } = opts;
        if (signal && typeof signal.on != "function" && typeof signal.addEventListener != "function")
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        super("UNDICI_UPGRADE"), this.responseHeaders = responseHeaders || null, this.opaque = opaque || null, this.callback = callback, this.abort = null, this.context = null, addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback)
          throw new RequestAbortedError();
        this.abort = abort, this.context = null;
      }
      onHeaders() {
        throw new SocketError("bad upgrade", null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        let { callback, opaque, context } = this;
        assert3.strictEqual(statusCode, 101), removeSignal(this), this.callback = null;
        let headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        this.runInAsyncScope(callback, null, null, {
          headers,
          socket,
          opaque,
          context
        });
      }
      onError(err) {
        let { callback, opaque } = this;
        removeSignal(this), callback && (this.callback = null, queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        }));
      }
    };
    function upgrade(opts, callback) {
      if (callback === void 0)
        return new Promise((resolve2, reject) => {
          upgrade.call(this, opts, (err, data) => err ? reject(err) : resolve2(data));
        });
      try {
        let upgradeHandler = new UpgradeHandler(opts, callback);
        this.dispatch({
          ...opts,
          method: opts.method || "GET",
          upgrade: opts.protocol || "Websocket"
        }, upgradeHandler);
      } catch (err) {
        if (typeof callback != "function")
          throw err;
        let opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = upgrade;
  }
});

// node_modules/undici/lib/api/api-connect.js
var require_api_connect = __commonJS({
  "node_modules/undici/lib/api/api-connect.js"(exports2, module2) {
    "use strict";
    var { AsyncResource } = require("async_hooks"), { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors(), util = require_util(), { addSignal, removeSignal } = require_abort_signal(), ConnectHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts != "object")
          throw new InvalidArgumentError("invalid opts");
        if (typeof callback != "function")
          throw new InvalidArgumentError("invalid callback");
        let { signal, opaque, responseHeaders } = opts;
        if (signal && typeof signal.on != "function" && typeof signal.addEventListener != "function")
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        super("UNDICI_CONNECT"), this.opaque = opaque || null, this.responseHeaders = responseHeaders || null, this.callback = callback, this.abort = null, addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback)
          throw new RequestAbortedError();
        this.abort = abort, this.context = context;
      }
      onHeaders() {
        throw new SocketError("bad connect", null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        let { callback, opaque, context } = this;
        removeSignal(this), this.callback = null;
        let headers = rawHeaders;
        headers != null && (headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)), this.runInAsyncScope(callback, null, null, {
          statusCode,
          headers,
          socket,
          opaque,
          context
        });
      }
      onError(err) {
        let { callback, opaque } = this;
        removeSignal(this), callback && (this.callback = null, queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        }));
      }
    };
    function connect(opts, callback) {
      if (callback === void 0)
        return new Promise((resolve2, reject) => {
          connect.call(this, opts, (err, data) => err ? reject(err) : resolve2(data));
        });
      try {
        let connectHandler = new ConnectHandler(opts, callback);
        this.dispatch({ ...opts, method: "CONNECT" }, connectHandler);
      } catch (err) {
        if (typeof callback != "function")
          throw err;
        let opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = connect;
  }
});

// node_modules/undici/lib/api/index.js
var require_api = __commonJS({
  "node_modules/undici/lib/api/index.js"(exports2, module2) {
    "use strict";
    module2.exports.request = require_api_request();
    module2.exports.stream = require_api_stream();
    module2.exports.pipeline = require_api_pipeline();
    module2.exports.upgrade = require_api_upgrade();
    module2.exports.connect = require_api_connect();
  }
});

// node_modules/undici/lib/mock/mock-errors.js
var require_mock_errors = __commonJS({
  "node_modules/undici/lib/mock/mock-errors.js"(exports2, module2) {
    "use strict";
    var { UndiciError } = require_errors(), MockNotMatchedError = class _MockNotMatchedError extends UndiciError {
      constructor(message) {
        super(message), Error.captureStackTrace(this, _MockNotMatchedError), this.name = "MockNotMatchedError", this.message = message || "The request does not match any registered mock dispatches", this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
      }
    };
    module2.exports = {
      MockNotMatchedError
    };
  }
});

// node_modules/undici/lib/mock/mock-symbols.js
var require_mock_symbols = __commonJS({
  "node_modules/undici/lib/mock/mock-symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kAgent: Symbol("agent"),
      kOptions: Symbol("options"),
      kFactory: Symbol("factory"),
      kDispatches: Symbol("dispatches"),
      kDispatchKey: Symbol("dispatch key"),
      kDefaultHeaders: Symbol("default headers"),
      kDefaultTrailers: Symbol("default trailers"),
      kContentLength: Symbol("content length"),
      kMockAgent: Symbol("mock agent"),
      kMockAgentSet: Symbol("mock agent set"),
      kMockAgentGet: Symbol("mock agent get"),
      kMockDispatch: Symbol("mock dispatch"),
      kClose: Symbol("close"),
      kOriginalClose: Symbol("original agent close"),
      kOrigin: Symbol("origin"),
      kIsMockActive: Symbol("is mock active"),
      kNetConnect: Symbol("net connect"),
      kGetNetConnect: Symbol("get net connect"),
      kConnected: Symbol("connected")
    };
  }
});

// node_modules/undici/lib/mock/mock-utils.js
var require_mock_utils = __commonJS({
  "node_modules/undici/lib/mock/mock-utils.js"(exports2, module2) {
    "use strict";
    var { MockNotMatchedError } = require_mock_errors(), {
      kDispatches,
      kMockAgent,
      kOriginalDispatch,
      kOrigin,
      kGetNetConnect
    } = require_mock_symbols(), { buildURL, nop } = require_util(), { STATUS_CODES } = require("http"), {
      types: {
        isPromise
      }
    } = require("util");
    function matchValue(match, value) {
      return typeof match == "string" ? match === value : match instanceof RegExp ? match.test(value) : typeof match == "function" ? match(value) === !0 : !1;
    }
    function lowerCaseEntries(headers) {
      return Object.fromEntries(
        Object.entries(headers).map(([headerName, headerValue]) => [headerName.toLocaleLowerCase(), headerValue])
      );
    }
    function getHeaderByName(headers, key) {
      if (Array.isArray(headers)) {
        for (let i = 0; i < headers.length; i += 2)
          if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase())
            return headers[i + 1];
        return;
      } else return typeof headers.get == "function" ? headers.get(key) : lowerCaseEntries(headers)[key.toLocaleLowerCase()];
    }
    function buildHeadersFromArray(headers) {
      let clone = headers.slice(), entries = [];
      for (let index = 0; index < clone.length; index += 2)
        entries.push([clone[index], clone[index + 1]]);
      return Object.fromEntries(entries);
    }
    function matchHeaders(mockDispatch2, headers) {
      if (typeof mockDispatch2.headers == "function")
        return Array.isArray(headers) && (headers = buildHeadersFromArray(headers)), mockDispatch2.headers(headers ? lowerCaseEntries(headers) : {});
      if (typeof mockDispatch2.headers > "u")
        return !0;
      if (typeof headers != "object" || typeof mockDispatch2.headers != "object")
        return !1;
      for (let [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch2.headers)) {
        let headerValue = getHeaderByName(headers, matchHeaderName);
        if (!matchValue(matchHeaderValue, headerValue))
          return !1;
      }
      return !0;
    }
    function safeUrl(path8) {
      if (typeof path8 != "string")
        return path8;
      let pathSegments = path8.split("?");
      if (pathSegments.length !== 2)
        return path8;
      let qp = new URLSearchParams(pathSegments.pop());
      return qp.sort(), [...pathSegments, qp.toString()].join("?");
    }
    function matchKey(mockDispatch2, { path: path8, method, body, headers }) {
      let pathMatch = matchValue(mockDispatch2.path, path8), methodMatch = matchValue(mockDispatch2.method, method), bodyMatch = typeof mockDispatch2.body < "u" ? matchValue(mockDispatch2.body, body) : !0, headersMatch = matchHeaders(mockDispatch2, headers);
      return pathMatch && methodMatch && bodyMatch && headersMatch;
    }
    function getResponseData(data) {
      return Buffer.isBuffer(data) ? data : typeof data == "object" ? JSON.stringify(data) : data.toString();
    }
    function getMockDispatch(mockDispatches, key) {
      let basePath = key.query ? buildURL(key.path, key.query) : key.path, resolvedPath = typeof basePath == "string" ? safeUrl(basePath) : basePath, matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path: path8 }) => matchValue(safeUrl(path8), resolvedPath));
      if (matchedMockDispatches.length === 0)
        throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
      if (matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method)), matchedMockDispatches.length === 0)
        throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);
      if (matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body < "u" ? matchValue(body, key.body) : !0), matchedMockDispatches.length === 0)
        throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);
      if (matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) => matchHeaders(mockDispatch2, key.headers)), matchedMockDispatches.length === 0)
        throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers == "object" ? JSON.stringify(key.headers) : key.headers}'`);
      return matchedMockDispatches[0];
    }
    function addMockDispatch(mockDispatches, key, data) {
      let baseData = { timesInvoked: 0, times: 1, persist: !1, consumed: !1 }, replyData = typeof data == "function" ? { callback: data } : { ...data }, newMockDispatch = { ...baseData, ...key, pending: !0, data: { error: null, ...replyData } };
      return mockDispatches.push(newMockDispatch), newMockDispatch;
    }
    function deleteMockDispatch(mockDispatches, key) {
      let index = mockDispatches.findIndex((dispatch) => dispatch.consumed ? matchKey(dispatch, key) : !1);
      index !== -1 && mockDispatches.splice(index, 1);
    }
    function buildKey(opts) {
      let { path: path8, method, body, headers, query } = opts;
      return {
        path: path8,
        method,
        body,
        headers,
        query
      };
    }
    function generateKeyValues(data) {
      return Object.entries(data).reduce((keyValuePairs, [key, value]) => [
        ...keyValuePairs,
        Buffer.from(`${key}`),
        Array.isArray(value) ? value.map((x) => Buffer.from(`${x}`)) : Buffer.from(`${value}`)
      ], []);
    }
    function getStatusText(statusCode) {
      return STATUS_CODES[statusCode] || "unknown";
    }
    async function getResponse(body) {
      let buffers = [];
      for await (let data of body)
        buffers.push(data);
      return Buffer.concat(buffers).toString("utf8");
    }
    function mockDispatch(opts, handler) {
      let key = buildKey(opts), mockDispatch2 = getMockDispatch(this[kDispatches], key);
      mockDispatch2.timesInvoked++, mockDispatch2.data.callback && (mockDispatch2.data = { ...mockDispatch2.data, ...mockDispatch2.data.callback(opts) });
      let { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch2, { timesInvoked, times } = mockDispatch2;
      if (mockDispatch2.consumed = !persist && timesInvoked >= times, mockDispatch2.pending = timesInvoked < times, error !== null)
        return deleteMockDispatch(this[kDispatches], key), handler.onError(error), !0;
      typeof delay == "number" && delay > 0 ? setTimeout(() => {
        handleReply(this[kDispatches]);
      }, delay) : handleReply(this[kDispatches]);
      function handleReply(mockDispatches, _data = data) {
        let optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers, body = typeof _data == "function" ? _data({ ...opts, headers: optsHeaders }) : _data;
        if (isPromise(body)) {
          body.then((newData) => handleReply(mockDispatches, newData));
          return;
        }
        let responseData = getResponseData(body), responseHeaders = generateKeyValues(headers), responseTrailers = generateKeyValues(trailers);
        handler.abort = nop, handler.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode)), handler.onData(Buffer.from(responseData)), handler.onComplete(responseTrailers), deleteMockDispatch(mockDispatches, key);
      }
      function resume() {
      }
      return !0;
    }
    function buildMockDispatch() {
      let agent = this[kMockAgent], origin = this[kOrigin], originalDispatch = this[kOriginalDispatch];
      return function(opts, handler) {
        if (agent.isMockActive)
          try {
            mockDispatch.call(this, opts, handler);
          } catch (error) {
            if (error instanceof MockNotMatchedError) {
              let netConnect = agent[kGetNetConnect]();
              if (netConnect === !1)
                throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
              if (checkNetConnect(netConnect, origin))
                originalDispatch.call(this, opts, handler);
              else
                throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
            } else
              throw error;
          }
        else
          originalDispatch.call(this, opts, handler);
      };
    }
    function checkNetConnect(netConnect, origin) {
      let url = new URL(origin);
      return netConnect === !0 ? !0 : !!(Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host)));
    }
    function buildMockOptions(opts) {
      if (opts) {
        let { agent, ...mockOptions } = opts;
        return mockOptions;
      }
    }
    module2.exports = {
      getResponseData,
      getMockDispatch,
      addMockDispatch,
      deleteMockDispatch,
      buildKey,
      generateKeyValues,
      matchValue,
      getResponse,
      getStatusText,
      mockDispatch,
      buildMockDispatch,
      checkNetConnect,
      buildMockOptions,
      getHeaderByName
    };
  }
});

// node_modules/undici/lib/mock/mock-interceptor.js
var require_mock_interceptor = __commonJS({
  "node_modules/undici/lib/mock/mock-interceptor.js"(exports2, module2) {
    "use strict";
    var { getResponseData, buildKey, addMockDispatch } = require_mock_utils(), {
      kDispatches,
      kDispatchKey,
      kDefaultHeaders,
      kDefaultTrailers,
      kContentLength,
      kMockDispatch
    } = require_mock_symbols(), { InvalidArgumentError } = require_errors(), { buildURL } = require_util(), MockScope = class {
      constructor(mockDispatch) {
        this[kMockDispatch] = mockDispatch;
      }
      /**
       * Delay a reply by a set amount in ms.
       */
      delay(waitInMs) {
        if (typeof waitInMs != "number" || !Number.isInteger(waitInMs) || waitInMs <= 0)
          throw new InvalidArgumentError("waitInMs must be a valid integer > 0");
        return this[kMockDispatch].delay = waitInMs, this;
      }
      /**
       * For a defined reply, never mark as consumed.
       */
      persist() {
        return this[kMockDispatch].persist = !0, this;
      }
      /**
       * Allow one to define a reply for a set amount of matching requests.
       */
      times(repeatTimes) {
        if (typeof repeatTimes != "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0)
          throw new InvalidArgumentError("repeatTimes must be a valid integer > 0");
        return this[kMockDispatch].times = repeatTimes, this;
      }
    }, MockInterceptor = class {
      constructor(opts, mockDispatches) {
        if (typeof opts != "object")
          throw new InvalidArgumentError("opts must be an object");
        if (typeof opts.path > "u")
          throw new InvalidArgumentError("opts.path must be defined");
        if (typeof opts.method > "u" && (opts.method = "GET"), typeof opts.path == "string")
          if (opts.query)
            opts.path = buildURL(opts.path, opts.query);
          else {
            let parsedURL = new URL(opts.path, "data://");
            opts.path = parsedURL.pathname + parsedURL.search;
          }
        typeof opts.method == "string" && (opts.method = opts.method.toUpperCase()), this[kDispatchKey] = buildKey(opts), this[kDispatches] = mockDispatches, this[kDefaultHeaders] = {}, this[kDefaultTrailers] = {}, this[kContentLength] = !1;
      }
      createMockScopeDispatchData(statusCode, data, responseOptions = {}) {
        let responseData = getResponseData(data), contentLength = this[kContentLength] ? { "content-length": responseData.length } : {}, headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers }, trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };
        return { statusCode, data, headers, trailers };
      }
      validateReplyParameters(statusCode, data, responseOptions) {
        if (typeof statusCode > "u")
          throw new InvalidArgumentError("statusCode must be defined");
        if (typeof data > "u")
          throw new InvalidArgumentError("data must be defined");
        if (typeof responseOptions != "object")
          throw new InvalidArgumentError("responseOptions must be an object");
      }
      /**
       * Mock an undici request with a defined reply.
       */
      reply(replyData) {
        if (typeof replyData == "function") {
          let wrappedDefaultsCallback = (opts) => {
            let resolvedData = replyData(opts);
            if (typeof resolvedData != "object")
              throw new InvalidArgumentError("reply options callback must return an object");
            let { statusCode: statusCode2, data: data2 = "", responseOptions: responseOptions2 = {} } = resolvedData;
            return this.validateReplyParameters(statusCode2, data2, responseOptions2), {
              ...this.createMockScopeDispatchData(statusCode2, data2, responseOptions2)
            };
          }, newMockDispatch2 = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);
          return new MockScope(newMockDispatch2);
        }
        let [statusCode, data = "", responseOptions = {}] = [...arguments];
        this.validateReplyParameters(statusCode, data, responseOptions);
        let dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions), newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);
        return new MockScope(newMockDispatch);
      }
      /**
       * Mock an undici request with a defined error.
       */
      replyWithError(error) {
        if (typeof error > "u")
          throw new InvalidArgumentError("error must be defined");
        let newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error });
        return new MockScope(newMockDispatch);
      }
      /**
       * Set default reply headers on the interceptor for subsequent replies
       */
      defaultReplyHeaders(headers) {
        if (typeof headers > "u")
          throw new InvalidArgumentError("headers must be defined");
        return this[kDefaultHeaders] = headers, this;
      }
      /**
       * Set default reply trailers on the interceptor for subsequent replies
       */
      defaultReplyTrailers(trailers) {
        if (typeof trailers > "u")
          throw new InvalidArgumentError("trailers must be defined");
        return this[kDefaultTrailers] = trailers, this;
      }
      /**
       * Set reply content length header for replies on the interceptor
       */
      replyContentLength() {
        return this[kContentLength] = !0, this;
      }
    };
    module2.exports.MockInterceptor = MockInterceptor;
    module2.exports.MockScope = MockScope;
  }
});

// node_modules/undici/lib/mock/mock-client.js
var require_mock_client = __commonJS({
  "node_modules/undici/lib/mock/mock-client.js"(exports2, module2) {
    "use strict";
    var { promisify } = require("util"), Client = require_client(), { buildMockDispatch } = require_mock_utils(), {
      kDispatches,
      kMockAgent,
      kClose,
      kOriginalClose,
      kOrigin,
      kOriginalDispatch,
      kConnected
    } = require_mock_symbols(), { MockInterceptor } = require_mock_interceptor(), Symbols = require_symbols(), { InvalidArgumentError } = require_errors(), MockClient = class extends Client {
      constructor(origin, opts) {
        if (super(origin, opts), !opts || !opts.agent || typeof opts.agent.dispatch != "function")
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        this[kMockAgent] = opts.agent, this[kOrigin] = origin, this[kDispatches] = [], this[kConnected] = 1, this[kOriginalDispatch] = this.dispatch, this[kOriginalClose] = this.close.bind(this), this.dispatch = buildMockDispatch.call(this), this.close = this[kClose];
      }
      get [Symbols.kConnected]() {
        return this[kConnected];
      }
      /**
       * Sets up the base interceptor for mocking replies from undici.
       */
      intercept(opts) {
        return new MockInterceptor(opts, this[kDispatches]);
      }
      async [kClose]() {
        await promisify(this[kOriginalClose])(), this[kConnected] = 0, this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    };
    module2.exports = MockClient;
  }
});

// node_modules/undici/lib/mock/mock-pool.js
var require_mock_pool = __commonJS({
  "node_modules/undici/lib/mock/mock-pool.js"(exports2, module2) {
    "use strict";
    var { promisify } = require("util"), Pool = require_pool(), { buildMockDispatch } = require_mock_utils(), {
      kDispatches,
      kMockAgent,
      kClose,
      kOriginalClose,
      kOrigin,
      kOriginalDispatch,
      kConnected
    } = require_mock_symbols(), { MockInterceptor } = require_mock_interceptor(), Symbols = require_symbols(), { InvalidArgumentError } = require_errors(), MockPool = class extends Pool {
      constructor(origin, opts) {
        if (super(origin, opts), !opts || !opts.agent || typeof opts.agent.dispatch != "function")
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        this[kMockAgent] = opts.agent, this[kOrigin] = origin, this[kDispatches] = [], this[kConnected] = 1, this[kOriginalDispatch] = this.dispatch, this[kOriginalClose] = this.close.bind(this), this.dispatch = buildMockDispatch.call(this), this.close = this[kClose];
      }
      get [Symbols.kConnected]() {
        return this[kConnected];
      }
      /**
       * Sets up the base interceptor for mocking replies from undici.
       */
      intercept(opts) {
        return new MockInterceptor(opts, this[kDispatches]);
      }
      async [kClose]() {
        await promisify(this[kOriginalClose])(), this[kConnected] = 0, this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    };
    module2.exports = MockPool;
  }
});

// node_modules/undici/lib/mock/pluralizer.js
var require_pluralizer = __commonJS({
  "node_modules/undici/lib/mock/pluralizer.js"(exports2, module2) {
    "use strict";
    var singulars = {
      pronoun: "it",
      is: "is",
      was: "was",
      this: "this"
    }, plurals = {
      pronoun: "they",
      is: "are",
      was: "were",
      this: "these"
    };
    module2.exports = class {
      constructor(singular, plural) {
        this.singular = singular, this.plural = plural;
      }
      pluralize(count) {
        let one = count === 1, keys = one ? singulars : plurals, noun = one ? this.singular : this.plural;
        return { ...keys, count, noun };
      }
    };
  }
});

// node_modules/undici/lib/mock/pending-interceptors-formatter.js
var require_pending_interceptors_formatter = __commonJS({
  "node_modules/undici/lib/mock/pending-interceptors-formatter.js"(exports2, module2) {
    "use strict";
    var { Transform } = require("stream"), { Console } = require("console");
    module2.exports = class {
      constructor({ disableColors } = {}) {
        this.transform = new Transform({
          transform(chunk, _enc, cb) {
            cb(null, chunk);
          }
        }), this.logger = new Console({
          stdout: this.transform,
          inspectOptions: {
            colors: !disableColors && !process.env.CI
          }
        });
      }
      format(pendingInterceptors) {
        let withPrettyHeaders = pendingInterceptors.map(
          ({ method, path: path8, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
            Method: method,
            Origin: origin,
            Path: path8,
            "Status code": statusCode,
            Persistent: persist ? "\u2705" : "\u274C",
            Invocations: timesInvoked,
            Remaining: persist ? 1 / 0 : times - timesInvoked
          })
        );
        return this.logger.table(withPrettyHeaders), this.transform.read().toString();
      }
    };
  }
});

// node_modules/undici/lib/mock/mock-agent.js
var require_mock_agent = __commonJS({
  "node_modules/undici/lib/mock/mock-agent.js"(exports2, module2) {
    "use strict";
    var { kClients } = require_symbols(), Agent = require_agent(), {
      kAgent,
      kMockAgentSet,
      kMockAgentGet,
      kDispatches,
      kIsMockActive,
      kNetConnect,
      kGetNetConnect,
      kOptions,
      kFactory
    } = require_mock_symbols(), MockClient = require_mock_client(), MockPool = require_mock_pool(), { matchValue, buildMockOptions } = require_mock_utils(), { InvalidArgumentError, UndiciError } = require_errors(), Dispatcher = require_dispatcher(), Pluralizer = require_pluralizer(), PendingInterceptorsFormatter = require_pending_interceptors_formatter(), FakeWeakRef = class {
      constructor(value) {
        this.value = value;
      }
      deref() {
        return this.value;
      }
    }, MockAgent = class extends Dispatcher {
      constructor(opts) {
        if (super(opts), this[kNetConnect] = !0, this[kIsMockActive] = !0, opts && opts.agent && typeof opts.agent.dispatch != "function")
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        let agent = opts && opts.agent ? opts.agent : new Agent(opts);
        this[kAgent] = agent, this[kClients] = agent[kClients], this[kOptions] = buildMockOptions(opts);
      }
      get(origin) {
        let dispatcher = this[kMockAgentGet](origin);
        return dispatcher || (dispatcher = this[kFactory](origin), this[kMockAgentSet](origin, dispatcher)), dispatcher;
      }
      dispatch(opts, handler) {
        return this.get(opts.origin), this[kAgent].dispatch(opts, handler);
      }
      async close() {
        await this[kAgent].close(), this[kClients].clear();
      }
      deactivate() {
        this[kIsMockActive] = !1;
      }
      activate() {
        this[kIsMockActive] = !0;
      }
      enableNetConnect(matcher) {
        if (typeof matcher == "string" || typeof matcher == "function" || matcher instanceof RegExp)
          Array.isArray(this[kNetConnect]) ? this[kNetConnect].push(matcher) : this[kNetConnect] = [matcher];
        else if (typeof matcher > "u")
          this[kNetConnect] = !0;
        else
          throw new InvalidArgumentError("Unsupported matcher. Must be one of String|Function|RegExp.");
      }
      disableNetConnect() {
        this[kNetConnect] = !1;
      }
      // This is required to bypass issues caused by using global symbols - see:
      // https://github.com/nodejs/undici/issues/1447
      get isMockActive() {
        return this[kIsMockActive];
      }
      [kMockAgentSet](origin, dispatcher) {
        this[kClients].set(origin, new FakeWeakRef(dispatcher));
      }
      [kFactory](origin) {
        let mockOptions = Object.assign({ agent: this }, this[kOptions]);
        return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);
      }
      [kMockAgentGet](origin) {
        let ref = this[kClients].get(origin);
        if (ref)
          return ref.deref();
        if (typeof origin != "string") {
          let dispatcher = this[kFactory]("http://localhost:9999");
          return this[kMockAgentSet](origin, dispatcher), dispatcher;
        }
        for (let [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {
          let nonExplicitDispatcher = nonExplicitRef.deref();
          if (nonExplicitDispatcher && typeof keyMatcher != "string" && matchValue(keyMatcher, origin)) {
            let dispatcher = this[kFactory](origin);
            return this[kMockAgentSet](origin, dispatcher), dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches], dispatcher;
          }
        }
      }
      [kGetNetConnect]() {
        return this[kNetConnect];
      }
      pendingInterceptors() {
        let mockAgentClients = this[kClients];
        return Array.from(mockAgentClients.entries()).flatMap(([origin, scope]) => scope.deref()[kDispatches].map((dispatch) => ({ ...dispatch, origin }))).filter(({ pending }) => pending);
      }
      assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {
        let pending = this.pendingInterceptors();
        if (pending.length === 0)
          return;
        let pluralizer = new Pluralizer("interceptor", "interceptors").pluralize(pending.length);
        throw new UndiciError(`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim());
      }
    };
    module2.exports = MockAgent;
  }
});

// node_modules/undici/lib/proxy-agent.js
var require_proxy_agent = __commonJS({
  "node_modules/undici/lib/proxy-agent.js"(exports2, module2) {
    "use strict";
    var { kProxy, kClose, kDestroy, kInterceptors } = require_symbols(), { URL: URL2 } = require("url"), Agent = require_agent(), Pool = require_pool(), DispatcherBase = require_dispatcher_base(), { InvalidArgumentError, RequestAbortedError } = require_errors(), buildConnector = require_connect(), kAgent = Symbol("proxy agent"), kClient = Symbol("proxy client"), kProxyHeaders = Symbol("proxy headers"), kRequestTls = Symbol("request tls settings"), kProxyTls = Symbol("proxy tls settings"), kConnectEndpoint = Symbol("connect endpoint function");
    function defaultProtocolPort(protocol) {
      return protocol === "https:" ? 443 : 80;
    }
    function buildProxyOptions(opts) {
      if (typeof opts == "string" && (opts = { uri: opts }), !opts || !opts.uri)
        throw new InvalidArgumentError("Proxy opts.uri is mandatory");
      return {
        uri: opts.uri,
        protocol: opts.protocol || "https"
      };
    }
    function defaultFactory(origin, opts) {
      return new Pool(origin, opts);
    }
    var ProxyAgent = class extends DispatcherBase {
      constructor(opts) {
        if (super(opts), this[kProxy] = buildProxyOptions(opts), this[kAgent] = new Agent(opts), this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [], typeof opts == "string" && (opts = { uri: opts }), !opts || !opts.uri)
          throw new InvalidArgumentError("Proxy opts.uri is mandatory");
        let { clientFactory = defaultFactory } = opts;
        if (typeof clientFactory != "function")
          throw new InvalidArgumentError("Proxy opts.clientFactory must be a function.");
        this[kRequestTls] = opts.requestTls, this[kProxyTls] = opts.proxyTls, this[kProxyHeaders] = opts.headers || {};
        let resolvedUrl = new URL2(opts.uri), { origin, port, host, username, password } = resolvedUrl;
        if (opts.auth && opts.token)
          throw new InvalidArgumentError("opts.auth cannot be used in combination with opts.token");
        opts.auth ? this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}` : opts.token ? this[kProxyHeaders]["proxy-authorization"] = opts.token : username && password && (this[kProxyHeaders]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString("base64")}`);
        let connect = buildConnector({ ...opts.proxyTls });
        this[kConnectEndpoint] = buildConnector({ ...opts.requestTls }), this[kClient] = clientFactory(resolvedUrl, { connect }), this[kAgent] = new Agent({
          ...opts,
          connect: async (opts2, callback) => {
            let requestedHost = opts2.host;
            opts2.port || (requestedHost += `:${defaultProtocolPort(opts2.protocol)}`);
            try {
              let { socket, statusCode } = await this[kClient].connect({
                origin,
                port,
                path: requestedHost,
                signal: opts2.signal,
                headers: {
                  ...this[kProxyHeaders],
                  host
                }
              });
              if (statusCode !== 200 && (socket.on("error", () => {
              }).destroy(), callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`))), opts2.protocol !== "https:") {
                callback(null, socket);
                return;
              }
              let servername;
              this[kRequestTls] ? servername = this[kRequestTls].servername : servername = opts2.servername, this[kConnectEndpoint]({ ...opts2, servername, httpSocket: socket }, callback);
            } catch (err) {
              callback(err);
            }
          }
        });
      }
      dispatch(opts, handler) {
        let { host } = new URL2(opts.origin), headers = buildHeaders(opts.headers);
        return throwIfProxyAuthIsSent(headers), this[kAgent].dispatch(
          {
            ...opts,
            headers: {
              ...headers,
              host
            }
          },
          handler
        );
      }
      async [kClose]() {
        await this[kAgent].close(), await this[kClient].close();
      }
      async [kDestroy]() {
        await this[kAgent].destroy(), await this[kClient].destroy();
      }
    };
    function buildHeaders(headers) {
      if (Array.isArray(headers)) {
        let headersPair = {};
        for (let i = 0; i < headers.length; i += 2)
          headersPair[headers[i]] = headers[i + 1];
        return headersPair;
      }
      return headers;
    }
    function throwIfProxyAuthIsSent(headers) {
      if (headers && Object.keys(headers).find((key) => key.toLowerCase() === "proxy-authorization"))
        throw new InvalidArgumentError("Proxy-Authorization should be sent in ProxyAgent constructor");
    }
    module2.exports = ProxyAgent;
  }
});

// node_modules/undici/lib/handler/RetryHandler.js
var require_RetryHandler = __commonJS({
  "node_modules/undici/lib/handler/RetryHandler.js"(exports2, module2) {
    var assert3 = require("assert"), { kRetryHandlerDefaultRetry } = require_symbols(), { RequestRetryError } = require_errors(), { isDisturbed, parseHeaders, parseRangeHeader } = require_util();
    function calculateRetryAfterHeader(retryAfter) {
      let current = Date.now();
      return new Date(retryAfter).getTime() - current;
    }
    var RetryHandler = class _RetryHandler {
      constructor(opts, handlers) {
        let { retryOptions, ...dispatchOpts } = opts, {
          // Retry scoped
          retry: retryFn,
          maxRetries,
          maxTimeout,
          minTimeout,
          timeoutFactor,
          // Response scoped
          methods,
          errorCodes,
          retryAfter,
          statusCodes
        } = retryOptions ?? {};
        this.dispatch = handlers.dispatch, this.handler = handlers.handler, this.opts = dispatchOpts, this.abort = null, this.aborted = !1, this.retryOpts = {
          retry: retryFn ?? _RetryHandler[kRetryHandlerDefaultRetry],
          retryAfter: retryAfter ?? !0,
          maxTimeout: maxTimeout ?? 30 * 1e3,
          // 30s,
          timeout: minTimeout ?? 500,
          // .5s
          timeoutFactor: timeoutFactor ?? 2,
          maxRetries: maxRetries ?? 5,
          // What errors we should retry
          methods: methods ?? ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"],
          // Indicates which errors to retry
          statusCodes: statusCodes ?? [500, 502, 503, 504, 429],
          // List of errors to retry
          errorCodes: errorCodes ?? [
            "ECONNRESET",
            "ECONNREFUSED",
            "ENOTFOUND",
            "ENETDOWN",
            "ENETUNREACH",
            "EHOSTDOWN",
            "EHOSTUNREACH",
            "EPIPE"
          ]
        }, this.retryCount = 0, this.start = 0, this.end = null, this.etag = null, this.resume = null, this.handler.onConnect((reason) => {
          this.aborted = !0, this.abort ? this.abort(reason) : this.reason = reason;
        });
      }
      onRequestSent() {
        this.handler.onRequestSent && this.handler.onRequestSent();
      }
      onUpgrade(statusCode, headers, socket) {
        this.handler.onUpgrade && this.handler.onUpgrade(statusCode, headers, socket);
      }
      onConnect(abort) {
        this.aborted ? abort(this.reason) : this.abort = abort;
      }
      onBodySent(chunk) {
        if (this.handler.onBodySent) return this.handler.onBodySent(chunk);
      }
      static [kRetryHandlerDefaultRetry](err, { state, opts }, cb) {
        let { statusCode, code: code2, headers } = err, { method, retryOptions } = opts, {
          maxRetries,
          timeout,
          maxTimeout,
          timeoutFactor,
          statusCodes,
          errorCodes,
          methods
        } = retryOptions, { counter, currentTimeout } = state;
        if (currentTimeout = currentTimeout != null && currentTimeout > 0 ? currentTimeout : timeout, code2 && code2 !== "UND_ERR_REQ_RETRY" && code2 !== "UND_ERR_SOCKET" && !errorCodes.includes(code2)) {
          cb(err);
          return;
        }
        if (Array.isArray(methods) && !methods.includes(method)) {
          cb(err);
          return;
        }
        if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {
          cb(err);
          return;
        }
        if (counter > maxRetries) {
          cb(err);
          return;
        }
        let retryAfterHeader = headers != null && headers["retry-after"];
        retryAfterHeader && (retryAfterHeader = Number(retryAfterHeader), retryAfterHeader = isNaN(retryAfterHeader) ? calculateRetryAfterHeader(retryAfterHeader) : retryAfterHeader * 1e3);
        let retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(currentTimeout * timeoutFactor ** counter, maxTimeout);
        state.currentTimeout = retryTimeout, setTimeout(() => cb(null), retryTimeout);
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        let headers = parseHeaders(rawHeaders);
        if (this.retryCount += 1, statusCode >= 300)
          return this.abort(
            new RequestRetryError("Request failed", statusCode, {
              headers,
              count: this.retryCount
            })
          ), !1;
        if (this.resume != null) {
          if (this.resume = null, statusCode !== 206)
            return !0;
          let contentRange = parseRangeHeader(headers["content-range"]);
          if (!contentRange)
            return this.abort(
              new RequestRetryError("Content-Range mismatch", statusCode, {
                headers,
                count: this.retryCount
              })
            ), !1;
          if (this.etag != null && this.etag !== headers.etag)
            return this.abort(
              new RequestRetryError("ETag mismatch", statusCode, {
                headers,
                count: this.retryCount
              })
            ), !1;
          let { start, size, end = size } = contentRange;
          return assert3(this.start === start, "content-range mismatch"), assert3(this.end == null || this.end === end, "content-range mismatch"), this.resume = resume, !0;
        }
        if (this.end == null) {
          if (statusCode === 206) {
            let range = parseRangeHeader(headers["content-range"]);
            if (range == null)
              return this.handler.onHeaders(
                statusCode,
                rawHeaders,
                resume,
                statusMessage
              );
            let { start, size, end = size } = range;
            assert3(
              start != null && Number.isFinite(start) && this.start !== start,
              "content-range mismatch"
            ), assert3(Number.isFinite(start)), assert3(
              end != null && Number.isFinite(end) && this.end !== end,
              "invalid content-length"
            ), this.start = start, this.end = end;
          }
          if (this.end == null) {
            let contentLength = headers["content-length"];
            this.end = contentLength != null ? Number(contentLength) : null;
          }
          return assert3(Number.isFinite(this.start)), assert3(
            this.end == null || Number.isFinite(this.end),
            "invalid content-length"
          ), this.resume = resume, this.etag = headers.etag != null ? headers.etag : null, this.handler.onHeaders(
            statusCode,
            rawHeaders,
            resume,
            statusMessage
          );
        }
        let err = new RequestRetryError("Request failed", statusCode, {
          headers,
          count: this.retryCount
        });
        return this.abort(err), !1;
      }
      onData(chunk) {
        return this.start += chunk.length, this.handler.onData(chunk);
      }
      onComplete(rawTrailers) {
        return this.retryCount = 0, this.handler.onComplete(rawTrailers);
      }
      onError(err) {
        if (this.aborted || isDisturbed(this.opts.body))
          return this.handler.onError(err);
        this.retryOpts.retry(
          err,
          {
            state: { counter: this.retryCount++, currentTimeout: this.retryAfter },
            opts: { retryOptions: this.retryOpts, ...this.opts }
          },
          onRetry.bind(this)
        );
        function onRetry(err2) {
          if (err2 != null || this.aborted || isDisturbed(this.opts.body))
            return this.handler.onError(err2);
          this.start !== 0 && (this.opts = {
            ...this.opts,
            headers: {
              ...this.opts.headers,
              range: `bytes=${this.start}-${this.end ?? ""}`
            }
          });
          try {
            this.dispatch(this.opts, this);
          } catch (err3) {
            this.handler.onError(err3);
          }
        }
      }
    };
    module2.exports = RetryHandler;
  }
});

// node_modules/undici/lib/global.js
var require_global2 = __commonJS({
  "node_modules/undici/lib/global.js"(exports2, module2) {
    "use strict";
    var globalDispatcher = Symbol.for("undici.globalDispatcher.1"), { InvalidArgumentError } = require_errors(), Agent = require_agent();
    getGlobalDispatcher() === void 0 && setGlobalDispatcher(new Agent());
    function setGlobalDispatcher(agent) {
      if (!agent || typeof agent.dispatch != "function")
        throw new InvalidArgumentError("Argument agent must implement Agent");
      Object.defineProperty(globalThis, globalDispatcher, {
        value: agent,
        writable: !0,
        enumerable: !1,
        configurable: !1
      });
    }
    function getGlobalDispatcher() {
      return globalThis[globalDispatcher];
    }
    module2.exports = {
      setGlobalDispatcher,
      getGlobalDispatcher
    };
  }
});

// node_modules/undici/lib/handler/DecoratorHandler.js
var require_DecoratorHandler = __commonJS({
  "node_modules/undici/lib/handler/DecoratorHandler.js"(exports2, module2) {
    "use strict";
    module2.exports = class {
      constructor(handler) {
        this.handler = handler;
      }
      onConnect(...args) {
        return this.handler.onConnect(...args);
      }
      onError(...args) {
        return this.handler.onError(...args);
      }
      onUpgrade(...args) {
        return this.handler.onUpgrade(...args);
      }
      onHeaders(...args) {
        return this.handler.onHeaders(...args);
      }
      onData(...args) {
        return this.handler.onData(...args);
      }
      onComplete(...args) {
        return this.handler.onComplete(...args);
      }
      onBodySent(...args) {
        return this.handler.onBodySent(...args);
      }
    };
  }
});

// node_modules/undici/lib/fetch/headers.js
var require_headers = __commonJS({
  "node_modules/undici/lib/fetch/headers.js"(exports2, module2) {
    "use strict";
    var { kHeadersList, kConstruct } = require_symbols(), { kGuard } = require_symbols2(), { kEnumerableProperty } = require_util(), {
      makeIterator,
      isValidHeaderName,
      isValidHeaderValue
    } = require_util2(), { webidl } = require_webidl(), assert3 = require("assert"), kHeadersMap = Symbol("headers map"), kHeadersSortedMap = Symbol("headers map sorted");
    function isHTTPWhiteSpaceCharCode(code2) {
      return code2 === 10 || code2 === 13 || code2 === 9 || code2 === 32;
    }
    function headerValueNormalize(potentialValue) {
      let i = 0, j = potentialValue.length;
      for (; j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1)); ) --j;
      for (; j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i)); ) ++i;
      return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j);
    }
    function fill(headers, object) {
      if (Array.isArray(object))
        for (let i = 0; i < object.length; ++i) {
          let header = object[i];
          if (header.length !== 2)
            throw webidl.errors.exception({
              header: "Headers constructor",
              message: `expected name/value pair to be length 2, found ${header.length}.`
            });
          appendHeader(headers, header[0], header[1]);
        }
      else if (typeof object == "object" && object !== null) {
        let keys = Object.keys(object);
        for (let i = 0; i < keys.length; ++i)
          appendHeader(headers, keys[i], object[keys[i]]);
      } else
        throw webidl.errors.conversionFailed({
          prefix: "Headers constructor",
          argument: "Argument 1",
          types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
        });
    }
    function appendHeader(headers, name2, value) {
      if (value = headerValueNormalize(value), isValidHeaderName(name2)) {
        if (!isValidHeaderValue(value))
          throw webidl.errors.invalidArgument({
            prefix: "Headers.append",
            value,
            type: "header value"
          });
      } else throw webidl.errors.invalidArgument({
        prefix: "Headers.append",
        value: name2,
        type: "header name"
      });
      if (headers[kGuard] === "immutable")
        throw new TypeError("immutable");
      return headers[kGuard], headers[kHeadersList].append(name2, value);
    }
    var HeadersList = class _HeadersList {
      /** @type {[string, string][]|null} */
      cookies = null;
      constructor(init) {
        init instanceof _HeadersList ? (this[kHeadersMap] = new Map(init[kHeadersMap]), this[kHeadersSortedMap] = init[kHeadersSortedMap], this.cookies = init.cookies === null ? null : [...init.cookies]) : (this[kHeadersMap] = new Map(init), this[kHeadersSortedMap] = null);
      }
      // https://fetch.spec.whatwg.org/#header-list-contains
      contains(name2) {
        return name2 = name2.toLowerCase(), this[kHeadersMap].has(name2);
      }
      clear() {
        this[kHeadersMap].clear(), this[kHeadersSortedMap] = null, this.cookies = null;
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-append
      append(name2, value) {
        this[kHeadersSortedMap] = null;
        let lowercaseName = name2.toLowerCase(), exists = this[kHeadersMap].get(lowercaseName);
        if (exists) {
          let delimiter = lowercaseName === "cookie" ? "; " : ", ";
          this[kHeadersMap].set(lowercaseName, {
            name: exists.name,
            value: `${exists.value}${delimiter}${value}`
          });
        } else
          this[kHeadersMap].set(lowercaseName, { name: name2, value });
        lowercaseName === "set-cookie" && (this.cookies ??= [], this.cookies.push(value));
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-set
      set(name2, value) {
        this[kHeadersSortedMap] = null;
        let lowercaseName = name2.toLowerCase();
        lowercaseName === "set-cookie" && (this.cookies = [value]), this[kHeadersMap].set(lowercaseName, { name: name2, value });
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-delete
      delete(name2) {
        this[kHeadersSortedMap] = null, name2 = name2.toLowerCase(), name2 === "set-cookie" && (this.cookies = null), this[kHeadersMap].delete(name2);
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-get
      get(name2) {
        let value = this[kHeadersMap].get(name2.toLowerCase());
        return value === void 0 ? null : value.value;
      }
      *[Symbol.iterator]() {
        for (let [name2, { value }] of this[kHeadersMap])
          yield [name2, value];
      }
      get entries() {
        let headers = {};
        if (this[kHeadersMap].size)
          for (let { name: name2, value } of this[kHeadersMap].values())
            headers[name2] = value;
        return headers;
      }
    }, Headers = class _Headers {
      constructor(init = void 0) {
        init !== kConstruct && (this[kHeadersList] = new HeadersList(), this[kGuard] = "none", init !== void 0 && (init = webidl.converters.HeadersInit(init), fill(this, init)));
      }
      // https://fetch.spec.whatwg.org/#dom-headers-append
      append(name2, value) {
        return webidl.brandCheck(this, _Headers), webidl.argumentLengthCheck(arguments, 2, { header: "Headers.append" }), name2 = webidl.converters.ByteString(name2), value = webidl.converters.ByteString(value), appendHeader(this, name2, value);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-delete
      delete(name2) {
        if (webidl.brandCheck(this, _Headers), webidl.argumentLengthCheck(arguments, 1, { header: "Headers.delete" }), name2 = webidl.converters.ByteString(name2), !isValidHeaderName(name2))
          throw webidl.errors.invalidArgument({
            prefix: "Headers.delete",
            value: name2,
            type: "header name"
          });
        if (this[kGuard] === "immutable")
          throw new TypeError("immutable");
        this[kGuard], this[kHeadersList].contains(name2) && this[kHeadersList].delete(name2);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-get
      get(name2) {
        if (webidl.brandCheck(this, _Headers), webidl.argumentLengthCheck(arguments, 1, { header: "Headers.get" }), name2 = webidl.converters.ByteString(name2), !isValidHeaderName(name2))
          throw webidl.errors.invalidArgument({
            prefix: "Headers.get",
            value: name2,
            type: "header name"
          });
        return this[kHeadersList].get(name2);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-has
      has(name2) {
        if (webidl.brandCheck(this, _Headers), webidl.argumentLengthCheck(arguments, 1, { header: "Headers.has" }), name2 = webidl.converters.ByteString(name2), !isValidHeaderName(name2))
          throw webidl.errors.invalidArgument({
            prefix: "Headers.has",
            value: name2,
            type: "header name"
          });
        return this[kHeadersList].contains(name2);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-set
      set(name2, value) {
        if (webidl.brandCheck(this, _Headers), webidl.argumentLengthCheck(arguments, 2, { header: "Headers.set" }), name2 = webidl.converters.ByteString(name2), value = webidl.converters.ByteString(value), value = headerValueNormalize(value), isValidHeaderName(name2)) {
          if (!isValidHeaderValue(value))
            throw webidl.errors.invalidArgument({
              prefix: "Headers.set",
              value,
              type: "header value"
            });
        } else throw webidl.errors.invalidArgument({
          prefix: "Headers.set",
          value: name2,
          type: "header name"
        });
        if (this[kGuard] === "immutable")
          throw new TypeError("immutable");
        this[kGuard], this[kHeadersList].set(name2, value);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie
      getSetCookie() {
        webidl.brandCheck(this, _Headers);
        let list2 = this[kHeadersList].cookies;
        return list2 ? [...list2] : [];
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine
      get [kHeadersSortedMap]() {
        if (this[kHeadersList][kHeadersSortedMap])
          return this[kHeadersList][kHeadersSortedMap];
        let headers = [], names = [...this[kHeadersList]].sort((a, b) => a[0] < b[0] ? -1 : 1), cookies = this[kHeadersList].cookies;
        for (let i = 0; i < names.length; ++i) {
          let [name2, value] = names[i];
          if (name2 === "set-cookie")
            for (let j = 0; j < cookies.length; ++j)
              headers.push([name2, cookies[j]]);
          else
            assert3(value !== null), headers.push([name2, value]);
        }
        return this[kHeadersList][kHeadersSortedMap] = headers, headers;
      }
      keys() {
        if (webidl.brandCheck(this, _Headers), this[kGuard] === "immutable") {
          let value = this[kHeadersSortedMap];
          return makeIterator(
            () => value,
            "Headers",
            "key"
          );
        }
        return makeIterator(
          () => [...this[kHeadersSortedMap].values()],
          "Headers",
          "key"
        );
      }
      values() {
        if (webidl.brandCheck(this, _Headers), this[kGuard] === "immutable") {
          let value = this[kHeadersSortedMap];
          return makeIterator(
            () => value,
            "Headers",
            "value"
          );
        }
        return makeIterator(
          () => [...this[kHeadersSortedMap].values()],
          "Headers",
          "value"
        );
      }
      entries() {
        if (webidl.brandCheck(this, _Headers), this[kGuard] === "immutable") {
          let value = this[kHeadersSortedMap];
          return makeIterator(
            () => value,
            "Headers",
            "key+value"
          );
        }
        return makeIterator(
          () => [...this[kHeadersSortedMap].values()],
          "Headers",
          "key+value"
        );
      }
      /**
       * @param {(value: string, key: string, self: Headers) => void} callbackFn
       * @param {unknown} thisArg
       */
      forEach(callbackFn, thisArg = globalThis) {
        if (webidl.brandCheck(this, _Headers), webidl.argumentLengthCheck(arguments, 1, { header: "Headers.forEach" }), typeof callbackFn != "function")
          throw new TypeError(
            "Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'."
          );
        for (let [key, value] of this)
          callbackFn.apply(thisArg, [value, key, this]);
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return webidl.brandCheck(this, _Headers), this[kHeadersList];
      }
    };
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
    Object.defineProperties(Headers.prototype, {
      append: kEnumerableProperty,
      delete: kEnumerableProperty,
      get: kEnumerableProperty,
      has: kEnumerableProperty,
      set: kEnumerableProperty,
      getSetCookie: kEnumerableProperty,
      keys: kEnumerableProperty,
      values: kEnumerableProperty,
      entries: kEnumerableProperty,
      forEach: kEnumerableProperty,
      [Symbol.iterator]: { enumerable: !1 },
      [Symbol.toStringTag]: {
        value: "Headers",
        configurable: !0
      }
    });
    webidl.converters.HeadersInit = function(V) {
      if (webidl.util.Type(V) === "Object")
        return V[Symbol.iterator] ? webidl.converters["sequence<sequence<ByteString>>"](V) : webidl.converters["record<ByteString, ByteString>"](V);
      throw webidl.errors.conversionFailed({
        prefix: "Headers constructor",
        argument: "Argument 1",
        types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
      });
    };
    module2.exports = {
      fill,
      Headers,
      HeadersList
    };
  }
});

// node_modules/undici/lib/fetch/response.js
var require_response = __commonJS({
  "node_modules/undici/lib/fetch/response.js"(exports2, module2) {
    "use strict";
    var { Headers, HeadersList, fill } = require_headers(), { extractBody, cloneBody, mixinBody } = require_body(), util = require_util(), { kEnumerableProperty } = util, {
      isValidReasonPhrase,
      isCancelled,
      isAborted,
      isBlobLike,
      serializeJavascriptValueToJSONString,
      isErrorLike,
      isomorphicEncode
    } = require_util2(), {
      redirectStatusSet,
      nullBodyStatus,
      DOMException: DOMException2
    } = require_constants2(), { kState, kHeaders, kGuard, kRealm } = require_symbols2(), { webidl } = require_webidl(), { FormData } = require_formdata(), { getGlobalOrigin } = require_global(), { URLSerializer } = require_dataURL(), { kHeadersList, kConstruct } = require_symbols(), assert3 = require("assert"), { types } = require("util"), ReadableStream = globalThis.ReadableStream || require("stream/web").ReadableStream, textEncoder = new TextEncoder("utf-8"), Response = class _Response {
      // Creates network error Response.
      static error() {
        let relevantRealm = { settingsObject: {} }, responseObject = new _Response();
        return responseObject[kState] = makeNetworkError(), responseObject[kRealm] = relevantRealm, responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList, responseObject[kHeaders][kGuard] = "immutable", responseObject[kHeaders][kRealm] = relevantRealm, responseObject;
      }
      // https://fetch.spec.whatwg.org/#dom-response-json
      static json(data, init = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: "Response.json" }), init !== null && (init = webidl.converters.ResponseInit(init));
        let bytes = textEncoder.encode(
          serializeJavascriptValueToJSONString(data)
        ), body = extractBody(bytes), relevantRealm = { settingsObject: {} }, responseObject = new _Response();
        return responseObject[kRealm] = relevantRealm, responseObject[kHeaders][kGuard] = "response", responseObject[kHeaders][kRealm] = relevantRealm, initializeResponse(responseObject, init, { body: body[0], type: "application/json" }), responseObject;
      }
      // Creates a redirect Response that redirects to url with status status.
      static redirect(url, status = 302) {
        let relevantRealm = { settingsObject: {} };
        webidl.argumentLengthCheck(arguments, 1, { header: "Response.redirect" }), url = webidl.converters.USVString(url), status = webidl.converters["unsigned short"](status);
        let parsedURL;
        try {
          parsedURL = new URL(url, getGlobalOrigin());
        } catch (err) {
          throw Object.assign(new TypeError("Failed to parse URL from " + url), {
            cause: err
          });
        }
        if (!redirectStatusSet.has(status))
          throw new RangeError("Invalid status code " + status);
        let responseObject = new _Response();
        responseObject[kRealm] = relevantRealm, responseObject[kHeaders][kGuard] = "immutable", responseObject[kHeaders][kRealm] = relevantRealm, responseObject[kState].status = status;
        let value = isomorphicEncode(URLSerializer(parsedURL));
        return responseObject[kState].headersList.append("location", value), responseObject;
      }
      // https://fetch.spec.whatwg.org/#dom-response
      constructor(body = null, init = {}) {
        body !== null && (body = webidl.converters.BodyInit(body)), init = webidl.converters.ResponseInit(init), this[kRealm] = { settingsObject: {} }, this[kState] = makeResponse({}), this[kHeaders] = new Headers(kConstruct), this[kHeaders][kGuard] = "response", this[kHeaders][kHeadersList] = this[kState].headersList, this[kHeaders][kRealm] = this[kRealm];
        let bodyWithType = null;
        if (body != null) {
          let [extractedBody, type] = extractBody(body);
          bodyWithType = { body: extractedBody, type };
        }
        initializeResponse(this, init, bodyWithType);
      }
      // Returns response’s type, e.g., "cors".
      get type() {
        return webidl.brandCheck(this, _Response), this[kState].type;
      }
      // Returns response’s URL, if it has one; otherwise the empty string.
      get url() {
        webidl.brandCheck(this, _Response);
        let urlList = this[kState].urlList, url = urlList[urlList.length - 1] ?? null;
        return url === null ? "" : URLSerializer(url, !0);
      }
      // Returns whether response was obtained through a redirect.
      get redirected() {
        return webidl.brandCheck(this, _Response), this[kState].urlList.length > 1;
      }
      // Returns response’s status.
      get status() {
        return webidl.brandCheck(this, _Response), this[kState].status;
      }
      // Returns whether response’s status is an ok status.
      get ok() {
        return webidl.brandCheck(this, _Response), this[kState].status >= 200 && this[kState].status <= 299;
      }
      // Returns response’s status message.
      get statusText() {
        return webidl.brandCheck(this, _Response), this[kState].statusText;
      }
      // Returns response’s headers as Headers.
      get headers() {
        return webidl.brandCheck(this, _Response), this[kHeaders];
      }
      get body() {
        return webidl.brandCheck(this, _Response), this[kState].body ? this[kState].body.stream : null;
      }
      get bodyUsed() {
        return webidl.brandCheck(this, _Response), !!this[kState].body && util.isDisturbed(this[kState].body.stream);
      }
      // Returns a clone of response.
      clone() {
        if (webidl.brandCheck(this, _Response), this.bodyUsed || this.body && this.body.locked)
          throw webidl.errors.exception({
            header: "Response.clone",
            message: "Body has already been consumed."
          });
        let clonedResponse = cloneResponse(this[kState]), clonedResponseObject = new _Response();
        return clonedResponseObject[kState] = clonedResponse, clonedResponseObject[kRealm] = this[kRealm], clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList, clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard], clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm], clonedResponseObject;
      }
    };
    mixinBody(Response);
    Object.defineProperties(Response.prototype, {
      type: kEnumerableProperty,
      url: kEnumerableProperty,
      status: kEnumerableProperty,
      ok: kEnumerableProperty,
      redirected: kEnumerableProperty,
      statusText: kEnumerableProperty,
      headers: kEnumerableProperty,
      clone: kEnumerableProperty,
      body: kEnumerableProperty,
      bodyUsed: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "Response",
        configurable: !0
      }
    });
    Object.defineProperties(Response, {
      json: kEnumerableProperty,
      redirect: kEnumerableProperty,
      error: kEnumerableProperty
    });
    function cloneResponse(response) {
      if (response.internalResponse)
        return filterResponse(
          cloneResponse(response.internalResponse),
          response.type
        );
      let newResponse = makeResponse({ ...response, body: null });
      return response.body != null && (newResponse.body = cloneBody(response.body)), newResponse;
    }
    function makeResponse(init) {
      return {
        aborted: !1,
        rangeRequested: !1,
        timingAllowPassed: !1,
        requestIncludesCredentials: !1,
        type: "default",
        status: 200,
        timingInfo: null,
        cacheState: "",
        statusText: "",
        ...init,
        headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList(),
        urlList: init.urlList ? [...init.urlList] : []
      };
    }
    function makeNetworkError(reason) {
      let isError = isErrorLike(reason);
      return makeResponse({
        type: "error",
        status: 0,
        error: isError ? reason : new Error(reason && String(reason)),
        aborted: reason && reason.name === "AbortError"
      });
    }
    function makeFilteredResponse(response, state) {
      return state = {
        internalResponse: response,
        ...state
      }, new Proxy(response, {
        get(target, p) {
          return p in state ? state[p] : target[p];
        },
        set(target, p, value) {
          return assert3(!(p in state)), target[p] = value, !0;
        }
      });
    }
    function filterResponse(response, type) {
      if (type === "basic")
        return makeFilteredResponse(response, {
          type: "basic",
          headersList: response.headersList
        });
      if (type === "cors")
        return makeFilteredResponse(response, {
          type: "cors",
          headersList: response.headersList
        });
      if (type === "opaque")
        return makeFilteredResponse(response, {
          type: "opaque",
          urlList: Object.freeze([]),
          status: 0,
          statusText: "",
          body: null
        });
      if (type === "opaqueredirect")
        return makeFilteredResponse(response, {
          type: "opaqueredirect",
          status: 0,
          statusText: "",
          headersList: [],
          body: null
        });
      assert3(!1);
    }
    function makeAppropriateNetworkError(fetchParams, err = null) {
      return assert3(isCancelled(fetchParams)), isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException2("The operation was aborted.", "AbortError"), { cause: err })) : makeNetworkError(Object.assign(new DOMException2("Request was cancelled."), { cause: err }));
    }
    function initializeResponse(response, init, body) {
      if (init.status !== null && (init.status < 200 || init.status > 599))
        throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
      if ("statusText" in init && init.statusText != null && !isValidReasonPhrase(String(init.statusText)))
        throw new TypeError("Invalid statusText");
      if ("status" in init && init.status != null && (response[kState].status = init.status), "statusText" in init && init.statusText != null && (response[kState].statusText = init.statusText), "headers" in init && init.headers != null && fill(response[kHeaders], init.headers), body) {
        if (nullBodyStatus.includes(response.status))
          throw webidl.errors.exception({
            header: "Response constructor",
            message: "Invalid response status code " + response.status
          });
        response[kState].body = body.body, body.type != null && !response[kState].headersList.contains("Content-Type") && response[kState].headersList.append("content-type", body.type);
      }
    }
    webidl.converters.ReadableStream = webidl.interfaceConverter(
      ReadableStream
    );
    webidl.converters.FormData = webidl.interfaceConverter(
      FormData
    );
    webidl.converters.URLSearchParams = webidl.interfaceConverter(
      URLSearchParams
    );
    webidl.converters.XMLHttpRequestBodyInit = function(V) {
      return typeof V == "string" ? webidl.converters.USVString(V) : isBlobLike(V) ? webidl.converters.Blob(V, { strict: !1 }) : types.isArrayBuffer(V) || types.isTypedArray(V) || types.isDataView(V) ? webidl.converters.BufferSource(V) : util.isFormDataLike(V) ? webidl.converters.FormData(V, { strict: !1 }) : V instanceof URLSearchParams ? webidl.converters.URLSearchParams(V) : webidl.converters.DOMString(V);
    };
    webidl.converters.BodyInit = function(V) {
      return V instanceof ReadableStream ? webidl.converters.ReadableStream(V) : V?.[Symbol.asyncIterator] ? V : webidl.converters.XMLHttpRequestBodyInit(V);
    };
    webidl.converters.ResponseInit = webidl.dictionaryConverter([
      {
        key: "status",
        converter: webidl.converters["unsigned short"],
        defaultValue: 200
      },
      {
        key: "statusText",
        converter: webidl.converters.ByteString,
        defaultValue: ""
      },
      {
        key: "headers",
        converter: webidl.converters.HeadersInit
      }
    ]);
    module2.exports = {
      makeNetworkError,
      makeResponse,
      makeAppropriateNetworkError,
      filterResponse,
      Response,
      cloneResponse
    };
  }
});

// node_modules/undici/lib/fetch/request.js
var require_request2 = __commonJS({
  "node_modules/undici/lib/fetch/request.js"(exports2, module2) {
    "use strict";
    var { extractBody, mixinBody, cloneBody } = require_body(), { Headers, fill: fillHeaders, HeadersList } = require_headers(), { FinalizationRegistry } = require_dispatcher_weakref()(), util = require_util(), {
      isValidHTTPToken,
      sameOrigin,
      normalizeMethod,
      makePolicyContainer,
      normalizeMethodRecord
    } = require_util2(), {
      forbiddenMethodsSet,
      corsSafeListedMethodsSet,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache,
      requestDuplex
    } = require_constants2(), { kEnumerableProperty } = util, { kHeaders, kSignal, kState, kGuard, kRealm } = require_symbols2(), { webidl } = require_webidl(), { getGlobalOrigin } = require_global(), { URLSerializer } = require_dataURL(), { kHeadersList, kConstruct } = require_symbols(), assert3 = require("assert"), { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = require("events"), TransformStream = globalThis.TransformStream, kAbortController = Symbol("abortController"), requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {
      signal.removeEventListener("abort", abort);
    }), Request = class _Request {
      // https://fetch.spec.whatwg.org/#dom-request
      constructor(input, init = {}) {
        if (input === kConstruct)
          return;
        webidl.argumentLengthCheck(arguments, 1, { header: "Request constructor" }), input = webidl.converters.RequestInfo(input), init = webidl.converters.RequestInit(init), this[kRealm] = {
          settingsObject: {
            baseUrl: getGlobalOrigin(),
            get origin() {
              return this.baseUrl?.origin;
            },
            policyContainer: makePolicyContainer()
          }
        };
        let request = null, fallbackMode = null, baseUrl = this[kRealm].settingsObject.baseUrl, signal = null;
        if (typeof input == "string") {
          let parsedURL;
          try {
            parsedURL = new URL(input, baseUrl);
          } catch (err) {
            throw new TypeError("Failed to parse URL from " + input, { cause: err });
          }
          if (parsedURL.username || parsedURL.password)
            throw new TypeError(
              "Request cannot be constructed from a URL that includes credentials: " + input
            );
          request = makeRequest({ urlList: [parsedURL] }), fallbackMode = "cors";
        } else
          assert3(input instanceof _Request), request = input[kState], signal = input[kSignal];
        let origin = this[kRealm].settingsObject.origin, window2 = "client";
        if (request.window?.constructor?.name === "EnvironmentSettingsObject" && sameOrigin(request.window, origin) && (window2 = request.window), init.window != null)
          throw new TypeError(`'window' option '${window2}' must be null`);
        "window" in init && (window2 = "no-window"), request = makeRequest({
          // URL request’s URL.
          // undici implementation note: this is set as the first item in request's urlList in makeRequest
          // method request’s method.
          method: request.method,
          // header list A copy of request’s header list.
          // undici implementation note: headersList is cloned in makeRequest
          headersList: request.headersList,
          // unsafe-request flag Set.
          unsafeRequest: request.unsafeRequest,
          // client This’s relevant settings object.
          client: this[kRealm].settingsObject,
          // window window.
          window: window2,
          // priority request’s priority.
          priority: request.priority,
          // origin request’s origin. The propagation of the origin is only significant for navigation requests
          // being handled by a service worker. In this scenario a request can have an origin that is different
          // from the current client.
          origin: request.origin,
          // referrer request’s referrer.
          referrer: request.referrer,
          // referrer policy request’s referrer policy.
          referrerPolicy: request.referrerPolicy,
          // mode request’s mode.
          mode: request.mode,
          // credentials mode request’s credentials mode.
          credentials: request.credentials,
          // cache mode request’s cache mode.
          cache: request.cache,
          // redirect mode request’s redirect mode.
          redirect: request.redirect,
          // integrity metadata request’s integrity metadata.
          integrity: request.integrity,
          // keepalive request’s keepalive.
          keepalive: request.keepalive,
          // reload-navigation flag request’s reload-navigation flag.
          reloadNavigation: request.reloadNavigation,
          // history-navigation flag request’s history-navigation flag.
          historyNavigation: request.historyNavigation,
          // URL list A clone of request’s URL list.
          urlList: [...request.urlList]
        });
        let initHasKey = Object.keys(init).length !== 0;
        if (initHasKey && (request.mode === "navigate" && (request.mode = "same-origin"), request.reloadNavigation = !1, request.historyNavigation = !1, request.origin = "client", request.referrer = "client", request.referrerPolicy = "", request.url = request.urlList[request.urlList.length - 1], request.urlList = [request.url]), init.referrer !== void 0) {
          let referrer = init.referrer;
          if (referrer === "")
            request.referrer = "no-referrer";
          else {
            let parsedReferrer;
            try {
              parsedReferrer = new URL(referrer, baseUrl);
            } catch (err) {
              throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
            }
            parsedReferrer.protocol === "about:" && parsedReferrer.hostname === "client" || origin && !sameOrigin(parsedReferrer, this[kRealm].settingsObject.baseUrl) ? request.referrer = "client" : request.referrer = parsedReferrer;
          }
        }
        init.referrerPolicy !== void 0 && (request.referrerPolicy = init.referrerPolicy);
        let mode;
        if (init.mode !== void 0 ? mode = init.mode : mode = fallbackMode, mode === "navigate")
          throw webidl.errors.exception({
            header: "Request constructor",
            message: "invalid request mode navigate."
          });
        if (mode != null && (request.mode = mode), init.credentials !== void 0 && (request.credentials = init.credentials), init.cache !== void 0 && (request.cache = init.cache), request.cache === "only-if-cached" && request.mode !== "same-origin")
          throw new TypeError(
            "'only-if-cached' can be set only with 'same-origin' mode"
          );
        if (init.redirect !== void 0 && (request.redirect = init.redirect), init.integrity != null && (request.integrity = String(init.integrity)), init.keepalive !== void 0 && (request.keepalive = !!init.keepalive), init.method !== void 0) {
          let method = init.method;
          if (!isValidHTTPToken(method))
            throw new TypeError(`'${method}' is not a valid HTTP method.`);
          if (forbiddenMethodsSet.has(method.toUpperCase()))
            throw new TypeError(`'${method}' HTTP method is unsupported.`);
          method = normalizeMethodRecord[method] ?? normalizeMethod(method), request.method = method;
        }
        init.signal !== void 0 && (signal = init.signal), this[kState] = request;
        let ac = new AbortController();
        if (this[kSignal] = ac.signal, this[kSignal][kRealm] = this[kRealm], signal != null) {
          if (!signal || typeof signal.aborted != "boolean" || typeof signal.addEventListener != "function")
            throw new TypeError(
              "Failed to construct 'Request': member signal is not of type AbortSignal."
            );
          if (signal.aborted)
            ac.abort(signal.reason);
          else {
            this[kAbortController] = ac;
            let acRef = new WeakRef(ac), abort = function() {
              let ac2 = acRef.deref();
              ac2 !== void 0 && ac2.abort(this.reason);
            };
            try {
              (typeof getMaxListeners == "function" && getMaxListeners(signal) === defaultMaxListeners || getEventListeners(signal, "abort").length >= defaultMaxListeners) && setMaxListeners(100, signal);
            } catch {
            }
            util.addAbortListener(signal, abort), requestFinalizer.register(ac, { signal, abort });
          }
        }
        if (this[kHeaders] = new Headers(kConstruct), this[kHeaders][kHeadersList] = request.headersList, this[kHeaders][kGuard] = "request", this[kHeaders][kRealm] = this[kRealm], mode === "no-cors") {
          if (!corsSafeListedMethodsSet.has(request.method))
            throw new TypeError(
              `'${request.method} is unsupported in no-cors mode.`
            );
          this[kHeaders][kGuard] = "request-no-cors";
        }
        if (initHasKey) {
          let headersList = this[kHeaders][kHeadersList], headers = init.headers !== void 0 ? init.headers : new HeadersList(headersList);
          if (headersList.clear(), headers instanceof HeadersList) {
            for (let [key, val] of headers)
              headersList.append(key, val);
            headersList.cookies = headers.cookies;
          } else
            fillHeaders(this[kHeaders], headers);
        }
        let inputBody = input instanceof _Request ? input[kState].body : null;
        if ((init.body != null || inputBody != null) && (request.method === "GET" || request.method === "HEAD"))
          throw new TypeError("Request with GET/HEAD method cannot have body.");
        let initBody = null;
        if (init.body != null) {
          let [extractedBody, contentType] = extractBody(
            init.body,
            request.keepalive
          );
          initBody = extractedBody, contentType && !this[kHeaders][kHeadersList].contains("content-type") && this[kHeaders].append("content-type", contentType);
        }
        let inputOrInitBody = initBody ?? inputBody;
        if (inputOrInitBody != null && inputOrInitBody.source == null) {
          if (initBody != null && init.duplex == null)
            throw new TypeError("RequestInit: duplex option is required when sending a body.");
          if (request.mode !== "same-origin" && request.mode !== "cors")
            throw new TypeError(
              'If request is made from ReadableStream, mode should be "same-origin" or "cors"'
            );
          request.useCORSPreflightFlag = !0;
        }
        let finalBody = inputOrInitBody;
        if (initBody == null && inputBody != null) {
          if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked)
            throw new TypeError(
              "Cannot construct a Request with a Request object that has already been used."
            );
          TransformStream || (TransformStream = require("stream/web").TransformStream);
          let identityTransform = new TransformStream();
          inputBody.stream.pipeThrough(identityTransform), finalBody = {
            source: inputBody.source,
            length: inputBody.length,
            stream: identityTransform.readable
          };
        }
        this[kState].body = finalBody;
      }
      // Returns request’s HTTP method, which is "GET" by default.
      get method() {
        return webidl.brandCheck(this, _Request), this[kState].method;
      }
      // Returns the URL of request as a string.
      get url() {
        return webidl.brandCheck(this, _Request), URLSerializer(this[kState].url);
      }
      // Returns a Headers object consisting of the headers associated with request.
      // Note that headers added in the network layer by the user agent will not
      // be accounted for in this object, e.g., the "Host" header.
      get headers() {
        return webidl.brandCheck(this, _Request), this[kHeaders];
      }
      // Returns the kind of resource requested by request, e.g., "document"
      // or "script".
      get destination() {
        return webidl.brandCheck(this, _Request), this[kState].destination;
      }
      // Returns the referrer of request. Its value can be a same-origin URL if
      // explicitly set in init, the empty string to indicate no referrer, and
      // "about:client" when defaulting to the global’s default. This is used
      // during fetching to determine the value of the `Referer` header of the
      // request being made.
      get referrer() {
        return webidl.brandCheck(this, _Request), this[kState].referrer === "no-referrer" ? "" : this[kState].referrer === "client" ? "about:client" : this[kState].referrer.toString();
      }
      // Returns the referrer policy associated with request.
      // This is used during fetching to compute the value of the request’s
      // referrer.
      get referrerPolicy() {
        return webidl.brandCheck(this, _Request), this[kState].referrerPolicy;
      }
      // Returns the mode associated with request, which is a string indicating
      // whether the request will use CORS, or will be restricted to same-origin
      // URLs.
      get mode() {
        return webidl.brandCheck(this, _Request), this[kState].mode;
      }
      // Returns the credentials mode associated with request,
      // which is a string indicating whether credentials will be sent with the
      // request always, never, or only when sent to a same-origin URL.
      get credentials() {
        return this[kState].credentials;
      }
      // Returns the cache mode associated with request,
      // which is a string indicating how the request will
      // interact with the browser’s cache when fetching.
      get cache() {
        return webidl.brandCheck(this, _Request), this[kState].cache;
      }
      // Returns the redirect mode associated with request,
      // which is a string indicating how redirects for the
      // request will be handled during fetching. A request
      // will follow redirects by default.
      get redirect() {
        return webidl.brandCheck(this, _Request), this[kState].redirect;
      }
      // Returns request’s subresource integrity metadata, which is a
      // cryptographic hash of the resource being fetched. Its value
      // consists of multiple hashes separated by whitespace. [SRI]
      get integrity() {
        return webidl.brandCheck(this, _Request), this[kState].integrity;
      }
      // Returns a boolean indicating whether or not request can outlive the
      // global in which it was created.
      get keepalive() {
        return webidl.brandCheck(this, _Request), this[kState].keepalive;
      }
      // Returns a boolean indicating whether or not request is for a reload
      // navigation.
      get isReloadNavigation() {
        return webidl.brandCheck(this, _Request), this[kState].reloadNavigation;
      }
      // Returns a boolean indicating whether or not request is for a history
      // navigation (a.k.a. back-foward navigation).
      get isHistoryNavigation() {
        return webidl.brandCheck(this, _Request), this[kState].historyNavigation;
      }
      // Returns the signal associated with request, which is an AbortSignal
      // object indicating whether or not request has been aborted, and its
      // abort event handler.
      get signal() {
        return webidl.brandCheck(this, _Request), this[kSignal];
      }
      get body() {
        return webidl.brandCheck(this, _Request), this[kState].body ? this[kState].body.stream : null;
      }
      get bodyUsed() {
        return webidl.brandCheck(this, _Request), !!this[kState].body && util.isDisturbed(this[kState].body.stream);
      }
      get duplex() {
        return webidl.brandCheck(this, _Request), "half";
      }
      // Returns a clone of request.
      clone() {
        if (webidl.brandCheck(this, _Request), this.bodyUsed || this.body?.locked)
          throw new TypeError("unusable");
        let clonedRequest = cloneRequest(this[kState]), clonedRequestObject = new _Request(kConstruct);
        clonedRequestObject[kState] = clonedRequest, clonedRequestObject[kRealm] = this[kRealm], clonedRequestObject[kHeaders] = new Headers(kConstruct), clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList, clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard], clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm];
        let ac = new AbortController();
        return this.signal.aborted ? ac.abort(this.signal.reason) : util.addAbortListener(
          this.signal,
          () => {
            ac.abort(this.signal.reason);
          }
        ), clonedRequestObject[kSignal] = ac.signal, clonedRequestObject;
      }
    };
    mixinBody(Request);
    function makeRequest(init) {
      let request = {
        method: "GET",
        localURLsOnly: !1,
        unsafeRequest: !1,
        body: null,
        client: null,
        reservedClient: null,
        replacesClientId: "",
        window: "client",
        keepalive: !1,
        serviceWorkers: "all",
        initiator: "",
        destination: "",
        priority: null,
        origin: "client",
        policyContainer: "client",
        referrer: "client",
        referrerPolicy: "",
        mode: "no-cors",
        useCORSPreflightFlag: !1,
        credentials: "same-origin",
        useCredentials: !1,
        cache: "default",
        redirect: "follow",
        integrity: "",
        cryptoGraphicsNonceMetadata: "",
        parserMetadata: "",
        reloadNavigation: !1,
        historyNavigation: !1,
        userActivation: !1,
        taintedOrigin: !1,
        redirectCount: 0,
        responseTainting: "basic",
        preventNoCacheCacheControlHeaderModification: !1,
        done: !1,
        timingAllowFailed: !1,
        ...init,
        headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList()
      };
      return request.url = request.urlList[0], request;
    }
    function cloneRequest(request) {
      let newRequest = makeRequest({ ...request, body: null });
      return request.body != null && (newRequest.body = cloneBody(request.body)), newRequest;
    }
    Object.defineProperties(Request.prototype, {
      method: kEnumerableProperty,
      url: kEnumerableProperty,
      headers: kEnumerableProperty,
      redirect: kEnumerableProperty,
      clone: kEnumerableProperty,
      signal: kEnumerableProperty,
      duplex: kEnumerableProperty,
      destination: kEnumerableProperty,
      body: kEnumerableProperty,
      bodyUsed: kEnumerableProperty,
      isHistoryNavigation: kEnumerableProperty,
      isReloadNavigation: kEnumerableProperty,
      keepalive: kEnumerableProperty,
      integrity: kEnumerableProperty,
      cache: kEnumerableProperty,
      credentials: kEnumerableProperty,
      attribute: kEnumerableProperty,
      referrerPolicy: kEnumerableProperty,
      referrer: kEnumerableProperty,
      mode: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "Request",
        configurable: !0
      }
    });
    webidl.converters.Request = webidl.interfaceConverter(
      Request
    );
    webidl.converters.RequestInfo = function(V) {
      return typeof V == "string" ? webidl.converters.USVString(V) : V instanceof Request ? webidl.converters.Request(V) : webidl.converters.USVString(V);
    };
    webidl.converters.AbortSignal = webidl.interfaceConverter(
      AbortSignal
    );
    webidl.converters.RequestInit = webidl.dictionaryConverter([
      {
        key: "method",
        converter: webidl.converters.ByteString
      },
      {
        key: "headers",
        converter: webidl.converters.HeadersInit
      },
      {
        key: "body",
        converter: webidl.nullableConverter(
          webidl.converters.BodyInit
        )
      },
      {
        key: "referrer",
        converter: webidl.converters.USVString
      },
      {
        key: "referrerPolicy",
        converter: webidl.converters.DOMString,
        // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy
        allowedValues: referrerPolicy
      },
      {
        key: "mode",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#concept-request-mode
        allowedValues: requestMode
      },
      {
        key: "credentials",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestcredentials
        allowedValues: requestCredentials
      },
      {
        key: "cache",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestcache
        allowedValues: requestCache
      },
      {
        key: "redirect",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestredirect
        allowedValues: requestRedirect
      },
      {
        key: "integrity",
        converter: webidl.converters.DOMString
      },
      {
        key: "keepalive",
        converter: webidl.converters.boolean
      },
      {
        key: "signal",
        converter: webidl.nullableConverter(
          (signal) => webidl.converters.AbortSignal(
            signal,
            { strict: !1 }
          )
        )
      },
      {
        key: "window",
        converter: webidl.converters.any
      },
      {
        key: "duplex",
        converter: webidl.converters.DOMString,
        allowedValues: requestDuplex
      }
    ]);
    module2.exports = { Request, makeRequest };
  }
});

// node_modules/undici/lib/fetch/index.js
var require_fetch = __commonJS({
  "node_modules/undici/lib/fetch/index.js"(exports2, module2) {
    "use strict";
    var {
      Response,
      makeNetworkError,
      makeAppropriateNetworkError,
      filterResponse,
      makeResponse
    } = require_response(), { Headers } = require_headers(), { Request, makeRequest } = require_request2(), zlib = require("zlib"), {
      bytesMatch,
      makePolicyContainer,
      clonePolicyContainer,
      requestBadPort,
      TAOCheck,
      appendRequestOriginHeader,
      responseLocationURL,
      requestCurrentURL,
      setRequestReferrerPolicyOnRedirect,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      createOpaqueTimingInfo,
      appendFetchMetadata,
      corsCheck,
      crossOriginResourcePolicyCheck,
      determineRequestsReferrer,
      coarsenedSharedCurrentTime,
      createDeferredPromise,
      isBlobLike,
      sameOrigin,
      isCancelled,
      isAborted,
      isErrorLike,
      fullyReadBody,
      readableStreamClose,
      isomorphicEncode,
      urlIsLocal,
      urlIsHttpHttpsScheme,
      urlHasHttpsScheme
    } = require_util2(), { kState, kHeaders, kGuard, kRealm } = require_symbols2(), assert3 = require("assert"), { safelyExtractBody } = require_body(), {
      redirectStatusSet,
      nullBodyStatus,
      safeMethodsSet,
      requestBodyHeader,
      subresourceSet,
      DOMException: DOMException2
    } = require_constants2(), { kHeadersList } = require_symbols(), EE3 = require("events"), { Readable, pipeline } = require("stream"), { addAbortListener, isErrored, isReadable: isReadable2, nodeMajor, nodeMinor } = require_util(), { dataURLProcessor, serializeAMimeType } = require_dataURL(), { TransformStream } = require("stream/web"), { getGlobalDispatcher } = require_global2(), { webidl } = require_webidl(), { STATUS_CODES } = require("http"), GET_OR_HEAD = ["GET", "HEAD"], resolveObjectURL, ReadableStream = globalThis.ReadableStream, Fetch = class extends EE3 {
      constructor(dispatcher) {
        super(), this.dispatcher = dispatcher, this.connection = null, this.dump = !1, this.state = "ongoing", this.setMaxListeners(21);
      }
      terminate(reason) {
        this.state === "ongoing" && (this.state = "terminated", this.connection?.destroy(reason), this.emit("terminated", reason));
      }
      // https://fetch.spec.whatwg.org/#fetch-controller-abort
      abort(error) {
        this.state === "ongoing" && (this.state = "aborted", error || (error = new DOMException2("The operation was aborted.", "AbortError")), this.serializedAbortReason = error, this.connection?.destroy(error), this.emit("terminated", error));
      }
    };
    function fetch2(input, init = {}) {
      webidl.argumentLengthCheck(arguments, 1, { header: "globalThis.fetch" });
      let p = createDeferredPromise(), requestObject;
      try {
        requestObject = new Request(input, init);
      } catch (e) {
        return p.reject(e), p.promise;
      }
      let request = requestObject[kState];
      if (requestObject.signal.aborted)
        return abortFetch(p, request, null, requestObject.signal.reason), p.promise;
      request.client.globalObject?.constructor?.name === "ServiceWorkerGlobalScope" && (request.serviceWorkers = "none");
      let responseObject = null, relevantRealm = null, locallyAborted = !1, controller = null;
      return addAbortListener(
        requestObject.signal,
        () => {
          locallyAborted = !0, assert3(controller != null), controller.abort(requestObject.signal.reason), abortFetch(p, request, responseObject, requestObject.signal.reason);
        }
      ), controller = fetching({
        request,
        processResponseEndOfBody: (response) => finalizeAndReportTiming(response, "fetch"),
        processResponse: (response) => {
          if (locallyAborted)
            return Promise.resolve();
          if (response.aborted)
            return abortFetch(p, request, responseObject, controller.serializedAbortReason), Promise.resolve();
          if (response.type === "error")
            return p.reject(
              Object.assign(new TypeError("fetch failed"), { cause: response.error })
            ), Promise.resolve();
          responseObject = new Response(), responseObject[kState] = response, responseObject[kRealm] = relevantRealm, responseObject[kHeaders][kHeadersList] = response.headersList, responseObject[kHeaders][kGuard] = "immutable", responseObject[kHeaders][kRealm] = relevantRealm, p.resolve(responseObject);
        },
        dispatcher: init.dispatcher ?? getGlobalDispatcher()
        // undici
      }), p.promise;
    }
    function finalizeAndReportTiming(response, initiatorType = "other") {
      if (response.type === "error" && response.aborted || !response.urlList?.length)
        return;
      let originalURL = response.urlList[0], timingInfo = response.timingInfo, cacheState = response.cacheState;
      urlIsHttpHttpsScheme(originalURL) && timingInfo !== null && (response.timingAllowPassed || (timingInfo = createOpaqueTimingInfo({
        startTime: timingInfo.startTime
      }), cacheState = ""), timingInfo.endTime = coarsenedSharedCurrentTime(), response.timingInfo = timingInfo, markResourceTiming(
        timingInfo,
        originalURL,
        initiatorType,
        globalThis,
        cacheState
      ));
    }
    function markResourceTiming(timingInfo, originalURL, initiatorType, globalThis2, cacheState) {
      (nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 2) && performance.markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis2, cacheState);
    }
    function abortFetch(p, request, responseObject, error) {
      if (error || (error = new DOMException2("The operation was aborted.", "AbortError")), p.reject(error), request.body != null && isReadable2(request.body?.stream) && request.body.stream.cancel(error).catch((err) => {
        if (err.code !== "ERR_INVALID_STATE")
          throw err;
      }), responseObject == null)
        return;
      let response = responseObject[kState];
      response.body != null && isReadable2(response.body?.stream) && response.body.stream.cancel(error).catch((err) => {
        if (err.code !== "ERR_INVALID_STATE")
          throw err;
      });
    }
    function fetching({
      request,
      processRequestBodyChunkLength,
      processRequestEndOfBody,
      processResponse,
      processResponseEndOfBody,
      processResponseConsumeBody,
      useParallelQueue = !1,
      dispatcher
      // undici
    }) {
      let taskDestination = null, crossOriginIsolatedCapability = !1;
      request.client != null && (taskDestination = request.client.globalObject, crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability);
      let currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability), timingInfo = createOpaqueTimingInfo({
        startTime: currenTime
      }), fetchParams = {
        controller: new Fetch(dispatcher),
        request,
        timingInfo,
        processRequestBodyChunkLength,
        processRequestEndOfBody,
        processResponse,
        processResponseConsumeBody,
        processResponseEndOfBody,
        taskDestination,
        crossOriginIsolatedCapability
      };
      return assert3(!request.body || request.body.stream), request.window === "client" && (request.window = request.client?.globalObject?.constructor?.name === "Window" ? request.client : "no-window"), request.origin === "client" && (request.origin = request.client?.origin), request.policyContainer === "client" && (request.client != null ? request.policyContainer = clonePolicyContainer(
        request.client.policyContainer
      ) : request.policyContainer = makePolicyContainer()), request.headersList.contains("accept") || request.headersList.append("accept", "*/*"), request.headersList.contains("accept-language") || request.headersList.append("accept-language", "*"), request.priority, subresourceSet.has(request.destination), mainFetch(fetchParams).catch((err) => {
        fetchParams.controller.terminate(err);
      }), fetchParams.controller;
    }
    async function mainFetch(fetchParams, recursive = !1) {
      let request = fetchParams.request, response = null;
      if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request)) && (response = makeNetworkError("local URLs only")), tryUpgradeRequestToAPotentiallyTrustworthyURL(request), requestBadPort(request) === "blocked" && (response = makeNetworkError("bad port")), request.referrerPolicy === "" && (request.referrerPolicy = request.policyContainer.referrerPolicy), request.referrer !== "no-referrer" && (request.referrer = determineRequestsReferrer(request)), response === null && (response = await (async () => {
        let currentURL = requestCurrentURL(request);
        return (
          // - request’s current URL’s origin is same origin with request’s origin,
          //   and request’s response tainting is "basic"
          sameOrigin(currentURL, request.url) && request.responseTainting === "basic" || // request’s current URL’s scheme is "data"
          currentURL.protocol === "data:" || // - request’s mode is "navigate" or "websocket"
          request.mode === "navigate" || request.mode === "websocket" ? (request.responseTainting = "basic", await schemeFetch(fetchParams)) : request.mode === "same-origin" ? makeNetworkError('request mode cannot be "same-origin"') : request.mode === "no-cors" ? request.redirect !== "follow" ? makeNetworkError(
            'redirect mode cannot be "follow" for "no-cors" request'
          ) : (request.responseTainting = "opaque", await schemeFetch(fetchParams)) : urlIsHttpHttpsScheme(requestCurrentURL(request)) ? (request.responseTainting = "cors", await httpFetch(fetchParams)) : makeNetworkError("URL scheme must be a HTTP(S) scheme")
        );
      })()), recursive)
        return response;
      response.status !== 0 && !response.internalResponse && (request.responseTainting, request.responseTainting === "basic" ? response = filterResponse(response, "basic") : request.responseTainting === "cors" ? response = filterResponse(response, "cors") : request.responseTainting === "opaque" ? response = filterResponse(response, "opaque") : assert3(!1));
      let internalResponse = response.status === 0 ? response : response.internalResponse;
      if (internalResponse.urlList.length === 0 && internalResponse.urlList.push(...request.urlList), request.timingAllowFailed || (response.timingAllowPassed = !0), response.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request.headers.contains("range") && (response = internalResponse = makeNetworkError()), response.status !== 0 && (request.method === "HEAD" || request.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status)) && (internalResponse.body = null, fetchParams.controller.dump = !0), request.integrity) {
        let processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
        if (request.responseTainting === "opaque" || response.body == null) {
          processBodyError(response.error);
          return;
        }
        let processBody = (bytes) => {
          if (!bytesMatch(bytes, request.integrity)) {
            processBodyError("integrity mismatch");
            return;
          }
          response.body = safelyExtractBody(bytes)[0], fetchFinale(fetchParams, response);
        };
        await fullyReadBody(response.body, processBody, processBodyError);
      } else
        fetchFinale(fetchParams, response);
    }
    function schemeFetch(fetchParams) {
      if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0)
        return Promise.resolve(makeAppropriateNetworkError(fetchParams));
      let { request } = fetchParams, { protocol: scheme } = requestCurrentURL(request);
      switch (scheme) {
        case "about:":
          return Promise.resolve(makeNetworkError("about scheme is not supported"));
        case "blob:": {
          resolveObjectURL || (resolveObjectURL = require("buffer").resolveObjectURL);
          let blobURLEntry = requestCurrentURL(request);
          if (blobURLEntry.search.length !== 0)
            return Promise.resolve(makeNetworkError("NetworkError when attempting to fetch resource."));
          let blobURLEntryObject = resolveObjectURL(blobURLEntry.toString());
          if (request.method !== "GET" || !isBlobLike(blobURLEntryObject))
            return Promise.resolve(makeNetworkError("invalid method"));
          let bodyWithType = safelyExtractBody(blobURLEntryObject), body = bodyWithType[0], length = isomorphicEncode(`${body.length}`), type = bodyWithType[1] ?? "", response = makeResponse({
            statusText: "OK",
            headersList: [
              ["content-length", { name: "Content-Length", value: length }],
              ["content-type", { name: "Content-Type", value: type }]
            ]
          });
          return response.body = body, Promise.resolve(response);
        }
        case "data:": {
          let currentURL = requestCurrentURL(request), dataURLStruct = dataURLProcessor(currentURL);
          if (dataURLStruct === "failure")
            return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
          let mimeType = serializeAMimeType(dataURLStruct.mimeType);
          return Promise.resolve(makeResponse({
            statusText: "OK",
            headersList: [
              ["content-type", { name: "Content-Type", value: mimeType }]
            ],
            body: safelyExtractBody(dataURLStruct.body)[0]
          }));
        }
        case "file:":
          return Promise.resolve(makeNetworkError("not implemented... yet..."));
        case "http:":
        case "https:":
          return httpFetch(fetchParams).catch((err) => makeNetworkError(err));
        default:
          return Promise.resolve(makeNetworkError("unknown scheme"));
      }
    }
    function finalizeResponse(fetchParams, response) {
      fetchParams.request.done = !0, fetchParams.processResponseDone != null && queueMicrotask(() => fetchParams.processResponseDone(response));
    }
    function fetchFinale(fetchParams, response) {
      response.type === "error" && (response.urlList = [fetchParams.request.urlList[0]], response.timingInfo = createOpaqueTimingInfo({
        startTime: fetchParams.timingInfo.startTime
      }));
      let processResponseEndOfBody = () => {
        fetchParams.request.done = !0, fetchParams.processResponseEndOfBody != null && queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
      };
      if (fetchParams.processResponse != null && queueMicrotask(() => fetchParams.processResponse(response)), response.body == null)
        processResponseEndOfBody();
      else {
        let identityTransformAlgorithm = (chunk, controller) => {
          controller.enqueue(chunk);
        }, transformStream = new TransformStream({
          start() {
          },
          transform: identityTransformAlgorithm,
          flush: processResponseEndOfBody
        }, {
          size() {
            return 1;
          }
        }, {
          size() {
            return 1;
          }
        });
        response.body = { stream: response.body.stream.pipeThrough(transformStream) };
      }
      if (fetchParams.processResponseConsumeBody != null) {
        let processBody = (nullOrBytes) => fetchParams.processResponseConsumeBody(response, nullOrBytes), processBodyError = (failure) => fetchParams.processResponseConsumeBody(response, failure);
        if (response.body == null)
          queueMicrotask(() => processBody(null));
        else
          return fullyReadBody(response.body, processBody, processBodyError);
        return Promise.resolve();
      }
    }
    async function httpFetch(fetchParams) {
      let request = fetchParams.request, response = null, actualResponse = null, timingInfo = fetchParams.timingInfo;
      if (request.serviceWorkers, response === null) {
        if (request.redirect === "follow" && (request.serviceWorkers = "none"), actualResponse = response = await httpNetworkOrCacheFetch(fetchParams), request.responseTainting === "cors" && corsCheck(request, response) === "failure")
          return makeNetworkError("cors failure");
        TAOCheck(request, response) === "failure" && (request.timingAllowFailed = !0);
      }
      return (request.responseTainting === "opaque" || response.type === "opaque") && crossOriginResourcePolicyCheck(
        request.origin,
        request.client,
        request.destination,
        actualResponse
      ) === "blocked" ? makeNetworkError("blocked") : (redirectStatusSet.has(actualResponse.status) && (request.redirect !== "manual" && fetchParams.controller.connection.destroy(), request.redirect === "error" ? response = makeNetworkError("unexpected redirect") : request.redirect === "manual" ? response = actualResponse : request.redirect === "follow" ? response = await httpRedirectFetch(fetchParams, response) : assert3(!1)), response.timingInfo = timingInfo, response);
    }
    function httpRedirectFetch(fetchParams, response) {
      let request = fetchParams.request, actualResponse = response.internalResponse ? response.internalResponse : response, locationURL;
      try {
        if (locationURL = responseLocationURL(
          actualResponse,
          requestCurrentURL(request).hash
        ), locationURL == null)
          return response;
      } catch (err) {
        return Promise.resolve(makeNetworkError(err));
      }
      if (!urlIsHttpHttpsScheme(locationURL))
        return Promise.resolve(makeNetworkError("URL scheme must be a HTTP(S) scheme"));
      if (request.redirectCount === 20)
        return Promise.resolve(makeNetworkError("redirect count exceeded"));
      if (request.redirectCount += 1, request.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request, locationURL))
        return Promise.resolve(makeNetworkError('cross origin not allowed for request mode "cors"'));
      if (request.responseTainting === "cors" && (locationURL.username || locationURL.password))
        return Promise.resolve(makeNetworkError(
          'URL cannot contain credentials for request mode "cors"'
        ));
      if (actualResponse.status !== 303 && request.body != null && request.body.source == null)
        return Promise.resolve(makeNetworkError());
      if ([301, 302].includes(actualResponse.status) && request.method === "POST" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request.method)) {
        request.method = "GET", request.body = null;
        for (let headerName of requestBodyHeader)
          request.headersList.delete(headerName);
      }
      sameOrigin(requestCurrentURL(request), locationURL) || (request.headersList.delete("authorization"), request.headersList.delete("proxy-authorization", !0), request.headersList.delete("cookie"), request.headersList.delete("host")), request.body != null && (assert3(request.body.source != null), request.body = safelyExtractBody(request.body.source)[0]);
      let timingInfo = fetchParams.timingInfo;
      return timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability), timingInfo.redirectStartTime === 0 && (timingInfo.redirectStartTime = timingInfo.startTime), request.urlList.push(locationURL), setRequestReferrerPolicyOnRedirect(request, actualResponse), mainFetch(fetchParams, !0);
    }
    async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = !1, isNewConnectionFetch = !1) {
      let request = fetchParams.request, httpFetchParams = null, httpRequest = null, response = null, httpCache = null, revalidatingFlag = !1;
      request.window === "no-window" && request.redirect === "error" ? (httpFetchParams = fetchParams, httpRequest = request) : (httpRequest = makeRequest(request), httpFetchParams = { ...fetchParams }, httpFetchParams.request = httpRequest);
      let includeCredentials = request.credentials === "include" || request.credentials === "same-origin" && request.responseTainting === "basic", contentLength = httpRequest.body ? httpRequest.body.length : null, contentLengthHeaderValue = null;
      if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method) && (contentLengthHeaderValue = "0"), contentLength != null && (contentLengthHeaderValue = isomorphicEncode(`${contentLength}`)), contentLengthHeaderValue != null && httpRequest.headersList.append("content-length", contentLengthHeaderValue), contentLength != null && httpRequest.keepalive, httpRequest.referrer instanceof URL && httpRequest.headersList.append("referer", isomorphicEncode(httpRequest.referrer.href)), appendRequestOriginHeader(httpRequest), appendFetchMetadata(httpRequest), httpRequest.headersList.contains("user-agent") || httpRequest.headersList.append("user-agent", typeof esbuildDetection > "u" ? "undici" : "node"), httpRequest.cache === "default" && (httpRequest.headersList.contains("if-modified-since") || httpRequest.headersList.contains("if-none-match") || httpRequest.headersList.contains("if-unmodified-since") || httpRequest.headersList.contains("if-match") || httpRequest.headersList.contains("if-range")) && (httpRequest.cache = "no-store"), httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains("cache-control") && httpRequest.headersList.append("cache-control", "max-age=0"), (httpRequest.cache === "no-store" || httpRequest.cache === "reload") && (httpRequest.headersList.contains("pragma") || httpRequest.headersList.append("pragma", "no-cache"), httpRequest.headersList.contains("cache-control") || httpRequest.headersList.append("cache-control", "no-cache")), httpRequest.headersList.contains("range") && httpRequest.headersList.append("accept-encoding", "identity"), httpRequest.headersList.contains("accept-encoding") || (urlHasHttpsScheme(requestCurrentURL(httpRequest)) ? httpRequest.headersList.append("accept-encoding", "br, gzip, deflate") : httpRequest.headersList.append("accept-encoding", "gzip, deflate")), httpRequest.headersList.delete("host"), httpCache == null && (httpRequest.cache = "no-store"), httpRequest.mode !== "no-store" && httpRequest.mode, response == null) {
        if (httpRequest.mode === "only-if-cached")
          return makeNetworkError("only if cached");
        let forwardResponse = await httpNetworkFetch(
          httpFetchParams,
          includeCredentials,
          isNewConnectionFetch
        );
        !safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399, revalidatingFlag && forwardResponse.status, response == null && (response = forwardResponse);
      }
      if (response.urlList = [...httpRequest.urlList], httpRequest.headersList.contains("range") && (response.rangeRequested = !0), response.requestIncludesCredentials = includeCredentials, response.status === 407)
        return request.window === "no-window" ? makeNetworkError() : isCancelled(fetchParams) ? makeAppropriateNetworkError(fetchParams) : makeNetworkError("proxy authentication required");
      if (
        // response’s status is 421
        response.status === 421 && // isNewConnectionFetch is false
        !isNewConnectionFetch && // request’s body is null, or request’s body is non-null and request’s body’s source is non-null
        (request.body == null || request.body.source != null)
      ) {
        if (isCancelled(fetchParams))
          return makeAppropriateNetworkError(fetchParams);
        fetchParams.controller.connection.destroy(), response = await httpNetworkOrCacheFetch(
          fetchParams,
          isAuthenticationFetch,
          !0
        );
      }
      return response;
    }
    async function httpNetworkFetch(fetchParams, includeCredentials = !1, forceNewConnection = !1) {
      assert3(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed), fetchParams.controller.connection = {
        abort: null,
        destroyed: !1,
        destroy(err) {
          this.destroyed || (this.destroyed = !0, this.abort?.(err ?? new DOMException2("The operation was aborted.", "AbortError")));
        }
      };
      let request = fetchParams.request, response = null, timingInfo = fetchParams.timingInfo;
      null == null && (request.cache = "no-store");
      let newConnection = forceNewConnection ? "yes" : "no";
      request.mode;
      let requestBody = null;
      if (request.body == null && fetchParams.processRequestEndOfBody)
        queueMicrotask(() => fetchParams.processRequestEndOfBody());
      else if (request.body != null) {
        let processBodyChunk = async function* (bytes) {
          isCancelled(fetchParams) || (yield bytes, fetchParams.processRequestBodyChunkLength?.(bytes.byteLength));
        }, processEndOfBody = () => {
          isCancelled(fetchParams) || fetchParams.processRequestEndOfBody && fetchParams.processRequestEndOfBody();
        }, processBodyError = (e) => {
          isCancelled(fetchParams) || (e.name === "AbortError" ? fetchParams.controller.abort() : fetchParams.controller.terminate(e));
        };
        requestBody = async function* () {
          try {
            for await (let bytes of request.body.stream)
              yield* processBodyChunk(bytes);
            processEndOfBody();
          } catch (err) {
            processBodyError(err);
          }
        }();
      }
      try {
        let { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody });
        if (socket)
          response = makeResponse({ status, statusText, headersList, socket });
        else {
          let iterator = body[Symbol.asyncIterator]();
          fetchParams.controller.next = () => iterator.next(), response = makeResponse({ status, statusText, headersList });
        }
      } catch (err) {
        return err.name === "AbortError" ? (fetchParams.controller.connection.destroy(), makeAppropriateNetworkError(fetchParams, err)) : makeNetworkError(err);
      }
      let pullAlgorithm = () => {
        fetchParams.controller.resume();
      }, cancelAlgorithm = (reason) => {
        fetchParams.controller.abort(reason);
      };
      ReadableStream || (ReadableStream = require("stream/web").ReadableStream);
      let stream = new ReadableStream(
        {
          async start(controller) {
            fetchParams.controller.controller = controller;
          },
          async pull(controller) {
            await pullAlgorithm(controller);
          },
          async cancel(reason) {
            await cancelAlgorithm(reason);
          }
        },
        {
          highWaterMark: 0,
          size() {
            return 1;
          }
        }
      );
      response.body = { stream }, fetchParams.controller.on("terminated", onAborted), fetchParams.controller.resume = async () => {
        for (; ; ) {
          let bytes, isFailure;
          try {
            let { done, value } = await fetchParams.controller.next();
            if (isAborted(fetchParams))
              break;
            bytes = done ? void 0 : value;
          } catch (err) {
            fetchParams.controller.ended && !timingInfo.encodedBodySize ? bytes = void 0 : (bytes = err, isFailure = !0);
          }
          if (bytes === void 0) {
            readableStreamClose(fetchParams.controller.controller), finalizeResponse(fetchParams, response);
            return;
          }
          if (timingInfo.decodedBodySize += bytes?.byteLength ?? 0, isFailure) {
            fetchParams.controller.terminate(bytes);
            return;
          }
          if (fetchParams.controller.controller.enqueue(new Uint8Array(bytes)), isErrored(stream)) {
            fetchParams.controller.terminate();
            return;
          }
          if (!fetchParams.controller.controller.desiredSize)
            return;
        }
      };
      function onAborted(reason) {
        isAborted(fetchParams) ? (response.aborted = !0, isReadable2(stream) && fetchParams.controller.controller.error(
          fetchParams.controller.serializedAbortReason
        )) : isReadable2(stream) && fetchParams.controller.controller.error(new TypeError("terminated", {
          cause: isErrorLike(reason) ? reason : void 0
        })), fetchParams.controller.connection.destroy();
      }
      return response;
      async function dispatch({ body }) {
        let url = requestCurrentURL(request), agent = fetchParams.controller.dispatcher;
        return new Promise((resolve2, reject) => agent.dispatch(
          {
            path: url.pathname + url.search,
            origin: url.origin,
            method: request.method,
            body: fetchParams.controller.dispatcher.isMockActive ? request.body && (request.body.source || request.body.stream) : body,
            headers: request.headersList.entries,
            maxRedirections: 0,
            upgrade: request.mode === "websocket" ? "websocket" : void 0
          },
          {
            body: null,
            abort: null,
            onConnect(abort) {
              let { connection } = fetchParams.controller;
              connection.destroyed ? abort(new DOMException2("The operation was aborted.", "AbortError")) : (fetchParams.controller.on("terminated", abort), this.abort = connection.abort = abort);
            },
            onHeaders(status, headersList, resume, statusText) {
              if (status < 200)
                return;
              let codings = [], location = "", headers = new Headers();
              if (Array.isArray(headersList))
                for (let n = 0; n < headersList.length; n += 2) {
                  let key = headersList[n + 0].toString("latin1"), val = headersList[n + 1].toString("latin1");
                  key.toLowerCase() === "content-encoding" ? codings = val.toLowerCase().split(",").map((x) => x.trim()) : key.toLowerCase() === "location" && (location = val), headers[kHeadersList].append(key, val);
                }
              else {
                let keys = Object.keys(headersList);
                for (let key of keys) {
                  let val = headersList[key];
                  key.toLowerCase() === "content-encoding" ? codings = val.toLowerCase().split(",").map((x) => x.trim()).reverse() : key.toLowerCase() === "location" && (location = val), headers[kHeadersList].append(key, val);
                }
              }
              this.body = new Readable({ read: resume });
              let decoders = [], willFollow = request.redirect === "follow" && location && redirectStatusSet.has(status);
              if (request.method !== "HEAD" && request.method !== "CONNECT" && !nullBodyStatus.includes(status) && !willFollow)
                for (let coding of codings)
                  if (coding === "x-gzip" || coding === "gzip")
                    decoders.push(zlib.createGunzip({
                      // Be less strict when decoding compressed responses, since sometimes
                      // servers send slightly invalid responses that are still accepted
                      // by common browsers.
                      // Always using Z_SYNC_FLUSH is what cURL does.
                      flush: zlib.constants.Z_SYNC_FLUSH,
                      finishFlush: zlib.constants.Z_SYNC_FLUSH
                    }));
                  else if (coding === "deflate")
                    decoders.push(zlib.createInflate());
                  else if (coding === "br")
                    decoders.push(zlib.createBrotliDecompress());
                  else {
                    decoders.length = 0;
                    break;
                  }
              return resolve2({
                status,
                statusText,
                headersList: headers[kHeadersList],
                body: decoders.length ? pipeline(this.body, ...decoders, () => {
                }) : this.body.on("error", () => {
                })
              }), !0;
            },
            onData(chunk) {
              if (fetchParams.controller.dump)
                return;
              let bytes = chunk;
              return timingInfo.encodedBodySize += bytes.byteLength, this.body.push(bytes);
            },
            onComplete() {
              this.abort && fetchParams.controller.off("terminated", this.abort), fetchParams.controller.ended = !0, this.body.push(null);
            },
            onError(error) {
              this.abort && fetchParams.controller.off("terminated", this.abort), this.body?.destroy(error), fetchParams.controller.terminate(error), reject(error);
            },
            onUpgrade(status, headersList, socket) {
              if (status !== 101)
                return;
              let headers = new Headers();
              for (let n = 0; n < headersList.length; n += 2) {
                let key = headersList[n + 0].toString("latin1"), val = headersList[n + 1].toString("latin1");
                headers[kHeadersList].append(key, val);
              }
              return resolve2({
                status,
                statusText: STATUS_CODES[status],
                headersList: headers[kHeadersList],
                socket
              }), !0;
            }
          }
        ));
      }
    }
    module2.exports = {
      fetch: fetch2,
      Fetch,
      fetching,
      finalizeAndReportTiming
    };
  }
});

// node_modules/undici/lib/fileapi/symbols.js
var require_symbols3 = __commonJS({
  "node_modules/undici/lib/fileapi/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kState: Symbol("FileReader state"),
      kResult: Symbol("FileReader result"),
      kError: Symbol("FileReader error"),
      kLastProgressEventFired: Symbol("FileReader last progress event fired timestamp"),
      kEvents: Symbol("FileReader events"),
      kAborted: Symbol("FileReader aborted")
    };
  }
});

// node_modules/undici/lib/fileapi/progressevent.js
var require_progressevent = __commonJS({
  "node_modules/undici/lib/fileapi/progressevent.js"(exports2, module2) {
    "use strict";
    var { webidl } = require_webidl(), kState = Symbol("ProgressEvent state"), ProgressEvent = class _ProgressEvent extends Event {
      constructor(type, eventInitDict = {}) {
        type = webidl.converters.DOMString(type), eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {}), super(type, eventInitDict), this[kState] = {
          lengthComputable: eventInitDict.lengthComputable,
          loaded: eventInitDict.loaded,
          total: eventInitDict.total
        };
      }
      get lengthComputable() {
        return webidl.brandCheck(this, _ProgressEvent), this[kState].lengthComputable;
      }
      get loaded() {
        return webidl.brandCheck(this, _ProgressEvent), this[kState].loaded;
      }
      get total() {
        return webidl.brandCheck(this, _ProgressEvent), this[kState].total;
      }
    };
    webidl.converters.ProgressEventInit = webidl.dictionaryConverter([
      {
        key: "lengthComputable",
        converter: webidl.converters.boolean,
        defaultValue: !1
      },
      {
        key: "loaded",
        converter: webidl.converters["unsigned long long"],
        defaultValue: 0
      },
      {
        key: "total",
        converter: webidl.converters["unsigned long long"],
        defaultValue: 0
      },
      {
        key: "bubbles",
        converter: webidl.converters.boolean,
        defaultValue: !1
      },
      {
        key: "cancelable",
        converter: webidl.converters.boolean,
        defaultValue: !1
      },
      {
        key: "composed",
        converter: webidl.converters.boolean,
        defaultValue: !1
      }
    ]);
    module2.exports = {
      ProgressEvent
    };
  }
});

// node_modules/undici/lib/fileapi/encoding.js
var require_encoding = __commonJS({
  "node_modules/undici/lib/fileapi/encoding.js"(exports2, module2) {
    "use strict";
    function getEncoding(label) {
      if (!label)
        return "failure";
      switch (label.trim().toLowerCase()) {
        case "unicode-1-1-utf-8":
        case "unicode11utf8":
        case "unicode20utf8":
        case "utf-8":
        case "utf8":
        case "x-unicode20utf8":
          return "UTF-8";
        case "866":
        case "cp866":
        case "csibm866":
        case "ibm866":
          return "IBM866";
        case "csisolatin2":
        case "iso-8859-2":
        case "iso-ir-101":
        case "iso8859-2":
        case "iso88592":
        case "iso_8859-2":
        case "iso_8859-2:1987":
        case "l2":
        case "latin2":
          return "ISO-8859-2";
        case "csisolatin3":
        case "iso-8859-3":
        case "iso-ir-109":
        case "iso8859-3":
        case "iso88593":
        case "iso_8859-3":
        case "iso_8859-3:1988":
        case "l3":
        case "latin3":
          return "ISO-8859-3";
        case "csisolatin4":
        case "iso-8859-4":
        case "iso-ir-110":
        case "iso8859-4":
        case "iso88594":
        case "iso_8859-4":
        case "iso_8859-4:1988":
        case "l4":
        case "latin4":
          return "ISO-8859-4";
        case "csisolatincyrillic":
        case "cyrillic":
        case "iso-8859-5":
        case "iso-ir-144":
        case "iso8859-5":
        case "iso88595":
        case "iso_8859-5":
        case "iso_8859-5:1988":
          return "ISO-8859-5";
        case "arabic":
        case "asmo-708":
        case "csiso88596e":
        case "csiso88596i":
        case "csisolatinarabic":
        case "ecma-114":
        case "iso-8859-6":
        case "iso-8859-6-e":
        case "iso-8859-6-i":
        case "iso-ir-127":
        case "iso8859-6":
        case "iso88596":
        case "iso_8859-6":
        case "iso_8859-6:1987":
          return "ISO-8859-6";
        case "csisolatingreek":
        case "ecma-118":
        case "elot_928":
        case "greek":
        case "greek8":
        case "iso-8859-7":
        case "iso-ir-126":
        case "iso8859-7":
        case "iso88597":
        case "iso_8859-7":
        case "iso_8859-7:1987":
        case "sun_eu_greek":
          return "ISO-8859-7";
        case "csiso88598e":
        case "csisolatinhebrew":
        case "hebrew":
        case "iso-8859-8":
        case "iso-8859-8-e":
        case "iso-ir-138":
        case "iso8859-8":
        case "iso88598":
        case "iso_8859-8":
        case "iso_8859-8:1988":
        case "visual":
          return "ISO-8859-8";
        case "csiso88598i":
        case "iso-8859-8-i":
        case "logical":
          return "ISO-8859-8-I";
        case "csisolatin6":
        case "iso-8859-10":
        case "iso-ir-157":
        case "iso8859-10":
        case "iso885910":
        case "l6":
        case "latin6":
          return "ISO-8859-10";
        case "iso-8859-13":
        case "iso8859-13":
        case "iso885913":
          return "ISO-8859-13";
        case "iso-8859-14":
        case "iso8859-14":
        case "iso885914":
          return "ISO-8859-14";
        case "csisolatin9":
        case "iso-8859-15":
        case "iso8859-15":
        case "iso885915":
        case "iso_8859-15":
        case "l9":
          return "ISO-8859-15";
        case "iso-8859-16":
          return "ISO-8859-16";
        case "cskoi8r":
        case "koi":
        case "koi8":
        case "koi8-r":
        case "koi8_r":
          return "KOI8-R";
        case "koi8-ru":
        case "koi8-u":
          return "KOI8-U";
        case "csmacintosh":
        case "mac":
        case "macintosh":
        case "x-mac-roman":
          return "macintosh";
        case "iso-8859-11":
        case "iso8859-11":
        case "iso885911":
        case "tis-620":
        case "windows-874":
          return "windows-874";
        case "cp1250":
        case "windows-1250":
        case "x-cp1250":
          return "windows-1250";
        case "cp1251":
        case "windows-1251":
        case "x-cp1251":
          return "windows-1251";
        case "ansi_x3.4-1968":
        case "ascii":
        case "cp1252":
        case "cp819":
        case "csisolatin1":
        case "ibm819":
        case "iso-8859-1":
        case "iso-ir-100":
        case "iso8859-1":
        case "iso88591":
        case "iso_8859-1":
        case "iso_8859-1:1987":
        case "l1":
        case "latin1":
        case "us-ascii":
        case "windows-1252":
        case "x-cp1252":
          return "windows-1252";
        case "cp1253":
        case "windows-1253":
        case "x-cp1253":
          return "windows-1253";
        case "cp1254":
        case "csisolatin5":
        case "iso-8859-9":
        case "iso-ir-148":
        case "iso8859-9":
        case "iso88599":
        case "iso_8859-9":
        case "iso_8859-9:1989":
        case "l5":
        case "latin5":
        case "windows-1254":
        case "x-cp1254":
          return "windows-1254";
        case "cp1255":
        case "windows-1255":
        case "x-cp1255":
          return "windows-1255";
        case "cp1256":
        case "windows-1256":
        case "x-cp1256":
          return "windows-1256";
        case "cp1257":
        case "windows-1257":
        case "x-cp1257":
          return "windows-1257";
        case "cp1258":
        case "windows-1258":
        case "x-cp1258":
          return "windows-1258";
        case "x-mac-cyrillic":
        case "x-mac-ukrainian":
          return "x-mac-cyrillic";
        case "chinese":
        case "csgb2312":
        case "csiso58gb231280":
        case "gb2312":
        case "gb_2312":
        case "gb_2312-80":
        case "gbk":
        case "iso-ir-58":
        case "x-gbk":
          return "GBK";
        case "gb18030":
          return "gb18030";
        case "big5":
        case "big5-hkscs":
        case "cn-big5":
        case "csbig5":
        case "x-x-big5":
          return "Big5";
        case "cseucpkdfmtjapanese":
        case "euc-jp":
        case "x-euc-jp":
          return "EUC-JP";
        case "csiso2022jp":
        case "iso-2022-jp":
          return "ISO-2022-JP";
        case "csshiftjis":
        case "ms932":
        case "ms_kanji":
        case "shift-jis":
        case "shift_jis":
        case "sjis":
        case "windows-31j":
        case "x-sjis":
          return "Shift_JIS";
        case "cseuckr":
        case "csksc56011987":
        case "euc-kr":
        case "iso-ir-149":
        case "korean":
        case "ks_c_5601-1987":
        case "ks_c_5601-1989":
        case "ksc5601":
        case "ksc_5601":
        case "windows-949":
          return "EUC-KR";
        case "csiso2022kr":
        case "hz-gb-2312":
        case "iso-2022-cn":
        case "iso-2022-cn-ext":
        case "iso-2022-kr":
        case "replacement":
          return "replacement";
        case "unicodefffe":
        case "utf-16be":
          return "UTF-16BE";
        case "csunicode":
        case "iso-10646-ucs-2":
        case "ucs-2":
        case "unicode":
        case "unicodefeff":
        case "utf-16":
        case "utf-16le":
          return "UTF-16LE";
        case "x-user-defined":
          return "x-user-defined";
        default:
          return "failure";
      }
    }
    module2.exports = {
      getEncoding
    };
  }
});

// node_modules/undici/lib/fileapi/util.js
var require_util4 = __commonJS({
  "node_modules/undici/lib/fileapi/util.js"(exports2, module2) {
    "use strict";
    var {
      kState,
      kError,
      kResult,
      kAborted,
      kLastProgressEventFired
    } = require_symbols3(), { ProgressEvent } = require_progressevent(), { getEncoding } = require_encoding(), { DOMException: DOMException2 } = require_constants2(), { serializeAMimeType, parseMIMEType } = require_dataURL(), { types } = require("util"), { StringDecoder: StringDecoder2 } = require("string_decoder"), { btoa } = require("buffer"), staticPropertyDescriptors = {
      enumerable: !0,
      writable: !1,
      configurable: !1
    };
    function readOperation(fr, blob, type, encodingName) {
      if (fr[kState] === "loading")
        throw new DOMException2("Invalid state", "InvalidStateError");
      fr[kState] = "loading", fr[kResult] = null, fr[kError] = null;
      let reader = blob.stream().getReader(), bytes = [], chunkPromise = reader.read(), isFirstChunk = !0;
      (async () => {
        for (; !fr[kAborted]; )
          try {
            let { done, value } = await chunkPromise;
            if (isFirstChunk && !fr[kAborted] && queueMicrotask(() => {
              fireAProgressEvent("loadstart", fr);
            }), isFirstChunk = !1, !done && types.isUint8Array(value))
              bytes.push(value), (fr[kLastProgressEventFired] === void 0 || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted] && (fr[kLastProgressEventFired] = Date.now(), queueMicrotask(() => {
                fireAProgressEvent("progress", fr);
              })), chunkPromise = reader.read();
            else if (done) {
              queueMicrotask(() => {
                fr[kState] = "done";
                try {
                  let result = packageData(bytes, type, blob.type, encodingName);
                  if (fr[kAborted])
                    return;
                  fr[kResult] = result, fireAProgressEvent("load", fr);
                } catch (error) {
                  fr[kError] = error, fireAProgressEvent("error", fr);
                }
                fr[kState] !== "loading" && fireAProgressEvent("loadend", fr);
              });
              break;
            }
          } catch (error) {
            if (fr[kAborted])
              return;
            queueMicrotask(() => {
              fr[kState] = "done", fr[kError] = error, fireAProgressEvent("error", fr), fr[kState] !== "loading" && fireAProgressEvent("loadend", fr);
            });
            break;
          }
      })();
    }
    function fireAProgressEvent(e, reader) {
      let event = new ProgressEvent(e, {
        bubbles: !1,
        cancelable: !1
      });
      reader.dispatchEvent(event);
    }
    function packageData(bytes, type, mimeType, encodingName) {
      switch (type) {
        case "DataURL": {
          let dataURL = "data:", parsed = parseMIMEType(mimeType || "application/octet-stream");
          parsed !== "failure" && (dataURL += serializeAMimeType(parsed)), dataURL += ";base64,";
          let decoder = new StringDecoder2("latin1");
          for (let chunk of bytes)
            dataURL += btoa(decoder.write(chunk));
          return dataURL += btoa(decoder.end()), dataURL;
        }
        case "Text": {
          let encoding = "failure";
          if (encodingName && (encoding = getEncoding(encodingName)), encoding === "failure" && mimeType) {
            let type2 = parseMIMEType(mimeType);
            type2 !== "failure" && (encoding = getEncoding(type2.parameters.get("charset")));
          }
          return encoding === "failure" && (encoding = "UTF-8"), decode2(bytes, encoding);
        }
        case "ArrayBuffer":
          return combineByteSequences(bytes).buffer;
        case "BinaryString": {
          let binaryString = "", decoder = new StringDecoder2("latin1");
          for (let chunk of bytes)
            binaryString += decoder.write(chunk);
          return binaryString += decoder.end(), binaryString;
        }
      }
    }
    function decode2(ioQueue, encoding) {
      let bytes = combineByteSequences(ioQueue), BOMEncoding = BOMSniffing(bytes), slice = 0;
      BOMEncoding !== null && (encoding = BOMEncoding, slice = BOMEncoding === "UTF-8" ? 3 : 2);
      let sliced = bytes.slice(slice);
      return new TextDecoder(encoding).decode(sliced);
    }
    function BOMSniffing(ioQueue) {
      let [a, b, c] = ioQueue;
      return a === 239 && b === 187 && c === 191 ? "UTF-8" : a === 254 && b === 255 ? "UTF-16BE" : a === 255 && b === 254 ? "UTF-16LE" : null;
    }
    function combineByteSequences(sequences) {
      let size = sequences.reduce((a, b) => a + b.byteLength, 0), offset = 0;
      return sequences.reduce((a, b) => (a.set(b, offset), offset += b.byteLength, a), new Uint8Array(size));
    }
    module2.exports = {
      staticPropertyDescriptors,
      readOperation,
      fireAProgressEvent
    };
  }
});

// node_modules/undici/lib/fileapi/filereader.js
var require_filereader = __commonJS({
  "node_modules/undici/lib/fileapi/filereader.js"(exports2, module2) {
    "use strict";
    var {
      staticPropertyDescriptors,
      readOperation,
      fireAProgressEvent
    } = require_util4(), {
      kState,
      kError,
      kResult,
      kEvents,
      kAborted
    } = require_symbols3(), { webidl } = require_webidl(), { kEnumerableProperty } = require_util(), FileReader = class _FileReader extends EventTarget {
      constructor() {
        super(), this[kState] = "empty", this[kResult] = null, this[kError] = null, this[kEvents] = {
          loadend: null,
          error: null,
          abort: null,
          load: null,
          progress: null,
          loadstart: null
        };
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer
       * @param {import('buffer').Blob} blob
       */
      readAsArrayBuffer(blob) {
        webidl.brandCheck(this, _FileReader), webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsArrayBuffer" }), blob = webidl.converters.Blob(blob, { strict: !1 }), readOperation(this, blob, "ArrayBuffer");
      }
      /**
       * @see https://w3c.github.io/FileAPI/#readAsBinaryString
       * @param {import('buffer').Blob} blob
       */
      readAsBinaryString(blob) {
        webidl.brandCheck(this, _FileReader), webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsBinaryString" }), blob = webidl.converters.Blob(blob, { strict: !1 }), readOperation(this, blob, "BinaryString");
      }
      /**
       * @see https://w3c.github.io/FileAPI/#readAsDataText
       * @param {import('buffer').Blob} blob
       * @param {string?} encoding
       */
      readAsText(blob, encoding = void 0) {
        webidl.brandCheck(this, _FileReader), webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsText" }), blob = webidl.converters.Blob(blob, { strict: !1 }), encoding !== void 0 && (encoding = webidl.converters.DOMString(encoding)), readOperation(this, blob, "Text", encoding);
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL
       * @param {import('buffer').Blob} blob
       */
      readAsDataURL(blob) {
        webidl.brandCheck(this, _FileReader), webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsDataURL" }), blob = webidl.converters.Blob(blob, { strict: !1 }), readOperation(this, blob, "DataURL");
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dfn-abort
       */
      abort() {
        if (this[kState] === "empty" || this[kState] === "done") {
          this[kResult] = null;
          return;
        }
        this[kState] === "loading" && (this[kState] = "done", this[kResult] = null), this[kAborted] = !0, fireAProgressEvent("abort", this), this[kState] !== "loading" && fireAProgressEvent("loadend", this);
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-readystate
       */
      get readyState() {
        switch (webidl.brandCheck(this, _FileReader), this[kState]) {
          case "empty":
            return this.EMPTY;
          case "loading":
            return this.LOADING;
          case "done":
            return this.DONE;
        }
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-result
       */
      get result() {
        return webidl.brandCheck(this, _FileReader), this[kResult];
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-error
       */
      get error() {
        return webidl.brandCheck(this, _FileReader), this[kError];
      }
      get onloadend() {
        return webidl.brandCheck(this, _FileReader), this[kEvents].loadend;
      }
      set onloadend(fn) {
        webidl.brandCheck(this, _FileReader), this[kEvents].loadend && this.removeEventListener("loadend", this[kEvents].loadend), typeof fn == "function" ? (this[kEvents].loadend = fn, this.addEventListener("loadend", fn)) : this[kEvents].loadend = null;
      }
      get onerror() {
        return webidl.brandCheck(this, _FileReader), this[kEvents].error;
      }
      set onerror(fn) {
        webidl.brandCheck(this, _FileReader), this[kEvents].error && this.removeEventListener("error", this[kEvents].error), typeof fn == "function" ? (this[kEvents].error = fn, this.addEventListener("error", fn)) : this[kEvents].error = null;
      }
      get onloadstart() {
        return webidl.brandCheck(this, _FileReader), this[kEvents].loadstart;
      }
      set onloadstart(fn) {
        webidl.brandCheck(this, _FileReader), this[kEvents].loadstart && this.removeEventListener("loadstart", this[kEvents].loadstart), typeof fn == "function" ? (this[kEvents].loadstart = fn, this.addEventListener("loadstart", fn)) : this[kEvents].loadstart = null;
      }
      get onprogress() {
        return webidl.brandCheck(this, _FileReader), this[kEvents].progress;
      }
      set onprogress(fn) {
        webidl.brandCheck(this, _FileReader), this[kEvents].progress && this.removeEventListener("progress", this[kEvents].progress), typeof fn == "function" ? (this[kEvents].progress = fn, this.addEventListener("progress", fn)) : this[kEvents].progress = null;
      }
      get onload() {
        return webidl.brandCheck(this, _FileReader), this[kEvents].load;
      }
      set onload(fn) {
        webidl.brandCheck(this, _FileReader), this[kEvents].load && this.removeEventListener("load", this[kEvents].load), typeof fn == "function" ? (this[kEvents].load = fn, this.addEventListener("load", fn)) : this[kEvents].load = null;
      }
      get onabort() {
        return webidl.brandCheck(this, _FileReader), this[kEvents].abort;
      }
      set onabort(fn) {
        webidl.brandCheck(this, _FileReader), this[kEvents].abort && this.removeEventListener("abort", this[kEvents].abort), typeof fn == "function" ? (this[kEvents].abort = fn, this.addEventListener("abort", fn)) : this[kEvents].abort = null;
      }
    };
    FileReader.EMPTY = FileReader.prototype.EMPTY = 0;
    FileReader.LOADING = FileReader.prototype.LOADING = 1;
    FileReader.DONE = FileReader.prototype.DONE = 2;
    Object.defineProperties(FileReader.prototype, {
      EMPTY: staticPropertyDescriptors,
      LOADING: staticPropertyDescriptors,
      DONE: staticPropertyDescriptors,
      readAsArrayBuffer: kEnumerableProperty,
      readAsBinaryString: kEnumerableProperty,
      readAsText: kEnumerableProperty,
      readAsDataURL: kEnumerableProperty,
      abort: kEnumerableProperty,
      readyState: kEnumerableProperty,
      result: kEnumerableProperty,
      error: kEnumerableProperty,
      onloadstart: kEnumerableProperty,
      onprogress: kEnumerableProperty,
      onload: kEnumerableProperty,
      onabort: kEnumerableProperty,
      onerror: kEnumerableProperty,
      onloadend: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "FileReader",
        writable: !1,
        enumerable: !1,
        configurable: !0
      }
    });
    Object.defineProperties(FileReader, {
      EMPTY: staticPropertyDescriptors,
      LOADING: staticPropertyDescriptors,
      DONE: staticPropertyDescriptors
    });
    module2.exports = {
      FileReader
    };
  }
});

// node_modules/undici/lib/cache/symbols.js
var require_symbols4 = __commonJS({
  "node_modules/undici/lib/cache/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kConstruct: require_symbols().kConstruct
    };
  }
});

// node_modules/undici/lib/cache/util.js
var require_util5 = __commonJS({
  "node_modules/undici/lib/cache/util.js"(exports2, module2) {
    "use strict";
    var assert3 = require("assert"), { URLSerializer } = require_dataURL(), { isValidHeaderName } = require_util2();
    function urlEquals(A, B, excludeFragment = !1) {
      let serializedA = URLSerializer(A, excludeFragment), serializedB = URLSerializer(B, excludeFragment);
      return serializedA === serializedB;
    }
    function fieldValues(header) {
      assert3(header !== null);
      let values = [];
      for (let value of header.split(",")) {
        if (value = value.trim(), value.length) {
          if (!isValidHeaderName(value))
            continue;
        } else continue;
        values.push(value);
      }
      return values;
    }
    module2.exports = {
      urlEquals,
      fieldValues
    };
  }
});

// node_modules/undici/lib/cache/cache.js
var require_cache = __commonJS({
  "node_modules/undici/lib/cache/cache.js"(exports2, module2) {
    "use strict";
    var { kConstruct } = require_symbols4(), { urlEquals, fieldValues: getFieldValues } = require_util5(), { kEnumerableProperty, isDisturbed } = require_util(), { kHeadersList } = require_symbols(), { webidl } = require_webidl(), { Response, cloneResponse } = require_response(), { Request } = require_request2(), { kState, kHeaders, kGuard, kRealm } = require_symbols2(), { fetching } = require_fetch(), { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = require_util2(), assert3 = require("assert"), { getGlobalDispatcher } = require_global2(), Cache = class _Cache {
      /**
       * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list
       * @type {requestResponseList}
       */
      #relevantRequestResponseList;
      constructor() {
        arguments[0] !== kConstruct && webidl.illegalConstructor(), this.#relevantRequestResponseList = arguments[1];
      }
      async match(request, options = {}) {
        webidl.brandCheck(this, _Cache), webidl.argumentLengthCheck(arguments, 1, { header: "Cache.match" }), request = webidl.converters.RequestInfo(request), options = webidl.converters.CacheQueryOptions(options);
        let p = await this.matchAll(request, options);
        if (p.length !== 0)
          return p[0];
      }
      async matchAll(request = void 0, options = {}) {
        webidl.brandCheck(this, _Cache), request !== void 0 && (request = webidl.converters.RequestInfo(request)), options = webidl.converters.CacheQueryOptions(options);
        let r = null;
        if (request !== void 0)
          if (request instanceof Request) {
            if (r = request[kState], r.method !== "GET" && !options.ignoreMethod)
              return [];
          } else typeof request == "string" && (r = new Request(request)[kState]);
        let responses = [];
        if (request === void 0)
          for (let requestResponse of this.#relevantRequestResponseList)
            responses.push(requestResponse[1]);
        else {
          let requestResponses = this.#queryCache(r, options);
          for (let requestResponse of requestResponses)
            responses.push(requestResponse[1]);
        }
        let responseList = [];
        for (let response of responses) {
          let responseObject = new Response(response.body?.source ?? null), body = responseObject[kState].body;
          responseObject[kState] = response, responseObject[kState].body = body, responseObject[kHeaders][kHeadersList] = response.headersList, responseObject[kHeaders][kGuard] = "immutable", responseList.push(responseObject);
        }
        return Object.freeze(responseList);
      }
      async add(request) {
        webidl.brandCheck(this, _Cache), webidl.argumentLengthCheck(arguments, 1, { header: "Cache.add" }), request = webidl.converters.RequestInfo(request);
        let requests = [request];
        return await this.addAll(requests);
      }
      async addAll(requests) {
        webidl.brandCheck(this, _Cache), webidl.argumentLengthCheck(arguments, 1, { header: "Cache.addAll" }), requests = webidl.converters["sequence<RequestInfo>"](requests);
        let responsePromises = [], requestList = [];
        for (let request of requests) {
          if (typeof request == "string")
            continue;
          let r = request[kState];
          if (!urlIsHttpHttpsScheme(r.url) || r.method !== "GET")
            throw webidl.errors.exception({
              header: "Cache.addAll",
              message: "Expected http/s scheme when method is not GET."
            });
        }
        let fetchControllers = [];
        for (let request of requests) {
          let r = new Request(request)[kState];
          if (!urlIsHttpHttpsScheme(r.url))
            throw webidl.errors.exception({
              header: "Cache.addAll",
              message: "Expected http/s scheme."
            });
          r.initiator = "fetch", r.destination = "subresource", requestList.push(r);
          let responsePromise = createDeferredPromise();
          fetchControllers.push(fetching({
            request: r,
            dispatcher: getGlobalDispatcher(),
            processResponse(response) {
              if (response.type === "error" || response.status === 206 || response.status < 200 || response.status > 299)
                responsePromise.reject(webidl.errors.exception({
                  header: "Cache.addAll",
                  message: "Received an invalid status code or the request failed."
                }));
              else if (response.headersList.contains("vary")) {
                let fieldValues = getFieldValues(response.headersList.get("vary"));
                for (let fieldValue of fieldValues)
                  if (fieldValue === "*") {
                    responsePromise.reject(webidl.errors.exception({
                      header: "Cache.addAll",
                      message: "invalid vary field value"
                    }));
                    for (let controller of fetchControllers)
                      controller.abort();
                    return;
                  }
              }
            },
            processResponseEndOfBody(response) {
              if (response.aborted) {
                responsePromise.reject(new DOMException("aborted", "AbortError"));
                return;
              }
              responsePromise.resolve(response);
            }
          })), responsePromises.push(responsePromise.promise);
        }
        let responses = await Promise.all(responsePromises), operations = [], index = 0;
        for (let response of responses) {
          let operation = {
            type: "put",
            // 7.3.2
            request: requestList[index],
            // 7.3.3
            response
            // 7.3.4
          };
          operations.push(operation), index++;
        }
        let cacheJobPromise = createDeferredPromise(), errorData = null;
        try {
          this.#batchCacheOperations(operations);
        } catch (e) {
          errorData = e;
        }
        return queueMicrotask(() => {
          errorData === null ? cacheJobPromise.resolve(void 0) : cacheJobPromise.reject(errorData);
        }), cacheJobPromise.promise;
      }
      async put(request, response) {
        webidl.brandCheck(this, _Cache), webidl.argumentLengthCheck(arguments, 2, { header: "Cache.put" }), request = webidl.converters.RequestInfo(request), response = webidl.converters.Response(response);
        let innerRequest = null;
        if (request instanceof Request ? innerRequest = request[kState] : innerRequest = new Request(request)[kState], !urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== "GET")
          throw webidl.errors.exception({
            header: "Cache.put",
            message: "Expected an http/s scheme when method is not GET"
          });
        let innerResponse = response[kState];
        if (innerResponse.status === 206)
          throw webidl.errors.exception({
            header: "Cache.put",
            message: "Got 206 status"
          });
        if (innerResponse.headersList.contains("vary")) {
          let fieldValues = getFieldValues(innerResponse.headersList.get("vary"));
          for (let fieldValue of fieldValues)
            if (fieldValue === "*")
              throw webidl.errors.exception({
                header: "Cache.put",
                message: "Got * vary field value"
              });
        }
        if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked))
          throw webidl.errors.exception({
            header: "Cache.put",
            message: "Response body is locked or disturbed"
          });
        let clonedResponse = cloneResponse(innerResponse), bodyReadPromise = createDeferredPromise();
        if (innerResponse.body != null) {
          let reader = innerResponse.body.stream.getReader();
          readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);
        } else
          bodyReadPromise.resolve(void 0);
        let operations = [], operation = {
          type: "put",
          // 14.
          request: innerRequest,
          // 15.
          response: clonedResponse
          // 16.
        };
        operations.push(operation);
        let bytes = await bodyReadPromise.promise;
        clonedResponse.body != null && (clonedResponse.body.source = bytes);
        let cacheJobPromise = createDeferredPromise(), errorData = null;
        try {
          this.#batchCacheOperations(operations);
        } catch (e) {
          errorData = e;
        }
        return queueMicrotask(() => {
          errorData === null ? cacheJobPromise.resolve() : cacheJobPromise.reject(errorData);
        }), cacheJobPromise.promise;
      }
      async delete(request, options = {}) {
        webidl.brandCheck(this, _Cache), webidl.argumentLengthCheck(arguments, 1, { header: "Cache.delete" }), request = webidl.converters.RequestInfo(request), options = webidl.converters.CacheQueryOptions(options);
        let r = null;
        if (request instanceof Request) {
          if (r = request[kState], r.method !== "GET" && !options.ignoreMethod)
            return !1;
        } else
          assert3(typeof request == "string"), r = new Request(request)[kState];
        let operations = [], operation = {
          type: "delete",
          request: r,
          options
        };
        operations.push(operation);
        let cacheJobPromise = createDeferredPromise(), errorData = null, requestResponses;
        try {
          requestResponses = this.#batchCacheOperations(operations);
        } catch (e) {
          errorData = e;
        }
        return queueMicrotask(() => {
          errorData === null ? cacheJobPromise.resolve(!!requestResponses?.length) : cacheJobPromise.reject(errorData);
        }), cacheJobPromise.promise;
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys
       * @param {any} request
       * @param {import('../../types/cache').CacheQueryOptions} options
       * @returns {readonly Request[]}
       */
      async keys(request = void 0, options = {}) {
        webidl.brandCheck(this, _Cache), request !== void 0 && (request = webidl.converters.RequestInfo(request)), options = webidl.converters.CacheQueryOptions(options);
        let r = null;
        if (request !== void 0)
          if (request instanceof Request) {
            if (r = request[kState], r.method !== "GET" && !options.ignoreMethod)
              return [];
          } else typeof request == "string" && (r = new Request(request)[kState]);
        let promise = createDeferredPromise(), requests = [];
        if (request === void 0)
          for (let requestResponse of this.#relevantRequestResponseList)
            requests.push(requestResponse[0]);
        else {
          let requestResponses = this.#queryCache(r, options);
          for (let requestResponse of requestResponses)
            requests.push(requestResponse[0]);
        }
        return queueMicrotask(() => {
          let requestList = [];
          for (let request2 of requests) {
            let requestObject = new Request("https://a");
            requestObject[kState] = request2, requestObject[kHeaders][kHeadersList] = request2.headersList, requestObject[kHeaders][kGuard] = "immutable", requestObject[kRealm] = request2.client, requestList.push(requestObject);
          }
          promise.resolve(Object.freeze(requestList));
        }), promise.promise;
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm
       * @param {CacheBatchOperation[]} operations
       * @returns {requestResponseList}
       */
      #batchCacheOperations(operations) {
        let cache = this.#relevantRequestResponseList, backupCache = [...cache], addedItems = [], resultList = [];
        try {
          for (let operation of operations) {
            if (operation.type !== "delete" && operation.type !== "put")
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: 'operation type does not match "delete" or "put"'
              });
            if (operation.type === "delete" && operation.response != null)
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "delete operation should not have an associated response"
              });
            if (this.#queryCache(operation.request, operation.options, addedItems).length)
              throw new DOMException("???", "InvalidStateError");
            let requestResponses;
            if (operation.type === "delete") {
              if (requestResponses = this.#queryCache(operation.request, operation.options), requestResponses.length === 0)
                return [];
              for (let requestResponse of requestResponses) {
                let idx = cache.indexOf(requestResponse);
                assert3(idx !== -1), cache.splice(idx, 1);
              }
            } else if (operation.type === "put") {
              if (operation.response == null)
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "put operation should have an associated response"
                });
              let r = operation.request;
              if (!urlIsHttpHttpsScheme(r.url))
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "expected http or https scheme"
                });
              if (r.method !== "GET")
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "not get method"
                });
              if (operation.options != null)
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "options must not be defined"
                });
              requestResponses = this.#queryCache(operation.request);
              for (let requestResponse of requestResponses) {
                let idx = cache.indexOf(requestResponse);
                assert3(idx !== -1), cache.splice(idx, 1);
              }
              cache.push([operation.request, operation.response]), addedItems.push([operation.request, operation.response]);
            }
            resultList.push([operation.request, operation.response]);
          }
          return resultList;
        } catch (e) {
          throw this.#relevantRequestResponseList.length = 0, this.#relevantRequestResponseList = backupCache, e;
        }
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#query-cache
       * @param {any} requestQuery
       * @param {import('../../types/cache').CacheQueryOptions} options
       * @param {requestResponseList} targetStorage
       * @returns {requestResponseList}
       */
      #queryCache(requestQuery, options, targetStorage) {
        let resultList = [], storage = targetStorage ?? this.#relevantRequestResponseList;
        for (let requestResponse of storage) {
          let [cachedRequest, cachedResponse] = requestResponse;
          this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options) && resultList.push(requestResponse);
        }
        return resultList;
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm
       * @param {any} requestQuery
       * @param {any} request
       * @param {any | null} response
       * @param {import('../../types/cache').CacheQueryOptions | undefined} options
       * @returns {boolean}
       */
      #requestMatchesCachedItem(requestQuery, request, response = null, options) {
        let queryURL = new URL(requestQuery.url), cachedURL = new URL(request.url);
        if (options?.ignoreSearch && (cachedURL.search = "", queryURL.search = ""), !urlEquals(queryURL, cachedURL, !0))
          return !1;
        if (response == null || options?.ignoreVary || !response.headersList.contains("vary"))
          return !0;
        let fieldValues = getFieldValues(response.headersList.get("vary"));
        for (let fieldValue of fieldValues) {
          if (fieldValue === "*")
            return !1;
          let requestValue = request.headersList.get(fieldValue), queryValue = requestQuery.headersList.get(fieldValue);
          if (requestValue !== queryValue)
            return !1;
        }
        return !0;
      }
    };
    Object.defineProperties(Cache.prototype, {
      [Symbol.toStringTag]: {
        value: "Cache",
        configurable: !0
      },
      match: kEnumerableProperty,
      matchAll: kEnumerableProperty,
      add: kEnumerableProperty,
      addAll: kEnumerableProperty,
      put: kEnumerableProperty,
      delete: kEnumerableProperty,
      keys: kEnumerableProperty
    });
    var cacheQueryOptionConverters = [
      {
        key: "ignoreSearch",
        converter: webidl.converters.boolean,
        defaultValue: !1
      },
      {
        key: "ignoreMethod",
        converter: webidl.converters.boolean,
        defaultValue: !1
      },
      {
        key: "ignoreVary",
        converter: webidl.converters.boolean,
        defaultValue: !1
      }
    ];
    webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);
    webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
      ...cacheQueryOptionConverters,
      {
        key: "cacheName",
        converter: webidl.converters.DOMString
      }
    ]);
    webidl.converters.Response = webidl.interfaceConverter(Response);
    webidl.converters["sequence<RequestInfo>"] = webidl.sequenceConverter(
      webidl.converters.RequestInfo
    );
    module2.exports = {
      Cache
    };
  }
});

// node_modules/undici/lib/cache/cachestorage.js
var require_cachestorage = __commonJS({
  "node_modules/undici/lib/cache/cachestorage.js"(exports2, module2) {
    "use strict";
    var { kConstruct } = require_symbols4(), { Cache } = require_cache(), { webidl } = require_webidl(), { kEnumerableProperty } = require_util(), CacheStorage = class _CacheStorage {
      /**
       * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map
       * @type {Map<string, import('./cache').requestResponseList}
       */
      #caches = /* @__PURE__ */ new Map();
      constructor() {
        arguments[0] !== kConstruct && webidl.illegalConstructor();
      }
      async match(request, options = {}) {
        if (webidl.brandCheck(this, _CacheStorage), webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.match" }), request = webidl.converters.RequestInfo(request), options = webidl.converters.MultiCacheQueryOptions(options), options.cacheName != null) {
          if (this.#caches.has(options.cacheName)) {
            let cacheList = this.#caches.get(options.cacheName);
            return await new Cache(kConstruct, cacheList).match(request, options);
          }
        } else
          for (let cacheList of this.#caches.values()) {
            let response = await new Cache(kConstruct, cacheList).match(request, options);
            if (response !== void 0)
              return response;
          }
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-has
       * @param {string} cacheName
       * @returns {Promise<boolean>}
       */
      async has(cacheName) {
        return webidl.brandCheck(this, _CacheStorage), webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.has" }), cacheName = webidl.converters.DOMString(cacheName), this.#caches.has(cacheName);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open
       * @param {string} cacheName
       * @returns {Promise<Cache>}
       */
      async open(cacheName) {
        if (webidl.brandCheck(this, _CacheStorage), webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.open" }), cacheName = webidl.converters.DOMString(cacheName), this.#caches.has(cacheName)) {
          let cache2 = this.#caches.get(cacheName);
          return new Cache(kConstruct, cache2);
        }
        let cache = [];
        return this.#caches.set(cacheName, cache), new Cache(kConstruct, cache);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete
       * @param {string} cacheName
       * @returns {Promise<boolean>}
       */
      async delete(cacheName) {
        return webidl.brandCheck(this, _CacheStorage), webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.delete" }), cacheName = webidl.converters.DOMString(cacheName), this.#caches.delete(cacheName);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys
       * @returns {string[]}
       */
      async keys() {
        return webidl.brandCheck(this, _CacheStorage), [...this.#caches.keys()];
      }
    };
    Object.defineProperties(CacheStorage.prototype, {
      [Symbol.toStringTag]: {
        value: "CacheStorage",
        configurable: !0
      },
      match: kEnumerableProperty,
      has: kEnumerableProperty,
      open: kEnumerableProperty,
      delete: kEnumerableProperty,
      keys: kEnumerableProperty
    });
    module2.exports = {
      CacheStorage
    };
  }
});

// node_modules/undici/lib/cookies/constants.js
var require_constants4 = __commonJS({
  "node_modules/undici/lib/cookies/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      maxAttributeValueSize: 1024,
      maxNameValuePairSize: 4096
    };
  }
});

// node_modules/undici/lib/cookies/util.js
var require_util6 = __commonJS({
  "node_modules/undici/lib/cookies/util.js"(exports2, module2) {
    "use strict";
    var assert3 = require("assert"), { kHeadersList } = require_symbols();
    function isCTLExcludingHtab(value) {
      if (value.length === 0)
        return !1;
      for (let char of value) {
        let code2 = char.charCodeAt(0);
        if (code2 >= 0 || code2 <= 8 || code2 >= 10 || code2 <= 31 || code2 === 127)
          return !1;
      }
    }
    function validateCookieName(name2) {
      for (let char of name2) {
        let code2 = char.charCodeAt(0);
        if (code2 <= 32 || code2 > 127 || char === "(" || char === ")" || char === ">" || char === "<" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}")
          throw new Error("Invalid cookie name");
      }
    }
    function validateCookieValue(value) {
      for (let char of value) {
        let code2 = char.charCodeAt(0);
        if (code2 < 33 || // exclude CTLs (0-31)
        code2 === 34 || code2 === 44 || code2 === 59 || code2 === 92 || code2 > 126)
          throw new Error("Invalid header value");
      }
    }
    function validateCookiePath(path8) {
      for (let char of path8)
        if (char.charCodeAt(0) < 33 || char === ";")
          throw new Error("Invalid cookie path");
    }
    function validateCookieDomain(domain) {
      if (domain.startsWith("-") || domain.endsWith(".") || domain.endsWith("-"))
        throw new Error("Invalid cookie domain");
    }
    function toIMFDate(date) {
      typeof date == "number" && (date = new Date(date));
      let days = [
        "Sun",
        "Mon",
        "Tue",
        "Wed",
        "Thu",
        "Fri",
        "Sat"
      ], months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ], dayName = days[date.getUTCDay()], day = date.getUTCDate().toString().padStart(2, "0"), month = months[date.getUTCMonth()], year = date.getUTCFullYear(), hour = date.getUTCHours().toString().padStart(2, "0"), minute = date.getUTCMinutes().toString().padStart(2, "0"), second = date.getUTCSeconds().toString().padStart(2, "0");
      return `${dayName}, ${day} ${month} ${year} ${hour}:${minute}:${second} GMT`;
    }
    function validateCookieMaxAge(maxAge) {
      if (maxAge < 0)
        throw new Error("Invalid cookie max-age");
    }
    function stringify(cookie) {
      if (cookie.name.length === 0)
        return null;
      validateCookieName(cookie.name), validateCookieValue(cookie.value);
      let out = [`${cookie.name}=${cookie.value}`];
      cookie.name.startsWith("__Secure-") && (cookie.secure = !0), cookie.name.startsWith("__Host-") && (cookie.secure = !0, cookie.domain = null, cookie.path = "/"), cookie.secure && out.push("Secure"), cookie.httpOnly && out.push("HttpOnly"), typeof cookie.maxAge == "number" && (validateCookieMaxAge(cookie.maxAge), out.push(`Max-Age=${cookie.maxAge}`)), cookie.domain && (validateCookieDomain(cookie.domain), out.push(`Domain=${cookie.domain}`)), cookie.path && (validateCookiePath(cookie.path), out.push(`Path=${cookie.path}`)), cookie.expires && cookie.expires.toString() !== "Invalid Date" && out.push(`Expires=${toIMFDate(cookie.expires)}`), cookie.sameSite && out.push(`SameSite=${cookie.sameSite}`);
      for (let part of cookie.unparsed) {
        if (!part.includes("="))
          throw new Error("Invalid unparsed");
        let [key, ...value] = part.split("=");
        out.push(`${key.trim()}=${value.join("=")}`);
      }
      return out.join("; ");
    }
    var kHeadersListNode;
    function getHeadersList(headers) {
      if (headers[kHeadersList])
        return headers[kHeadersList];
      kHeadersListNode || (kHeadersListNode = Object.getOwnPropertySymbols(headers).find(
        (symbol) => symbol.description === "headers list"
      ), assert3(kHeadersListNode, "Headers cannot be parsed"));
      let headersList = headers[kHeadersListNode];
      return assert3(headersList), headersList;
    }
    module2.exports = {
      isCTLExcludingHtab,
      stringify,
      getHeadersList
    };
  }
});

// node_modules/undici/lib/cookies/parse.js
var require_parse = __commonJS({
  "node_modules/undici/lib/cookies/parse.js"(exports2, module2) {
    "use strict";
    var { maxNameValuePairSize, maxAttributeValueSize } = require_constants4(), { isCTLExcludingHtab } = require_util6(), { collectASequenceOfCodePointsFast } = require_dataURL(), assert3 = require("assert");
    function parseSetCookie(header) {
      if (isCTLExcludingHtab(header))
        return null;
      let nameValuePair = "", unparsedAttributes = "", name2 = "", value = "";
      if (header.includes(";")) {
        let position = { position: 0 };
        nameValuePair = collectASequenceOfCodePointsFast(";", header, position), unparsedAttributes = header.slice(position.position);
      } else
        nameValuePair = header;
      if (!nameValuePair.includes("="))
        value = nameValuePair;
      else {
        let position = { position: 0 };
        name2 = collectASequenceOfCodePointsFast(
          "=",
          nameValuePair,
          position
        ), value = nameValuePair.slice(position.position + 1);
      }
      return name2 = name2.trim(), value = value.trim(), name2.length + value.length > maxNameValuePairSize ? null : {
        name: name2,
        value,
        ...parseUnparsedAttributes(unparsedAttributes)
      };
    }
    function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
      if (unparsedAttributes.length === 0)
        return cookieAttributeList;
      assert3(unparsedAttributes[0] === ";"), unparsedAttributes = unparsedAttributes.slice(1);
      let cookieAv = "";
      unparsedAttributes.includes(";") ? (cookieAv = collectASequenceOfCodePointsFast(
        ";",
        unparsedAttributes,
        { position: 0 }
      ), unparsedAttributes = unparsedAttributes.slice(cookieAv.length)) : (cookieAv = unparsedAttributes, unparsedAttributes = "");
      let attributeName = "", attributeValue = "";
      if (cookieAv.includes("=")) {
        let position = { position: 0 };
        attributeName = collectASequenceOfCodePointsFast(
          "=",
          cookieAv,
          position
        ), attributeValue = cookieAv.slice(position.position + 1);
      } else
        attributeName = cookieAv;
      if (attributeName = attributeName.trim(), attributeValue = attributeValue.trim(), attributeValue.length > maxAttributeValueSize)
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      let attributeNameLowercase = attributeName.toLowerCase();
      if (attributeNameLowercase === "expires") {
        let expiryTime = new Date(attributeValue);
        cookieAttributeList.expires = expiryTime;
      } else if (attributeNameLowercase === "max-age") {
        let charCode = attributeValue.charCodeAt(0);
        if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-" || !/^\d+$/.test(attributeValue))
          return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
        let deltaSeconds = Number(attributeValue);
        cookieAttributeList.maxAge = deltaSeconds;
      } else if (attributeNameLowercase === "domain") {
        let cookieDomain = attributeValue;
        cookieDomain[0] === "." && (cookieDomain = cookieDomain.slice(1)), cookieDomain = cookieDomain.toLowerCase(), cookieAttributeList.domain = cookieDomain;
      } else if (attributeNameLowercase === "path") {
        let cookiePath = "";
        attributeValue.length === 0 || attributeValue[0] !== "/" ? cookiePath = "/" : cookiePath = attributeValue, cookieAttributeList.path = cookiePath;
      } else if (attributeNameLowercase === "secure")
        cookieAttributeList.secure = !0;
      else if (attributeNameLowercase === "httponly")
        cookieAttributeList.httpOnly = !0;
      else if (attributeNameLowercase === "samesite") {
        let enforcement = "Default", attributeValueLowercase = attributeValue.toLowerCase();
        attributeValueLowercase.includes("none") && (enforcement = "None"), attributeValueLowercase.includes("strict") && (enforcement = "Strict"), attributeValueLowercase.includes("lax") && (enforcement = "Lax"), cookieAttributeList.sameSite = enforcement;
      } else
        cookieAttributeList.unparsed ??= [], cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
    }
    module2.exports = {
      parseSetCookie,
      parseUnparsedAttributes
    };
  }
});

// node_modules/undici/lib/cookies/index.js
var require_cookies = __commonJS({
  "node_modules/undici/lib/cookies/index.js"(exports2, module2) {
    "use strict";
    var { parseSetCookie } = require_parse(), { stringify, getHeadersList } = require_util6(), { webidl } = require_webidl(), { Headers } = require_headers();
    function getCookies(headers) {
      webidl.argumentLengthCheck(arguments, 1, { header: "getCookies" }), webidl.brandCheck(headers, Headers, { strict: !1 });
      let cookie = headers.get("cookie"), out = {};
      if (!cookie)
        return out;
      for (let piece of cookie.split(";")) {
        let [name2, ...value] = piece.split("=");
        out[name2.trim()] = value.join("=");
      }
      return out;
    }
    function deleteCookie(headers, name2, attributes) {
      webidl.argumentLengthCheck(arguments, 2, { header: "deleteCookie" }), webidl.brandCheck(headers, Headers, { strict: !1 }), name2 = webidl.converters.DOMString(name2), attributes = webidl.converters.DeleteCookieAttributes(attributes), setCookie(headers, {
        name: name2,
        value: "",
        expires: /* @__PURE__ */ new Date(0),
        ...attributes
      });
    }
    function getSetCookies(headers) {
      webidl.argumentLengthCheck(arguments, 1, { header: "getSetCookies" }), webidl.brandCheck(headers, Headers, { strict: !1 });
      let cookies = getHeadersList(headers).cookies;
      return cookies ? cookies.map((pair) => parseSetCookie(Array.isArray(pair) ? pair[1] : pair)) : [];
    }
    function setCookie(headers, cookie) {
      webidl.argumentLengthCheck(arguments, 2, { header: "setCookie" }), webidl.brandCheck(headers, Headers, { strict: !1 }), cookie = webidl.converters.Cookie(cookie), stringify(cookie) && headers.append("Set-Cookie", stringify(cookie));
    }
    webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "path",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "domain",
        defaultValue: null
      }
    ]);
    webidl.converters.Cookie = webidl.dictionaryConverter([
      {
        converter: webidl.converters.DOMString,
        key: "name"
      },
      {
        converter: webidl.converters.DOMString,
        key: "value"
      },
      {
        converter: webidl.nullableConverter((value) => typeof value == "number" ? webidl.converters["unsigned long long"](value) : new Date(value)),
        key: "expires",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters["long long"]),
        key: "maxAge",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "domain",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "path",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.boolean),
        key: "secure",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.boolean),
        key: "httpOnly",
        defaultValue: null
      },
      {
        converter: webidl.converters.USVString,
        key: "sameSite",
        allowedValues: ["Strict", "Lax", "None"]
      },
      {
        converter: webidl.sequenceConverter(webidl.converters.DOMString),
        key: "unparsed",
        defaultValue: []
      }
    ]);
    module2.exports = {
      getCookies,
      deleteCookie,
      getSetCookies,
      setCookie
    };
  }
});

// node_modules/undici/lib/websocket/constants.js
var require_constants5 = __commonJS({
  "node_modules/undici/lib/websocket/constants.js"(exports2, module2) {
    "use strict";
    var uid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11", staticPropertyDescriptors = {
      enumerable: !0,
      writable: !1,
      configurable: !1
    }, states = {
      CONNECTING: 0,
      OPEN: 1,
      CLOSING: 2,
      CLOSED: 3
    }, opcodes = {
      CONTINUATION: 0,
      TEXT: 1,
      BINARY: 2,
      CLOSE: 8,
      PING: 9,
      PONG: 10
    }, maxUnsigned16Bit = 2 ** 16 - 1, parserStates = {
      INFO: 0,
      PAYLOADLENGTH_16: 2,
      PAYLOADLENGTH_64: 3,
      READ_DATA: 4
    }, emptyBuffer = Buffer.allocUnsafe(0);
    module2.exports = {
      uid,
      staticPropertyDescriptors,
      states,
      opcodes,
      maxUnsigned16Bit,
      parserStates,
      emptyBuffer
    };
  }
});

// node_modules/undici/lib/websocket/symbols.js
var require_symbols5 = __commonJS({
  "node_modules/undici/lib/websocket/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kWebSocketURL: Symbol("url"),
      kReadyState: Symbol("ready state"),
      kController: Symbol("controller"),
      kResponse: Symbol("response"),
      kBinaryType: Symbol("binary type"),
      kSentClose: Symbol("sent close"),
      kReceivedClose: Symbol("received close"),
      kByteParser: Symbol("byte parser")
    };
  }
});

// node_modules/undici/lib/websocket/events.js
var require_events = __commonJS({
  "node_modules/undici/lib/websocket/events.js"(exports2, module2) {
    "use strict";
    var { webidl } = require_webidl(), { kEnumerableProperty } = require_util(), { MessagePort } = require("worker_threads"), MessageEvent = class _MessageEvent extends Event {
      #eventInit;
      constructor(type, eventInitDict = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent constructor" }), type = webidl.converters.DOMString(type), eventInitDict = webidl.converters.MessageEventInit(eventInitDict), super(type, eventInitDict), this.#eventInit = eventInitDict;
      }
      get data() {
        return webidl.brandCheck(this, _MessageEvent), this.#eventInit.data;
      }
      get origin() {
        return webidl.brandCheck(this, _MessageEvent), this.#eventInit.origin;
      }
      get lastEventId() {
        return webidl.brandCheck(this, _MessageEvent), this.#eventInit.lastEventId;
      }
      get source() {
        return webidl.brandCheck(this, _MessageEvent), this.#eventInit.source;
      }
      get ports() {
        return webidl.brandCheck(this, _MessageEvent), Object.isFrozen(this.#eventInit.ports) || Object.freeze(this.#eventInit.ports), this.#eventInit.ports;
      }
      initMessageEvent(type, bubbles = !1, cancelable = !1, data = null, origin = "", lastEventId = "", source = null, ports = []) {
        return webidl.brandCheck(this, _MessageEvent), webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent.initMessageEvent" }), new _MessageEvent(type, {
          bubbles,
          cancelable,
          data,
          origin,
          lastEventId,
          source,
          ports
        });
      }
    }, CloseEvent = class _CloseEvent extends Event {
      #eventInit;
      constructor(type, eventInitDict = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: "CloseEvent constructor" }), type = webidl.converters.DOMString(type), eventInitDict = webidl.converters.CloseEventInit(eventInitDict), super(type, eventInitDict), this.#eventInit = eventInitDict;
      }
      get wasClean() {
        return webidl.brandCheck(this, _CloseEvent), this.#eventInit.wasClean;
      }
      get code() {
        return webidl.brandCheck(this, _CloseEvent), this.#eventInit.code;
      }
      get reason() {
        return webidl.brandCheck(this, _CloseEvent), this.#eventInit.reason;
      }
    }, ErrorEvent = class _ErrorEvent extends Event {
      #eventInit;
      constructor(type, eventInitDict) {
        webidl.argumentLengthCheck(arguments, 1, { header: "ErrorEvent constructor" }), super(type, eventInitDict), type = webidl.converters.DOMString(type), eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {}), this.#eventInit = eventInitDict;
      }
      get message() {
        return webidl.brandCheck(this, _ErrorEvent), this.#eventInit.message;
      }
      get filename() {
        return webidl.brandCheck(this, _ErrorEvent), this.#eventInit.filename;
      }
      get lineno() {
        return webidl.brandCheck(this, _ErrorEvent), this.#eventInit.lineno;
      }
      get colno() {
        return webidl.brandCheck(this, _ErrorEvent), this.#eventInit.colno;
      }
      get error() {
        return webidl.brandCheck(this, _ErrorEvent), this.#eventInit.error;
      }
    };
    Object.defineProperties(MessageEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "MessageEvent",
        configurable: !0
      },
      data: kEnumerableProperty,
      origin: kEnumerableProperty,
      lastEventId: kEnumerableProperty,
      source: kEnumerableProperty,
      ports: kEnumerableProperty,
      initMessageEvent: kEnumerableProperty
    });
    Object.defineProperties(CloseEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "CloseEvent",
        configurable: !0
      },
      reason: kEnumerableProperty,
      code: kEnumerableProperty,
      wasClean: kEnumerableProperty
    });
    Object.defineProperties(ErrorEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "ErrorEvent",
        configurable: !0
      },
      message: kEnumerableProperty,
      filename: kEnumerableProperty,
      lineno: kEnumerableProperty,
      colno: kEnumerableProperty,
      error: kEnumerableProperty
    });
    webidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);
    webidl.converters["sequence<MessagePort>"] = webidl.sequenceConverter(
      webidl.converters.MessagePort
    );
    var eventInit = [
      {
        key: "bubbles",
        converter: webidl.converters.boolean,
        defaultValue: !1
      },
      {
        key: "cancelable",
        converter: webidl.converters.boolean,
        defaultValue: !1
      },
      {
        key: "composed",
        converter: webidl.converters.boolean,
        defaultValue: !1
      }
    ];
    webidl.converters.MessageEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "data",
        converter: webidl.converters.any,
        defaultValue: null
      },
      {
        key: "origin",
        converter: webidl.converters.USVString,
        defaultValue: ""
      },
      {
        key: "lastEventId",
        converter: webidl.converters.DOMString,
        defaultValue: ""
      },
      {
        key: "source",
        // Node doesn't implement WindowProxy or ServiceWorker, so the only
        // valid value for source is a MessagePort.
        converter: webidl.nullableConverter(webidl.converters.MessagePort),
        defaultValue: null
      },
      {
        key: "ports",
        converter: webidl.converters["sequence<MessagePort>"],
        get defaultValue() {
          return [];
        }
      }
    ]);
    webidl.converters.CloseEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "wasClean",
        converter: webidl.converters.boolean,
        defaultValue: !1
      },
      {
        key: "code",
        converter: webidl.converters["unsigned short"],
        defaultValue: 0
      },
      {
        key: "reason",
        converter: webidl.converters.USVString,
        defaultValue: ""
      }
    ]);
    webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "message",
        converter: webidl.converters.DOMString,
        defaultValue: ""
      },
      {
        key: "filename",
        converter: webidl.converters.USVString,
        defaultValue: ""
      },
      {
        key: "lineno",
        converter: webidl.converters["unsigned long"],
        defaultValue: 0
      },
      {
        key: "colno",
        converter: webidl.converters["unsigned long"],
        defaultValue: 0
      },
      {
        key: "error",
        converter: webidl.converters.any
      }
    ]);
    module2.exports = {
      MessageEvent,
      CloseEvent,
      ErrorEvent
    };
  }
});

// node_modules/undici/lib/websocket/util.js
var require_util7 = __commonJS({
  "node_modules/undici/lib/websocket/util.js"(exports2, module2) {
    "use strict";
    var { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = require_symbols5(), { states, opcodes } = require_constants5(), { MessageEvent, ErrorEvent } = require_events();
    function isEstablished(ws) {
      return ws[kReadyState] === states.OPEN;
    }
    function isClosing(ws) {
      return ws[kReadyState] === states.CLOSING;
    }
    function isClosed(ws) {
      return ws[kReadyState] === states.CLOSED;
    }
    function fireEvent(e, target, eventConstructor = Event, eventInitDict) {
      let event = new eventConstructor(e, eventInitDict);
      target.dispatchEvent(event);
    }
    function websocketMessageReceived(ws, type, data) {
      if (ws[kReadyState] !== states.OPEN)
        return;
      let dataForEvent;
      if (type === opcodes.TEXT)
        try {
          dataForEvent = new TextDecoder("utf-8", { fatal: !0 }).decode(data);
        } catch {
          failWebsocketConnection(ws, "Received invalid UTF-8 in text frame.");
          return;
        }
      else type === opcodes.BINARY && (ws[kBinaryType] === "blob" ? dataForEvent = new Blob([data]) : dataForEvent = new Uint8Array(data).buffer);
      fireEvent("message", ws, MessageEvent, {
        origin: ws[kWebSocketURL].origin,
        data: dataForEvent
      });
    }
    function isValidSubprotocol(protocol) {
      if (protocol.length === 0)
        return !1;
      for (let char of protocol) {
        let code2 = char.charCodeAt(0);
        if (code2 < 33 || code2 > 126 || char === "(" || char === ")" || char === "<" || char === ">" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}" || code2 === 32 || // SP
        code2 === 9)
          return !1;
      }
      return !0;
    }
    function isValidStatusCode(code2) {
      return code2 >= 1e3 && code2 < 1015 ? code2 !== 1004 && // reserved
      code2 !== 1005 && // "MUST NOT be set as a status code"
      code2 !== 1006 : code2 >= 3e3 && code2 <= 4999;
    }
    function failWebsocketConnection(ws, reason) {
      let { [kController]: controller, [kResponse]: response } = ws;
      controller.abort(), response?.socket && !response.socket.destroyed && response.socket.destroy(), reason && fireEvent("error", ws, ErrorEvent, {
        error: new Error(reason)
      });
    }
    module2.exports = {
      isEstablished,
      isClosing,
      isClosed,
      fireEvent,
      isValidSubprotocol,
      isValidStatusCode,
      failWebsocketConnection,
      websocketMessageReceived
    };
  }
});

// node_modules/undici/lib/websocket/connection.js
var require_connection = __commonJS({
  "node_modules/undici/lib/websocket/connection.js"(exports2, module2) {
    "use strict";
    var diagnosticsChannel = require("diagnostics_channel"), { uid, states } = require_constants5(), {
      kReadyState,
      kSentClose,
      kByteParser,
      kReceivedClose
    } = require_symbols5(), { fireEvent, failWebsocketConnection } = require_util7(), { CloseEvent } = require_events(), { makeRequest } = require_request2(), { fetching } = require_fetch(), { Headers } = require_headers(), { getGlobalDispatcher } = require_global2(), { kHeadersList } = require_symbols(), channels = {};
    channels.open = diagnosticsChannel.channel("undici:websocket:open");
    channels.close = diagnosticsChannel.channel("undici:websocket:close");
    channels.socketError = diagnosticsChannel.channel("undici:websocket:socket_error");
    var crypto;
    try {
      crypto = require("crypto");
    } catch {
    }
    function establishWebSocketConnection(url, protocols, ws, onEstablish, options) {
      let requestURL = url;
      requestURL.protocol = url.protocol === "ws:" ? "http:" : "https:";
      let request = makeRequest({
        urlList: [requestURL],
        serviceWorkers: "none",
        referrer: "no-referrer",
        mode: "websocket",
        credentials: "include",
        cache: "no-store",
        redirect: "error"
      });
      if (options.headers) {
        let headersList = new Headers(options.headers)[kHeadersList];
        request.headersList = headersList;
      }
      let keyValue = crypto.randomBytes(16).toString("base64");
      request.headersList.append("sec-websocket-key", keyValue), request.headersList.append("sec-websocket-version", "13");
      for (let protocol of protocols)
        request.headersList.append("sec-websocket-protocol", protocol);
      let permessageDeflate = "";
      return fetching({
        request,
        useParallelQueue: !0,
        dispatcher: options.dispatcher ?? getGlobalDispatcher(),
        processResponse(response) {
          if (response.type === "error" || response.status !== 101) {
            failWebsocketConnection(ws, "Received network error or non-101 status code.");
            return;
          }
          if (protocols.length !== 0 && !response.headersList.get("Sec-WebSocket-Protocol")) {
            failWebsocketConnection(ws, "Server did not respond with sent protocols.");
            return;
          }
          if (response.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
            failWebsocketConnection(ws, 'Server did not set Upgrade header to "websocket".');
            return;
          }
          if (response.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
            failWebsocketConnection(ws, 'Server did not set Connection header to "upgrade".');
            return;
          }
          let secWSAccept = response.headersList.get("Sec-WebSocket-Accept"), digest = crypto.createHash("sha1").update(keyValue + uid).digest("base64");
          if (secWSAccept !== digest) {
            failWebsocketConnection(ws, "Incorrect hash received in Sec-WebSocket-Accept header.");
            return;
          }
          let secExtension = response.headersList.get("Sec-WebSocket-Extensions");
          if (secExtension !== null && secExtension !== permessageDeflate) {
            failWebsocketConnection(ws, "Received different permessage-deflate than the one set.");
            return;
          }
          let secProtocol = response.headersList.get("Sec-WebSocket-Protocol");
          if (secProtocol !== null && secProtocol !== request.headersList.get("Sec-WebSocket-Protocol")) {
            failWebsocketConnection(ws, "Protocol was not set in the opening handshake.");
            return;
          }
          response.socket.on("data", onSocketData), response.socket.on("close", onSocketClose), response.socket.on("error", onSocketError), channels.open.hasSubscribers && channels.open.publish({
            address: response.socket.address(),
            protocol: secProtocol,
            extensions: secExtension
          }), onEstablish(response);
        }
      });
    }
    function onSocketData(chunk) {
      this.ws[kByteParser].write(chunk) || this.pause();
    }
    function onSocketClose() {
      let { ws } = this, wasClean = ws[kSentClose] && ws[kReceivedClose], code2 = 1005, reason = "", result = ws[kByteParser].closingInfo;
      result ? (code2 = result.code ?? 1005, reason = result.reason) : ws[kSentClose] || (code2 = 1006), ws[kReadyState] = states.CLOSED, fireEvent("close", ws, CloseEvent, {
        wasClean,
        code: code2,
        reason
      }), channels.close.hasSubscribers && channels.close.publish({
        websocket: ws,
        code: code2,
        reason
      });
    }
    function onSocketError(error) {
      let { ws } = this;
      ws[kReadyState] = states.CLOSING, channels.socketError.hasSubscribers && channels.socketError.publish(error), this.destroy();
    }
    module2.exports = {
      establishWebSocketConnection
    };
  }
});

// node_modules/undici/lib/websocket/frame.js
var require_frame = __commonJS({
  "node_modules/undici/lib/websocket/frame.js"(exports2, module2) {
    "use strict";
    var { maxUnsigned16Bit } = require_constants5(), crypto;
    try {
      crypto = require("crypto");
    } catch {
    }
    var WebsocketFrameSend = class {
      /**
       * @param {Buffer|undefined} data
       */
      constructor(data) {
        this.frameData = data, this.maskKey = crypto.randomBytes(4);
      }
      createFrame(opcode) {
        let bodyLength = this.frameData?.byteLength ?? 0, payloadLength = bodyLength, offset = 6;
        bodyLength > maxUnsigned16Bit ? (offset += 8, payloadLength = 127) : bodyLength > 125 && (offset += 2, payloadLength = 126);
        let buffer = Buffer.allocUnsafe(bodyLength + offset);
        buffer[0] = buffer[1] = 0, buffer[0] |= 128, buffer[0] = (buffer[0] & 240) + opcode;
        buffer[offset - 4] = this.maskKey[0], buffer[offset - 3] = this.maskKey[1], buffer[offset - 2] = this.maskKey[2], buffer[offset - 1] = this.maskKey[3], buffer[1] = payloadLength, payloadLength === 126 ? buffer.writeUInt16BE(bodyLength, 2) : payloadLength === 127 && (buffer[2] = buffer[3] = 0, buffer.writeUIntBE(bodyLength, 4, 6)), buffer[1] |= 128;
        for (let i = 0; i < bodyLength; i++)
          buffer[offset + i] = this.frameData[i] ^ this.maskKey[i % 4];
        return buffer;
      }
    };
    module2.exports = {
      WebsocketFrameSend
    };
  }
});

// node_modules/undici/lib/websocket/receiver.js
var require_receiver = __commonJS({
  "node_modules/undici/lib/websocket/receiver.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("stream"), diagnosticsChannel = require("diagnostics_channel"), { parserStates, opcodes, states, emptyBuffer } = require_constants5(), { kReadyState, kSentClose, kResponse, kReceivedClose } = require_symbols5(), { isValidStatusCode, failWebsocketConnection, websocketMessageReceived } = require_util7(), { WebsocketFrameSend } = require_frame(), channels = {};
    channels.ping = diagnosticsChannel.channel("undici:websocket:ping");
    channels.pong = diagnosticsChannel.channel("undici:websocket:pong");
    var ByteParser = class extends Writable {
      #buffers = [];
      #byteOffset = 0;
      #state = parserStates.INFO;
      #info = {};
      #fragments = [];
      constructor(ws) {
        super(), this.ws = ws;
      }
      /**
       * @param {Buffer} chunk
       * @param {() => void} callback
       */
      _write(chunk, _, callback) {
        this.#buffers.push(chunk), this.#byteOffset += chunk.length, this.run(callback);
      }
      /**
       * Runs whenever a new chunk is received.
       * Callback is called whenever there are no more chunks buffering,
       * or not enough bytes are buffered to parse.
       */
      run(callback) {
        for (; ; ) {
          if (this.#state === parserStates.INFO) {
            if (this.#byteOffset < 2)
              return callback();
            let buffer = this.consume(2);
            if (this.#info.fin = (buffer[0] & 128) !== 0, this.#info.opcode = buffer[0] & 15, this.#info.originalOpcode ??= this.#info.opcode, this.#info.fragmented = !this.#info.fin && this.#info.opcode !== opcodes.CONTINUATION, this.#info.fragmented && this.#info.opcode !== opcodes.BINARY && this.#info.opcode !== opcodes.TEXT) {
              failWebsocketConnection(this.ws, "Invalid frame type was fragmented.");
              return;
            }
            let payloadLength = buffer[1] & 127;
            if (payloadLength <= 125 ? (this.#info.payloadLength = payloadLength, this.#state = parserStates.READ_DATA) : payloadLength === 126 ? this.#state = parserStates.PAYLOADLENGTH_16 : payloadLength === 127 && (this.#state = parserStates.PAYLOADLENGTH_64), this.#info.fragmented && payloadLength > 125) {
              failWebsocketConnection(this.ws, "Fragmented frame exceeded 125 bytes.");
              return;
            } else if ((this.#info.opcode === opcodes.PING || this.#info.opcode === opcodes.PONG || this.#info.opcode === opcodes.CLOSE) && payloadLength > 125) {
              failWebsocketConnection(this.ws, "Payload length for control frame exceeded 125 bytes.");
              return;
            } else if (this.#info.opcode === opcodes.CLOSE) {
              if (payloadLength === 1) {
                failWebsocketConnection(this.ws, "Received close frame with a 1-byte body.");
                return;
              }
              let body = this.consume(payloadLength);
              if (this.#info.closeInfo = this.parseCloseBody(!1, body), !this.ws[kSentClose]) {
                let body2 = Buffer.allocUnsafe(2);
                body2.writeUInt16BE(this.#info.closeInfo.code, 0);
                let closeFrame = new WebsocketFrameSend(body2);
                this.ws[kResponse].socket.write(
                  closeFrame.createFrame(opcodes.CLOSE),
                  (err) => {
                    err || (this.ws[kSentClose] = !0);
                  }
                );
              }
              this.ws[kReadyState] = states.CLOSING, this.ws[kReceivedClose] = !0, this.end();
              return;
            } else if (this.#info.opcode === opcodes.PING) {
              let body = this.consume(payloadLength);
              if (!this.ws[kReceivedClose]) {
                let frame = new WebsocketFrameSend(body);
                this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG)), channels.ping.hasSubscribers && channels.ping.publish({
                  payload: body
                });
              }
              if (this.#state = parserStates.INFO, this.#byteOffset > 0)
                continue;
              callback();
              return;
            } else if (this.#info.opcode === opcodes.PONG) {
              let body = this.consume(payloadLength);
              if (channels.pong.hasSubscribers && channels.pong.publish({
                payload: body
              }), this.#byteOffset > 0)
                continue;
              callback();
              return;
            }
          } else if (this.#state === parserStates.PAYLOADLENGTH_16) {
            if (this.#byteOffset < 2)
              return callback();
            let buffer = this.consume(2);
            this.#info.payloadLength = buffer.readUInt16BE(0), this.#state = parserStates.READ_DATA;
          } else if (this.#state === parserStates.PAYLOADLENGTH_64) {
            if (this.#byteOffset < 8)
              return callback();
            let buffer = this.consume(8), upper = buffer.readUInt32BE(0);
            if (upper > 2 ** 31 - 1) {
              failWebsocketConnection(this.ws, "Received payload length > 2^31 bytes.");
              return;
            }
            let lower = buffer.readUInt32BE(4);
            this.#info.payloadLength = (upper << 8) + lower, this.#state = parserStates.READ_DATA;
          } else if (this.#state === parserStates.READ_DATA) {
            if (this.#byteOffset < this.#info.payloadLength)
              return callback();
            if (this.#byteOffset >= this.#info.payloadLength) {
              let body = this.consume(this.#info.payloadLength);
              if (this.#fragments.push(body), !this.#info.fragmented || this.#info.fin && this.#info.opcode === opcodes.CONTINUATION) {
                let fullMessage = Buffer.concat(this.#fragments);
                websocketMessageReceived(this.ws, this.#info.originalOpcode, fullMessage), this.#info = {}, this.#fragments.length = 0;
              }
              this.#state = parserStates.INFO;
            }
          }
          if (!(this.#byteOffset > 0)) {
            callback();
            break;
          }
        }
      }
      /**
       * Take n bytes from the buffered Buffers
       * @param {number} n
       * @returns {Buffer|null}
       */
      consume(n) {
        if (n > this.#byteOffset)
          return null;
        if (n === 0)
          return emptyBuffer;
        if (this.#buffers[0].length === n)
          return this.#byteOffset -= this.#buffers[0].length, this.#buffers.shift();
        let buffer = Buffer.allocUnsafe(n), offset = 0;
        for (; offset !== n; ) {
          let next = this.#buffers[0], { length } = next;
          if (length + offset === n) {
            buffer.set(this.#buffers.shift(), offset);
            break;
          } else if (length + offset > n) {
            buffer.set(next.subarray(0, n - offset), offset), this.#buffers[0] = next.subarray(n - offset);
            break;
          } else
            buffer.set(this.#buffers.shift(), offset), offset += next.length;
        }
        return this.#byteOffset -= n, buffer;
      }
      parseCloseBody(onlyCode, data) {
        let code2;
        if (data.length >= 2 && (code2 = data.readUInt16BE(0)), onlyCode)
          return isValidStatusCode(code2) ? { code: code2 } : null;
        let reason = data.subarray(2);
        if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191 && (reason = reason.subarray(3)), code2 !== void 0 && !isValidStatusCode(code2))
          return null;
        try {
          reason = new TextDecoder("utf-8", { fatal: !0 }).decode(reason);
        } catch {
          return null;
        }
        return { code: code2, reason };
      }
      get closingInfo() {
        return this.#info.closeInfo;
      }
    };
    module2.exports = {
      ByteParser
    };
  }
});

// node_modules/undici/lib/websocket/websocket.js
var require_websocket = __commonJS({
  "node_modules/undici/lib/websocket/websocket.js"(exports2, module2) {
    "use strict";
    var { webidl } = require_webidl(), { DOMException: DOMException2 } = require_constants2(), { URLSerializer } = require_dataURL(), { getGlobalOrigin } = require_global(), { staticPropertyDescriptors, states, opcodes, emptyBuffer } = require_constants5(), {
      kWebSocketURL,
      kReadyState,
      kController,
      kBinaryType,
      kResponse,
      kSentClose,
      kByteParser
    } = require_symbols5(), { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection, fireEvent } = require_util7(), { establishWebSocketConnection } = require_connection(), { WebsocketFrameSend } = require_frame(), { ByteParser } = require_receiver(), { kEnumerableProperty, isBlobLike } = require_util(), { getGlobalDispatcher } = require_global2(), { types } = require("util"), experimentalWarned = !1, WebSocket = class _WebSocket extends EventTarget {
      #events = {
        open: null,
        error: null,
        close: null,
        message: null
      };
      #bufferedAmount = 0;
      #protocol = "";
      #extensions = "";
      /**
       * @param {string} url
       * @param {string|string[]} protocols
       */
      constructor(url, protocols = []) {
        super(), webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket constructor" }), experimentalWarned || (experimentalWarned = !0, process.emitWarning("WebSockets are experimental, expect them to change at any time.", {
          code: "UNDICI-WS"
        }));
        let options = webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"](protocols);
        url = webidl.converters.USVString(url), protocols = options.protocols;
        let baseURL = getGlobalOrigin(), urlRecord;
        try {
          urlRecord = new URL(url, baseURL);
        } catch (e) {
          throw new DOMException2(e, "SyntaxError");
        }
        if (urlRecord.protocol === "http:" ? urlRecord.protocol = "ws:" : urlRecord.protocol === "https:" && (urlRecord.protocol = "wss:"), urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:")
          throw new DOMException2(
            `Expected a ws: or wss: protocol, got ${urlRecord.protocol}`,
            "SyntaxError"
          );
        if (urlRecord.hash || urlRecord.href.endsWith("#"))
          throw new DOMException2("Got fragment", "SyntaxError");
        if (typeof protocols == "string" && (protocols = [protocols]), protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size)
          throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p)))
          throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        this[kWebSocketURL] = new URL(urlRecord.href), this[kController] = establishWebSocketConnection(
          urlRecord,
          protocols,
          this,
          (response) => this.#onConnectionEstablished(response),
          options
        ), this[kReadyState] = _WebSocket.CONNECTING, this[kBinaryType] = "blob";
      }
      /**
       * @see https://websockets.spec.whatwg.org/#dom-websocket-close
       * @param {number|undefined} code
       * @param {string|undefined} reason
       */
      close(code2 = void 0, reason = void 0) {
        if (webidl.brandCheck(this, _WebSocket), code2 !== void 0 && (code2 = webidl.converters["unsigned short"](code2, { clamp: !0 })), reason !== void 0 && (reason = webidl.converters.USVString(reason)), code2 !== void 0 && code2 !== 1e3 && (code2 < 3e3 || code2 > 4999))
          throw new DOMException2("invalid code", "InvalidAccessError");
        let reasonByteLength = 0;
        if (reason !== void 0 && (reasonByteLength = Buffer.byteLength(reason), reasonByteLength > 123))
          throw new DOMException2(
            `Reason must be less than 123 bytes; received ${reasonByteLength}`,
            "SyntaxError"
          );
        if (!(this[kReadyState] === _WebSocket.CLOSING || this[kReadyState] === _WebSocket.CLOSED))
          if (!isEstablished(this))
            failWebsocketConnection(this, "Connection was closed before it was established."), this[kReadyState] = _WebSocket.CLOSING;
          else if (isClosing(this))
            this[kReadyState] = _WebSocket.CLOSING;
          else {
            let frame = new WebsocketFrameSend();
            code2 !== void 0 && reason === void 0 ? (frame.frameData = Buffer.allocUnsafe(2), frame.frameData.writeUInt16BE(code2, 0)) : code2 !== void 0 && reason !== void 0 ? (frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength), frame.frameData.writeUInt16BE(code2, 0), frame.frameData.write(reason, 2, "utf-8")) : frame.frameData = emptyBuffer, this[kResponse].socket.write(frame.createFrame(opcodes.CLOSE), (err) => {
              err || (this[kSentClose] = !0);
            }), this[kReadyState] = states.CLOSING;
          }
      }
      /**
       * @see https://websockets.spec.whatwg.org/#dom-websocket-send
       * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data
       */
      send(data) {
        if (webidl.brandCheck(this, _WebSocket), webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket.send" }), data = webidl.converters.WebSocketSendData(data), this[kReadyState] === _WebSocket.CONNECTING)
          throw new DOMException2("Sent before connected.", "InvalidStateError");
        if (!isEstablished(this) || isClosing(this))
          return;
        let socket = this[kResponse].socket;
        if (typeof data == "string") {
          let value = Buffer.from(data), buffer = new WebsocketFrameSend(value).createFrame(opcodes.TEXT);
          this.#bufferedAmount += value.byteLength, socket.write(buffer, () => {
            this.#bufferedAmount -= value.byteLength;
          });
        } else if (types.isArrayBuffer(data)) {
          let value = Buffer.from(data), buffer = new WebsocketFrameSend(value).createFrame(opcodes.BINARY);
          this.#bufferedAmount += value.byteLength, socket.write(buffer, () => {
            this.#bufferedAmount -= value.byteLength;
          });
        } else if (ArrayBuffer.isView(data)) {
          let ab = Buffer.from(data, data.byteOffset, data.byteLength), buffer = new WebsocketFrameSend(ab).createFrame(opcodes.BINARY);
          this.#bufferedAmount += ab.byteLength, socket.write(buffer, () => {
            this.#bufferedAmount -= ab.byteLength;
          });
        } else if (isBlobLike(data)) {
          let frame = new WebsocketFrameSend();
          data.arrayBuffer().then((ab) => {
            let value = Buffer.from(ab);
            frame.frameData = value;
            let buffer = frame.createFrame(opcodes.BINARY);
            this.#bufferedAmount += value.byteLength, socket.write(buffer, () => {
              this.#bufferedAmount -= value.byteLength;
            });
          });
        }
      }
      get readyState() {
        return webidl.brandCheck(this, _WebSocket), this[kReadyState];
      }
      get bufferedAmount() {
        return webidl.brandCheck(this, _WebSocket), this.#bufferedAmount;
      }
      get url() {
        return webidl.brandCheck(this, _WebSocket), URLSerializer(this[kWebSocketURL]);
      }
      get extensions() {
        return webidl.brandCheck(this, _WebSocket), this.#extensions;
      }
      get protocol() {
        return webidl.brandCheck(this, _WebSocket), this.#protocol;
      }
      get onopen() {
        return webidl.brandCheck(this, _WebSocket), this.#events.open;
      }
      set onopen(fn) {
        webidl.brandCheck(this, _WebSocket), this.#events.open && this.removeEventListener("open", this.#events.open), typeof fn == "function" ? (this.#events.open = fn, this.addEventListener("open", fn)) : this.#events.open = null;
      }
      get onerror() {
        return webidl.brandCheck(this, _WebSocket), this.#events.error;
      }
      set onerror(fn) {
        webidl.brandCheck(this, _WebSocket), this.#events.error && this.removeEventListener("error", this.#events.error), typeof fn == "function" ? (this.#events.error = fn, this.addEventListener("error", fn)) : this.#events.error = null;
      }
      get onclose() {
        return webidl.brandCheck(this, _WebSocket), this.#events.close;
      }
      set onclose(fn) {
        webidl.brandCheck(this, _WebSocket), this.#events.close && this.removeEventListener("close", this.#events.close), typeof fn == "function" ? (this.#events.close = fn, this.addEventListener("close", fn)) : this.#events.close = null;
      }
      get onmessage() {
        return webidl.brandCheck(this, _WebSocket), this.#events.message;
      }
      set onmessage(fn) {
        webidl.brandCheck(this, _WebSocket), this.#events.message && this.removeEventListener("message", this.#events.message), typeof fn == "function" ? (this.#events.message = fn, this.addEventListener("message", fn)) : this.#events.message = null;
      }
      get binaryType() {
        return webidl.brandCheck(this, _WebSocket), this[kBinaryType];
      }
      set binaryType(type) {
        webidl.brandCheck(this, _WebSocket), type !== "blob" && type !== "arraybuffer" ? this[kBinaryType] = "blob" : this[kBinaryType] = type;
      }
      /**
       * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
       */
      #onConnectionEstablished(response) {
        this[kResponse] = response;
        let parser = new ByteParser(this);
        parser.on("drain", function() {
          this.ws[kResponse].socket.resume();
        }), response.socket.ws = this, this[kByteParser] = parser, this[kReadyState] = states.OPEN;
        let extensions = response.headersList.get("sec-websocket-extensions");
        extensions !== null && (this.#extensions = extensions);
        let protocol = response.headersList.get("sec-websocket-protocol");
        protocol !== null && (this.#protocol = protocol), fireEvent("open", this);
      }
    };
    WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
    WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
    WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
    WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;
    Object.defineProperties(WebSocket.prototype, {
      CONNECTING: staticPropertyDescriptors,
      OPEN: staticPropertyDescriptors,
      CLOSING: staticPropertyDescriptors,
      CLOSED: staticPropertyDescriptors,
      url: kEnumerableProperty,
      readyState: kEnumerableProperty,
      bufferedAmount: kEnumerableProperty,
      onopen: kEnumerableProperty,
      onerror: kEnumerableProperty,
      onclose: kEnumerableProperty,
      close: kEnumerableProperty,
      onmessage: kEnumerableProperty,
      binaryType: kEnumerableProperty,
      send: kEnumerableProperty,
      extensions: kEnumerableProperty,
      protocol: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "WebSocket",
        writable: !1,
        enumerable: !1,
        configurable: !0
      }
    });
    Object.defineProperties(WebSocket, {
      CONNECTING: staticPropertyDescriptors,
      OPEN: staticPropertyDescriptors,
      CLOSING: staticPropertyDescriptors,
      CLOSED: staticPropertyDescriptors
    });
    webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(
      webidl.converters.DOMString
    );
    webidl.converters["DOMString or sequence<DOMString>"] = function(V) {
      return webidl.util.Type(V) === "Object" && Symbol.iterator in V ? webidl.converters["sequence<DOMString>"](V) : webidl.converters.DOMString(V);
    };
    webidl.converters.WebSocketInit = webidl.dictionaryConverter([
      {
        key: "protocols",
        converter: webidl.converters["DOMString or sequence<DOMString>"],
        get defaultValue() {
          return [];
        }
      },
      {
        key: "dispatcher",
        converter: (V) => V,
        get defaultValue() {
          return getGlobalDispatcher();
        }
      },
      {
        key: "headers",
        converter: webidl.nullableConverter(webidl.converters.HeadersInit)
      }
    ]);
    webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(V) {
      return webidl.util.Type(V) === "Object" && !(Symbol.iterator in V) ? webidl.converters.WebSocketInit(V) : { protocols: webidl.converters["DOMString or sequence<DOMString>"](V) };
    };
    webidl.converters.WebSocketSendData = function(V) {
      if (webidl.util.Type(V) === "Object") {
        if (isBlobLike(V))
          return webidl.converters.Blob(V, { strict: !1 });
        if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V))
          return webidl.converters.BufferSource(V);
      }
      return webidl.converters.USVString(V);
    };
    module2.exports = {
      WebSocket
    };
  }
});

// node_modules/undici/index.js
var require_undici = __commonJS({
  "node_modules/undici/index.js"(exports2, module2) {
    "use strict";
    var Client = require_client(), Dispatcher = require_dispatcher(), errors = require_errors(), Pool = require_pool(), BalancedPool = require_balanced_pool(), Agent = require_agent(), util = require_util(), { InvalidArgumentError } = errors, api = require_api(), buildConnector = require_connect(), MockClient = require_mock_client(), MockAgent = require_mock_agent(), MockPool = require_mock_pool(), mockErrors = require_mock_errors(), ProxyAgent = require_proxy_agent(), RetryHandler = require_RetryHandler(), { getGlobalDispatcher, setGlobalDispatcher } = require_global2(), DecoratorHandler = require_DecoratorHandler(), RedirectHandler = require_RedirectHandler(), createRedirectInterceptor = require_redirectInterceptor(), hasCrypto;
    try {
      require("crypto"), hasCrypto = !0;
    } catch {
      hasCrypto = !1;
    }
    Object.assign(Dispatcher.prototype, api);
    module2.exports.Dispatcher = Dispatcher;
    module2.exports.Client = Client;
    module2.exports.Pool = Pool;
    module2.exports.BalancedPool = BalancedPool;
    module2.exports.Agent = Agent;
    module2.exports.ProxyAgent = ProxyAgent;
    module2.exports.RetryHandler = RetryHandler;
    module2.exports.DecoratorHandler = DecoratorHandler;
    module2.exports.RedirectHandler = RedirectHandler;
    module2.exports.createRedirectInterceptor = createRedirectInterceptor;
    module2.exports.buildConnector = buildConnector;
    module2.exports.errors = errors;
    function makeDispatcher(fn) {
      return (url, opts, handler) => {
        if (typeof opts == "function" && (handler = opts, opts = null), !url || typeof url != "string" && typeof url != "object" && !(url instanceof URL))
          throw new InvalidArgumentError("invalid url");
        if (opts != null && typeof opts != "object")
          throw new InvalidArgumentError("invalid opts");
        if (opts && opts.path != null) {
          if (typeof opts.path != "string")
            throw new InvalidArgumentError("invalid opts.path");
          let path8 = opts.path;
          opts.path.startsWith("/") || (path8 = `/${path8}`), url = new URL(util.parseOrigin(url).origin + path8);
        } else
          opts || (opts = typeof url == "object" ? url : {}), url = util.parseURL(url);
        let { agent, dispatcher = getGlobalDispatcher() } = opts;
        if (agent)
          throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
        return fn.call(dispatcher, {
          ...opts,
          origin: url.origin,
          path: url.search ? `${url.pathname}${url.search}` : url.pathname,
          method: opts.method || (opts.body ? "PUT" : "GET")
        }, handler);
      };
    }
    module2.exports.setGlobalDispatcher = setGlobalDispatcher;
    module2.exports.getGlobalDispatcher = getGlobalDispatcher;
    if (util.nodeMajor > 16 || util.nodeMajor === 16 && util.nodeMinor >= 8) {
      let fetchImpl = null;
      module2.exports.fetch = async function(resource) {
        fetchImpl || (fetchImpl = require_fetch().fetch);
        try {
          return await fetchImpl(...arguments);
        } catch (err) {
          throw typeof err == "object" && Error.captureStackTrace(err, this), err;
        }
      }, module2.exports.Headers = require_headers().Headers, module2.exports.Response = require_response().Response, module2.exports.Request = require_request2().Request, module2.exports.FormData = require_formdata().FormData, module2.exports.File = require_file().File, module2.exports.FileReader = require_filereader().FileReader;
      let { setGlobalOrigin, getGlobalOrigin } = require_global();
      module2.exports.setGlobalOrigin = setGlobalOrigin, module2.exports.getGlobalOrigin = getGlobalOrigin;
      let { CacheStorage } = require_cachestorage(), { kConstruct } = require_symbols4();
      module2.exports.caches = new CacheStorage(kConstruct);
    }
    if (util.nodeMajor >= 16) {
      let { deleteCookie, getCookies, getSetCookies, setCookie } = require_cookies();
      module2.exports.deleteCookie = deleteCookie, module2.exports.getCookies = getCookies, module2.exports.getSetCookies = getSetCookies, module2.exports.setCookie = setCookie;
      let { parseMIMEType, serializeAMimeType } = require_dataURL();
      module2.exports.parseMIMEType = parseMIMEType, module2.exports.serializeAMimeType = serializeAMimeType;
    }
    if (util.nodeMajor >= 18 && hasCrypto) {
      let { WebSocket } = require_websocket();
      module2.exports.WebSocket = WebSocket;
    }
    module2.exports.request = makeDispatcher(api.request);
    module2.exports.stream = makeDispatcher(api.stream);
    module2.exports.pipeline = makeDispatcher(api.pipeline);
    module2.exports.connect = makeDispatcher(api.connect);
    module2.exports.upgrade = makeDispatcher(api.upgrade);
    module2.exports.MockClient = MockClient;
    module2.exports.MockPool = MockPool;
    module2.exports.MockAgent = MockAgent;
    module2.exports.mockErrors = mockErrors;
  }
});

// node_modules/@actions/http-client/lib/index.js
var require_lib = __commonJS({
  "node_modules/@actions/http-client/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k);
      var desc = Object.getOwnPropertyDescriptor(m, k);
      (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = { enumerable: !0, get: function() {
        return m[k];
      } }), Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: !0, value: v });
    } : function(o, v) {
      o.default = v;
    }), __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) k !== "default" && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
      return __setModuleDefault(result, mod), result;
    }, __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.HttpClient = exports2.isHttps = exports2.HttpClientResponse = exports2.HttpClientError = exports2.getProxyUrl = exports2.MediaTypes = exports2.Headers = exports2.HttpCodes = void 0;
    var http = __importStar(require("http")), https = __importStar(require("https")), pm = __importStar(require_proxy()), tunnel = __importStar(require_tunnel2()), undici_1 = require_undici(), HttpCodes;
    (function(HttpCodes2) {
      HttpCodes2[HttpCodes2.OK = 200] = "OK", HttpCodes2[HttpCodes2.MultipleChoices = 300] = "MultipleChoices", HttpCodes2[HttpCodes2.MovedPermanently = 301] = "MovedPermanently", HttpCodes2[HttpCodes2.ResourceMoved = 302] = "ResourceMoved", HttpCodes2[HttpCodes2.SeeOther = 303] = "SeeOther", HttpCodes2[HttpCodes2.NotModified = 304] = "NotModified", HttpCodes2[HttpCodes2.UseProxy = 305] = "UseProxy", HttpCodes2[HttpCodes2.SwitchProxy = 306] = "SwitchProxy", HttpCodes2[HttpCodes2.TemporaryRedirect = 307] = "TemporaryRedirect", HttpCodes2[HttpCodes2.PermanentRedirect = 308] = "PermanentRedirect", HttpCodes2[HttpCodes2.BadRequest = 400] = "BadRequest", HttpCodes2[HttpCodes2.Unauthorized = 401] = "Unauthorized", HttpCodes2[HttpCodes2.PaymentRequired = 402] = "PaymentRequired", HttpCodes2[HttpCodes2.Forbidden = 403] = "Forbidden", HttpCodes2[HttpCodes2.NotFound = 404] = "NotFound", HttpCodes2[HttpCodes2.MethodNotAllowed = 405] = "MethodNotAllowed", HttpCodes2[HttpCodes2.NotAcceptable = 406] = "NotAcceptable", HttpCodes2[HttpCodes2.ProxyAuthenticationRequired = 407] = "ProxyAuthenticationRequired", HttpCodes2[HttpCodes2.RequestTimeout = 408] = "RequestTimeout", HttpCodes2[HttpCodes2.Conflict = 409] = "Conflict", HttpCodes2[HttpCodes2.Gone = 410] = "Gone", HttpCodes2[HttpCodes2.TooManyRequests = 429] = "TooManyRequests", HttpCodes2[HttpCodes2.InternalServerError = 500] = "InternalServerError", HttpCodes2[HttpCodes2.NotImplemented = 501] = "NotImplemented", HttpCodes2[HttpCodes2.BadGateway = 502] = "BadGateway", HttpCodes2[HttpCodes2.ServiceUnavailable = 503] = "ServiceUnavailable", HttpCodes2[HttpCodes2.GatewayTimeout = 504] = "GatewayTimeout";
    })(HttpCodes || (exports2.HttpCodes = HttpCodes = {}));
    var Headers;
    (function(Headers2) {
      Headers2.Accept = "accept", Headers2.ContentType = "content-type";
    })(Headers || (exports2.Headers = Headers = {}));
    var MediaTypes;
    (function(MediaTypes2) {
      MediaTypes2.ApplicationJson = "application/json";
    })(MediaTypes || (exports2.MediaTypes = MediaTypes = {}));
    function getProxyUrl(serverUrl) {
      let proxyUrl = pm.getProxyUrl(new URL(serverUrl));
      return proxyUrl ? proxyUrl.href : "";
    }
    exports2.getProxyUrl = getProxyUrl;
    var HttpRedirectCodes = [
      HttpCodes.MovedPermanently,
      HttpCodes.ResourceMoved,
      HttpCodes.SeeOther,
      HttpCodes.TemporaryRedirect,
      HttpCodes.PermanentRedirect
    ], HttpResponseRetryCodes = [
      HttpCodes.BadGateway,
      HttpCodes.ServiceUnavailable,
      HttpCodes.GatewayTimeout
    ], RetryableHttpVerbs = ["OPTIONS", "GET", "DELETE", "HEAD"], ExponentialBackoffCeiling = 10, ExponentialBackoffTimeSlice = 5, HttpClientError = class _HttpClientError extends Error {
      constructor(message, statusCode) {
        super(message), this.name = "HttpClientError", this.statusCode = statusCode, Object.setPrototypeOf(this, _HttpClientError.prototype);
      }
    };
    exports2.HttpClientError = HttpClientError;
    var HttpClientResponse = class {
      constructor(message) {
        this.message = message;
      }
      readBody() {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve2) => __awaiter(this, void 0, void 0, function* () {
            let output = Buffer.alloc(0);
            this.message.on("data", (chunk) => {
              output = Buffer.concat([output, chunk]);
            }), this.message.on("end", () => {
              resolve2(output.toString());
            });
          }));
        });
      }
      readBodyBuffer() {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve2) => __awaiter(this, void 0, void 0, function* () {
            let chunks = [];
            this.message.on("data", (chunk) => {
              chunks.push(chunk);
            }), this.message.on("end", () => {
              resolve2(Buffer.concat(chunks));
            });
          }));
        });
      }
    };
    exports2.HttpClientResponse = HttpClientResponse;
    function isHttps(requestUrl) {
      return new URL(requestUrl).protocol === "https:";
    }
    exports2.isHttps = isHttps;
    var HttpClient = class {
      constructor(userAgent2, handlers, requestOptions) {
        this._ignoreSslError = !1, this._allowRedirects = !0, this._allowRedirectDowngrade = !1, this._maxRedirects = 50, this._allowRetries = !1, this._maxRetries = 1, this._keepAlive = !1, this._disposed = !1, this.userAgent = userAgent2, this.handlers = handlers || [], this.requestOptions = requestOptions, requestOptions && (requestOptions.ignoreSslError != null && (this._ignoreSslError = requestOptions.ignoreSslError), this._socketTimeout = requestOptions.socketTimeout, requestOptions.allowRedirects != null && (this._allowRedirects = requestOptions.allowRedirects), requestOptions.allowRedirectDowngrade != null && (this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade), requestOptions.maxRedirects != null && (this._maxRedirects = Math.max(requestOptions.maxRedirects, 0)), requestOptions.keepAlive != null && (this._keepAlive = requestOptions.keepAlive), requestOptions.allowRetries != null && (this._allowRetries = requestOptions.allowRetries), requestOptions.maxRetries != null && (this._maxRetries = requestOptions.maxRetries));
      }
      options(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("OPTIONS", requestUrl, null, additionalHeaders || {});
        });
      }
      get(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("GET", requestUrl, null, additionalHeaders || {});
        });
      }
      del(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("DELETE", requestUrl, null, additionalHeaders || {});
        });
      }
      post(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("POST", requestUrl, data, additionalHeaders || {});
        });
      }
      patch(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("PATCH", requestUrl, data, additionalHeaders || {});
        });
      }
      put(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("PUT", requestUrl, data, additionalHeaders || {});
        });
      }
      head(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("HEAD", requestUrl, null, additionalHeaders || {});
        });
      }
      sendStream(verb, requestUrl, stream, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request(verb, requestUrl, stream, additionalHeaders);
        });
      }
      /**
       * Gets a typed object from an endpoint
       * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
       */
      getJson(requestUrl, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
          let res = yield this.get(requestUrl, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      postJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          let data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson), additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
          let res = yield this.post(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      putJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          let data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson), additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
          let res = yield this.put(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      patchJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          let data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson), additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
          let res = yield this.patch(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      /**
       * Makes a raw http request.
       * All other methods such as get, post, patch, and request ultimately call this.
       * Prefer get, del, post and patch
       */
      request(verb, requestUrl, data, headers) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._disposed)
            throw new Error("Client has already been disposed.");
          let parsedUrl = new URL(requestUrl), info = this._prepareRequest(verb, parsedUrl, headers), maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb) ? this._maxRetries + 1 : 1, numTries = 0, response;
          do {
            if (response = yield this.requestRaw(info, data), response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {
              let authenticationHandler;
              for (let handler of this.handlers)
                if (handler.canHandleAuthentication(response)) {
                  authenticationHandler = handler;
                  break;
                }
              return authenticationHandler ? authenticationHandler.handleAuthentication(this, info, data) : response;
            }
            let redirectsRemaining = this._maxRedirects;
            for (; response.message.statusCode && HttpRedirectCodes.includes(response.message.statusCode) && this._allowRedirects && redirectsRemaining > 0; ) {
              let redirectUrl = response.message.headers.location;
              if (!redirectUrl)
                break;
              let parsedRedirectUrl = new URL(redirectUrl);
              if (parsedUrl.protocol === "https:" && parsedUrl.protocol !== parsedRedirectUrl.protocol && !this._allowRedirectDowngrade)
                throw new Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.");
              if (yield response.readBody(), parsedRedirectUrl.hostname !== parsedUrl.hostname)
                for (let header in headers)
                  header.toLowerCase() === "authorization" && delete headers[header];
              info = this._prepareRequest(verb, parsedRedirectUrl, headers), response = yield this.requestRaw(info, data), redirectsRemaining--;
            }
            if (!response.message.statusCode || !HttpResponseRetryCodes.includes(response.message.statusCode))
              return response;
            numTries += 1, numTries < maxTries && (yield response.readBody(), yield this._performExponentialBackoff(numTries));
          } while (numTries < maxTries);
          return response;
        });
      }
      /**
       * Needs to be called if keepAlive is set to true in request options.
       */
      dispose() {
        this._agent && this._agent.destroy(), this._disposed = !0;
      }
      /**
       * Raw request.
       * @param info
       * @param data
       */
      requestRaw(info, data) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve2, reject) => {
            function callbackForResult(err, res) {
              err ? reject(err) : res ? resolve2(res) : reject(new Error("Unknown error"));
            }
            this.requestRawWithCallback(info, data, callbackForResult);
          });
        });
      }
      /**
       * Raw request with callback.
       * @param info
       * @param data
       * @param onResult
       */
      requestRawWithCallback(info, data, onResult) {
        typeof data == "string" && (info.options.headers || (info.options.headers = {}), info.options.headers["Content-Length"] = Buffer.byteLength(data, "utf8"));
        let callbackCalled = !1;
        function handleResult(err, res) {
          callbackCalled || (callbackCalled = !0, onResult(err, res));
        }
        let req = info.httpModule.request(info.options, (msg) => {
          let res = new HttpClientResponse(msg);
          handleResult(void 0, res);
        }), socket;
        req.on("socket", (sock) => {
          socket = sock;
        }), req.setTimeout(this._socketTimeout || 3 * 6e4, () => {
          socket && socket.end(), handleResult(new Error(`Request timeout: ${info.options.path}`));
        }), req.on("error", function(err) {
          handleResult(err);
        }), data && typeof data == "string" && req.write(data, "utf8"), data && typeof data != "string" ? (data.on("close", function() {
          req.end();
        }), data.pipe(req)) : req.end();
      }
      /**
       * Gets an http agent. This function is useful when you need an http agent that handles
       * routing through a proxy server - depending upon the url and proxy environment variables.
       * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
       */
      getAgent(serverUrl) {
        let parsedUrl = new URL(serverUrl);
        return this._getAgent(parsedUrl);
      }
      getAgentDispatcher(serverUrl) {
        let parsedUrl = new URL(serverUrl), proxyUrl = pm.getProxyUrl(parsedUrl);
        if (proxyUrl && proxyUrl.hostname)
          return this._getProxyAgentDispatcher(parsedUrl, proxyUrl);
      }
      _prepareRequest(method, requestUrl, headers) {
        let info = {};
        info.parsedUrl = requestUrl;
        let usingSsl = info.parsedUrl.protocol === "https:";
        info.httpModule = usingSsl ? https : http;
        let defaultPort = usingSsl ? 443 : 80;
        if (info.options = {}, info.options.host = info.parsedUrl.hostname, info.options.port = info.parsedUrl.port ? parseInt(info.parsedUrl.port) : defaultPort, info.options.path = (info.parsedUrl.pathname || "") + (info.parsedUrl.search || ""), info.options.method = method, info.options.headers = this._mergeHeaders(headers), this.userAgent != null && (info.options.headers["user-agent"] = this.userAgent), info.options.agent = this._getAgent(info.parsedUrl), this.handlers)
          for (let handler of this.handlers)
            handler.prepareRequest(info.options);
        return info;
      }
      _mergeHeaders(headers) {
        return this.requestOptions && this.requestOptions.headers ? Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {})) : lowercaseKeys(headers || {});
      }
      _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
        let clientHeader;
        return this.requestOptions && this.requestOptions.headers && (clientHeader = lowercaseKeys(this.requestOptions.headers)[header]), additionalHeaders[header] || clientHeader || _default;
      }
      _getAgent(parsedUrl) {
        let agent, proxyUrl = pm.getProxyUrl(parsedUrl), useProxy = proxyUrl && proxyUrl.hostname;
        if (this._keepAlive && useProxy && (agent = this._proxyAgent), useProxy || (agent = this._agent), agent)
          return agent;
        let usingSsl = parsedUrl.protocol === "https:", maxSockets = 100;
        if (this.requestOptions && (maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets), proxyUrl && proxyUrl.hostname) {
          let agentOptions = {
            maxSockets,
            keepAlive: this._keepAlive,
            proxy: Object.assign(Object.assign({}, (proxyUrl.username || proxyUrl.password) && {
              proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
            }), { host: proxyUrl.hostname, port: proxyUrl.port })
          }, tunnelAgent, overHttps = proxyUrl.protocol === "https:";
          usingSsl ? tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp : tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp, agent = tunnelAgent(agentOptions), this._proxyAgent = agent;
        }
        if (!agent) {
          let options = { keepAlive: this._keepAlive, maxSockets };
          agent = usingSsl ? new https.Agent(options) : new http.Agent(options), this._agent = agent;
        }
        return usingSsl && this._ignoreSslError && (agent.options = Object.assign(agent.options || {}, {
          rejectUnauthorized: !1
        })), agent;
      }
      _getProxyAgentDispatcher(parsedUrl, proxyUrl) {
        let proxyAgent;
        if (this._keepAlive && (proxyAgent = this._proxyAgentDispatcher), proxyAgent)
          return proxyAgent;
        let usingSsl = parsedUrl.protocol === "https:";
        return proxyAgent = new undici_1.ProxyAgent(Object.assign({ uri: proxyUrl.href, pipelining: this._keepAlive ? 1 : 0 }, (proxyUrl.username || proxyUrl.password) && {
          token: `Basic ${Buffer.from(`${proxyUrl.username}:${proxyUrl.password}`).toString("base64")}`
        })), this._proxyAgentDispatcher = proxyAgent, usingSsl && this._ignoreSslError && (proxyAgent.options = Object.assign(proxyAgent.options.requestTls || {}, {
          rejectUnauthorized: !1
        })), proxyAgent;
      }
      _performExponentialBackoff(retryNumber) {
        return __awaiter(this, void 0, void 0, function* () {
          retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
          let ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
          return new Promise((resolve2) => setTimeout(() => resolve2(), ms));
        });
      }
      _processResponse(res, options) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve2, reject) => __awaiter(this, void 0, void 0, function* () {
            let statusCode = res.message.statusCode || 0, response = {
              statusCode,
              result: null,
              headers: {}
            };
            statusCode === HttpCodes.NotFound && resolve2(response);
            function dateTimeDeserializer(key, value) {
              if (typeof value == "string") {
                let a = new Date(value);
                if (!isNaN(a.valueOf()))
                  return a;
              }
              return value;
            }
            let obj, contents;
            try {
              contents = yield res.readBody(), contents && contents.length > 0 && (options && options.deserializeDates ? obj = JSON.parse(contents, dateTimeDeserializer) : obj = JSON.parse(contents), response.result = obj), response.headers = res.message.headers;
            } catch {
            }
            if (statusCode > 299) {
              let msg;
              obj && obj.message ? msg = obj.message : contents && contents.length > 0 ? msg = contents : msg = `Failed request: (${statusCode})`;
              let err = new HttpClientError(msg, statusCode);
              err.result = response.result, reject(err);
            } else
              resolve2(response);
          }));
        });
      }
    };
    exports2.HttpClient = HttpClient;
    var lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => (c[k.toLowerCase()] = obj[k], c), {});
  }
});

// node_modules/@actions/http-client/lib/auth.js
var require_auth = __commonJS({
  "node_modules/@actions/http-client/lib/auth.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.PersonalAccessTokenCredentialHandler = exports2.BearerCredentialHandler = exports2.BasicCredentialHandler = void 0;
    var BasicCredentialHandler = class {
      constructor(username, password) {
        this.username = username, this.password = password;
      }
      prepareRequest(options) {
        if (!options.headers)
          throw Error("The request has no headers");
        options.headers.Authorization = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString("base64")}`;
      }
      // This handler cannot handle 401
      canHandleAuthentication() {
        return !1;
      }
      handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    };
    exports2.BasicCredentialHandler = BasicCredentialHandler;
    var BearerCredentialHandler = class {
      constructor(token) {
        this.token = token;
      }
      // currently implements pre-authorization
      // TODO: support preAuth = false where it hooks on 401
      prepareRequest(options) {
        if (!options.headers)
          throw Error("The request has no headers");
        options.headers.Authorization = `Bearer ${this.token}`;
      }
      // This handler cannot handle 401
      canHandleAuthentication() {
        return !1;
      }
      handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    };
    exports2.BearerCredentialHandler = BearerCredentialHandler;
    var PersonalAccessTokenCredentialHandler = class {
      constructor(token) {
        this.token = token;
      }
      // currently implements pre-authorization
      // TODO: support preAuth = false where it hooks on 401
      prepareRequest(options) {
        if (!options.headers)
          throw Error("The request has no headers");
        options.headers.Authorization = `Basic ${Buffer.from(`PAT:${this.token}`).toString("base64")}`;
      }
      // This handler cannot handle 401
      canHandleAuthentication() {
        return !1;
      }
      handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    };
    exports2.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
  }
});

// node_modules/@actions/core/lib/oidc-utils.js
var require_oidc_utils = __commonJS({
  "node_modules/@actions/core/lib/oidc-utils.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.OidcClient = void 0;
    var http_client_1 = require_lib(), auth_1 = require_auth(), core_1 = require_core(), OidcClient = class _OidcClient {
      static createHttpClient(allowRetry = !0, maxRetry = 10) {
        let requestOptions = {
          allowRetries: allowRetry,
          maxRetries: maxRetry
        };
        return new http_client_1.HttpClient("actions/oidc-client", [new auth_1.BearerCredentialHandler(_OidcClient.getRequestToken())], requestOptions);
      }
      static getRequestToken() {
        let token = process.env.ACTIONS_ID_TOKEN_REQUEST_TOKEN;
        if (!token)
          throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable");
        return token;
      }
      static getIDTokenUrl() {
        let runtimeUrl = process.env.ACTIONS_ID_TOKEN_REQUEST_URL;
        if (!runtimeUrl)
          throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable");
        return runtimeUrl;
      }
      static getCall(id_token_url) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          let id_token = (_a = (yield _OidcClient.createHttpClient().getJson(id_token_url).catch((error) => {
            throw new Error(`Failed to get ID Token. 
 
        Error Code : ${error.statusCode}
 
        Error Message: ${error.message}`);
          })).result) === null || _a === void 0 ? void 0 : _a.value;
          if (!id_token)
            throw new Error("Response json body do not have ID Token field");
          return id_token;
        });
      }
      static getIDToken(audience) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            let id_token_url = _OidcClient.getIDTokenUrl();
            if (audience) {
              let encodedAudience = encodeURIComponent(audience);
              id_token_url = `${id_token_url}&audience=${encodedAudience}`;
            }
            (0, core_1.debug)(`ID token url is ${id_token_url}`);
            let id_token = yield _OidcClient.getCall(id_token_url);
            return (0, core_1.setSecret)(id_token), id_token;
          } catch (error) {
            throw new Error(`Error message: ${error.message}`);
          }
        });
      }
    };
    exports2.OidcClient = OidcClient;
  }
});

// node_modules/@actions/core/lib/summary.js
var require_summary = __commonJS({
  "node_modules/@actions/core/lib/summary.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.summary = exports2.markdownSummary = exports2.SUMMARY_DOCS_URL = exports2.SUMMARY_ENV_VAR = void 0;
    var os_1 = require("os"), fs_1 = require("fs"), { access, appendFile, writeFile } = fs_1.promises;
    exports2.SUMMARY_ENV_VAR = "GITHUB_STEP_SUMMARY";
    exports2.SUMMARY_DOCS_URL = "https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary";
    var Summary = class {
      constructor() {
        this._buffer = "";
      }
      /**
       * Finds the summary file path from the environment, rejects if env var is not found or file does not exist
       * Also checks r/w permissions.
       *
       * @returns step summary file path
       */
      filePath() {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._filePath)
            return this._filePath;
          let pathFromEnv = process.env[exports2.SUMMARY_ENV_VAR];
          if (!pathFromEnv)
            throw new Error(`Unable to find environment variable for $${exports2.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
          try {
            yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
          } catch {
            throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
          }
          return this._filePath = pathFromEnv, this._filePath;
        });
      }
      /**
       * Wraps content in an HTML tag, adding any HTML attributes
       *
       * @param {string} tag HTML tag to wrap
       * @param {string | null} content content within the tag
       * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
       *
       * @returns {string} content wrapped in HTML element
       */
      wrap(tag, content, attrs = {}) {
        let htmlAttrs = Object.entries(attrs).map(([key, value]) => ` ${key}="${value}"`).join("");
        return content ? `<${tag}${htmlAttrs}>${content}</${tag}>` : `<${tag}${htmlAttrs}>`;
      }
      /**
       * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
       *
       * @param {SummaryWriteOptions} [options] (optional) options for write operation
       *
       * @returns {Promise<Summary>} summary instance
       */
      write(options) {
        return __awaiter(this, void 0, void 0, function* () {
          let overwrite = !!options?.overwrite, filePath = yield this.filePath();
          return yield (overwrite ? writeFile : appendFile)(filePath, this._buffer, { encoding: "utf8" }), this.emptyBuffer();
        });
      }
      /**
       * Clears the summary buffer and wipes the summary file
       *
       * @returns {Summary} summary instance
       */
      clear() {
        return __awaiter(this, void 0, void 0, function* () {
          return this.emptyBuffer().write({ overwrite: !0 });
        });
      }
      /**
       * Returns the current summary buffer as a string
       *
       * @returns {string} string of summary buffer
       */
      stringify() {
        return this._buffer;
      }
      /**
       * If the summary buffer is empty
       *
       * @returns {boolen} true if the buffer is empty
       */
      isEmptyBuffer() {
        return this._buffer.length === 0;
      }
      /**
       * Resets the summary buffer without writing to summary file
       *
       * @returns {Summary} summary instance
       */
      emptyBuffer() {
        return this._buffer = "", this;
      }
      /**
       * Adds raw text to the summary buffer
       *
       * @param {string} text content to add
       * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
       *
       * @returns {Summary} summary instance
       */
      addRaw(text, addEOL = !1) {
        return this._buffer += text, addEOL ? this.addEOL() : this;
      }
      /**
       * Adds the operating system-specific end-of-line marker to the buffer
       *
       * @returns {Summary} summary instance
       */
      addEOL() {
        return this.addRaw(os_1.EOL);
      }
      /**
       * Adds an HTML codeblock to the summary buffer
       *
       * @param {string} code content to render within fenced code block
       * @param {string} lang (optional) language to syntax highlight code
       *
       * @returns {Summary} summary instance
       */
      addCodeBlock(code2, lang) {
        let attrs = Object.assign({}, lang && { lang }), element = this.wrap("pre", this.wrap("code", code2), attrs);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML list to the summary buffer
       *
       * @param {string[]} items list of items to render
       * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
       *
       * @returns {Summary} summary instance
       */
      addList(items, ordered = !1) {
        let tag = ordered ? "ol" : "ul", listItems = items.map((item) => this.wrap("li", item)).join(""), element = this.wrap(tag, listItems);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML table to the summary buffer
       *
       * @param {SummaryTableCell[]} rows table rows
       *
       * @returns {Summary} summary instance
       */
      addTable(rows) {
        let tableBody = rows.map((row) => {
          let cells = row.map((cell) => {
            if (typeof cell == "string")
              return this.wrap("td", cell);
            let { header, data, colspan, rowspan } = cell, tag = header ? "th" : "td", attrs = Object.assign(Object.assign({}, colspan && { colspan }), rowspan && { rowspan });
            return this.wrap(tag, data, attrs);
          }).join("");
          return this.wrap("tr", cells);
        }).join(""), element = this.wrap("table", tableBody);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds a collapsable HTML details element to the summary buffer
       *
       * @param {string} label text for the closed state
       * @param {string} content collapsable content
       *
       * @returns {Summary} summary instance
       */
      addDetails(label, content) {
        let element = this.wrap("details", this.wrap("summary", label) + content);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML image tag to the summary buffer
       *
       * @param {string} src path to the image you to embed
       * @param {string} alt text description of the image
       * @param {SummaryImageOptions} options (optional) addition image attributes
       *
       * @returns {Summary} summary instance
       */
      addImage(src, alt, options) {
        let { width, height } = options || {}, attrs = Object.assign(Object.assign({}, width && { width }), height && { height }), element = this.wrap("img", null, Object.assign({ src, alt }, attrs));
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML section heading element
       *
       * @param {string} text heading text
       * @param {number | string} [level=1] (optional) the heading level, default: 1
       *
       * @returns {Summary} summary instance
       */
      addHeading(text, level) {
        let tag = `h${level}`, allowedTag = ["h1", "h2", "h3", "h4", "h5", "h6"].includes(tag) ? tag : "h1", element = this.wrap(allowedTag, text);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML thematic break (<hr>) to the summary buffer
       *
       * @returns {Summary} summary instance
       */
      addSeparator() {
        let element = this.wrap("hr", null);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML line break (<br>) to the summary buffer
       *
       * @returns {Summary} summary instance
       */
      addBreak() {
        let element = this.wrap("br", null);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML blockquote to the summary buffer
       *
       * @param {string} text quote text
       * @param {string} cite (optional) citation url
       *
       * @returns {Summary} summary instance
       */
      addQuote(text, cite) {
        let attrs = Object.assign({}, cite && { cite }), element = this.wrap("blockquote", text, attrs);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML anchor tag to the summary buffer
       *
       * @param {string} text link text/content
       * @param {string} href hyperlink
       *
       * @returns {Summary} summary instance
       */
      addLink(text, href) {
        let element = this.wrap("a", text, { href });
        return this.addRaw(element).addEOL();
      }
    }, _summary = new Summary();
    exports2.markdownSummary = _summary;
    exports2.summary = _summary;
  }
});

// node_modules/@actions/core/lib/path-utils.js
var require_path_utils = __commonJS({
  "node_modules/@actions/core/lib/path-utils.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k);
      var desc = Object.getOwnPropertyDescriptor(m, k);
      (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = { enumerable: !0, get: function() {
        return m[k];
      } }), Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: !0, value: v });
    } : function(o, v) {
      o.default = v;
    }), __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) k !== "default" && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
      return __setModuleDefault(result, mod), result;
    };
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.toPlatformPath = exports2.toWin32Path = exports2.toPosixPath = void 0;
    var path8 = __importStar(require("path"));
    function toPosixPath(pth) {
      return pth.replace(/[\\]/g, "/");
    }
    exports2.toPosixPath = toPosixPath;
    function toWin32Path(pth) {
      return pth.replace(/[/]/g, "\\");
    }
    exports2.toWin32Path = toWin32Path;
    function toPlatformPath(pth) {
      return pth.replace(/[/\\]/g, path8.sep);
    }
    exports2.toPlatformPath = toPlatformPath;
  }
});

// node_modules/@actions/io/lib/io-util.js
var require_io_util = __commonJS({
  "node_modules/@actions/io/lib/io-util.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, { enumerable: !0, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: !0, value: v });
    } : function(o, v) {
      o.default = v;
    }), __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) k !== "default" && Object.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
      return __setModuleDefault(result, mod), result;
    }, __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, _a;
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.getCmdPath = exports2.tryGetExecutablePath = exports2.isRooted = exports2.isDirectory = exports2.exists = exports2.READONLY = exports2.UV_FS_O_EXLOCK = exports2.IS_WINDOWS = exports2.unlink = exports2.symlink = exports2.stat = exports2.rmdir = exports2.rm = exports2.rename = exports2.readlink = exports2.readdir = exports2.open = exports2.mkdir = exports2.lstat = exports2.copyFile = exports2.chmod = void 0;
    var fs11 = __importStar(require("fs")), path8 = __importStar(require("path"));
    _a = fs11.promises, exports2.chmod = _a.chmod, exports2.copyFile = _a.copyFile, exports2.lstat = _a.lstat, exports2.mkdir = _a.mkdir, exports2.open = _a.open, exports2.readdir = _a.readdir, exports2.readlink = _a.readlink, exports2.rename = _a.rename, exports2.rm = _a.rm, exports2.rmdir = _a.rmdir, exports2.stat = _a.stat, exports2.symlink = _a.symlink, exports2.unlink = _a.unlink;
    exports2.IS_WINDOWS = process.platform === "win32";
    exports2.UV_FS_O_EXLOCK = 268435456;
    exports2.READONLY = fs11.constants.O_RDONLY;
    function exists(fsPath) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          yield exports2.stat(fsPath);
        } catch (err) {
          if (err.code === "ENOENT")
            return !1;
          throw err;
        }
        return !0;
      });
    }
    exports2.exists = exists;
    function isDirectory(fsPath, useStat = !1) {
      return __awaiter(this, void 0, void 0, function* () {
        return (useStat ? yield exports2.stat(fsPath) : yield exports2.lstat(fsPath)).isDirectory();
      });
    }
    exports2.isDirectory = isDirectory;
    function isRooted(p) {
      if (p = normalizeSeparators(p), !p)
        throw new Error('isRooted() parameter "p" cannot be empty');
      return exports2.IS_WINDOWS ? p.startsWith("\\") || /^[A-Z]:/i.test(p) : p.startsWith("/");
    }
    exports2.isRooted = isRooted;
    function tryGetExecutablePath(filePath, extensions) {
      return __awaiter(this, void 0, void 0, function* () {
        let stats;
        try {
          stats = yield exports2.stat(filePath);
        } catch (err) {
          err.code !== "ENOENT" && console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
        }
        if (stats && stats.isFile()) {
          if (exports2.IS_WINDOWS) {
            let upperExt = path8.extname(filePath).toUpperCase();
            if (extensions.some((validExt) => validExt.toUpperCase() === upperExt))
              return filePath;
          } else if (isUnixExecutable(stats))
            return filePath;
        }
        let originalFilePath = filePath;
        for (let extension of extensions) {
          filePath = originalFilePath + extension, stats = void 0;
          try {
            stats = yield exports2.stat(filePath);
          } catch (err) {
            err.code !== "ENOENT" && console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
          }
          if (stats && stats.isFile()) {
            if (exports2.IS_WINDOWS) {
              try {
                let directory = path8.dirname(filePath), upperName = path8.basename(filePath).toUpperCase();
                for (let actualName of yield exports2.readdir(directory))
                  if (upperName === actualName.toUpperCase()) {
                    filePath = path8.join(directory, actualName);
                    break;
                  }
              } catch (err) {
                console.log(`Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`);
              }
              return filePath;
            } else if (isUnixExecutable(stats))
              return filePath;
          }
        }
        return "";
      });
    }
    exports2.tryGetExecutablePath = tryGetExecutablePath;
    function normalizeSeparators(p) {
      return p = p || "", exports2.IS_WINDOWS ? (p = p.replace(/\//g, "\\"), p.replace(/\\\\+/g, "\\")) : p.replace(/\/\/+/g, "/");
    }
    function isUnixExecutable(stats) {
      return (stats.mode & 1) > 0 || (stats.mode & 8) > 0 && stats.gid === process.getgid() || (stats.mode & 64) > 0 && stats.uid === process.getuid();
    }
    function getCmdPath() {
      var _a2;
      return (_a2 = process.env.COMSPEC) !== null && _a2 !== void 0 ? _a2 : "cmd.exe";
    }
    exports2.getCmdPath = getCmdPath;
  }
});

// node_modules/@actions/io/lib/io.js
var require_io = __commonJS({
  "node_modules/@actions/io/lib/io.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, { enumerable: !0, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: !0, value: v });
    } : function(o, v) {
      o.default = v;
    }), __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) k !== "default" && Object.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
      return __setModuleDefault(result, mod), result;
    }, __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.findInPath = exports2.which = exports2.mkdirP = exports2.rmRF = exports2.mv = exports2.cp = void 0;
    var assert_1 = require("assert"), path8 = __importStar(require("path")), ioUtil = __importStar(require_io_util());
    function cp(source, dest, options = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        let { force, recursive, copySourceDirectory } = readCopyOptions(options), destStat = (yield ioUtil.exists(dest)) ? yield ioUtil.stat(dest) : null;
        if (destStat && destStat.isFile() && !force)
          return;
        let newDest = destStat && destStat.isDirectory() && copySourceDirectory ? path8.join(dest, path8.basename(source)) : dest;
        if (!(yield ioUtil.exists(source)))
          throw new Error(`no such file or directory: ${source}`);
        if ((yield ioUtil.stat(source)).isDirectory())
          if (recursive)
            yield cpDirRecursive(source, newDest, 0, force);
          else
            throw new Error(`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`);
        else {
          if (path8.relative(source, newDest) === "")
            throw new Error(`'${newDest}' and '${source}' are the same file`);
          yield copyFile(source, newDest, force);
        }
      });
    }
    exports2.cp = cp;
    function mv(source, dest, options = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        if (yield ioUtil.exists(dest)) {
          let destExists = !0;
          if ((yield ioUtil.isDirectory(dest)) && (dest = path8.join(dest, path8.basename(source)), destExists = yield ioUtil.exists(dest)), destExists)
            if (options.force == null || options.force)
              yield rmRF(dest);
            else
              throw new Error("Destination already exists");
        }
        yield mkdirP(path8.dirname(dest)), yield ioUtil.rename(source, dest);
      });
    }
    exports2.mv = mv;
    function rmRF(inputPath) {
      return __awaiter(this, void 0, void 0, function* () {
        if (ioUtil.IS_WINDOWS && /[*"<>|]/.test(inputPath))
          throw new Error('File path must not contain `*`, `"`, `<`, `>` or `|` on Windows');
        try {
          yield ioUtil.rm(inputPath, {
            force: !0,
            maxRetries: 3,
            recursive: !0,
            retryDelay: 300
          });
        } catch (err) {
          throw new Error(`File was unable to be removed ${err}`);
        }
      });
    }
    exports2.rmRF = rmRF;
    function mkdirP(fsPath) {
      return __awaiter(this, void 0, void 0, function* () {
        assert_1.ok(fsPath, "a path argument must be provided"), yield ioUtil.mkdir(fsPath, { recursive: !0 });
      });
    }
    exports2.mkdirP = mkdirP;
    function which(tool, check) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!tool)
          throw new Error("parameter 'tool' is required");
        if (check) {
          let result = yield which(tool, !1);
          if (!result)
            throw ioUtil.IS_WINDOWS ? new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`) : new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);
          return result;
        }
        let matches = yield findInPath(tool);
        return matches && matches.length > 0 ? matches[0] : "";
      });
    }
    exports2.which = which;
    function findInPath(tool) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!tool)
          throw new Error("parameter 'tool' is required");
        let extensions = [];
        if (ioUtil.IS_WINDOWS && process.env.PATHEXT)
          for (let extension of process.env.PATHEXT.split(path8.delimiter))
            extension && extensions.push(extension);
        if (ioUtil.isRooted(tool)) {
          let filePath = yield ioUtil.tryGetExecutablePath(tool, extensions);
          return filePath ? [filePath] : [];
        }
        if (tool.includes(path8.sep))
          return [];
        let directories = [];
        if (process.env.PATH)
          for (let p of process.env.PATH.split(path8.delimiter))
            p && directories.push(p);
        let matches = [];
        for (let directory of directories) {
          let filePath = yield ioUtil.tryGetExecutablePath(path8.join(directory, tool), extensions);
          filePath && matches.push(filePath);
        }
        return matches;
      });
    }
    exports2.findInPath = findInPath;
    function readCopyOptions(options) {
      let force = options.force == null ? !0 : options.force, recursive = !!options.recursive, copySourceDirectory = options.copySourceDirectory == null ? !0 : !!options.copySourceDirectory;
      return { force, recursive, copySourceDirectory };
    }
    function cpDirRecursive(sourceDir, destDir, currentDepth, force) {
      return __awaiter(this, void 0, void 0, function* () {
        if (currentDepth >= 255)
          return;
        currentDepth++, yield mkdirP(destDir);
        let files = yield ioUtil.readdir(sourceDir);
        for (let fileName of files) {
          let srcFile = `${sourceDir}/${fileName}`, destFile = `${destDir}/${fileName}`;
          (yield ioUtil.lstat(srcFile)).isDirectory() ? yield cpDirRecursive(srcFile, destFile, currentDepth, force) : yield copyFile(srcFile, destFile, force);
        }
        yield ioUtil.chmod(destDir, (yield ioUtil.stat(sourceDir)).mode);
      });
    }
    function copyFile(srcFile, destFile, force) {
      return __awaiter(this, void 0, void 0, function* () {
        if ((yield ioUtil.lstat(srcFile)).isSymbolicLink()) {
          try {
            yield ioUtil.lstat(destFile), yield ioUtil.unlink(destFile);
          } catch (e) {
            e.code === "EPERM" && (yield ioUtil.chmod(destFile, "0666"), yield ioUtil.unlink(destFile));
          }
          let symlinkFull = yield ioUtil.readlink(srcFile);
          yield ioUtil.symlink(symlinkFull, destFile, ioUtil.IS_WINDOWS ? "junction" : null);
        } else (!(yield ioUtil.exists(destFile)) || force) && (yield ioUtil.copyFile(srcFile, destFile));
      });
    }
  }
});

// node_modules/@actions/exec/lib/toolrunner.js
var require_toolrunner = __commonJS({
  "node_modules/@actions/exec/lib/toolrunner.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, { enumerable: !0, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: !0, value: v });
    } : function(o, v) {
      o.default = v;
    }), __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) k !== "default" && Object.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
      return __setModuleDefault(result, mod), result;
    }, __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.argStringToArray = exports2.ToolRunner = void 0;
    var os = __importStar(require("os")), events = __importStar(require("events")), child = __importStar(require("child_process")), path8 = __importStar(require("path")), io = __importStar(require_io()), ioUtil = __importStar(require_io_util()), timers_1 = require("timers"), IS_WINDOWS = process.platform === "win32", ToolRunner = class extends events.EventEmitter {
      constructor(toolPath, args, options) {
        if (super(), !toolPath)
          throw new Error("Parameter 'toolPath' cannot be null or empty.");
        this.toolPath = toolPath, this.args = args || [], this.options = options || {};
      }
      _debug(message) {
        this.options.listeners && this.options.listeners.debug && this.options.listeners.debug(message);
      }
      _getCommandString(options, noPrefix) {
        let toolPath = this._getSpawnFileName(), args = this._getSpawnArgs(options), cmd = noPrefix ? "" : "[command]";
        if (IS_WINDOWS)
          if (this._isCmdFile()) {
            cmd += toolPath;
            for (let a of args)
              cmd += ` ${a}`;
          } else if (options.windowsVerbatimArguments) {
            cmd += `"${toolPath}"`;
            for (let a of args)
              cmd += ` ${a}`;
          } else {
            cmd += this._windowsQuoteCmdArg(toolPath);
            for (let a of args)
              cmd += ` ${this._windowsQuoteCmdArg(a)}`;
          }
        else {
          cmd += toolPath;
          for (let a of args)
            cmd += ` ${a}`;
        }
        return cmd;
      }
      _processLineBuffer(data, strBuffer, onLine) {
        try {
          let s = strBuffer + data.toString(), n = s.indexOf(os.EOL);
          for (; n > -1; ) {
            let line = s.substring(0, n);
            onLine(line), s = s.substring(n + os.EOL.length), n = s.indexOf(os.EOL);
          }
          return s;
        } catch (err) {
          return this._debug(`error processing line. Failed with error ${err}`), "";
        }
      }
      _getSpawnFileName() {
        return IS_WINDOWS && this._isCmdFile() ? process.env.COMSPEC || "cmd.exe" : this.toolPath;
      }
      _getSpawnArgs(options) {
        if (IS_WINDOWS && this._isCmdFile()) {
          let argline = `/D /S /C "${this._windowsQuoteCmdArg(this.toolPath)}`;
          for (let a of this.args)
            argline += " ", argline += options.windowsVerbatimArguments ? a : this._windowsQuoteCmdArg(a);
          return argline += '"', [argline];
        }
        return this.args;
      }
      _endsWith(str, end) {
        return str.endsWith(end);
      }
      _isCmdFile() {
        let upperToolPath = this.toolPath.toUpperCase();
        return this._endsWith(upperToolPath, ".CMD") || this._endsWith(upperToolPath, ".BAT");
      }
      _windowsQuoteCmdArg(arg) {
        if (!this._isCmdFile())
          return this._uvQuoteCmdArg(arg);
        if (!arg)
          return '""';
        let cmdSpecialChars = [
          " ",
          "	",
          "&",
          "(",
          ")",
          "[",
          "]",
          "{",
          "}",
          "^",
          "=",
          ";",
          "!",
          "'",
          "+",
          ",",
          "`",
          "~",
          "|",
          "<",
          ">",
          '"'
        ], needsQuotes = !1;
        for (let char of arg)
          if (cmdSpecialChars.some((x) => x === char)) {
            needsQuotes = !0;
            break;
          }
        if (!needsQuotes)
          return arg;
        let reverse = '"', quoteHit = !0;
        for (let i = arg.length; i > 0; i--)
          reverse += arg[i - 1], quoteHit && arg[i - 1] === "\\" ? reverse += "\\" : arg[i - 1] === '"' ? (quoteHit = !0, reverse += '"') : quoteHit = !1;
        return reverse += '"', reverse.split("").reverse().join("");
      }
      _uvQuoteCmdArg(arg) {
        if (!arg)
          return '""';
        if (!arg.includes(" ") && !arg.includes("	") && !arg.includes('"'))
          return arg;
        if (!arg.includes('"') && !arg.includes("\\"))
          return `"${arg}"`;
        let reverse = '"', quoteHit = !0;
        for (let i = arg.length; i > 0; i--)
          reverse += arg[i - 1], quoteHit && arg[i - 1] === "\\" ? reverse += "\\" : arg[i - 1] === '"' ? (quoteHit = !0, reverse += "\\") : quoteHit = !1;
        return reverse += '"', reverse.split("").reverse().join("");
      }
      _cloneExecOptions(options) {
        options = options || {};
        let result = {
          cwd: options.cwd || process.cwd(),
          env: options.env || process.env,
          silent: options.silent || !1,
          windowsVerbatimArguments: options.windowsVerbatimArguments || !1,
          failOnStdErr: options.failOnStdErr || !1,
          ignoreReturnCode: options.ignoreReturnCode || !1,
          delay: options.delay || 1e4
        };
        return result.outStream = options.outStream || process.stdout, result.errStream = options.errStream || process.stderr, result;
      }
      _getSpawnOptions(options, toolPath) {
        options = options || {};
        let result = {};
        return result.cwd = options.cwd, result.env = options.env, result.windowsVerbatimArguments = options.windowsVerbatimArguments || this._isCmdFile(), options.windowsVerbatimArguments && (result.argv0 = `"${toolPath}"`), result;
      }
      /**
       * Exec a tool.
       * Output will be streamed to the live console.
       * Returns promise with return code
       *
       * @param     tool     path to tool to exec
       * @param     options  optional exec options.  See ExecOptions
       * @returns   number
       */
      exec() {
        return __awaiter(this, void 0, void 0, function* () {
          return !ioUtil.isRooted(this.toolPath) && (this.toolPath.includes("/") || IS_WINDOWS && this.toolPath.includes("\\")) && (this.toolPath = path8.resolve(process.cwd(), this.options.cwd || process.cwd(), this.toolPath)), this.toolPath = yield io.which(this.toolPath, !0), new Promise((resolve2, reject) => __awaiter(this, void 0, void 0, function* () {
            this._debug(`exec tool: ${this.toolPath}`), this._debug("arguments:");
            for (let arg of this.args)
              this._debug(`   ${arg}`);
            let optionsNonNull = this._cloneExecOptions(this.options);
            !optionsNonNull.silent && optionsNonNull.outStream && optionsNonNull.outStream.write(this._getCommandString(optionsNonNull) + os.EOL);
            let state = new ExecState(optionsNonNull, this.toolPath);
            if (state.on("debug", (message) => {
              this._debug(message);
            }), this.options.cwd && !(yield ioUtil.exists(this.options.cwd)))
              return reject(new Error(`The cwd: ${this.options.cwd} does not exist!`));
            let fileName = this._getSpawnFileName(), cp = child.spawn(fileName, this._getSpawnArgs(optionsNonNull), this._getSpawnOptions(this.options, fileName)), stdbuffer = "";
            cp.stdout && cp.stdout.on("data", (data) => {
              this.options.listeners && this.options.listeners.stdout && this.options.listeners.stdout(data), !optionsNonNull.silent && optionsNonNull.outStream && optionsNonNull.outStream.write(data), stdbuffer = this._processLineBuffer(data, stdbuffer, (line) => {
                this.options.listeners && this.options.listeners.stdline && this.options.listeners.stdline(line);
              });
            });
            let errbuffer = "";
            if (cp.stderr && cp.stderr.on("data", (data) => {
              state.processStderr = !0, this.options.listeners && this.options.listeners.stderr && this.options.listeners.stderr(data), !optionsNonNull.silent && optionsNonNull.errStream && optionsNonNull.outStream && (optionsNonNull.failOnStdErr ? optionsNonNull.errStream : optionsNonNull.outStream).write(data), errbuffer = this._processLineBuffer(data, errbuffer, (line) => {
                this.options.listeners && this.options.listeners.errline && this.options.listeners.errline(line);
              });
            }), cp.on("error", (err) => {
              state.processError = err.message, state.processExited = !0, state.processClosed = !0, state.CheckComplete();
            }), cp.on("exit", (code2) => {
              state.processExitCode = code2, state.processExited = !0, this._debug(`Exit code ${code2} received from tool '${this.toolPath}'`), state.CheckComplete();
            }), cp.on("close", (code2) => {
              state.processExitCode = code2, state.processExited = !0, state.processClosed = !0, this._debug(`STDIO streams have closed for tool '${this.toolPath}'`), state.CheckComplete();
            }), state.on("done", (error, exitCode2) => {
              stdbuffer.length > 0 && this.emit("stdline", stdbuffer), errbuffer.length > 0 && this.emit("errline", errbuffer), cp.removeAllListeners(), error ? reject(error) : resolve2(exitCode2);
            }), this.options.input) {
              if (!cp.stdin)
                throw new Error("child process missing stdin");
              cp.stdin.end(this.options.input);
            }
          }));
        });
      }
    };
    exports2.ToolRunner = ToolRunner;
    function argStringToArray(argString) {
      let args = [], inQuotes = !1, escaped = !1, arg = "";
      function append(c) {
        escaped && c !== '"' && (arg += "\\"), arg += c, escaped = !1;
      }
      for (let i = 0; i < argString.length; i++) {
        let c = argString.charAt(i);
        if (c === '"') {
          escaped ? append(c) : inQuotes = !inQuotes;
          continue;
        }
        if (c === "\\" && escaped) {
          append(c);
          continue;
        }
        if (c === "\\" && inQuotes) {
          escaped = !0;
          continue;
        }
        if (c === " " && !inQuotes) {
          arg.length > 0 && (args.push(arg), arg = "");
          continue;
        }
        append(c);
      }
      return arg.length > 0 && args.push(arg.trim()), args;
    }
    exports2.argStringToArray = argStringToArray;
    var ExecState = class _ExecState extends events.EventEmitter {
      constructor(options, toolPath) {
        if (super(), this.processClosed = !1, this.processError = "", this.processExitCode = 0, this.processExited = !1, this.processStderr = !1, this.delay = 1e4, this.done = !1, this.timeout = null, !toolPath)
          throw new Error("toolPath must not be empty");
        this.options = options, this.toolPath = toolPath, options.delay && (this.delay = options.delay);
      }
      CheckComplete() {
        this.done || (this.processClosed ? this._setResult() : this.processExited && (this.timeout = timers_1.setTimeout(_ExecState.HandleTimeout, this.delay, this)));
      }
      _debug(message) {
        this.emit("debug", message);
      }
      _setResult() {
        let error;
        this.processExited && (this.processError ? error = new Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`) : this.processExitCode !== 0 && !this.options.ignoreReturnCode ? error = new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`) : this.processStderr && this.options.failOnStdErr && (error = new Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`))), this.timeout && (clearTimeout(this.timeout), this.timeout = null), this.done = !0, this.emit("done", error, this.processExitCode);
      }
      static HandleTimeout(state) {
        if (!state.done) {
          if (!state.processClosed && state.processExited) {
            let message = `The STDIO streams did not close within ${state.delay / 1e3} seconds of the exit event from process '${state.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;
            state._debug(message);
          }
          state._setResult();
        }
      }
    };
  }
});

// node_modules/@actions/exec/lib/exec.js
var require_exec = __commonJS({
  "node_modules/@actions/exec/lib/exec.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, { enumerable: !0, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: !0, value: v });
    } : function(o, v) {
      o.default = v;
    }), __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) k !== "default" && Object.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
      return __setModuleDefault(result, mod), result;
    }, __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.getExecOutput = exports2.exec = void 0;
    var string_decoder_1 = require("string_decoder"), tr = __importStar(require_toolrunner());
    function exec(commandLine, args, options) {
      return __awaiter(this, void 0, void 0, function* () {
        let commandArgs = tr.argStringToArray(commandLine);
        if (commandArgs.length === 0)
          throw new Error("Parameter 'commandLine' cannot be null or empty.");
        let toolPath = commandArgs[0];
        return args = commandArgs.slice(1).concat(args || []), new tr.ToolRunner(toolPath, args, options).exec();
      });
    }
    exports2.exec = exec;
    function getExecOutput(commandLine, args, options) {
      var _a, _b;
      return __awaiter(this, void 0, void 0, function* () {
        let stdout = "", stderr = "", stdoutDecoder = new string_decoder_1.StringDecoder("utf8"), stderrDecoder = new string_decoder_1.StringDecoder("utf8"), originalStdoutListener = (_a = options?.listeners) === null || _a === void 0 ? void 0 : _a.stdout, originalStdErrListener = (_b = options?.listeners) === null || _b === void 0 ? void 0 : _b.stderr, stdErrListener = (data) => {
          stderr += stderrDecoder.write(data), originalStdErrListener && originalStdErrListener(data);
        }, stdOutListener = (data) => {
          stdout += stdoutDecoder.write(data), originalStdoutListener && originalStdoutListener(data);
        }, listeners = Object.assign(Object.assign({}, options?.listeners), { stdout: stdOutListener, stderr: stdErrListener }), exitCode2 = yield exec(commandLine, args, Object.assign(Object.assign({}, options), { listeners }));
        return stdout += stdoutDecoder.end(), stderr += stderrDecoder.end(), {
          exitCode: exitCode2,
          stdout,
          stderr
        };
      });
    }
    exports2.getExecOutput = getExecOutput;
  }
});

// node_modules/@actions/core/lib/platform.js
var require_platform = __commonJS({
  "node_modules/@actions/core/lib/platform.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k);
      var desc = Object.getOwnPropertyDescriptor(m, k);
      (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = { enumerable: !0, get: function() {
        return m[k];
      } }), Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: !0, value: v });
    } : function(o, v) {
      o.default = v;
    }), __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) k !== "default" && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
      return __setModuleDefault(result, mod), result;
    }, __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.getDetails = exports2.isLinux = exports2.isMacOS = exports2.isWindows = exports2.arch = exports2.platform = void 0;
    var os_1 = __importDefault(require("os")), exec = __importStar(require_exec()), getWindowsInfo = () => __awaiter(void 0, void 0, void 0, function* () {
      let { stdout: version2 } = yield exec.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Version"', void 0, {
        silent: !0
      }), { stdout: name2 } = yield exec.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Caption"', void 0, {
        silent: !0
      });
      return {
        name: name2.trim(),
        version: version2.trim()
      };
    }), getMacOsInfo = () => __awaiter(void 0, void 0, void 0, function* () {
      var _a, _b, _c, _d;
      let { stdout } = yield exec.getExecOutput("sw_vers", void 0, {
        silent: !0
      }), version2 = (_b = (_a = stdout.match(/ProductVersion:\s*(.+)/)) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : "";
      return {
        name: (_d = (_c = stdout.match(/ProductName:\s*(.+)/)) === null || _c === void 0 ? void 0 : _c[1]) !== null && _d !== void 0 ? _d : "",
        version: version2
      };
    }), getLinuxInfo = () => __awaiter(void 0, void 0, void 0, function* () {
      let { stdout } = yield exec.getExecOutput("lsb_release", ["-i", "-r", "-s"], {
        silent: !0
      }), [name2, version2] = stdout.trim().split(`
`);
      return {
        name: name2,
        version: version2
      };
    });
    exports2.platform = os_1.default.platform();
    exports2.arch = os_1.default.arch();
    exports2.isWindows = exports2.platform === "win32";
    exports2.isMacOS = exports2.platform === "darwin";
    exports2.isLinux = exports2.platform === "linux";
    function getDetails() {
      return __awaiter(this, void 0, void 0, function* () {
        return Object.assign(Object.assign({}, yield exports2.isWindows ? getWindowsInfo() : exports2.isMacOS ? getMacOsInfo() : getLinuxInfo()), {
          platform: exports2.platform,
          arch: exports2.arch,
          isWindows: exports2.isWindows,
          isMacOS: exports2.isMacOS,
          isLinux: exports2.isLinux
        });
      });
    }
    exports2.getDetails = getDetails;
  }
});

// node_modules/@actions/core/lib/core.js
var require_core = __commonJS({
  "node_modules/@actions/core/lib/core.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k);
      var desc = Object.getOwnPropertyDescriptor(m, k);
      (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = { enumerable: !0, get: function() {
        return m[k];
      } }), Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: !0, value: v });
    } : function(o, v) {
      o.default = v;
    }), __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) k !== "default" && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
      return __setModuleDefault(result, mod), result;
    }, __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.platform = exports2.toPlatformPath = exports2.toWin32Path = exports2.toPosixPath = exports2.markdownSummary = exports2.summary = exports2.getIDToken = exports2.getState = exports2.saveState = exports2.group = exports2.endGroup = exports2.startGroup = exports2.info = exports2.notice = exports2.warning = exports2.error = exports2.debug = exports2.isDebug = exports2.setFailed = exports2.setCommandEcho = exports2.setOutput = exports2.getBooleanInput = exports2.getMultilineInput = exports2.getInput = exports2.addPath = exports2.setSecret = exports2.exportVariable = exports2.ExitCode = void 0;
    var command_1 = require_command(), file_command_1 = require_file_command(), utils_1 = require_utils(), os = __importStar(require("os")), path8 = __importStar(require("path")), oidc_utils_1 = require_oidc_utils(), ExitCode;
    (function(ExitCode2) {
      ExitCode2[ExitCode2.Success = 0] = "Success", ExitCode2[ExitCode2.Failure = 1] = "Failure";
    })(ExitCode || (exports2.ExitCode = ExitCode = {}));
    function exportVariable(name2, val) {
      let convertedVal = (0, utils_1.toCommandValue)(val);
      if (process.env[name2] = convertedVal, process.env.GITHUB_ENV || "")
        return (0, file_command_1.issueFileCommand)("ENV", (0, file_command_1.prepareKeyValueMessage)(name2, val));
      (0, command_1.issueCommand)("set-env", { name: name2 }, convertedVal);
    }
    exports2.exportVariable = exportVariable;
    function setSecret(secret) {
      (0, command_1.issueCommand)("add-mask", {}, secret);
    }
    exports2.setSecret = setSecret;
    function addPath(inputPath) {
      process.env.GITHUB_PATH || "" ? (0, file_command_1.issueFileCommand)("PATH", inputPath) : (0, command_1.issueCommand)("add-path", {}, inputPath), process.env.PATH = `${inputPath}${path8.delimiter}${process.env.PATH}`;
    }
    exports2.addPath = addPath;
    function getInput2(name2, options) {
      let val = process.env[`INPUT_${name2.replace(/ /g, "_").toUpperCase()}`] || "";
      if (options && options.required && !val)
        throw new Error(`Input required and not supplied: ${name2}`);
      return options && options.trimWhitespace === !1 ? val : val.trim();
    }
    exports2.getInput = getInput2;
    function getMultilineInput(name2, options) {
      let inputs = getInput2(name2, options).split(`
`).filter((x) => x !== "");
      return options && options.trimWhitespace === !1 ? inputs : inputs.map((input) => input.trim());
    }
    exports2.getMultilineInput = getMultilineInput;
    function getBooleanInput(name2, options) {
      let trueValue = ["true", "True", "TRUE"], falseValue = ["false", "False", "FALSE"], val = getInput2(name2, options);
      if (trueValue.includes(val))
        return !0;
      if (falseValue.includes(val))
        return !1;
      throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name2}
Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
    }
    exports2.getBooleanInput = getBooleanInput;
    function setOutput(name2, value) {
      if (process.env.GITHUB_OUTPUT || "")
        return (0, file_command_1.issueFileCommand)("OUTPUT", (0, file_command_1.prepareKeyValueMessage)(name2, value));
      process.stdout.write(os.EOL), (0, command_1.issueCommand)("set-output", { name: name2 }, (0, utils_1.toCommandValue)(value));
    }
    exports2.setOutput = setOutput;
    function setCommandEcho(enabled) {
      (0, command_1.issue)("echo", enabled ? "on" : "off");
    }
    exports2.setCommandEcho = setCommandEcho;
    function setFailed(message) {
      process.exitCode = ExitCode.Failure, error(message);
    }
    exports2.setFailed = setFailed;
    function isDebug() {
      return process.env.RUNNER_DEBUG === "1";
    }
    exports2.isDebug = isDebug;
    function debug(message) {
      (0, command_1.issueCommand)("debug", {}, message);
    }
    exports2.debug = debug;
    function error(message, properties = {}) {
      (0, command_1.issueCommand)("error", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
    }
    exports2.error = error;
    function warning(message, properties = {}) {
      (0, command_1.issueCommand)("warning", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
    }
    exports2.warning = warning;
    function notice(message, properties = {}) {
      (0, command_1.issueCommand)("notice", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
    }
    exports2.notice = notice;
    function info(message) {
      process.stdout.write(message + os.EOL);
    }
    exports2.info = info;
    function startGroup(name2) {
      (0, command_1.issue)("group", name2);
    }
    exports2.startGroup = startGroup;
    function endGroup() {
      (0, command_1.issue)("endgroup");
    }
    exports2.endGroup = endGroup;
    function group(name2, fn) {
      return __awaiter(this, void 0, void 0, function* () {
        startGroup(name2);
        let result;
        try {
          result = yield fn();
        } finally {
          endGroup();
        }
        return result;
      });
    }
    exports2.group = group;
    function saveState(name2, value) {
      if (process.env.GITHUB_STATE || "")
        return (0, file_command_1.issueFileCommand)("STATE", (0, file_command_1.prepareKeyValueMessage)(name2, value));
      (0, command_1.issueCommand)("save-state", { name: name2 }, (0, utils_1.toCommandValue)(value));
    }
    exports2.saveState = saveState;
    function getState(name2) {
      return process.env[`STATE_${name2}`] || "";
    }
    exports2.getState = getState;
    function getIDToken(aud) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield oidc_utils_1.OidcClient.getIDToken(aud);
      });
    }
    exports2.getIDToken = getIDToken;
    var summary_1 = require_summary();
    Object.defineProperty(exports2, "summary", { enumerable: !0, get: function() {
      return summary_1.summary;
    } });
    var summary_2 = require_summary();
    Object.defineProperty(exports2, "markdownSummary", { enumerable: !0, get: function() {
      return summary_2.markdownSummary;
    } });
    var path_utils_1 = require_path_utils();
    Object.defineProperty(exports2, "toPosixPath", { enumerable: !0, get: function() {
      return path_utils_1.toPosixPath;
    } });
    Object.defineProperty(exports2, "toWin32Path", { enumerable: !0, get: function() {
      return path_utils_1.toWin32Path;
    } });
    Object.defineProperty(exports2, "toPlatformPath", { enumerable: !0, get: function() {
      return path_utils_1.toPlatformPath;
    } });
    exports2.platform = __importStar(require_platform());
  }
});

// node_modules/async/dist/async.js
var require_async = __commonJS({
  "node_modules/async/dist/async.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 == "object" && typeof module2 < "u" ? factory(exports2) : typeof define == "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis < "u" ? globalThis : global2 || self, factory(global2.async = {}));
    })(exports2, function(exports3) {
      "use strict";
      function apply(fn, ...args) {
        return (...callArgs) => fn(...args, ...callArgs);
      }
      function initialParams(fn) {
        return function(...args) {
          var callback = args.pop();
          return fn.call(this, args, callback);
        };
      }
      var hasQueueMicrotask = typeof queueMicrotask == "function" && queueMicrotask, hasSetImmediate = typeof setImmediate == "function" && setImmediate, hasNextTick = typeof process == "object" && typeof process.nextTick == "function";
      function fallback(fn) {
        setTimeout(fn, 0);
      }
      function wrap(defer2) {
        return (fn, ...args) => defer2(() => fn(...args));
      }
      var _defer$1;
      hasQueueMicrotask ? _defer$1 = queueMicrotask : hasSetImmediate ? _defer$1 = setImmediate : hasNextTick ? _defer$1 = process.nextTick : _defer$1 = fallback;
      var setImmediate$1 = wrap(_defer$1);
      function asyncify(func) {
        return isAsync(func) ? function(...args) {
          let callback = args.pop(), promise = func.apply(this, args);
          return handlePromise(promise, callback);
        } : initialParams(function(args, callback) {
          var result;
          try {
            result = func.apply(this, args);
          } catch (e) {
            return callback(e);
          }
          if (result && typeof result.then == "function")
            return handlePromise(result, callback);
          callback(null, result);
        });
      }
      function handlePromise(promise, callback) {
        return promise.then((value) => {
          invokeCallback(callback, null, value);
        }, (err) => {
          invokeCallback(callback, err && (err instanceof Error || err.message) ? err : new Error(err));
        });
      }
      function invokeCallback(callback, error, value) {
        try {
          callback(error, value);
        } catch (err) {
          setImmediate$1((e) => {
            throw e;
          }, err);
        }
      }
      function isAsync(fn) {
        return fn[Symbol.toStringTag] === "AsyncFunction";
      }
      function isAsyncGenerator(fn) {
        return fn[Symbol.toStringTag] === "AsyncGenerator";
      }
      function isAsyncIterable(obj) {
        return typeof obj[Symbol.asyncIterator] == "function";
      }
      function wrapAsync(asyncFn) {
        if (typeof asyncFn != "function") throw new Error("expected a function");
        return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
      }
      function awaitify(asyncFn, arity) {
        if (arity || (arity = asyncFn.length), !arity) throw new Error("arity is undefined");
        function awaitable(...args) {
          return typeof args[arity - 1] == "function" ? asyncFn.apply(this, args) : new Promise((resolve2, reject2) => {
            args[arity - 1] = (err, ...cbArgs) => {
              if (err) return reject2(err);
              resolve2(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
            }, asyncFn.apply(this, args);
          });
        }
        return awaitable;
      }
      function applyEach$1(eachfn) {
        return function(fns, ...callArgs) {
          return awaitify(function(callback) {
            var that = this;
            return eachfn(fns, (fn, cb) => {
              wrapAsync(fn).apply(that, callArgs.concat(cb));
            }, callback);
          });
        };
      }
      function _asyncMap(eachfn, arr, iteratee, callback) {
        arr = arr || [];
        var results = [], counter = 0, _iteratee = wrapAsync(iteratee);
        return eachfn(arr, (value, _, iterCb) => {
          var index2 = counter++;
          _iteratee(value, (err, v) => {
            results[index2] = v, iterCb(err);
          });
        }, (err) => {
          callback(err, results);
        });
      }
      function isArrayLike(value) {
        return value && typeof value.length == "number" && value.length >= 0 && value.length % 1 === 0;
      }
      let breakLoop = {};
      function once(fn) {
        function wrapper(...args) {
          if (fn !== null) {
            var callFn = fn;
            fn = null, callFn.apply(this, args);
          }
        }
        return Object.assign(wrapper, fn), wrapper;
      }
      function getIterator(coll) {
        return coll[Symbol.iterator] && coll[Symbol.iterator]();
      }
      function createArrayIterator(coll) {
        var i = -1, len = coll.length;
        return function() {
          return ++i < len ? { value: coll[i], key: i } : null;
        };
      }
      function createES2015Iterator(iterator) {
        var i = -1;
        return function() {
          var item = iterator.next();
          return item.done ? null : (i++, { value: item.value, key: i });
        };
      }
      function createObjectIterator(obj) {
        var okeys = obj ? Object.keys(obj) : [], i = -1, len = okeys.length;
        return function next() {
          var key = okeys[++i];
          return key === "__proto__" ? next() : i < len ? { value: obj[key], key } : null;
        };
      }
      function createIterator(coll) {
        if (isArrayLike(coll))
          return createArrayIterator(coll);
        var iterator = getIterator(coll);
        return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
      }
      function onlyOnce(fn) {
        return function(...args) {
          if (fn === null) throw new Error("Callback was already called.");
          var callFn = fn;
          fn = null, callFn.apply(this, args);
        };
      }
      function asyncEachOfLimit(generator, limit, iteratee, callback) {
        let done = !1, canceled = !1, awaiting = !1, running = 0, idx = 0;
        function replenish() {
          running >= limit || awaiting || done || (awaiting = !0, generator.next().then(({ value, done: iterDone }) => {
            if (!(canceled || done)) {
              if (awaiting = !1, iterDone) {
                done = !0, running <= 0 && callback(null);
                return;
              }
              running++, iteratee(value, idx, iterateeCallback), idx++, replenish();
            }
          }).catch(handleError));
        }
        function iterateeCallback(err, result) {
          if (running -= 1, !canceled) {
            if (err) return handleError(err);
            if (err === !1) {
              done = !0, canceled = !0;
              return;
            }
            if (result === breakLoop || done && running <= 0)
              return done = !0, callback(null);
            replenish();
          }
        }
        function handleError(err) {
          canceled || (awaiting = !1, done = !0, callback(err));
        }
        replenish();
      }
      var eachOfLimit$2 = (limit) => (obj, iteratee, callback) => {
        if (callback = once(callback), limit <= 0)
          throw new RangeError("concurrency limit cannot be less than 1");
        if (!obj)
          return callback(null);
        if (isAsyncGenerator(obj))
          return asyncEachOfLimit(obj, limit, iteratee, callback);
        if (isAsyncIterable(obj))
          return asyncEachOfLimit(obj[Symbol.asyncIterator](), limit, iteratee, callback);
        var nextElem = createIterator(obj), done = !1, canceled = !1, running = 0, looping = !1;
        function iterateeCallback(err, value) {
          if (!canceled)
            if (running -= 1, err)
              done = !0, callback(err);
            else if (err === !1)
              done = !0, canceled = !0;
            else {
              if (value === breakLoop || done && running <= 0)
                return done = !0, callback(null);
              looping || replenish();
            }
        }
        function replenish() {
          for (looping = !0; running < limit && !done; ) {
            var elem = nextElem();
            if (elem === null) {
              done = !0, running <= 0 && callback(null);
              return;
            }
            running += 1, iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
          }
          looping = !1;
        }
        replenish();
      };
      function eachOfLimit(coll, limit, iteratee, callback) {
        return eachOfLimit$2(limit)(coll, wrapAsync(iteratee), callback);
      }
      var eachOfLimit$1 = awaitify(eachOfLimit, 4);
      function eachOfArrayLike(coll, iteratee, callback) {
        callback = once(callback);
        var index2 = 0, completed = 0, { length } = coll, canceled = !1;
        length === 0 && callback(null);
        function iteratorCallback(err, value) {
          err === !1 && (canceled = !0), canceled !== !0 && (err ? callback(err) : (++completed === length || value === breakLoop) && callback(null));
        }
        for (; index2 < length; index2++)
          iteratee(coll[index2], index2, onlyOnce(iteratorCallback));
      }
      function eachOfGeneric(coll, iteratee, callback) {
        return eachOfLimit$1(coll, 1 / 0, iteratee, callback);
      }
      function eachOf(coll, iteratee, callback) {
        var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
        return eachOfImplementation(coll, wrapAsync(iteratee), callback);
      }
      var eachOf$1 = awaitify(eachOf, 3);
      function map(coll, iteratee, callback) {
        return _asyncMap(eachOf$1, coll, iteratee, callback);
      }
      var map$1 = awaitify(map, 3), applyEach = applyEach$1(map$1);
      function eachOfSeries(coll, iteratee, callback) {
        return eachOfLimit$1(coll, 1, iteratee, callback);
      }
      var eachOfSeries$1 = awaitify(eachOfSeries, 3);
      function mapSeries(coll, iteratee, callback) {
        return _asyncMap(eachOfSeries$1, coll, iteratee, callback);
      }
      var mapSeries$1 = awaitify(mapSeries, 3), applyEachSeries = applyEach$1(mapSeries$1);
      let PROMISE_SYMBOL = Symbol("promiseCallback");
      function promiseCallback() {
        let resolve2, reject2;
        function callback(err, ...args) {
          if (err) return reject2(err);
          resolve2(args.length > 1 ? args : args[0]);
        }
        return callback[PROMISE_SYMBOL] = new Promise((res, rej) => {
          resolve2 = res, reject2 = rej;
        }), callback;
      }
      function auto(tasks, concurrency, callback) {
        typeof concurrency != "number" && (callback = concurrency, concurrency = null), callback = once(callback || promiseCallback());
        var numTasks = Object.keys(tasks).length;
        if (!numTasks)
          return callback(null);
        concurrency || (concurrency = numTasks);
        var results = {}, runningTasks = 0, canceled = !1, hasError = !1, listeners = /* @__PURE__ */ Object.create(null), readyTasks = [], readyToCheck = [], uncheckedDependencies = {};
        Object.keys(tasks).forEach((key) => {
          var task = tasks[key];
          if (!Array.isArray(task)) {
            enqueueTask(key, [task]), readyToCheck.push(key);
            return;
          }
          var dependencies = task.slice(0, task.length - 1), remainingDependencies = dependencies.length;
          if (remainingDependencies === 0) {
            enqueueTask(key, task), readyToCheck.push(key);
            return;
          }
          uncheckedDependencies[key] = remainingDependencies, dependencies.forEach((dependencyName) => {
            if (!tasks[dependencyName])
              throw new Error("async.auto task `" + key + "` has a non-existent dependency `" + dependencyName + "` in " + dependencies.join(", "));
            addListener(dependencyName, () => {
              remainingDependencies--, remainingDependencies === 0 && enqueueTask(key, task);
            });
          });
        }), checkForDeadlocks(), processQueue();
        function enqueueTask(key, task) {
          readyTasks.push(() => runTask(key, task));
        }
        function processQueue() {
          if (!canceled) {
            if (readyTasks.length === 0 && runningTasks === 0)
              return callback(null, results);
            for (; readyTasks.length && runningTasks < concurrency; ) {
              var run2 = readyTasks.shift();
              run2();
            }
          }
        }
        function addListener(taskName, fn) {
          var taskListeners = listeners[taskName];
          taskListeners || (taskListeners = listeners[taskName] = []), taskListeners.push(fn);
        }
        function taskComplete(taskName) {
          var taskListeners = listeners[taskName] || [];
          taskListeners.forEach((fn) => fn()), processQueue();
        }
        function runTask(key, task) {
          if (!hasError) {
            var taskCallback = onlyOnce((err, ...result) => {
              if (runningTasks--, err === !1) {
                canceled = !0;
                return;
              }
              if (result.length < 2 && ([result] = result), err) {
                var safeResults = {};
                if (Object.keys(results).forEach((rkey) => {
                  safeResults[rkey] = results[rkey];
                }), safeResults[key] = result, hasError = !0, listeners = /* @__PURE__ */ Object.create(null), canceled) return;
                callback(err, safeResults);
              } else
                results[key] = result, taskComplete(key);
            });
            runningTasks++;
            var taskFn = wrapAsync(task[task.length - 1]);
            task.length > 1 ? taskFn(results, taskCallback) : taskFn(taskCallback);
          }
        }
        function checkForDeadlocks() {
          for (var currentTask, counter = 0; readyToCheck.length; )
            currentTask = readyToCheck.pop(), counter++, getDependents(currentTask).forEach((dependent) => {
              --uncheckedDependencies[dependent] === 0 && readyToCheck.push(dependent);
            });
          if (counter !== numTasks)
            throw new Error(
              "async.auto cannot execute tasks due to a recursive dependency"
            );
        }
        function getDependents(taskName) {
          var result = [];
          return Object.keys(tasks).forEach((key) => {
            let task = tasks[key];
            Array.isArray(task) && task.indexOf(taskName) >= 0 && result.push(key);
          }), result;
        }
        return callback[PROMISE_SYMBOL];
      }
      var FN_ARGS = /^(?:async\s)?(?:function)?\s*(?:\w+\s*)?\(([^)]+)\)(?:\s*{)/, ARROW_FN_ARGS = /^(?:async\s)?\s*(?:\(\s*)?((?:[^)=\s]\s*)*)(?:\)\s*)?=>/, FN_ARG_SPLIT = /,/, FN_ARG = /(=.+)?(\s*)$/;
      function stripComments(string) {
        let stripped = "", index2 = 0, endBlockComment = string.indexOf("*/");
        for (; index2 < string.length; )
          if (string[index2] === "/" && string[index2 + 1] === "/") {
            let endIndex = string.indexOf(`
`, index2);
            index2 = endIndex === -1 ? string.length : endIndex;
          } else if (endBlockComment !== -1 && string[index2] === "/" && string[index2 + 1] === "*") {
            let endIndex = string.indexOf("*/", index2);
            endIndex !== -1 ? (index2 = endIndex + 2, endBlockComment = string.indexOf("*/", index2)) : (stripped += string[index2], index2++);
          } else
            stripped += string[index2], index2++;
        return stripped;
      }
      function parseParams(func) {
        let src = stripComments(func.toString()), match = src.match(FN_ARGS);
        if (match || (match = src.match(ARROW_FN_ARGS)), !match) throw new Error(`could not parse args in autoInject
Source:
` + src);
        let [, args] = match;
        return args.replace(/\s/g, "").split(FN_ARG_SPLIT).map((arg) => arg.replace(FN_ARG, "").trim());
      }
      function autoInject(tasks, callback) {
        var newTasks = {};
        return Object.keys(tasks).forEach((key) => {
          var taskFn = tasks[key], params, fnIsAsync = isAsync(taskFn), hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;
          if (Array.isArray(taskFn))
            params = [...taskFn], taskFn = params.pop(), newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
          else if (hasNoDeps)
            newTasks[key] = taskFn;
          else {
            if (params = parseParams(taskFn), taskFn.length === 0 && !fnIsAsync && params.length === 0)
              throw new Error("autoInject task functions require explicit parameters.");
            fnIsAsync || params.pop(), newTasks[key] = params.concat(newTask);
          }
          function newTask(results, taskCb) {
            var newArgs = params.map((name2) => results[name2]);
            newArgs.push(taskCb), wrapAsync(taskFn)(...newArgs);
          }
        }), auto(newTasks, callback);
      }
      class DLL {
        constructor() {
          this.head = this.tail = null, this.length = 0;
        }
        removeLink(node) {
          return node.prev ? node.prev.next = node.next : this.head = node.next, node.next ? node.next.prev = node.prev : this.tail = node.prev, node.prev = node.next = null, this.length -= 1, node;
        }
        empty() {
          for (; this.head; ) this.shift();
          return this;
        }
        insertAfter(node, newNode) {
          newNode.prev = node, newNode.next = node.next, node.next ? node.next.prev = newNode : this.tail = newNode, node.next = newNode, this.length += 1;
        }
        insertBefore(node, newNode) {
          newNode.prev = node.prev, newNode.next = node, node.prev ? node.prev.next = newNode : this.head = newNode, node.prev = newNode, this.length += 1;
        }
        unshift(node) {
          this.head ? this.insertBefore(this.head, node) : setInitial(this, node);
        }
        push(node) {
          this.tail ? this.insertAfter(this.tail, node) : setInitial(this, node);
        }
        shift() {
          return this.head && this.removeLink(this.head);
        }
        pop() {
          return this.tail && this.removeLink(this.tail);
        }
        toArray() {
          return [...this];
        }
        *[Symbol.iterator]() {
          for (var cur = this.head; cur; )
            yield cur.data, cur = cur.next;
        }
        remove(testFn) {
          for (var curr = this.head; curr; ) {
            var { next } = curr;
            testFn(curr) && this.removeLink(curr), curr = next;
          }
          return this;
        }
      }
      function setInitial(dll, node) {
        dll.length = 1, dll.head = dll.tail = node;
      }
      function queue$1(worker, concurrency, payload) {
        if (concurrency == null)
          concurrency = 1;
        else if (concurrency === 0)
          throw new RangeError("Concurrency must not be zero");
        var _worker = wrapAsync(worker), numRunning = 0, workersList = [];
        let events = {
          error: [],
          drain: [],
          saturated: [],
          unsaturated: [],
          empty: []
        };
        function on(event, handler) {
          events[event].push(handler);
        }
        function once2(event, handler) {
          let handleAndRemove = (...args) => {
            off(event, handleAndRemove), handler(...args);
          };
          events[event].push(handleAndRemove);
        }
        function off(event, handler) {
          if (!event) return Object.keys(events).forEach((ev) => events[ev] = []);
          if (!handler) return events[event] = [];
          events[event] = events[event].filter((ev) => ev !== handler);
        }
        function trigger(event, ...args) {
          events[event].forEach((handler) => handler(...args));
        }
        var processingScheduled = !1;
        function _insert(data, insertAtFront, rejectOnError, callback) {
          if (callback != null && typeof callback != "function")
            throw new Error("task callback must be a function");
          q.started = !0;
          var res, rej;
          function promiseCallback2(err, ...args) {
            if (err) return rejectOnError ? rej(err) : res();
            if (args.length <= 1) return res(args[0]);
            res(args);
          }
          var item = q._createTaskItem(
            data,
            rejectOnError ? promiseCallback2 : callback || promiseCallback2
          );
          if (insertAtFront ? q._tasks.unshift(item) : q._tasks.push(item), processingScheduled || (processingScheduled = !0, setImmediate$1(() => {
            processingScheduled = !1, q.process();
          })), rejectOnError || !callback)
            return new Promise((resolve2, reject2) => {
              res = resolve2, rej = reject2;
            });
        }
        function _createCB(tasks) {
          return function(err, ...args) {
            numRunning -= 1;
            for (var i = 0, l = tasks.length; i < l; i++) {
              var task = tasks[i], index2 = workersList.indexOf(task);
              index2 === 0 ? workersList.shift() : index2 > 0 && workersList.splice(index2, 1), task.callback(err, ...args), err != null && trigger("error", err, task.data);
            }
            numRunning <= q.concurrency - q.buffer && trigger("unsaturated"), q.idle() && trigger("drain"), q.process();
          };
        }
        function _maybeDrain(data) {
          return data.length === 0 && q.idle() ? (setImmediate$1(() => trigger("drain")), !0) : !1;
        }
        let eventMethod = (name2) => (handler) => {
          if (!handler)
            return new Promise((resolve2, reject2) => {
              once2(name2, (err, data) => {
                if (err) return reject2(err);
                resolve2(data);
              });
            });
          off(name2), on(name2, handler);
        };
        var isProcessing = !1, q = {
          _tasks: new DLL(),
          _createTaskItem(data, callback) {
            return {
              data,
              callback
            };
          },
          *[Symbol.iterator]() {
            yield* q._tasks[Symbol.iterator]();
          },
          concurrency,
          payload,
          buffer: concurrency / 4,
          started: !1,
          paused: !1,
          push(data, callback) {
            return Array.isArray(data) ? _maybeDrain(data) ? void 0 : data.map((datum) => _insert(datum, !1, !1, callback)) : _insert(data, !1, !1, callback);
          },
          pushAsync(data, callback) {
            return Array.isArray(data) ? _maybeDrain(data) ? void 0 : data.map((datum) => _insert(datum, !1, !0, callback)) : _insert(data, !1, !0, callback);
          },
          kill() {
            off(), q._tasks.empty();
          },
          unshift(data, callback) {
            return Array.isArray(data) ? _maybeDrain(data) ? void 0 : data.map((datum) => _insert(datum, !0, !1, callback)) : _insert(data, !0, !1, callback);
          },
          unshiftAsync(data, callback) {
            return Array.isArray(data) ? _maybeDrain(data) ? void 0 : data.map((datum) => _insert(datum, !0, !0, callback)) : _insert(data, !0, !0, callback);
          },
          remove(testFn) {
            q._tasks.remove(testFn);
          },
          process() {
            if (!isProcessing) {
              for (isProcessing = !0; !q.paused && numRunning < q.concurrency && q._tasks.length; ) {
                var tasks = [], data = [], l = q._tasks.length;
                q.payload && (l = Math.min(l, q.payload));
                for (var i = 0; i < l; i++) {
                  var node = q._tasks.shift();
                  tasks.push(node), workersList.push(node), data.push(node.data);
                }
                numRunning += 1, q._tasks.length === 0 && trigger("empty"), numRunning === q.concurrency && trigger("saturated");
                var cb = onlyOnce(_createCB(tasks));
                _worker(data, cb);
              }
              isProcessing = !1;
            }
          },
          length() {
            return q._tasks.length;
          },
          running() {
            return numRunning;
          },
          workersList() {
            return workersList;
          },
          idle() {
            return q._tasks.length + numRunning === 0;
          },
          pause() {
            q.paused = !0;
          },
          resume() {
            q.paused !== !1 && (q.paused = !1, setImmediate$1(q.process));
          }
        };
        return Object.defineProperties(q, {
          saturated: {
            writable: !1,
            value: eventMethod("saturated")
          },
          unsaturated: {
            writable: !1,
            value: eventMethod("unsaturated")
          },
          empty: {
            writable: !1,
            value: eventMethod("empty")
          },
          drain: {
            writable: !1,
            value: eventMethod("drain")
          },
          error: {
            writable: !1,
            value: eventMethod("error")
          }
        }), q;
      }
      function cargo$1(worker, payload) {
        return queue$1(worker, 1, payload);
      }
      function cargo(worker, concurrency, payload) {
        return queue$1(worker, concurrency, payload);
      }
      function reduce(coll, memo, iteratee, callback) {
        callback = once(callback);
        var _iteratee = wrapAsync(iteratee);
        return eachOfSeries$1(coll, (x, i, iterCb) => {
          _iteratee(memo, x, (err, v) => {
            memo = v, iterCb(err);
          });
        }, (err) => callback(err, memo));
      }
      var reduce$1 = awaitify(reduce, 4);
      function seq(...functions) {
        var _functions = functions.map(wrapAsync);
        return function(...args) {
          var that = this, cb = args[args.length - 1];
          return typeof cb == "function" ? args.pop() : cb = promiseCallback(), reduce$1(
            _functions,
            args,
            (newargs, fn, iterCb) => {
              fn.apply(that, newargs.concat((err, ...nextargs) => {
                iterCb(err, nextargs);
              }));
            },
            (err, results) => cb(err, ...results)
          ), cb[PROMISE_SYMBOL];
        };
      }
      function compose(...args) {
        return seq(...args.reverse());
      }
      function mapLimit(coll, limit, iteratee, callback) {
        return _asyncMap(eachOfLimit$2(limit), coll, iteratee, callback);
      }
      var mapLimit$1 = awaitify(mapLimit, 4);
      function concatLimit(coll, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(coll, limit, (val, iterCb) => {
          _iteratee(val, (err, ...args) => err ? iterCb(err) : iterCb(err, args));
        }, (err, mapResults) => {
          for (var result = [], i = 0; i < mapResults.length; i++)
            mapResults[i] && (result = result.concat(...mapResults[i]));
          return callback(err, result);
        });
      }
      var concatLimit$1 = awaitify(concatLimit, 4);
      function concat(coll, iteratee, callback) {
        return concatLimit$1(coll, 1 / 0, iteratee, callback);
      }
      var concat$1 = awaitify(concat, 3);
      function concatSeries(coll, iteratee, callback) {
        return concatLimit$1(coll, 1, iteratee, callback);
      }
      var concatSeries$1 = awaitify(concatSeries, 3);
      function constant$1(...args) {
        return function(...ignoredArgs) {
          var callback = ignoredArgs.pop();
          return callback(null, ...args);
        };
      }
      function _createTester(check, getResult) {
        return (eachfn, arr, _iteratee, cb) => {
          var testPassed = !1, testResult;
          let iteratee = wrapAsync(_iteratee);
          eachfn(arr, (value, _, callback) => {
            iteratee(value, (err, result) => {
              if (err || err === !1) return callback(err);
              if (check(result) && !testResult)
                return testPassed = !0, testResult = getResult(!0, value), callback(null, breakLoop);
              callback();
            });
          }, (err) => {
            if (err) return cb(err);
            cb(null, testPassed ? testResult : getResult(!1));
          });
        };
      }
      function detect(coll, iteratee, callback) {
        return _createTester((bool) => bool, (res, item) => item)(eachOf$1, coll, iteratee, callback);
      }
      var detect$1 = awaitify(detect, 3);
      function detectLimit(coll, limit, iteratee, callback) {
        return _createTester((bool) => bool, (res, item) => item)(eachOfLimit$2(limit), coll, iteratee, callback);
      }
      var detectLimit$1 = awaitify(detectLimit, 4);
      function detectSeries(coll, iteratee, callback) {
        return _createTester((bool) => bool, (res, item) => item)(eachOfLimit$2(1), coll, iteratee, callback);
      }
      var detectSeries$1 = awaitify(detectSeries, 3);
      function consoleFunc(name2) {
        return (fn, ...args) => wrapAsync(fn)(...args, (err, ...resultArgs) => {
          typeof console == "object" && (err ? console.error && console.error(err) : console[name2] && resultArgs.forEach((x) => console[name2](x)));
        });
      }
      var dir = consoleFunc("dir");
      function doWhilst(iteratee, test, callback) {
        callback = onlyOnce(callback);
        var _fn = wrapAsync(iteratee), _test = wrapAsync(test), results;
        function next(err, ...args) {
          if (err) return callback(err);
          err !== !1 && (results = args, _test(...args, check));
        }
        function check(err, truth) {
          if (err) return callback(err);
          if (err !== !1) {
            if (!truth) return callback(null, ...results);
            _fn(next);
          }
        }
        return check(null, !0);
      }
      var doWhilst$1 = awaitify(doWhilst, 3);
      function doUntil(iteratee, test, callback) {
        let _test = wrapAsync(test);
        return doWhilst$1(iteratee, (...args) => {
          let cb = args.pop();
          _test(...args, (err, truth) => cb(err, !truth));
        }, callback);
      }
      function _withoutIndex(iteratee) {
        return (value, index2, callback) => iteratee(value, callback);
      }
      function eachLimit$2(coll, iteratee, callback) {
        return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);
      }
      var each = awaitify(eachLimit$2, 3);
      function eachLimit(coll, limit, iteratee, callback) {
        return eachOfLimit$2(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
      }
      var eachLimit$1 = awaitify(eachLimit, 4);
      function eachSeries(coll, iteratee, callback) {
        return eachLimit$1(coll, 1, iteratee, callback);
      }
      var eachSeries$1 = awaitify(eachSeries, 3);
      function ensureAsync(fn) {
        return isAsync(fn) ? fn : function(...args) {
          var callback = args.pop(), sync = !0;
          args.push((...innerArgs) => {
            sync ? setImmediate$1(() => callback(...innerArgs)) : callback(...innerArgs);
          }), fn.apply(this, args), sync = !1;
        };
      }
      function every(coll, iteratee, callback) {
        return _createTester((bool) => !bool, (res) => !res)(eachOf$1, coll, iteratee, callback);
      }
      var every$1 = awaitify(every, 3);
      function everyLimit(coll, limit, iteratee, callback) {
        return _createTester((bool) => !bool, (res) => !res)(eachOfLimit$2(limit), coll, iteratee, callback);
      }
      var everyLimit$1 = awaitify(everyLimit, 4);
      function everySeries(coll, iteratee, callback) {
        return _createTester((bool) => !bool, (res) => !res)(eachOfSeries$1, coll, iteratee, callback);
      }
      var everySeries$1 = awaitify(everySeries, 3);
      function filterArray(eachfn, arr, iteratee, callback) {
        var truthValues = new Array(arr.length);
        eachfn(arr, (x, index2, iterCb) => {
          iteratee(x, (err, v) => {
            truthValues[index2] = !!v, iterCb(err);
          });
        }, (err) => {
          if (err) return callback(err);
          for (var results = [], i = 0; i < arr.length; i++)
            truthValues[i] && results.push(arr[i]);
          callback(null, results);
        });
      }
      function filterGeneric(eachfn, coll, iteratee, callback) {
        var results = [];
        eachfn(coll, (x, index2, iterCb) => {
          iteratee(x, (err, v) => {
            if (err) return iterCb(err);
            v && results.push({ index: index2, value: x }), iterCb(err);
          });
        }, (err) => {
          if (err) return callback(err);
          callback(null, results.sort((a, b) => a.index - b.index).map((v) => v.value));
        });
      }
      function _filter(eachfn, coll, iteratee, callback) {
        var filter2 = isArrayLike(coll) ? filterArray : filterGeneric;
        return filter2(eachfn, coll, wrapAsync(iteratee), callback);
      }
      function filter(coll, iteratee, callback) {
        return _filter(eachOf$1, coll, iteratee, callback);
      }
      var filter$1 = awaitify(filter, 3);
      function filterLimit(coll, limit, iteratee, callback) {
        return _filter(eachOfLimit$2(limit), coll, iteratee, callback);
      }
      var filterLimit$1 = awaitify(filterLimit, 4);
      function filterSeries(coll, iteratee, callback) {
        return _filter(eachOfSeries$1, coll, iteratee, callback);
      }
      var filterSeries$1 = awaitify(filterSeries, 3);
      function forever(fn, errback) {
        var done = onlyOnce(errback), task = wrapAsync(ensureAsync(fn));
        function next(err) {
          if (err) return done(err);
          err !== !1 && task(next);
        }
        return next();
      }
      var forever$1 = awaitify(forever, 2);
      function groupByLimit(coll, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(coll, limit, (val, iterCb) => {
          _iteratee(val, (err, key) => err ? iterCb(err) : iterCb(err, { key, val }));
        }, (err, mapResults) => {
          for (var result = {}, { hasOwnProperty: hasOwnProperty2 } = Object.prototype, i = 0; i < mapResults.length; i++)
            if (mapResults[i]) {
              var { key } = mapResults[i], { val } = mapResults[i];
              hasOwnProperty2.call(result, key) ? result[key].push(val) : result[key] = [val];
            }
          return callback(err, result);
        });
      }
      var groupByLimit$1 = awaitify(groupByLimit, 4);
      function groupBy(coll, iteratee, callback) {
        return groupByLimit$1(coll, 1 / 0, iteratee, callback);
      }
      function groupBySeries(coll, iteratee, callback) {
        return groupByLimit$1(coll, 1, iteratee, callback);
      }
      var log = consoleFunc("log");
      function mapValuesLimit(obj, limit, iteratee, callback) {
        callback = once(callback);
        var newObj = {}, _iteratee = wrapAsync(iteratee);
        return eachOfLimit$2(limit)(obj, (val, key, next) => {
          _iteratee(val, key, (err, result) => {
            if (err) return next(err);
            newObj[key] = result, next(err);
          });
        }, (err) => callback(err, newObj));
      }
      var mapValuesLimit$1 = awaitify(mapValuesLimit, 4);
      function mapValues(obj, iteratee, callback) {
        return mapValuesLimit$1(obj, 1 / 0, iteratee, callback);
      }
      function mapValuesSeries(obj, iteratee, callback) {
        return mapValuesLimit$1(obj, 1, iteratee, callback);
      }
      function memoize(fn, hasher = (v) => v) {
        var memo = /* @__PURE__ */ Object.create(null), queues = /* @__PURE__ */ Object.create(null), _fn = wrapAsync(fn), memoized = initialParams((args, callback) => {
          var key = hasher(...args);
          key in memo ? setImmediate$1(() => callback(null, ...memo[key])) : key in queues ? queues[key].push(callback) : (queues[key] = [callback], _fn(...args, (err, ...resultArgs) => {
            err || (memo[key] = resultArgs);
            var q = queues[key];
            delete queues[key];
            for (var i = 0, l = q.length; i < l; i++)
              q[i](err, ...resultArgs);
          }));
        });
        return memoized.memo = memo, memoized.unmemoized = fn, memoized;
      }
      var _defer;
      hasNextTick ? _defer = process.nextTick : hasSetImmediate ? _defer = setImmediate : _defer = fallback;
      var nextTick = wrap(_defer), _parallel = awaitify((eachfn, tasks, callback) => {
        var results = isArrayLike(tasks) ? [] : {};
        eachfn(tasks, (task, key, taskCb) => {
          wrapAsync(task)((err, ...result) => {
            result.length < 2 && ([result] = result), results[key] = result, taskCb(err);
          });
        }, (err) => callback(err, results));
      }, 3);
      function parallel(tasks, callback) {
        return _parallel(eachOf$1, tasks, callback);
      }
      function parallelLimit(tasks, limit, callback) {
        return _parallel(eachOfLimit$2(limit), tasks, callback);
      }
      function queue(worker, concurrency) {
        var _worker = wrapAsync(worker);
        return queue$1((items, cb) => {
          _worker(items[0], cb);
        }, concurrency, 1);
      }
      class Heap {
        constructor() {
          this.heap = [], this.pushCount = Number.MIN_SAFE_INTEGER;
        }
        get length() {
          return this.heap.length;
        }
        empty() {
          return this.heap = [], this;
        }
        percUp(index2) {
          let p;
          for (; index2 > 0 && smaller(this.heap[index2], this.heap[p = parent(index2)]); ) {
            let t = this.heap[index2];
            this.heap[index2] = this.heap[p], this.heap[p] = t, index2 = p;
          }
        }
        percDown(index2) {
          let l;
          for (; (l = leftChi(index2)) < this.heap.length && (l + 1 < this.heap.length && smaller(this.heap[l + 1], this.heap[l]) && (l = l + 1), !smaller(this.heap[index2], this.heap[l])); ) {
            let t = this.heap[index2];
            this.heap[index2] = this.heap[l], this.heap[l] = t, index2 = l;
          }
        }
        push(node) {
          node.pushCount = ++this.pushCount, this.heap.push(node), this.percUp(this.heap.length - 1);
        }
        unshift(node) {
          return this.heap.push(node);
        }
        shift() {
          let [top] = this.heap;
          return this.heap[0] = this.heap[this.heap.length - 1], this.heap.pop(), this.percDown(0), top;
        }
        toArray() {
          return [...this];
        }
        *[Symbol.iterator]() {
          for (let i = 0; i < this.heap.length; i++)
            yield this.heap[i].data;
        }
        remove(testFn) {
          let j = 0;
          for (let i = 0; i < this.heap.length; i++)
            testFn(this.heap[i]) || (this.heap[j] = this.heap[i], j++);
          this.heap.splice(j);
          for (let i = parent(this.heap.length - 1); i >= 0; i--)
            this.percDown(i);
          return this;
        }
      }
      function leftChi(i) {
        return (i << 1) + 1;
      }
      function parent(i) {
        return (i + 1 >> 1) - 1;
      }
      function smaller(x, y) {
        return x.priority !== y.priority ? x.priority < y.priority : x.pushCount < y.pushCount;
      }
      function priorityQueue(worker, concurrency) {
        var q = queue(worker, concurrency), {
          push: push2,
          pushAsync
        } = q;
        q._tasks = new Heap(), q._createTaskItem = ({ data, priority }, callback) => ({
          data,
          priority,
          callback
        });
        function createDataItems(tasks, priority) {
          return Array.isArray(tasks) ? tasks.map((data) => ({ data, priority })) : { data: tasks, priority };
        }
        return q.push = function(data, priority = 0, callback) {
          return push2(createDataItems(data, priority), callback);
        }, q.pushAsync = function(data, priority = 0, callback) {
          return pushAsync(createDataItems(data, priority), callback);
        }, delete q.unshift, delete q.unshiftAsync, q;
      }
      function race(tasks, callback) {
        if (callback = once(callback), !Array.isArray(tasks)) return callback(new TypeError("First argument to race must be an array of functions"));
        if (!tasks.length) return callback();
        for (var i = 0, l = tasks.length; i < l; i++)
          wrapAsync(tasks[i])(callback);
      }
      var race$1 = awaitify(race, 2);
      function reduceRight(array, memo, iteratee, callback) {
        var reversed = [...array].reverse();
        return reduce$1(reversed, memo, iteratee, callback);
      }
      function reflect(fn) {
        var _fn = wrapAsync(fn);
        return initialParams(function(args, reflectCallback) {
          return args.push((error, ...cbArgs) => {
            let retVal = {};
            if (error && (retVal.error = error), cbArgs.length > 0) {
              var value = cbArgs;
              cbArgs.length <= 1 && ([value] = cbArgs), retVal.value = value;
            }
            reflectCallback(null, retVal);
          }), _fn.apply(this, args);
        });
      }
      function reflectAll(tasks) {
        var results;
        return Array.isArray(tasks) ? results = tasks.map(reflect) : (results = {}, Object.keys(tasks).forEach((key) => {
          results[key] = reflect.call(this, tasks[key]);
        })), results;
      }
      function reject$2(eachfn, arr, _iteratee, callback) {
        let iteratee = wrapAsync(_iteratee);
        return _filter(eachfn, arr, (value, cb) => {
          iteratee(value, (err, v) => {
            cb(err, !v);
          });
        }, callback);
      }
      function reject(coll, iteratee, callback) {
        return reject$2(eachOf$1, coll, iteratee, callback);
      }
      var reject$1 = awaitify(reject, 3);
      function rejectLimit(coll, limit, iteratee, callback) {
        return reject$2(eachOfLimit$2(limit), coll, iteratee, callback);
      }
      var rejectLimit$1 = awaitify(rejectLimit, 4);
      function rejectSeries(coll, iteratee, callback) {
        return reject$2(eachOfSeries$1, coll, iteratee, callback);
      }
      var rejectSeries$1 = awaitify(rejectSeries, 3);
      function constant(value) {
        return function() {
          return value;
        };
      }
      let DEFAULT_TIMES = 5, DEFAULT_INTERVAL = 0;
      function retry(opts, task, callback) {
        var options = {
          times: DEFAULT_TIMES,
          intervalFunc: constant(DEFAULT_INTERVAL)
        };
        if (arguments.length < 3 && typeof opts == "function" ? (callback = task || promiseCallback(), task = opts) : (parseTimes(options, opts), callback = callback || promiseCallback()), typeof task != "function")
          throw new Error("Invalid arguments for async.retry");
        var _task = wrapAsync(task), attempt = 1;
        function retryAttempt() {
          _task((err, ...args) => {
            err !== !1 && (err && attempt++ < options.times && (typeof options.errorFilter != "function" || options.errorFilter(err)) ? setTimeout(retryAttempt, options.intervalFunc(attempt - 1)) : callback(err, ...args));
          });
        }
        return retryAttempt(), callback[PROMISE_SYMBOL];
      }
      function parseTimes(acc, t) {
        if (typeof t == "object")
          acc.times = +t.times || DEFAULT_TIMES, acc.intervalFunc = typeof t.interval == "function" ? t.interval : constant(+t.interval || DEFAULT_INTERVAL), acc.errorFilter = t.errorFilter;
        else if (typeof t == "number" || typeof t == "string")
          acc.times = +t || DEFAULT_TIMES;
        else
          throw new Error("Invalid arguments for async.retry");
      }
      function retryable(opts, task) {
        task || (task = opts, opts = null);
        let arity = opts && opts.arity || task.length;
        isAsync(task) && (arity += 1);
        var _task = wrapAsync(task);
        return initialParams((args, callback) => {
          (args.length < arity - 1 || callback == null) && (args.push(callback), callback = promiseCallback());
          function taskFn(cb) {
            _task(...args, cb);
          }
          return opts ? retry(opts, taskFn, callback) : retry(taskFn, callback), callback[PROMISE_SYMBOL];
        });
      }
      function series(tasks, callback) {
        return _parallel(eachOfSeries$1, tasks, callback);
      }
      function some(coll, iteratee, callback) {
        return _createTester(Boolean, (res) => res)(eachOf$1, coll, iteratee, callback);
      }
      var some$1 = awaitify(some, 3);
      function someLimit(coll, limit, iteratee, callback) {
        return _createTester(Boolean, (res) => res)(eachOfLimit$2(limit), coll, iteratee, callback);
      }
      var someLimit$1 = awaitify(someLimit, 4);
      function someSeries(coll, iteratee, callback) {
        return _createTester(Boolean, (res) => res)(eachOfSeries$1, coll, iteratee, callback);
      }
      var someSeries$1 = awaitify(someSeries, 3);
      function sortBy(coll, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return map$1(coll, (x, iterCb) => {
          _iteratee(x, (err, criteria) => {
            if (err) return iterCb(err);
            iterCb(err, { value: x, criteria });
          });
        }, (err, results) => {
          if (err) return callback(err);
          callback(null, results.sort(comparator).map((v) => v.value));
        });
        function comparator(left, right) {
          var a = left.criteria, b = right.criteria;
          return a < b ? -1 : a > b ? 1 : 0;
        }
      }
      var sortBy$1 = awaitify(sortBy, 3);
      function timeout(asyncFn, milliseconds, info) {
        var fn = wrapAsync(asyncFn);
        return initialParams((args, callback) => {
          var timedOut = !1, timer;
          function timeoutCallback() {
            var name2 = asyncFn.name || "anonymous", error = new Error('Callback function "' + name2 + '" timed out.');
            error.code = "ETIMEDOUT", info && (error.info = info), timedOut = !0, callback(error);
          }
          args.push((...cbArgs) => {
            timedOut || (callback(...cbArgs), clearTimeout(timer));
          }), timer = setTimeout(timeoutCallback, milliseconds), fn(...args);
        });
      }
      function range(size) {
        for (var result = Array(size); size--; )
          result[size] = size;
        return result;
      }
      function timesLimit(count, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(range(count), limit, _iteratee, callback);
      }
      function times(n, iteratee, callback) {
        return timesLimit(n, 1 / 0, iteratee, callback);
      }
      function timesSeries(n, iteratee, callback) {
        return timesLimit(n, 1, iteratee, callback);
      }
      function transform(coll, accumulator, iteratee, callback) {
        arguments.length <= 3 && typeof accumulator == "function" && (callback = iteratee, iteratee = accumulator, accumulator = Array.isArray(coll) ? [] : {}), callback = once(callback || promiseCallback());
        var _iteratee = wrapAsync(iteratee);
        return eachOf$1(coll, (v, k, cb) => {
          _iteratee(accumulator, v, k, cb);
        }, (err) => callback(err, accumulator)), callback[PROMISE_SYMBOL];
      }
      function tryEach(tasks, callback) {
        var error = null, result;
        return eachSeries$1(tasks, (task, taskCb) => {
          wrapAsync(task)((err, ...args) => {
            if (err === !1) return taskCb(err);
            args.length < 2 ? [result] = args : result = args, error = err, taskCb(err ? null : {});
          });
        }, () => callback(error, result));
      }
      var tryEach$1 = awaitify(tryEach);
      function unmemoize(fn) {
        return (...args) => (fn.unmemoized || fn)(...args);
      }
      function whilst(test, iteratee, callback) {
        callback = onlyOnce(callback);
        var _fn = wrapAsync(iteratee), _test = wrapAsync(test), results = [];
        function next(err, ...rest) {
          if (err) return callback(err);
          results = rest, err !== !1 && _test(check);
        }
        function check(err, truth) {
          if (err) return callback(err);
          if (err !== !1) {
            if (!truth) return callback(null, ...results);
            _fn(next);
          }
        }
        return _test(check);
      }
      var whilst$1 = awaitify(whilst, 3);
      function until(test, iteratee, callback) {
        let _test = wrapAsync(test);
        return whilst$1((cb) => _test((err, truth) => cb(err, !truth)), iteratee, callback);
      }
      function waterfall(tasks, callback) {
        if (callback = once(callback), !Array.isArray(tasks)) return callback(new Error("First argument to waterfall must be an array of functions"));
        if (!tasks.length) return callback();
        var taskIndex = 0;
        function nextTask(args) {
          var task = wrapAsync(tasks[taskIndex++]);
          task(...args, onlyOnce(next));
        }
        function next(err, ...args) {
          if (err !== !1) {
            if (err || taskIndex === tasks.length)
              return callback(err, ...args);
            nextTask(args);
          }
        }
        nextTask([]);
      }
      var waterfall$1 = awaitify(waterfall), index = {
        apply,
        applyEach,
        applyEachSeries,
        asyncify,
        auto,
        autoInject,
        cargo: cargo$1,
        cargoQueue: cargo,
        compose,
        concat: concat$1,
        concatLimit: concatLimit$1,
        concatSeries: concatSeries$1,
        constant: constant$1,
        detect: detect$1,
        detectLimit: detectLimit$1,
        detectSeries: detectSeries$1,
        dir,
        doUntil,
        doWhilst: doWhilst$1,
        each,
        eachLimit: eachLimit$1,
        eachOf: eachOf$1,
        eachOfLimit: eachOfLimit$1,
        eachOfSeries: eachOfSeries$1,
        eachSeries: eachSeries$1,
        ensureAsync,
        every: every$1,
        everyLimit: everyLimit$1,
        everySeries: everySeries$1,
        filter: filter$1,
        filterLimit: filterLimit$1,
        filterSeries: filterSeries$1,
        forever: forever$1,
        groupBy,
        groupByLimit: groupByLimit$1,
        groupBySeries,
        log,
        map: map$1,
        mapLimit: mapLimit$1,
        mapSeries: mapSeries$1,
        mapValues,
        mapValuesLimit: mapValuesLimit$1,
        mapValuesSeries,
        memoize,
        nextTick,
        parallel,
        parallelLimit,
        priorityQueue,
        queue,
        race: race$1,
        reduce: reduce$1,
        reduceRight,
        reflect,
        reflectAll,
        reject: reject$1,
        rejectLimit: rejectLimit$1,
        rejectSeries: rejectSeries$1,
        retry,
        retryable,
        seq,
        series,
        setImmediate: setImmediate$1,
        some: some$1,
        someLimit: someLimit$1,
        someSeries: someSeries$1,
        sortBy: sortBy$1,
        timeout,
        times,
        timesLimit,
        timesSeries,
        transform,
        tryEach: tryEach$1,
        unmemoize,
        until,
        waterfall: waterfall$1,
        whilst: whilst$1,
        // aliases
        all: every$1,
        allLimit: everyLimit$1,
        allSeries: everySeries$1,
        any: some$1,
        anyLimit: someLimit$1,
        anySeries: someSeries$1,
        find: detect$1,
        findLimit: detectLimit$1,
        findSeries: detectSeries$1,
        flatMap: concat$1,
        flatMapLimit: concatLimit$1,
        flatMapSeries: concatSeries$1,
        forEach: each,
        forEachSeries: eachSeries$1,
        forEachLimit: eachLimit$1,
        forEachOf: eachOf$1,
        forEachOfSeries: eachOfSeries$1,
        forEachOfLimit: eachOfLimit$1,
        inject: reduce$1,
        foldl: reduce$1,
        foldr: reduceRight,
        select: filter$1,
        selectLimit: filterLimit$1,
        selectSeries: filterSeries$1,
        wrapSync: asyncify,
        during: whilst$1,
        doDuring: doWhilst$1
      };
      exports3.all = every$1, exports3.allLimit = everyLimit$1, exports3.allSeries = everySeries$1, exports3.any = some$1, exports3.anyLimit = someLimit$1, exports3.anySeries = someSeries$1, exports3.apply = apply, exports3.applyEach = applyEach, exports3.applyEachSeries = applyEachSeries, exports3.asyncify = asyncify, exports3.auto = auto, exports3.autoInject = autoInject, exports3.cargo = cargo$1, exports3.cargoQueue = cargo, exports3.compose = compose, exports3.concat = concat$1, exports3.concatLimit = concatLimit$1, exports3.concatSeries = concatSeries$1, exports3.constant = constant$1, exports3.default = index, exports3.detect = detect$1, exports3.detectLimit = detectLimit$1, exports3.detectSeries = detectSeries$1, exports3.dir = dir, exports3.doDuring = doWhilst$1, exports3.doUntil = doUntil, exports3.doWhilst = doWhilst$1, exports3.during = whilst$1, exports3.each = each, exports3.eachLimit = eachLimit$1, exports3.eachOf = eachOf$1, exports3.eachOfLimit = eachOfLimit$1, exports3.eachOfSeries = eachOfSeries$1, exports3.eachSeries = eachSeries$1, exports3.ensureAsync = ensureAsync, exports3.every = every$1, exports3.everyLimit = everyLimit$1, exports3.everySeries = everySeries$1, exports3.filter = filter$1, exports3.filterLimit = filterLimit$1, exports3.filterSeries = filterSeries$1, exports3.find = detect$1, exports3.findLimit = detectLimit$1, exports3.findSeries = detectSeries$1, exports3.flatMap = concat$1, exports3.flatMapLimit = concatLimit$1, exports3.flatMapSeries = concatSeries$1, exports3.foldl = reduce$1, exports3.foldr = reduceRight, exports3.forEach = each, exports3.forEachLimit = eachLimit$1, exports3.forEachOf = eachOf$1, exports3.forEachOfLimit = eachOfLimit$1, exports3.forEachOfSeries = eachOfSeries$1, exports3.forEachSeries = eachSeries$1, exports3.forever = forever$1, exports3.groupBy = groupBy, exports3.groupByLimit = groupByLimit$1, exports3.groupBySeries = groupBySeries, exports3.inject = reduce$1, exports3.log = log, exports3.map = map$1, exports3.mapLimit = mapLimit$1, exports3.mapSeries = mapSeries$1, exports3.mapValues = mapValues, exports3.mapValuesLimit = mapValuesLimit$1, exports3.mapValuesSeries = mapValuesSeries, exports3.memoize = memoize, exports3.nextTick = nextTick, exports3.parallel = parallel, exports3.parallelLimit = parallelLimit, exports3.priorityQueue = priorityQueue, exports3.queue = queue, exports3.race = race$1, exports3.reduce = reduce$1, exports3.reduceRight = reduceRight, exports3.reflect = reflect, exports3.reflectAll = reflectAll, exports3.reject = reject$1, exports3.rejectLimit = rejectLimit$1, exports3.rejectSeries = rejectSeries$1, exports3.retry = retry, exports3.retryable = retryable, exports3.select = filter$1, exports3.selectLimit = filterLimit$1, exports3.selectSeries = filterSeries$1, exports3.seq = seq, exports3.series = series, exports3.setImmediate = setImmediate$1, exports3.some = some$1, exports3.someLimit = someLimit$1, exports3.someSeries = someSeries$1, exports3.sortBy = sortBy$1, exports3.timeout = timeout, exports3.times = times, exports3.timesLimit = timesLimit, exports3.timesSeries = timesSeries, exports3.transform = transform, exports3.tryEach = tryEach$1, exports3.unmemoize = unmemoize, exports3.until = until, exports3.waterfall = waterfall$1, exports3.whilst = whilst$1, exports3.wrapSync = asyncify, Object.defineProperty(exports3, "__esModule", { value: !0 });
    });
  }
});

// node_modules/universalify/index.js
var require_universalify = __commonJS({
  "node_modules/universalify/index.js"(exports2) {
    "use strict";
    exports2.fromCallback = function(fn) {
      return Object.defineProperty(function(...args) {
        if (typeof args[args.length - 1] == "function") fn.apply(this, args);
        else
          return new Promise((resolve2, reject) => {
            args.push((err, res) => err != null ? reject(err) : resolve2(res)), fn.apply(this, args);
          });
      }, "name", { value: fn.name });
    };
    exports2.fromPromise = function(fn) {
      return Object.defineProperty(function(...args) {
        let cb = args[args.length - 1];
        if (typeof cb != "function") return fn.apply(this, args);
        args.pop(), fn.apply(this, args).then((r) => cb(null, r), cb);
      }, "name", { value: fn.name });
    };
  }
});

// node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "node_modules/graceful-fs/polyfills.js"(exports2, module2) {
    var constants2 = require("constants"), origCwd = process.cwd, cwd = null, platform6 = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      return cwd || (cwd = origCwd.call(process)), cwd;
    };
    try {
      process.cwd();
    } catch {
    }
    typeof process.chdir == "function" && (chdir = process.chdir, process.chdir = function(d) {
      cwd = null, chdir.call(process, d);
    }, Object.setPrototypeOf && Object.setPrototypeOf(process.chdir, chdir));
    var chdir;
    module2.exports = patch;
    function patch(fs11) {
      constants2.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./) && patchLchmod(fs11), fs11.lutimes || patchLutimes(fs11), fs11.chown = chownFix(fs11.chown), fs11.fchown = chownFix(fs11.fchown), fs11.lchown = chownFix(fs11.lchown), fs11.chmod = chmodFix(fs11.chmod), fs11.fchmod = chmodFix(fs11.fchmod), fs11.lchmod = chmodFix(fs11.lchmod), fs11.chownSync = chownFixSync(fs11.chownSync), fs11.fchownSync = chownFixSync(fs11.fchownSync), fs11.lchownSync = chownFixSync(fs11.lchownSync), fs11.chmodSync = chmodFixSync(fs11.chmodSync), fs11.fchmodSync = chmodFixSync(fs11.fchmodSync), fs11.lchmodSync = chmodFixSync(fs11.lchmodSync), fs11.stat = statFix(fs11.stat), fs11.fstat = statFix(fs11.fstat), fs11.lstat = statFix(fs11.lstat), fs11.statSync = statFixSync(fs11.statSync), fs11.fstatSync = statFixSync(fs11.fstatSync), fs11.lstatSync = statFixSync(fs11.lstatSync), fs11.chmod && !fs11.lchmod && (fs11.lchmod = function(path8, mode, cb) {
        cb && process.nextTick(cb);
      }, fs11.lchmodSync = function() {
      }), fs11.chown && !fs11.lchown && (fs11.lchown = function(path8, uid, gid, cb) {
        cb && process.nextTick(cb);
      }, fs11.lchownSync = function() {
      }), platform6 === "win32" && (fs11.rename = typeof fs11.rename != "function" ? fs11.rename : function(fs$rename) {
        function rename(from, to, cb) {
          var start = Date.now(), backoff = 0;
          fs$rename(from, to, function CB(er) {
            if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
              setTimeout(function() {
                fs11.stat(to, function(stater, st) {
                  stater && stater.code === "ENOENT" ? fs$rename(from, to, CB) : cb(er);
                });
              }, backoff), backoff < 100 && (backoff += 10);
              return;
            }
            cb && cb(er);
          });
        }
        return Object.setPrototypeOf && Object.setPrototypeOf(rename, fs$rename), rename;
      }(fs11.rename)), fs11.read = typeof fs11.read != "function" ? fs11.read : function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ == "function") {
            var eagCounter = 0;
            callback = function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10)
                return eagCounter++, fs$read.call(fs11, fd, buffer, offset, length, position, callback);
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs11, fd, buffer, offset, length, position, callback);
        }
        return Object.setPrototypeOf && Object.setPrototypeOf(read, fs$read), read;
      }(fs11.read), fs11.readSync = typeof fs11.readSync != "function" ? fs11.readSync : /* @__PURE__ */ function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          for (var eagCounter = 0; ; )
            try {
              return fs$readSync.call(fs11, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
        };
      }(fs11.readSync);
      function patchLchmod(fs12) {
        fs12.lchmod = function(path8, mode, callback) {
          fs12.open(
            path8,
            constants2.O_WRONLY | constants2.O_SYMLINK,
            mode,
            function(err, fd) {
              if (err) {
                callback && callback(err);
                return;
              }
              fs12.fchmod(fd, mode, function(err2) {
                fs12.close(fd, function(err22) {
                  callback && callback(err2 || err22);
                });
              });
            }
          );
        }, fs12.lchmodSync = function(path8, mode) {
          var fd = fs12.openSync(path8, constants2.O_WRONLY | constants2.O_SYMLINK, mode), threw = !0, ret;
          try {
            ret = fs12.fchmodSync(fd, mode), threw = !1;
          } finally {
            if (threw)
              try {
                fs12.closeSync(fd);
              } catch {
              }
            else
              fs12.closeSync(fd);
          }
          return ret;
        };
      }
      function patchLutimes(fs12) {
        constants2.hasOwnProperty("O_SYMLINK") && fs12.futimes ? (fs12.lutimes = function(path8, at, mt, cb) {
          fs12.open(path8, constants2.O_SYMLINK, function(er, fd) {
            if (er) {
              cb && cb(er);
              return;
            }
            fs12.futimes(fd, at, mt, function(er2) {
              fs12.close(fd, function(er22) {
                cb && cb(er2 || er22);
              });
            });
          });
        }, fs12.lutimesSync = function(path8, at, mt) {
          var fd = fs12.openSync(path8, constants2.O_SYMLINK), ret, threw = !0;
          try {
            ret = fs12.futimesSync(fd, at, mt), threw = !1;
          } finally {
            if (threw)
              try {
                fs12.closeSync(fd);
              } catch {
              }
            else
              fs12.closeSync(fd);
          }
          return ret;
        }) : fs12.futimes && (fs12.lutimes = function(_a, _b, _c, cb) {
          cb && process.nextTick(cb);
        }, fs12.lutimesSync = function() {
        });
      }
      function chmodFix(orig) {
        return orig && function(target, mode, cb) {
          return orig.call(fs11, target, mode, function(er) {
            chownErOk(er) && (er = null), cb && cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        return orig && function(target, mode) {
          try {
            return orig.call(fs11, target, mode);
          } catch (er) {
            if (!chownErOk(er)) throw er;
          }
        };
      }
      function chownFix(orig) {
        return orig && function(target, uid, gid, cb) {
          return orig.call(fs11, target, uid, gid, function(er) {
            chownErOk(er) && (er = null), cb && cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        return orig && function(target, uid, gid) {
          try {
            return orig.call(fs11, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er)) throw er;
          }
        };
      }
      function statFix(orig) {
        return orig && function(target, options, cb) {
          typeof options == "function" && (cb = options, options = null);
          function callback(er, stats) {
            stats && (stats.uid < 0 && (stats.uid += 4294967296), stats.gid < 0 && (stats.gid += 4294967296)), cb && cb.apply(this, arguments);
          }
          return options ? orig.call(fs11, target, options, callback) : orig.call(fs11, target, callback);
        };
      }
      function statFixSync(orig) {
        return orig && function(target, options) {
          var stats = options ? orig.call(fs11, target, options) : orig.call(fs11, target);
          return stats && (stats.uid < 0 && (stats.uid += 4294967296), stats.gid < 0 && (stats.gid += 4294967296)), stats;
        };
      }
      function chownErOk(er) {
        if (!er || er.code === "ENOSYS")
          return !0;
        var nonroot = !process.getuid || process.getuid() !== 0;
        return !!(nonroot && (er.code === "EINVAL" || er.code === "EPERM"));
      }
    }
  }
});

// node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "node_modules/graceful-fs/legacy-streams.js"(exports2, module2) {
    var Stream2 = require("stream").Stream;
    module2.exports = legacy;
    function legacy(fs11) {
      return {
        ReadStream: ReadStream2,
        WriteStream: WriteStream2
      };
      function ReadStream2(path8, options) {
        if (!(this instanceof ReadStream2)) return new ReadStream2(path8, options);
        Stream2.call(this);
        var self2 = this;
        this.path = path8, this.fd = null, this.readable = !0, this.paused = !1, this.flags = "r", this.mode = 438, this.bufferSize = 64 * 1024, options = options || {};
        for (var keys = Object.keys(options), index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.encoding && this.setEncoding(this.encoding), this.start !== void 0) {
          if (typeof this.start != "number")
            throw TypeError("start must be a Number");
          if (this.end === void 0)
            this.end = 1 / 0;
          else if (typeof this.end != "number")
            throw TypeError("end must be a Number");
          if (this.start > this.end)
            throw new Error("start must be <= end");
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self2._read();
          });
          return;
        }
        fs11.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self2.emit("error", err), self2.readable = !1;
            return;
          }
          self2.fd = fd, self2.emit("open", fd), self2._read();
        });
      }
      function WriteStream2(path8, options) {
        if (!(this instanceof WriteStream2)) return new WriteStream2(path8, options);
        Stream2.call(this), this.path = path8, this.fd = null, this.writable = !0, this.flags = "w", this.encoding = "binary", this.mode = 438, this.bytesWritten = 0, options = options || {};
        for (var keys = Object.keys(options), index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if (typeof this.start != "number")
            throw TypeError("start must be a Number");
          if (this.start < 0)
            throw new Error("start must be >= zero");
          this.pos = this.start;
        }
        this.busy = !1, this._queue = [], this.fd === null && (this._open = fs11.open, this._queue.push([this._open, this.path, this.flags, this.mode, void 0]), this.flush());
      }
    }
  }
});

// node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "node_modules/graceful-fs/clone.js"(exports2, module2) {
    "use strict";
    module2.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj != "object")
        return obj;
      if (obj instanceof Object)
        var copy = { __proto__: getPrototypeOf(obj) };
      else
        var copy = /* @__PURE__ */ Object.create(null);
      return Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      }), copy;
    }
  }
});

// node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "node_modules/graceful-fs/graceful-fs.js"(exports2, module2) {
    var fs11 = require("fs"), polyfills = require_polyfills(), legacy = require_legacy_streams(), clone = require_clone(), util = require("util"), gracefulQueue, previousSymbol;
    typeof Symbol == "function" && typeof Symbol.for == "function" ? (gracefulQueue = Symbol.for("graceful-fs.queue"), previousSymbol = Symbol.for("graceful-fs.previous")) : (gracefulQueue = "___graceful-fs.queue", previousSymbol = "___graceful-fs.previous");
    function noop2() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug = noop2;
    util.debuglog ? debug = util.debuglog("gfs4") : /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && (debug = function() {
      var m = util.format.apply(util, arguments);
      m = "GFS4: " + m.split(/\n/).join(`
GFS4: `), console.error(m);
    });
    fs11[gracefulQueue] || (queue = global[gracefulQueue] || [], publishQueue(fs11, queue), fs11.close = function(fs$close) {
      function close(fd, cb) {
        return fs$close.call(fs11, fd, function(err) {
          err || resetQueue(), typeof cb == "function" && cb.apply(this, arguments);
        });
      }
      return Object.defineProperty(close, previousSymbol, {
        value: fs$close
      }), close;
    }(fs11.close), fs11.closeSync = function(fs$closeSync) {
      function closeSync(fd) {
        fs$closeSync.apply(fs11, arguments), resetQueue();
      }
      return Object.defineProperty(closeSync, previousSymbol, {
        value: fs$closeSync
      }), closeSync;
    }(fs11.closeSync), /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && process.on("exit", function() {
      debug(fs11[gracefulQueue]), require("assert").equal(fs11[gracefulQueue].length, 0);
    }));
    var queue;
    global[gracefulQueue] || publishQueue(global, fs11[gracefulQueue]);
    module2.exports = patch(clone(fs11));
    process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs11.__patched && (module2.exports = patch(fs11), fs11.__patched = !0);
    function patch(fs12) {
      polyfills(fs12), fs12.gracefulify = patch, fs12.createReadStream = createReadStream, fs12.createWriteStream = createWriteStream;
      var fs$readFile = fs12.readFile;
      fs12.readFile = readFile;
      function readFile(path8, options, cb) {
        return typeof options == "function" && (cb = options, options = null), go$readFile(path8, options, cb);
        function go$readFile(path9, options2, cb2, startTime) {
          return fs$readFile(path9, options2, function(err) {
            err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$readFile, [path9, options2, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
          });
        }
      }
      var fs$writeFile = fs12.writeFile;
      fs12.writeFile = writeFile;
      function writeFile(path8, data, options, cb) {
        return typeof options == "function" && (cb = options, options = null), go$writeFile(path8, data, options, cb);
        function go$writeFile(path9, data2, options2, cb2, startTime) {
          return fs$writeFile(path9, data2, options2, function(err) {
            err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$writeFile, [path9, data2, options2, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
          });
        }
      }
      var fs$appendFile = fs12.appendFile;
      fs$appendFile && (fs12.appendFile = appendFile);
      function appendFile(path8, data, options, cb) {
        return typeof options == "function" && (cb = options, options = null), go$appendFile(path8, data, options, cb);
        function go$appendFile(path9, data2, options2, cb2, startTime) {
          return fs$appendFile(path9, data2, options2, function(err) {
            err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$appendFile, [path9, data2, options2, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
          });
        }
      }
      var fs$copyFile = fs12.copyFile;
      fs$copyFile && (fs12.copyFile = copyFile);
      function copyFile(src, dest, flags, cb) {
        return typeof flags == "function" && (cb = flags, flags = 0), go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
          });
        }
      }
      var fs$readdir = fs12.readdir;
      fs12.readdir = readdir;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir(path8, options, cb) {
        typeof options == "function" && (cb = options, options = null);
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function(path9, options2, cb2, startTime) {
          return fs$readdir(path9, fs$readdirCallback(
            path9,
            options2,
            cb2,
            startTime
          ));
        } : function(path9, options2, cb2, startTime) {
          return fs$readdir(path9, options2, fs$readdirCallback(
            path9,
            options2,
            cb2,
            startTime
          ));
        };
        return go$readdir(path8, options, cb);
        function fs$readdirCallback(path9, options2, cb2, startTime) {
          return function(err, files) {
            err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([
              go$readdir,
              [path9, options2, cb2],
              err,
              startTime || Date.now(),
              Date.now()
            ]) : (files && files.sort && files.sort(), typeof cb2 == "function" && cb2.call(this, err, files));
          };
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs12);
        ReadStream2 = legStreams.ReadStream, WriteStream2 = legStreams.WriteStream;
      }
      var fs$ReadStream = fs12.ReadStream;
      fs$ReadStream && (ReadStream2.prototype = Object.create(fs$ReadStream.prototype), ReadStream2.prototype.open = ReadStream$open);
      var fs$WriteStream = fs12.WriteStream;
      fs$WriteStream && (WriteStream2.prototype = Object.create(fs$WriteStream.prototype), WriteStream2.prototype.open = WriteStream$open), Object.defineProperty(fs12, "ReadStream", {
        get: function() {
          return ReadStream2;
        },
        set: function(val) {
          ReadStream2 = val;
        },
        enumerable: !0,
        configurable: !0
      }), Object.defineProperty(fs12, "WriteStream", {
        get: function() {
          return WriteStream2;
        },
        set: function(val) {
          WriteStream2 = val;
        },
        enumerable: !0,
        configurable: !0
      });
      var FileReadStream = ReadStream2;
      Object.defineProperty(fs12, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: !0,
        configurable: !0
      });
      var FileWriteStream = WriteStream2;
      Object.defineProperty(fs12, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: !0,
        configurable: !0
      });
      function ReadStream2(path8, options) {
        return this instanceof ReadStream2 ? (fs$ReadStream.apply(this, arguments), this) : ReadStream2.apply(Object.create(ReadStream2.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          err ? (that.autoClose && that.destroy(), that.emit("error", err)) : (that.fd = fd, that.emit("open", fd), that.read());
        });
      }
      function WriteStream2(path8, options) {
        return this instanceof WriteStream2 ? (fs$WriteStream.apply(this, arguments), this) : WriteStream2.apply(Object.create(WriteStream2.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          err ? (that.destroy(), that.emit("error", err)) : (that.fd = fd, that.emit("open", fd));
        });
      }
      function createReadStream(path8, options) {
        return new fs12.ReadStream(path8, options);
      }
      function createWriteStream(path8, options) {
        return new fs12.WriteStream(path8, options);
      }
      var fs$open = fs12.open;
      fs12.open = open;
      function open(path8, flags, mode, cb) {
        return typeof mode == "function" && (cb = mode, mode = null), go$open(path8, flags, mode, cb);
        function go$open(path9, flags2, mode2, cb2, startTime) {
          return fs$open(path9, flags2, mode2, function(err, fd) {
            err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$open, [path9, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
          });
        }
      }
      return fs12;
    }
    function enqueue(elem) {
      debug("ENQUEUE", elem[0].name, elem[1]), fs11[gracefulQueue].push(elem), retry();
    }
    var retryTimer;
    function resetQueue() {
      for (var now = Date.now(), i = 0; i < fs11[gracefulQueue].length; ++i)
        fs11[gracefulQueue][i].length > 2 && (fs11[gracefulQueue][i][3] = now, fs11[gracefulQueue][i][4] = now);
      retry();
    }
    function retry() {
      if (clearTimeout(retryTimer), retryTimer = void 0, fs11[gracefulQueue].length !== 0) {
        var elem = fs11[gracefulQueue].shift(), fn = elem[0], args = elem[1], err = elem[2], startTime = elem[3], lastTime = elem[4];
        if (startTime === void 0)
          debug("RETRY", fn.name, args), fn.apply(null, args);
        else if (Date.now() - startTime >= 6e4) {
          debug("TIMEOUT", fn.name, args);
          var cb = args.pop();
          typeof cb == "function" && cb.call(null, err);
        } else {
          var sinceAttempt = Date.now() - lastTime, sinceStart = Math.max(lastTime - startTime, 1), desiredDelay = Math.min(sinceStart * 1.2, 100);
          sinceAttempt >= desiredDelay ? (debug("RETRY", fn.name, args), fn.apply(null, args.concat([startTime]))) : fs11[gracefulQueue].push(elem);
        }
        retryTimer === void 0 && (retryTimer = setTimeout(retry, 0));
      }
    }
  }
});

// node_modules/fs-extra/lib/fs/index.js
var require_fs = __commonJS({
  "node_modules/fs-extra/lib/fs/index.js"(exports2) {
    "use strict";
    var u = require_universalify().fromCallback, fs11 = require_graceful_fs(), api = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "cp",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "glob",
      "lchmod",
      "lchown",
      "lutimes",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "opendir",
      "readdir",
      "readFile",
      "readlink",
      "realpath",
      "rename",
      "rm",
      "rmdir",
      "stat",
      "statfs",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile"
    ].filter((key) => typeof fs11[key] == "function");
    Object.assign(exports2, fs11);
    api.forEach((method) => {
      exports2[method] = u(fs11[method]);
    });
    exports2.exists = function(filename, callback) {
      return typeof callback == "function" ? fs11.exists(filename, callback) : new Promise((resolve2) => fs11.exists(filename, resolve2));
    };
    exports2.read = function(fd, buffer, offset, length, position, callback) {
      return typeof callback == "function" ? fs11.read(fd, buffer, offset, length, position, callback) : new Promise((resolve2, reject) => {
        fs11.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
          if (err) return reject(err);
          resolve2({ bytesRead, buffer: buffer2 });
        });
      });
    };
    exports2.write = function(fd, buffer, ...args) {
      return typeof args[args.length - 1] == "function" ? fs11.write(fd, buffer, ...args) : new Promise((resolve2, reject) => {
        fs11.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
          if (err) return reject(err);
          resolve2({ bytesWritten, buffer: buffer2 });
        });
      });
    };
    exports2.readv = function(fd, buffers, ...args) {
      return typeof args[args.length - 1] == "function" ? fs11.readv(fd, buffers, ...args) : new Promise((resolve2, reject) => {
        fs11.readv(fd, buffers, ...args, (err, bytesRead, buffers2) => {
          if (err) return reject(err);
          resolve2({ bytesRead, buffers: buffers2 });
        });
      });
    };
    exports2.writev = function(fd, buffers, ...args) {
      return typeof args[args.length - 1] == "function" ? fs11.writev(fd, buffers, ...args) : new Promise((resolve2, reject) => {
        fs11.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
          if (err) return reject(err);
          resolve2({ bytesWritten, buffers: buffers2 });
        });
      });
    };
    typeof fs11.realpath.native == "function" ? exports2.realpath.native = u(fs11.realpath.native) : process.emitWarning(
      "fs.realpath.native is not a function. Is fs being monkey-patched?",
      "Warning",
      "fs-extra-WARN0003"
    );
  }
});

// node_modules/fs-extra/lib/mkdirs/utils.js
var require_utils3 = __commonJS({
  "node_modules/fs-extra/lib/mkdirs/utils.js"(exports2, module2) {
    "use strict";
    var path8 = require("path");
    module2.exports.checkPath = function(pth) {
      if (process.platform === "win32" && /[<>:"|?*]/.test(pth.replace(path8.parse(pth).root, ""))) {
        let error = new Error(`Path contains invalid characters: ${pth}`);
        throw error.code = "EINVAL", error;
      }
    };
  }
});

// node_modules/fs-extra/lib/mkdirs/make-dir.js
var require_make_dir = __commonJS({
  "node_modules/fs-extra/lib/mkdirs/make-dir.js"(exports2, module2) {
    "use strict";
    var fs11 = require_fs(), { checkPath } = require_utils3(), getMode = (options) => {
      let defaults = { mode: 511 };
      return typeof options == "number" ? options : { ...defaults, ...options }.mode;
    };
    module2.exports.makeDir = async (dir, options) => (checkPath(dir), fs11.mkdir(dir, {
      mode: getMode(options),
      recursive: !0
    }));
    module2.exports.makeDirSync = (dir, options) => (checkPath(dir), fs11.mkdirSync(dir, {
      mode: getMode(options),
      recursive: !0
    }));
  }
});

// node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs = __commonJS({
  "node_modules/fs-extra/lib/mkdirs/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromPromise, { makeDir: _makeDir, makeDirSync } = require_make_dir(), makeDir = u(_makeDir);
    module2.exports = {
      mkdirs: makeDir,
      mkdirsSync: makeDirSync,
      // alias
      mkdirp: makeDir,
      mkdirpSync: makeDirSync,
      ensureDir: makeDir,
      ensureDirSync: makeDirSync
    };
  }
});

// node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists = __commonJS({
  "node_modules/fs-extra/lib/path-exists/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromPromise, fs11 = require_fs();
    function pathExists(path8) {
      return fs11.access(path8).then(() => !0).catch(() => !1);
    }
    module2.exports = {
      pathExists: u(pathExists),
      pathExistsSync: fs11.existsSync
    };
  }
});

// node_modules/fs-extra/lib/util/utimes.js
var require_utimes = __commonJS({
  "node_modules/fs-extra/lib/util/utimes.js"(exports2, module2) {
    "use strict";
    var fs11 = require_fs(), u = require_universalify().fromPromise;
    async function utimesMillis(path8, atime, mtime) {
      let fd = await fs11.open(path8, "r+"), closeErr = null;
      try {
        await fs11.futimes(fd, atime, mtime);
      } finally {
        try {
          await fs11.close(fd);
        } catch (e) {
          closeErr = e;
        }
      }
      if (closeErr)
        throw closeErr;
    }
    function utimesMillisSync(path8, atime, mtime) {
      let fd = fs11.openSync(path8, "r+");
      return fs11.futimesSync(fd, atime, mtime), fs11.closeSync(fd);
    }
    module2.exports = {
      utimesMillis: u(utimesMillis),
      utimesMillisSync
    };
  }
});

// node_modules/fs-extra/lib/util/stat.js
var require_stat = __commonJS({
  "node_modules/fs-extra/lib/util/stat.js"(exports2, module2) {
    "use strict";
    var fs11 = require_fs(), path8 = require("path"), u = require_universalify().fromPromise;
    function getStats(src, dest, opts) {
      let statFunc = opts.dereference ? (file) => fs11.stat(file, { bigint: !0 }) : (file) => fs11.lstat(file, { bigint: !0 });
      return Promise.all([
        statFunc(src),
        statFunc(dest).catch((err) => {
          if (err.code === "ENOENT") return null;
          throw err;
        })
      ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
    }
    function getStatsSync(src, dest, opts) {
      let destStat, statFunc = opts.dereference ? (file) => fs11.statSync(file, { bigint: !0 }) : (file) => fs11.lstatSync(file, { bigint: !0 }), srcStat = statFunc(src);
      try {
        destStat = statFunc(dest);
      } catch (err) {
        if (err.code === "ENOENT") return { srcStat, destStat: null };
        throw err;
      }
      return { srcStat, destStat };
    }
    async function checkPaths(src, dest, funcName, opts) {
      let { srcStat, destStat } = await getStats(src, dest, opts);
      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          let srcBaseName = path8.basename(src), destBaseName = path8.basename(dest);
          if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase())
            return { srcStat, destStat, isChangingCase: !0 };
          throw new Error("Source and destination must not be the same.");
        }
        if (srcStat.isDirectory() && !destStat.isDirectory())
          throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
        if (!srcStat.isDirectory() && destStat.isDirectory())
          throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest))
        throw new Error(errMsg(src, dest, funcName));
      return { srcStat, destStat };
    }
    function checkPathsSync(src, dest, funcName, opts) {
      let { srcStat, destStat } = getStatsSync(src, dest, opts);
      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          let srcBaseName = path8.basename(src), destBaseName = path8.basename(dest);
          if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase())
            return { srcStat, destStat, isChangingCase: !0 };
          throw new Error("Source and destination must not be the same.");
        }
        if (srcStat.isDirectory() && !destStat.isDirectory())
          throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
        if (!srcStat.isDirectory() && destStat.isDirectory())
          throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest))
        throw new Error(errMsg(src, dest, funcName));
      return { srcStat, destStat };
    }
    async function checkParentPaths(src, srcStat, dest, funcName) {
      let srcParent = path8.resolve(path8.dirname(src)), destParent = path8.resolve(path8.dirname(dest));
      if (destParent === srcParent || destParent === path8.parse(destParent).root) return;
      let destStat;
      try {
        destStat = await fs11.stat(destParent, { bigint: !0 });
      } catch (err) {
        if (err.code === "ENOENT") return;
        throw err;
      }
      if (areIdentical(srcStat, destStat))
        throw new Error(errMsg(src, dest, funcName));
      return checkParentPaths(src, srcStat, destParent, funcName);
    }
    function checkParentPathsSync(src, srcStat, dest, funcName) {
      let srcParent = path8.resolve(path8.dirname(src)), destParent = path8.resolve(path8.dirname(dest));
      if (destParent === srcParent || destParent === path8.parse(destParent).root) return;
      let destStat;
      try {
        destStat = fs11.statSync(destParent, { bigint: !0 });
      } catch (err) {
        if (err.code === "ENOENT") return;
        throw err;
      }
      if (areIdentical(srcStat, destStat))
        throw new Error(errMsg(src, dest, funcName));
      return checkParentPathsSync(src, srcStat, destParent, funcName);
    }
    function areIdentical(srcStat, destStat) {
      return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
    }
    function isSrcSubdir(src, dest) {
      let srcArr = path8.resolve(src).split(path8.sep).filter((i) => i), destArr = path8.resolve(dest).split(path8.sep).filter((i) => i);
      return srcArr.every((cur, i) => destArr[i] === cur);
    }
    function errMsg(src, dest, funcName) {
      return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
    }
    module2.exports = {
      // checkPaths
      checkPaths: u(checkPaths),
      checkPathsSync,
      // checkParent
      checkParentPaths: u(checkParentPaths),
      checkParentPathsSync,
      // Misc
      isSrcSubdir,
      areIdentical
    };
  }
});

// node_modules/fs-extra/lib/copy/copy.js
var require_copy = __commonJS({
  "node_modules/fs-extra/lib/copy/copy.js"(exports2, module2) {
    "use strict";
    var fs11 = require_fs(), path8 = require("path"), { mkdirs } = require_mkdirs(), { pathExists } = require_path_exists(), { utimesMillis } = require_utimes(), stat2 = require_stat();
    async function copy(src, dest, opts = {}) {
      typeof opts == "function" && (opts = { filter: opts }), opts.clobber = "clobber" in opts ? !!opts.clobber : !0, opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber, opts.preserveTimestamps && process.arch === "ia32" && process.emitWarning(
        `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
        "Warning",
        "fs-extra-WARN0001"
      );
      let { srcStat, destStat } = await stat2.checkPaths(src, dest, "copy", opts);
      if (await stat2.checkParentPaths(src, srcStat, dest, "copy"), !await runFilter(src, dest, opts)) return;
      let destParent = path8.dirname(dest);
      await pathExists(destParent) || await mkdirs(destParent), await getStatsAndPerformCopy(destStat, src, dest, opts);
    }
    async function runFilter(src, dest, opts) {
      return opts.filter ? opts.filter(src, dest) : !0;
    }
    async function getStatsAndPerformCopy(destStat, src, dest, opts) {
      let srcStat = await (opts.dereference ? fs11.stat : fs11.lstat)(src);
      if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts);
      if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts);
      if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts);
      throw srcStat.isSocket() ? new Error(`Cannot copy a socket file: ${src}`) : srcStat.isFIFO() ? new Error(`Cannot copy a FIFO pipe: ${src}`) : new Error(`Unknown file: ${src}`);
    }
    async function onFile(srcStat, destStat, src, dest, opts) {
      if (!destStat) return copyFile(srcStat, src, dest, opts);
      if (opts.overwrite)
        return await fs11.unlink(dest), copyFile(srcStat, src, dest, opts);
      if (opts.errorOnExist)
        throw new Error(`'${dest}' already exists`);
    }
    async function copyFile(srcStat, src, dest, opts) {
      if (await fs11.copyFile(src, dest), opts.preserveTimestamps) {
        fileIsNotWritable(srcStat.mode) && await makeFileWritable(dest, srcStat.mode);
        let updatedSrcStat = await fs11.stat(src);
        await utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
      }
      return fs11.chmod(dest, srcStat.mode);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode) {
      return fs11.chmod(dest, srcMode | 128);
    }
    async function onDir(srcStat, destStat, src, dest, opts) {
      destStat || await fs11.mkdir(dest);
      let promises = [];
      for await (let item of await fs11.opendir(src)) {
        let srcItem = path8.join(src, item.name), destItem = path8.join(dest, item.name);
        promises.push(
          runFilter(srcItem, destItem, opts).then((include) => {
            if (include)
              return stat2.checkPaths(srcItem, destItem, "copy", opts).then(({ destStat: destStat2 }) => getStatsAndPerformCopy(destStat2, srcItem, destItem, opts));
          })
        );
      }
      await Promise.all(promises), destStat || await fs11.chmod(dest, srcStat.mode);
    }
    async function onLink(destStat, src, dest, opts) {
      let resolvedSrc = await fs11.readlink(src);
      if (opts.dereference && (resolvedSrc = path8.resolve(process.cwd(), resolvedSrc)), !destStat)
        return fs11.symlink(resolvedSrc, dest);
      let resolvedDest = null;
      try {
        resolvedDest = await fs11.readlink(dest);
      } catch (e) {
        if (e.code === "EINVAL" || e.code === "UNKNOWN") return fs11.symlink(resolvedSrc, dest);
        throw e;
      }
      if (opts.dereference && (resolvedDest = path8.resolve(process.cwd(), resolvedDest)), stat2.isSrcSubdir(resolvedSrc, resolvedDest))
        throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
      if (stat2.isSrcSubdir(resolvedDest, resolvedSrc))
        throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
      return await fs11.unlink(dest), fs11.symlink(resolvedSrc, dest);
    }
    module2.exports = copy;
  }
});

// node_modules/fs-extra/lib/copy/copy-sync.js
var require_copy_sync = __commonJS({
  "node_modules/fs-extra/lib/copy/copy-sync.js"(exports2, module2) {
    "use strict";
    var fs11 = require_graceful_fs(), path8 = require("path"), mkdirsSync = require_mkdirs().mkdirsSync, utimesMillisSync = require_utimes().utimesMillisSync, stat2 = require_stat();
    function copySync(src, dest, opts) {
      typeof opts == "function" && (opts = { filter: opts }), opts = opts || {}, opts.clobber = "clobber" in opts ? !!opts.clobber : !0, opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber, opts.preserveTimestamps && process.arch === "ia32" && process.emitWarning(
        `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
        "Warning",
        "fs-extra-WARN0002"
      );
      let { srcStat, destStat } = stat2.checkPathsSync(src, dest, "copy", opts);
      if (stat2.checkParentPathsSync(src, srcStat, dest, "copy"), opts.filter && !opts.filter(src, dest)) return;
      let destParent = path8.dirname(dest);
      return fs11.existsSync(destParent) || mkdirsSync(destParent), getStats(destStat, src, dest, opts);
    }
    function getStats(destStat, src, dest, opts) {
      let srcStat = (opts.dereference ? fs11.statSync : fs11.lstatSync)(src);
      if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts);
      if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts);
      if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts);
      throw srcStat.isSocket() ? new Error(`Cannot copy a socket file: ${src}`) : srcStat.isFIFO() ? new Error(`Cannot copy a FIFO pipe: ${src}`) : new Error(`Unknown file: ${src}`);
    }
    function onFile(srcStat, destStat, src, dest, opts) {
      return destStat ? mayCopyFile(srcStat, src, dest, opts) : copyFile(srcStat, src, dest, opts);
    }
    function mayCopyFile(srcStat, src, dest, opts) {
      if (opts.overwrite)
        return fs11.unlinkSync(dest), copyFile(srcStat, src, dest, opts);
      if (opts.errorOnExist)
        throw new Error(`'${dest}' already exists`);
    }
    function copyFile(srcStat, src, dest, opts) {
      return fs11.copyFileSync(src, dest), opts.preserveTimestamps && handleTimestamps(srcStat.mode, src, dest), setDestMode(dest, srcStat.mode);
    }
    function handleTimestamps(srcMode, src, dest) {
      return fileIsNotWritable(srcMode) && makeFileWritable(dest, srcMode), setDestTimestamps(src, dest);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode) {
      return setDestMode(dest, srcMode | 128);
    }
    function setDestMode(dest, srcMode) {
      return fs11.chmodSync(dest, srcMode);
    }
    function setDestTimestamps(src, dest) {
      let updatedSrcStat = fs11.statSync(src);
      return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
    }
    function onDir(srcStat, destStat, src, dest, opts) {
      return destStat ? copyDir(src, dest, opts) : mkDirAndCopy(srcStat.mode, src, dest, opts);
    }
    function mkDirAndCopy(srcMode, src, dest, opts) {
      return fs11.mkdirSync(dest), copyDir(src, dest, opts), setDestMode(dest, srcMode);
    }
    function copyDir(src, dest, opts) {
      let dir = fs11.opendirSync(src);
      try {
        let dirent;
        for (; (dirent = dir.readSync()) !== null; )
          copyDirItem(dirent.name, src, dest, opts);
      } finally {
        dir.closeSync();
      }
    }
    function copyDirItem(item, src, dest, opts) {
      let srcItem = path8.join(src, item), destItem = path8.join(dest, item);
      if (opts.filter && !opts.filter(srcItem, destItem)) return;
      let { destStat } = stat2.checkPathsSync(srcItem, destItem, "copy", opts);
      return getStats(destStat, srcItem, destItem, opts);
    }
    function onLink(destStat, src, dest, opts) {
      let resolvedSrc = fs11.readlinkSync(src);
      if (opts.dereference && (resolvedSrc = path8.resolve(process.cwd(), resolvedSrc)), destStat) {
        let resolvedDest;
        try {
          resolvedDest = fs11.readlinkSync(dest);
        } catch (err) {
          if (err.code === "EINVAL" || err.code === "UNKNOWN") return fs11.symlinkSync(resolvedSrc, dest);
          throw err;
        }
        if (opts.dereference && (resolvedDest = path8.resolve(process.cwd(), resolvedDest)), stat2.isSrcSubdir(resolvedSrc, resolvedDest))
          throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
        if (stat2.isSrcSubdir(resolvedDest, resolvedSrc))
          throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
        return copyLink(resolvedSrc, dest);
      } else
        return fs11.symlinkSync(resolvedSrc, dest);
    }
    function copyLink(resolvedSrc, dest) {
      return fs11.unlinkSync(dest), fs11.symlinkSync(resolvedSrc, dest);
    }
    module2.exports = copySync;
  }
});

// node_modules/fs-extra/lib/copy/index.js
var require_copy2 = __commonJS({
  "node_modules/fs-extra/lib/copy/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    module2.exports = {
      copy: u(require_copy()),
      copySync: require_copy_sync()
    };
  }
});

// node_modules/fs-extra/lib/remove/index.js
var require_remove = __commonJS({
  "node_modules/fs-extra/lib/remove/index.js"(exports2, module2) {
    "use strict";
    var fs11 = require_graceful_fs(), u = require_universalify().fromCallback;
    function remove(path8, callback) {
      fs11.rm(path8, { recursive: !0, force: !0 }, callback);
    }
    function removeSync(path8) {
      fs11.rmSync(path8, { recursive: !0, force: !0 });
    }
    module2.exports = {
      remove: u(remove),
      removeSync
    };
  }
});

// node_modules/fs-extra/lib/empty/index.js
var require_empty = __commonJS({
  "node_modules/fs-extra/lib/empty/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromPromise, fs11 = require_fs(), path8 = require("path"), mkdir4 = require_mkdirs(), remove = require_remove(), emptyDir = u(async function(dir) {
      let items;
      try {
        items = await fs11.readdir(dir);
      } catch {
        return mkdir4.mkdirs(dir);
      }
      return Promise.all(items.map((item) => remove.remove(path8.join(dir, item))));
    });
    function emptyDirSync(dir) {
      let items;
      try {
        items = fs11.readdirSync(dir);
      } catch {
        return mkdir4.mkdirsSync(dir);
      }
      items.forEach((item) => {
        item = path8.join(dir, item), remove.removeSync(item);
      });
    }
    module2.exports = {
      emptyDirSync,
      emptydirSync: emptyDirSync,
      emptyDir,
      emptydir: emptyDir
    };
  }
});

// node_modules/fs-extra/lib/ensure/file.js
var require_file2 = __commonJS({
  "node_modules/fs-extra/lib/ensure/file.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromPromise, path8 = require("path"), fs11 = require_fs(), mkdir4 = require_mkdirs();
    async function createFile2(file) {
      let stats;
      try {
        stats = await fs11.stat(file);
      } catch {
      }
      if (stats && stats.isFile()) return;
      let dir = path8.dirname(file), dirStats = null;
      try {
        dirStats = await fs11.stat(dir);
      } catch (err) {
        if (err.code === "ENOENT") {
          await mkdir4.mkdirs(dir), await fs11.writeFile(file, "");
          return;
        } else
          throw err;
      }
      dirStats.isDirectory() ? await fs11.writeFile(file, "") : await fs11.readdir(dir);
    }
    function createFileSync2(file) {
      let stats;
      try {
        stats = fs11.statSync(file);
      } catch {
      }
      if (stats && stats.isFile()) return;
      let dir = path8.dirname(file);
      try {
        fs11.statSync(dir).isDirectory() || fs11.readdirSync(dir);
      } catch (err) {
        if (err && err.code === "ENOENT") mkdir4.mkdirsSync(dir);
        else throw err;
      }
      fs11.writeFileSync(file, "");
    }
    module2.exports = {
      createFile: u(createFile2),
      createFileSync: createFileSync2
    };
  }
});

// node_modules/fs-extra/lib/ensure/link.js
var require_link = __commonJS({
  "node_modules/fs-extra/lib/ensure/link.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromPromise, path8 = require("path"), fs11 = require_fs(), mkdir4 = require_mkdirs(), { pathExists } = require_path_exists(), { areIdentical } = require_stat();
    async function createLink(srcpath, dstpath) {
      let dstStat;
      try {
        dstStat = await fs11.lstat(dstpath);
      } catch {
      }
      let srcStat;
      try {
        srcStat = await fs11.lstat(srcpath);
      } catch (err) {
        throw err.message = err.message.replace("lstat", "ensureLink"), err;
      }
      if (dstStat && areIdentical(srcStat, dstStat)) return;
      let dir = path8.dirname(dstpath);
      await pathExists(dir) || await mkdir4.mkdirs(dir), await fs11.link(srcpath, dstpath);
    }
    function createLinkSync(srcpath, dstpath) {
      let dstStat;
      try {
        dstStat = fs11.lstatSync(dstpath);
      } catch {
      }
      try {
        let srcStat = fs11.lstatSync(srcpath);
        if (dstStat && areIdentical(srcStat, dstStat)) return;
      } catch (err) {
        throw err.message = err.message.replace("lstat", "ensureLink"), err;
      }
      let dir = path8.dirname(dstpath);
      return fs11.existsSync(dir) || mkdir4.mkdirsSync(dir), fs11.linkSync(srcpath, dstpath);
    }
    module2.exports = {
      createLink: u(createLink),
      createLinkSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths = __commonJS({
  "node_modules/fs-extra/lib/ensure/symlink-paths.js"(exports2, module2) {
    "use strict";
    var path8 = require("path"), fs11 = require_fs(), { pathExists } = require_path_exists(), u = require_universalify().fromPromise;
    async function symlinkPaths(srcpath, dstpath) {
      if (path8.isAbsolute(srcpath)) {
        try {
          await fs11.lstat(srcpath);
        } catch (err) {
          throw err.message = err.message.replace("lstat", "ensureSymlink"), err;
        }
        return {
          toCwd: srcpath,
          toDst: srcpath
        };
      }
      let dstdir = path8.dirname(dstpath), relativeToDst = path8.join(dstdir, srcpath);
      if (await pathExists(relativeToDst))
        return {
          toCwd: relativeToDst,
          toDst: srcpath
        };
      try {
        await fs11.lstat(srcpath);
      } catch (err) {
        throw err.message = err.message.replace("lstat", "ensureSymlink"), err;
      }
      return {
        toCwd: srcpath,
        toDst: path8.relative(dstdir, srcpath)
      };
    }
    function symlinkPathsSync(srcpath, dstpath) {
      if (path8.isAbsolute(srcpath)) {
        if (!fs11.existsSync(srcpath)) throw new Error("absolute srcpath does not exist");
        return {
          toCwd: srcpath,
          toDst: srcpath
        };
      }
      let dstdir = path8.dirname(dstpath), relativeToDst = path8.join(dstdir, srcpath);
      if (fs11.existsSync(relativeToDst))
        return {
          toCwd: relativeToDst,
          toDst: srcpath
        };
      if (!fs11.existsSync(srcpath)) throw new Error("relative srcpath does not exist");
      return {
        toCwd: srcpath,
        toDst: path8.relative(dstdir, srcpath)
      };
    }
    module2.exports = {
      symlinkPaths: u(symlinkPaths),
      symlinkPathsSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type = __commonJS({
  "node_modules/fs-extra/lib/ensure/symlink-type.js"(exports2, module2) {
    "use strict";
    var fs11 = require_fs(), u = require_universalify().fromPromise;
    async function symlinkType(srcpath, type) {
      if (type) return type;
      let stats;
      try {
        stats = await fs11.lstat(srcpath);
      } catch {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    function symlinkTypeSync(srcpath, type) {
      if (type) return type;
      let stats;
      try {
        stats = fs11.lstatSync(srcpath);
      } catch {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    module2.exports = {
      symlinkType: u(symlinkType),
      symlinkTypeSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink = __commonJS({
  "node_modules/fs-extra/lib/ensure/symlink.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromPromise, path8 = require("path"), fs11 = require_fs(), { mkdirs, mkdirsSync } = require_mkdirs(), { symlinkPaths, symlinkPathsSync } = require_symlink_paths(), { symlinkType, symlinkTypeSync } = require_symlink_type(), { pathExists } = require_path_exists(), { areIdentical } = require_stat();
    async function createSymlink(srcpath, dstpath, type) {
      let stats;
      try {
        stats = await fs11.lstat(dstpath);
      } catch {
      }
      if (stats && stats.isSymbolicLink()) {
        let [srcStat, dstStat] = await Promise.all([
          fs11.stat(srcpath),
          fs11.stat(dstpath)
        ]);
        if (areIdentical(srcStat, dstStat)) return;
      }
      let relative = await symlinkPaths(srcpath, dstpath);
      srcpath = relative.toDst;
      let toType = await symlinkType(relative.toCwd, type), dir = path8.dirname(dstpath);
      return await pathExists(dir) || await mkdirs(dir), fs11.symlink(srcpath, dstpath, toType);
    }
    function createSymlinkSync(srcpath, dstpath, type) {
      let stats;
      try {
        stats = fs11.lstatSync(dstpath);
      } catch {
      }
      if (stats && stats.isSymbolicLink()) {
        let srcStat = fs11.statSync(srcpath), dstStat = fs11.statSync(dstpath);
        if (areIdentical(srcStat, dstStat)) return;
      }
      let relative = symlinkPathsSync(srcpath, dstpath);
      srcpath = relative.toDst, type = symlinkTypeSync(relative.toCwd, type);
      let dir = path8.dirname(dstpath);
      return fs11.existsSync(dir) || mkdirsSync(dir), fs11.symlinkSync(srcpath, dstpath, type);
    }
    module2.exports = {
      createSymlink: u(createSymlink),
      createSymlinkSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/index.js
var require_ensure = __commonJS({
  "node_modules/fs-extra/lib/ensure/index.js"(exports2, module2) {
    "use strict";
    var { createFile: createFile2, createFileSync: createFileSync2 } = require_file2(), { createLink, createLinkSync } = require_link(), { createSymlink, createSymlinkSync } = require_symlink();
    module2.exports = {
      // file
      createFile: createFile2,
      createFileSync: createFileSync2,
      ensureFile: createFile2,
      ensureFileSync: createFileSync2,
      // link
      createLink,
      createLinkSync,
      ensureLink: createLink,
      ensureLinkSync: createLinkSync,
      // symlink
      createSymlink,
      createSymlinkSync,
      ensureSymlink: createSymlink,
      ensureSymlinkSync: createSymlinkSync
    };
  }
});

// node_modules/jsonfile/utils.js
var require_utils4 = __commonJS({
  "node_modules/jsonfile/utils.js"(exports2, module2) {
    function stringify(obj, { EOL = `
`, finalEOL = !0, replacer = null, spaces } = {}) {
      let EOF3 = finalEOL ? EOL : "";
      return JSON.stringify(obj, replacer, spaces).replace(/\n/g, EOL) + EOF3;
    }
    function stripBom(content) {
      return Buffer.isBuffer(content) && (content = content.toString("utf8")), content.replace(/^\uFEFF/, "");
    }
    module2.exports = { stringify, stripBom };
  }
});

// node_modules/jsonfile/index.js
var require_jsonfile = __commonJS({
  "node_modules/jsonfile/index.js"(exports2, module2) {
    var _fs;
    try {
      _fs = require_graceful_fs();
    } catch {
      _fs = require("fs");
    }
    var universalify = require_universalify(), { stringify, stripBom } = require_utils4();
    async function _readFile(file, options = {}) {
      typeof options == "string" && (options = { encoding: options });
      let fs11 = options.fs || _fs, shouldThrow = "throws" in options ? options.throws : !0, data = await universalify.fromCallback(fs11.readFile)(file, options);
      data = stripBom(data);
      let obj;
      try {
        obj = JSON.parse(data, options ? options.reviver : null);
      } catch (err) {
        if (shouldThrow)
          throw err.message = `${file}: ${err.message}`, err;
        return null;
      }
      return obj;
    }
    var readFile = universalify.fromPromise(_readFile);
    function readFileSync(file, options = {}) {
      typeof options == "string" && (options = { encoding: options });
      let fs11 = options.fs || _fs, shouldThrow = "throws" in options ? options.throws : !0;
      try {
        let content = fs11.readFileSync(file, options);
        return content = stripBom(content), JSON.parse(content, options.reviver);
      } catch (err) {
        if (shouldThrow)
          throw err.message = `${file}: ${err.message}`, err;
        return null;
      }
    }
    async function _writeFile(file, obj, options = {}) {
      let fs11 = options.fs || _fs, str = stringify(obj, options);
      await universalify.fromCallback(fs11.writeFile)(file, str, options);
    }
    var writeFile = universalify.fromPromise(_writeFile);
    function writeFileSync(file, obj, options = {}) {
      let fs11 = options.fs || _fs, str = stringify(obj, options);
      return fs11.writeFileSync(file, str, options);
    }
    var jsonfile = {
      readFile,
      readFileSync,
      writeFile,
      writeFileSync
    };
    module2.exports = jsonfile;
  }
});

// node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile2 = __commonJS({
  "node_modules/fs-extra/lib/json/jsonfile.js"(exports2, module2) {
    "use strict";
    var jsonFile = require_jsonfile();
    module2.exports = {
      // jsonfile exports
      readJson: jsonFile.readFile,
      readJsonSync: jsonFile.readFileSync,
      writeJson: jsonFile.writeFile,
      writeJsonSync: jsonFile.writeFileSync
    };
  }
});

// node_modules/fs-extra/lib/output-file/index.js
var require_output_file = __commonJS({
  "node_modules/fs-extra/lib/output-file/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromPromise, fs11 = require_fs(), path8 = require("path"), mkdir4 = require_mkdirs(), pathExists = require_path_exists().pathExists;
    async function outputFile(file, data, encoding = "utf-8") {
      let dir = path8.dirname(file);
      return await pathExists(dir) || await mkdir4.mkdirs(dir), fs11.writeFile(file, data, encoding);
    }
    function outputFileSync(file, ...args) {
      let dir = path8.dirname(file);
      fs11.existsSync(dir) || mkdir4.mkdirsSync(dir), fs11.writeFileSync(file, ...args);
    }
    module2.exports = {
      outputFile: u(outputFile),
      outputFileSync
    };
  }
});

// node_modules/fs-extra/lib/json/output-json.js
var require_output_json = __commonJS({
  "node_modules/fs-extra/lib/json/output-json.js"(exports2, module2) {
    "use strict";
    var { stringify } = require_utils4(), { outputFile } = require_output_file();
    async function outputJson(file, data, options = {}) {
      let str = stringify(data, options);
      await outputFile(file, str, options);
    }
    module2.exports = outputJson;
  }
});

// node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync = __commonJS({
  "node_modules/fs-extra/lib/json/output-json-sync.js"(exports2, module2) {
    "use strict";
    var { stringify } = require_utils4(), { outputFileSync } = require_output_file();
    function outputJsonSync(file, data, options) {
      let str = stringify(data, options);
      outputFileSync(file, str, options);
    }
    module2.exports = outputJsonSync;
  }
});

// node_modules/fs-extra/lib/json/index.js
var require_json = __commonJS({
  "node_modules/fs-extra/lib/json/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromPromise, jsonFile = require_jsonfile2();
    jsonFile.outputJson = u(require_output_json());
    jsonFile.outputJsonSync = require_output_json_sync();
    jsonFile.outputJSON = jsonFile.outputJson;
    jsonFile.outputJSONSync = jsonFile.outputJsonSync;
    jsonFile.writeJSON = jsonFile.writeJson;
    jsonFile.writeJSONSync = jsonFile.writeJsonSync;
    jsonFile.readJSON = jsonFile.readJson;
    jsonFile.readJSONSync = jsonFile.readJsonSync;
    module2.exports = jsonFile;
  }
});

// node_modules/fs-extra/lib/move/move.js
var require_move = __commonJS({
  "node_modules/fs-extra/lib/move/move.js"(exports2, module2) {
    "use strict";
    var fs11 = require_fs(), path8 = require("path"), { copy } = require_copy2(), { remove } = require_remove(), { mkdirp: mkdirp2 } = require_mkdirs(), { pathExists } = require_path_exists(), stat2 = require_stat();
    async function move(src, dest, opts = {}) {
      let overwrite = opts.overwrite || opts.clobber || !1, { srcStat, isChangingCase = !1 } = await stat2.checkPaths(src, dest, "move", opts);
      await stat2.checkParentPaths(src, srcStat, dest, "move");
      let destParent = path8.dirname(dest);
      return path8.parse(destParent).root !== destParent && await mkdirp2(destParent), doRename(src, dest, overwrite, isChangingCase);
    }
    async function doRename(src, dest, overwrite, isChangingCase) {
      if (!isChangingCase) {
        if (overwrite)
          await remove(dest);
        else if (await pathExists(dest))
          throw new Error("dest already exists.");
      }
      try {
        await fs11.rename(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV")
          throw err;
        await moveAcrossDevice(src, dest, overwrite);
      }
    }
    async function moveAcrossDevice(src, dest, overwrite) {
      return await copy(src, dest, {
        overwrite,
        errorOnExist: !0,
        preserveTimestamps: !0
      }), remove(src);
    }
    module2.exports = move;
  }
});

// node_modules/fs-extra/lib/move/move-sync.js
var require_move_sync = __commonJS({
  "node_modules/fs-extra/lib/move/move-sync.js"(exports2, module2) {
    "use strict";
    var fs11 = require_graceful_fs(), path8 = require("path"), copySync = require_copy2().copySync, removeSync = require_remove().removeSync, mkdirpSync2 = require_mkdirs().mkdirpSync, stat2 = require_stat();
    function moveSync(src, dest, opts) {
      opts = opts || {};
      let overwrite = opts.overwrite || opts.clobber || !1, { srcStat, isChangingCase = !1 } = stat2.checkPathsSync(src, dest, "move", opts);
      return stat2.checkParentPathsSync(src, srcStat, dest, "move"), isParentRoot(dest) || mkdirpSync2(path8.dirname(dest)), doRename(src, dest, overwrite, isChangingCase);
    }
    function isParentRoot(dest) {
      let parent = path8.dirname(dest);
      return path8.parse(parent).root === parent;
    }
    function doRename(src, dest, overwrite, isChangingCase) {
      if (isChangingCase) return rename(src, dest, overwrite);
      if (overwrite)
        return removeSync(dest), rename(src, dest, overwrite);
      if (fs11.existsSync(dest)) throw new Error("dest already exists.");
      return rename(src, dest, overwrite);
    }
    function rename(src, dest, overwrite) {
      try {
        fs11.renameSync(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV") throw err;
        return moveAcrossDevice(src, dest, overwrite);
      }
    }
    function moveAcrossDevice(src, dest, overwrite) {
      return copySync(src, dest, {
        overwrite,
        errorOnExist: !0,
        preserveTimestamps: !0
      }), removeSync(src);
    }
    module2.exports = moveSync;
  }
});

// node_modules/fs-extra/lib/move/index.js
var require_move2 = __commonJS({
  "node_modules/fs-extra/lib/move/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    module2.exports = {
      move: u(require_move()),
      moveSync: require_move_sync()
    };
  }
});

// node_modules/fs-extra/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/fs-extra/lib/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      // Export promiseified graceful-fs:
      ...require_fs(),
      // Export extra methods:
      ...require_copy2(),
      ...require_empty(),
      ...require_ensure(),
      ...require_json(),
      ...require_mkdirs(),
      ...require_move2(),
      ...require_output_file(),
      ...require_path_exists(),
      ...require_remove()
    };
  }
});

// node_modules/sax/lib/sax.js
var require_sax = __commonJS({
  "node_modules/sax/lib/sax.js"(exports2) {
    (function(sax) {
      sax.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
      }, sax.SAXParser = SAXParser, sax.SAXStream = SAXStream, sax.createStream = createStream, sax.MAX_BUFFER_LENGTH = 64 * 1024;
      var buffers = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      sax.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser))
          return new SAXParser(strict, opt);
        var parser = this;
        clearBuffers(parser), parser.q = parser.c = "", parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH, parser.opt = opt || {}, parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags, parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase", parser.tags = [], parser.closed = parser.closedRoot = parser.sawRoot = !1, parser.tag = parser.error = null, parser.strict = !!strict, parser.noscript = !!(strict || parser.opt.noscript), parser.state = S.BEGIN, parser.strictEntities = parser.opt.strictEntities, parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES), parser.attribList = [], parser.opt.xmlns && (parser.ns = Object.create(rootNS)), parser.opt.unquotedAttributeValues === void 0 && (parser.opt.unquotedAttributeValues = !strict), parser.trackPosition = parser.opt.position !== !1, parser.trackPosition && (parser.position = parser.line = parser.column = 0), emit(parser, "onready");
      }
      Object.create || (Object.create = function(o) {
        function F() {
        }
        F.prototype = o;
        var newf = new F();
        return newf;
      }), Object.keys || (Object.keys = function(o) {
        var a = [];
        for (var i in o) o.hasOwnProperty(i) && a.push(i);
        return a;
      });
      function checkBufferLength(parser) {
        for (var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10), maxActual = 0, i = 0, l = buffers.length; i < l; i++) {
          var len = parser[buffers[i]].length;
          if (len > maxAllowed)
            switch (buffers[i]) {
              case "textNode":
                closeText(parser);
                break;
              case "cdata":
                emitNode(parser, "oncdata", parser.cdata), parser.cdata = "";
                break;
              case "script":
                emitNode(parser, "onscript", parser.script), parser.script = "";
                break;
              default:
                error(parser, "Max buffer length exceeded: " + buffers[i]);
            }
          maxActual = Math.max(maxActual, len);
        }
        var m = sax.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m + parser.position;
      }
      function clearBuffers(parser) {
        for (var i = 0, l = buffers.length; i < l; i++)
          parser[buffers[i]] = "";
      }
      function flushBuffers(parser) {
        closeText(parser), parser.cdata !== "" && (emitNode(parser, "oncdata", parser.cdata), parser.cdata = ""), parser.script !== "" && (emitNode(parser, "onscript", parser.script), parser.script = "");
      }
      SAXParser.prototype = {
        end: function() {
          end(this);
        },
        write,
        resume: function() {
          return this.error = null, this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          flushBuffers(this);
        }
      };
      var Stream2;
      try {
        Stream2 = require("stream").Stream;
      } catch {
        Stream2 = function() {
        };
      }
      Stream2 || (Stream2 = function() {
      });
      var streamWraps = sax.EVENTS.filter(function(ev) {
        return ev !== "error" && ev !== "end";
      });
      function createStream(strict, opt) {
        return new SAXStream(strict, opt);
      }
      function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream))
          return new SAXStream(strict, opt);
        Stream2.apply(this), this._parser = new SAXParser(strict, opt), this.writable = !0, this.readable = !0;
        var me = this;
        this._parser.onend = function() {
          me.emit("end");
        }, this._parser.onerror = function(er) {
          me.emit("error", er), me._parser.error = null;
        }, this._decoder = null, streamWraps.forEach(function(ev) {
          Object.defineProperty(me, "on" + ev, {
            get: function() {
              return me._parser["on" + ev];
            },
            set: function(h) {
              if (!h)
                return me.removeAllListeners(ev), me._parser["on" + ev] = h, h;
              me.on(ev, h);
            },
            enumerable: !0,
            configurable: !1
          });
        });
      }
      SAXStream.prototype = Object.create(Stream2.prototype, {
        constructor: {
          value: SAXStream
        }
      }), SAXStream.prototype.write = function(data) {
        if (typeof Buffer == "function" && typeof Buffer.isBuffer == "function" && Buffer.isBuffer(data)) {
          if (!this._decoder) {
            var SD = require("string_decoder").StringDecoder;
            this._decoder = new SD("utf8");
          }
          data = this._decoder.write(data);
        }
        return this._parser.write(data.toString()), this.emit("data", data), !0;
      }, SAXStream.prototype.end = function(chunk) {
        return chunk && chunk.length && this.write(chunk), this._parser.end(), !0;
      }, SAXStream.prototype.on = function(ev, handler) {
        var me = this;
        return !me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1 && (me._parser["on" + ev] = function() {
          var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
          args.splice(0, 0, ev), me.emit.apply(me, args);
        }), Stream2.prototype.on.call(me, ev, handler);
      };
      var CDATA = "[CDATA[", DOCTYPE = "DOCTYPE", XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace", XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/", rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }, nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/, entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function isWhitespace(c) {
        return c === " " || c === `
` || c === "\r" || c === "	";
      }
      function isQuote(c) {
        return c === '"' || c === "'";
      }
      function isAttribEnd(c) {
        return c === ">" || isWhitespace(c);
      }
      function isMatch(regex, c) {
        return regex.test(c);
      }
      function notMatch(regex, c) {
        return !isMatch(regex, c);
      }
      var S = 0;
      sax.STATE = {
        BEGIN: S++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: S++,
        // leading whitespace
        TEXT: S++,
        // general stuff
        TEXT_ENTITY: S++,
        // &amp and such.
        OPEN_WAKA: S++,
        // <
        SGML_DECL: S++,
        // <!BLARG
        SGML_DECL_QUOTED: S++,
        // <!BLARG foo "bar
        DOCTYPE: S++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: S++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: S++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: S++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: S++,
        // <!-
        COMMENT: S++,
        // <!--
        COMMENT_ENDING: S++,
        // <!-- blah -
        COMMENT_ENDED: S++,
        // <!-- blah --
        CDATA: S++,
        // <![CDATA[ something
        CDATA_ENDING: S++,
        // ]
        CDATA_ENDING_2: S++,
        // ]]
        PROC_INST: S++,
        // <?hi
        PROC_INST_BODY: S++,
        // <?hi there
        PROC_INST_ENDING: S++,
        // <?hi "there" ?
        OPEN_TAG: S++,
        // <strong
        OPEN_TAG_SLASH: S++,
        // <strong /
        ATTRIB: S++,
        // <a
        ATTRIB_NAME: S++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: S++,
        // <a foo _
        ATTRIB_VALUE: S++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: S++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: S++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: S++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: S++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: S++,
        // <foo bar=&quot
        CLOSE_TAG: S++,
        // </a
        CLOSE_TAG_SAW_WHITE: S++,
        // </a   >
        SCRIPT: S++,
        // <script> ...
        SCRIPT_ENDING: S++
        // <script> ... <
      }, sax.XML_ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'"
      }, sax.ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'",
        AElig: 198,
        Aacute: 193,
        Acirc: 194,
        Agrave: 192,
        Aring: 197,
        Atilde: 195,
        Auml: 196,
        Ccedil: 199,
        ETH: 208,
        Eacute: 201,
        Ecirc: 202,
        Egrave: 200,
        Euml: 203,
        Iacute: 205,
        Icirc: 206,
        Igrave: 204,
        Iuml: 207,
        Ntilde: 209,
        Oacute: 211,
        Ocirc: 212,
        Ograve: 210,
        Oslash: 216,
        Otilde: 213,
        Ouml: 214,
        THORN: 222,
        Uacute: 218,
        Ucirc: 219,
        Ugrave: 217,
        Uuml: 220,
        Yacute: 221,
        aacute: 225,
        acirc: 226,
        aelig: 230,
        agrave: 224,
        aring: 229,
        atilde: 227,
        auml: 228,
        ccedil: 231,
        eacute: 233,
        ecirc: 234,
        egrave: 232,
        eth: 240,
        euml: 235,
        iacute: 237,
        icirc: 238,
        igrave: 236,
        iuml: 239,
        ntilde: 241,
        oacute: 243,
        ocirc: 244,
        ograve: 242,
        oslash: 248,
        otilde: 245,
        ouml: 246,
        szlig: 223,
        thorn: 254,
        uacute: 250,
        ucirc: 251,
        ugrave: 249,
        uuml: 252,
        yacute: 253,
        yuml: 255,
        copy: 169,
        reg: 174,
        nbsp: 160,
        iexcl: 161,
        cent: 162,
        pound: 163,
        curren: 164,
        yen: 165,
        brvbar: 166,
        sect: 167,
        uml: 168,
        ordf: 170,
        laquo: 171,
        not: 172,
        shy: 173,
        macr: 175,
        deg: 176,
        plusmn: 177,
        sup1: 185,
        sup2: 178,
        sup3: 179,
        acute: 180,
        micro: 181,
        para: 182,
        middot: 183,
        cedil: 184,
        ordm: 186,
        raquo: 187,
        frac14: 188,
        frac12: 189,
        frac34: 190,
        iquest: 191,
        times: 215,
        divide: 247,
        OElig: 338,
        oelig: 339,
        Scaron: 352,
        scaron: 353,
        Yuml: 376,
        fnof: 402,
        circ: 710,
        tilde: 732,
        Alpha: 913,
        Beta: 914,
        Gamma: 915,
        Delta: 916,
        Epsilon: 917,
        Zeta: 918,
        Eta: 919,
        Theta: 920,
        Iota: 921,
        Kappa: 922,
        Lambda: 923,
        Mu: 924,
        Nu: 925,
        Xi: 926,
        Omicron: 927,
        Pi: 928,
        Rho: 929,
        Sigma: 931,
        Tau: 932,
        Upsilon: 933,
        Phi: 934,
        Chi: 935,
        Psi: 936,
        Omega: 937,
        alpha: 945,
        beta: 946,
        gamma: 947,
        delta: 948,
        epsilon: 949,
        zeta: 950,
        eta: 951,
        theta: 952,
        iota: 953,
        kappa: 954,
        lambda: 955,
        mu: 956,
        nu: 957,
        xi: 958,
        omicron: 959,
        pi: 960,
        rho: 961,
        sigmaf: 962,
        sigma: 963,
        tau: 964,
        upsilon: 965,
        phi: 966,
        chi: 967,
        psi: 968,
        omega: 969,
        thetasym: 977,
        upsih: 978,
        piv: 982,
        ensp: 8194,
        emsp: 8195,
        thinsp: 8201,
        zwnj: 8204,
        zwj: 8205,
        lrm: 8206,
        rlm: 8207,
        ndash: 8211,
        mdash: 8212,
        lsquo: 8216,
        rsquo: 8217,
        sbquo: 8218,
        ldquo: 8220,
        rdquo: 8221,
        bdquo: 8222,
        dagger: 8224,
        Dagger: 8225,
        bull: 8226,
        hellip: 8230,
        permil: 8240,
        prime: 8242,
        Prime: 8243,
        lsaquo: 8249,
        rsaquo: 8250,
        oline: 8254,
        frasl: 8260,
        euro: 8364,
        image: 8465,
        weierp: 8472,
        real: 8476,
        trade: 8482,
        alefsym: 8501,
        larr: 8592,
        uarr: 8593,
        rarr: 8594,
        darr: 8595,
        harr: 8596,
        crarr: 8629,
        lArr: 8656,
        uArr: 8657,
        rArr: 8658,
        dArr: 8659,
        hArr: 8660,
        forall: 8704,
        part: 8706,
        exist: 8707,
        empty: 8709,
        nabla: 8711,
        isin: 8712,
        notin: 8713,
        ni: 8715,
        prod: 8719,
        sum: 8721,
        minus: 8722,
        lowast: 8727,
        radic: 8730,
        prop: 8733,
        infin: 8734,
        ang: 8736,
        and: 8743,
        or: 8744,
        cap: 8745,
        cup: 8746,
        int: 8747,
        there4: 8756,
        sim: 8764,
        cong: 8773,
        asymp: 8776,
        ne: 8800,
        equiv: 8801,
        le: 8804,
        ge: 8805,
        sub: 8834,
        sup: 8835,
        nsub: 8836,
        sube: 8838,
        supe: 8839,
        oplus: 8853,
        otimes: 8855,
        perp: 8869,
        sdot: 8901,
        lceil: 8968,
        rceil: 8969,
        lfloor: 8970,
        rfloor: 8971,
        lang: 9001,
        rang: 9002,
        loz: 9674,
        spades: 9824,
        clubs: 9827,
        hearts: 9829,
        diams: 9830
      }, Object.keys(sax.ENTITIES).forEach(function(key) {
        var e = sax.ENTITIES[key], s2 = typeof e == "number" ? String.fromCharCode(e) : e;
        sax.ENTITIES[key] = s2;
      });
      for (var s in sax.STATE)
        sax.STATE[sax.STATE[s]] = s;
      S = sax.STATE;
      function emit(parser, event, data) {
        parser[event] && parser[event](data);
      }
      function emitNode(parser, nodeType, data) {
        parser.textNode && closeText(parser), emit(parser, nodeType, data);
      }
      function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode), parser.textNode && emit(parser, "ontext", parser.textNode), parser.textNode = "";
      }
      function textopts(opt, text) {
        return opt.trim && (text = text.trim()), opt.normalize && (text = text.replace(/\s+/g, " ")), text;
      }
      function error(parser, er) {
        return closeText(parser), parser.trackPosition && (er += `
Line: ` + parser.line + `
Column: ` + parser.column + `
Char: ` + parser.c), er = new Error(er), parser.error = er, emit(parser, "onerror", er), parser;
      }
      function end(parser) {
        return parser.sawRoot && !parser.closedRoot && strictFail(parser, "Unclosed root tag"), parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT && error(parser, "Unexpected end"), closeText(parser), parser.c = "", parser.closed = !0, emit(parser, "onend"), SAXParser.call(parser, parser.strict, parser.opt), parser;
      }
      function strictFail(parser, message) {
        if (typeof parser != "object" || !(parser instanceof SAXParser))
          throw new Error("bad call to strictFail");
        parser.strict && error(parser, message);
      }
      function newTag(parser) {
        parser.strict || (parser.tagName = parser.tagName[parser.looseCase]());
        var parent = parser.tags[parser.tags.length - 1] || parser, tag = parser.tag = { name: parser.tagName, attributes: {} };
        parser.opt.xmlns && (tag.ns = parent.ns), parser.attribList.length = 0, emitNode(parser, "onopentagstart", tag);
      }
      function qname(name2, attribute) {
        var i = name2.indexOf(":"), qualName = i < 0 ? ["", name2] : name2.split(":"), prefix = qualName[0], local = qualName[1];
        return attribute && name2 === "xmlns" && (prefix = "xmlns", local = ""), { prefix, local };
      }
      function attrib(parser) {
        if (parser.strict || (parser.attribName = parser.attribName[parser.looseCase]()), parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
          parser.attribName = parser.attribValue = "";
          return;
        }
        if (parser.opt.xmlns) {
          var qn = qname(parser.attribName, !0), prefix = qn.prefix, local = qn.local;
          if (prefix === "xmlns")
            if (local === "xml" && parser.attribValue !== XML_NAMESPACE)
              strictFail(
                parser,
                "xml: prefix must be bound to " + XML_NAMESPACE + `
Actual: ` + parser.attribValue
              );
            else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE)
              strictFail(
                parser,
                "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + `
Actual: ` + parser.attribValue
              );
            else {
              var tag = parser.tag, parent = parser.tags[parser.tags.length - 1] || parser;
              tag.ns === parent.ns && (tag.ns = Object.create(parent.ns)), tag.ns[local] = parser.attribValue;
            }
          parser.attribList.push([parser.attribName, parser.attribValue]);
        } else
          parser.tag.attributes[parser.attribName] = parser.attribValue, emitNode(parser, "onattribute", {
            name: parser.attribName,
            value: parser.attribValue
          });
        parser.attribName = parser.attribValue = "";
      }
      function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
          var tag = parser.tag, qn = qname(parser.tagName);
          tag.prefix = qn.prefix, tag.local = qn.local, tag.uri = tag.ns[qn.prefix] || "", tag.prefix && !tag.uri && (strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName)), tag.uri = qn.prefix);
          var parent = parser.tags[parser.tags.length - 1] || parser;
          tag.ns && parent.ns !== tag.ns && Object.keys(tag.ns).forEach(function(p) {
            emitNode(parser, "onopennamespace", {
              prefix: p,
              uri: tag.ns[p]
            });
          });
          for (var i = 0, l = parser.attribList.length; i < l; i++) {
            var nv = parser.attribList[i], name2 = nv[0], value = nv[1], qualName = qname(name2, !0), prefix = qualName.prefix, local = qualName.local, uri = prefix === "" ? "" : tag.ns[prefix] || "", a = {
              name: name2,
              value,
              prefix,
              local,
              uri
            };
            prefix && prefix !== "xmlns" && !uri && (strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix)), a.uri = prefix), parser.tag.attributes[name2] = a, emitNode(parser, "onattribute", a);
          }
          parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing, parser.sawRoot = !0, parser.tags.push(parser.tag), emitNode(parser, "onopentag", parser.tag), selfClosing || (!parser.noscript && parser.tagName.toLowerCase() === "script" ? parser.state = S.SCRIPT : parser.state = S.TEXT, parser.tag = null, parser.tagName = ""), parser.attribName = parser.attribValue = "", parser.attribList.length = 0;
      }
      function closeTag(parser) {
        if (!parser.tagName) {
          strictFail(parser, "Weird empty close tag."), parser.textNode += "</>", parser.state = S.TEXT;
          return;
        }
        if (parser.script) {
          if (parser.tagName !== "script") {
            parser.script += "</" + parser.tagName + ">", parser.tagName = "", parser.state = S.SCRIPT;
            return;
          }
          emitNode(parser, "onscript", parser.script), parser.script = "";
        }
        var t = parser.tags.length, tagName = parser.tagName;
        parser.strict || (tagName = tagName[parser.looseCase]());
        for (var closeTo = tagName; t--; ) {
          var close = parser.tags[t];
          if (close.name !== closeTo)
            strictFail(parser, "Unexpected close tag");
          else
            break;
        }
        if (t < 0) {
          strictFail(parser, "Unmatched closing tag: " + parser.tagName), parser.textNode += "</" + parser.tagName + ">", parser.state = S.TEXT;
          return;
        }
        parser.tagName = tagName;
        for (var s2 = parser.tags.length; s2-- > t; ) {
          var tag = parser.tag = parser.tags.pop();
          parser.tagName = parser.tag.name, emitNode(parser, "onclosetag", parser.tagName);
          var x = {};
          for (var i in tag.ns)
            x[i] = tag.ns[i];
          var parent = parser.tags[parser.tags.length - 1] || parser;
          parser.opt.xmlns && tag.ns !== parent.ns && Object.keys(tag.ns).forEach(function(p) {
            var n = tag.ns[p];
            emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
          });
        }
        t === 0 && (parser.closedRoot = !0), parser.tagName = parser.attribValue = parser.attribName = "", parser.attribList.length = 0, parser.state = S.TEXT;
      }
      function parseEntity(parser) {
        var entity = parser.entity, entityLC = entity.toLowerCase(), num, numStr = "";
        return parser.ENTITIES[entity] ? parser.ENTITIES[entity] : parser.ENTITIES[entityLC] ? parser.ENTITIES[entityLC] : (entity = entityLC, entity.charAt(0) === "#" && (entity.charAt(1) === "x" ? (entity = entity.slice(2), num = parseInt(entity, 16), numStr = num.toString(16)) : (entity = entity.slice(1), num = parseInt(entity, 10), numStr = num.toString(10))), entity = entity.replace(/^0+/, ""), isNaN(num) || numStr.toLowerCase() !== entity ? (strictFail(parser, "Invalid character entity"), "&" + parser.entity + ";") : String.fromCodePoint(num));
      }
      function beginWhiteSpace(parser, c) {
        c === "<" ? (parser.state = S.OPEN_WAKA, parser.startTagPosition = parser.position) : isWhitespace(c) || (strictFail(parser, "Non-whitespace before first tag."), parser.textNode = c, parser.state = S.TEXT);
      }
      function charAt(chunk, i) {
        var result = "";
        return i < chunk.length && (result = chunk.charAt(i)), result;
      }
      function write(chunk) {
        var parser = this;
        if (this.error)
          throw this.error;
        if (parser.closed)
          return error(
            parser,
            "Cannot write after close. Assign an onready handler."
          );
        if (chunk === null)
          return end(parser);
        typeof chunk == "object" && (chunk = chunk.toString());
        for (var i = 0, c = ""; c = charAt(chunk, i++), parser.c = c, !!c; )
          switch (parser.trackPosition && (parser.position++, c === `
` ? (parser.line++, parser.column = 0) : parser.column++), parser.state) {
            case S.BEGIN:
              if (parser.state = S.BEGIN_WHITESPACE, c === "\uFEFF")
                continue;
              beginWhiteSpace(parser, c);
              continue;
            case S.BEGIN_WHITESPACE:
              beginWhiteSpace(parser, c);
              continue;
            case S.TEXT:
              if (parser.sawRoot && !parser.closedRoot) {
                for (var starti = i - 1; c && c !== "<" && c !== "&"; )
                  c = charAt(chunk, i++), c && parser.trackPosition && (parser.position++, c === `
` ? (parser.line++, parser.column = 0) : parser.column++);
                parser.textNode += chunk.substring(starti, i - 1);
              }
              c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict) ? (parser.state = S.OPEN_WAKA, parser.startTagPosition = parser.position) : (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot) && strictFail(parser, "Text data outside of root node."), c === "&" ? parser.state = S.TEXT_ENTITY : parser.textNode += c);
              continue;
            case S.SCRIPT:
              c === "<" ? parser.state = S.SCRIPT_ENDING : parser.script += c;
              continue;
            case S.SCRIPT_ENDING:
              c === "/" ? parser.state = S.CLOSE_TAG : (parser.script += "<" + c, parser.state = S.SCRIPT);
              continue;
            case S.OPEN_WAKA:
              if (c === "!")
                parser.state = S.SGML_DECL, parser.sgmlDecl = "";
              else if (!isWhitespace(c))
                if (isMatch(nameStart, c))
                  parser.state = S.OPEN_TAG, parser.tagName = c;
                else if (c === "/")
                  parser.state = S.CLOSE_TAG, parser.tagName = "";
                else if (c === "?")
                  parser.state = S.PROC_INST, parser.procInstName = parser.procInstBody = "";
                else {
                  if (strictFail(parser, "Unencoded <"), parser.startTagPosition + 1 < parser.position) {
                    var pad = parser.position - parser.startTagPosition;
                    c = new Array(pad).join(" ") + c;
                  }
                  parser.textNode += "<" + c, parser.state = S.TEXT;
                }
              continue;
            case S.SGML_DECL:
              if (parser.sgmlDecl + c === "--") {
                parser.state = S.COMMENT, parser.comment = "", parser.sgmlDecl = "";
                continue;
              }
              parser.doctype && parser.doctype !== !0 && parser.sgmlDecl ? (parser.state = S.DOCTYPE_DTD, parser.doctype += "<!" + parser.sgmlDecl + c, parser.sgmlDecl = "") : (parser.sgmlDecl + c).toUpperCase() === CDATA ? (emitNode(parser, "onopencdata"), parser.state = S.CDATA, parser.sgmlDecl = "", parser.cdata = "") : (parser.sgmlDecl + c).toUpperCase() === DOCTYPE ? (parser.state = S.DOCTYPE, (parser.doctype || parser.sawRoot) && strictFail(
                parser,
                "Inappropriately located doctype declaration"
              ), parser.doctype = "", parser.sgmlDecl = "") : c === ">" ? (emitNode(parser, "onsgmldeclaration", parser.sgmlDecl), parser.sgmlDecl = "", parser.state = S.TEXT) : (isQuote(c) && (parser.state = S.SGML_DECL_QUOTED), parser.sgmlDecl += c);
              continue;
            case S.SGML_DECL_QUOTED:
              c === parser.q && (parser.state = S.SGML_DECL, parser.q = ""), parser.sgmlDecl += c;
              continue;
            case S.DOCTYPE:
              c === ">" ? (parser.state = S.TEXT, emitNode(parser, "ondoctype", parser.doctype), parser.doctype = !0) : (parser.doctype += c, c === "[" ? parser.state = S.DOCTYPE_DTD : isQuote(c) && (parser.state = S.DOCTYPE_QUOTED, parser.q = c));
              continue;
            case S.DOCTYPE_QUOTED:
              parser.doctype += c, c === parser.q && (parser.q = "", parser.state = S.DOCTYPE);
              continue;
            case S.DOCTYPE_DTD:
              c === "]" ? (parser.doctype += c, parser.state = S.DOCTYPE) : c === "<" ? (parser.state = S.OPEN_WAKA, parser.startTagPosition = parser.position) : isQuote(c) ? (parser.doctype += c, parser.state = S.DOCTYPE_DTD_QUOTED, parser.q = c) : parser.doctype += c;
              continue;
            case S.DOCTYPE_DTD_QUOTED:
              parser.doctype += c, c === parser.q && (parser.state = S.DOCTYPE_DTD, parser.q = "");
              continue;
            case S.COMMENT:
              c === "-" ? parser.state = S.COMMENT_ENDING : parser.comment += c;
              continue;
            case S.COMMENT_ENDING:
              c === "-" ? (parser.state = S.COMMENT_ENDED, parser.comment = textopts(parser.opt, parser.comment), parser.comment && emitNode(parser, "oncomment", parser.comment), parser.comment = "") : (parser.comment += "-" + c, parser.state = S.COMMENT);
              continue;
            case S.COMMENT_ENDED:
              c !== ">" ? (strictFail(parser, "Malformed comment"), parser.comment += "--" + c, parser.state = S.COMMENT) : parser.doctype && parser.doctype !== !0 ? parser.state = S.DOCTYPE_DTD : parser.state = S.TEXT;
              continue;
            case S.CDATA:
              c === "]" ? parser.state = S.CDATA_ENDING : parser.cdata += c;
              continue;
            case S.CDATA_ENDING:
              c === "]" ? parser.state = S.CDATA_ENDING_2 : (parser.cdata += "]" + c, parser.state = S.CDATA);
              continue;
            case S.CDATA_ENDING_2:
              c === ">" ? (parser.cdata && emitNode(parser, "oncdata", parser.cdata), emitNode(parser, "onclosecdata"), parser.cdata = "", parser.state = S.TEXT) : c === "]" ? parser.cdata += "]" : (parser.cdata += "]]" + c, parser.state = S.CDATA);
              continue;
            case S.PROC_INST:
              c === "?" ? parser.state = S.PROC_INST_ENDING : isWhitespace(c) ? parser.state = S.PROC_INST_BODY : parser.procInstName += c;
              continue;
            case S.PROC_INST_BODY:
              if (!parser.procInstBody && isWhitespace(c))
                continue;
              c === "?" ? parser.state = S.PROC_INST_ENDING : parser.procInstBody += c;
              continue;
            case S.PROC_INST_ENDING:
              c === ">" ? (emitNode(parser, "onprocessinginstruction", {
                name: parser.procInstName,
                body: parser.procInstBody
              }), parser.procInstName = parser.procInstBody = "", parser.state = S.TEXT) : (parser.procInstBody += "?" + c, parser.state = S.PROC_INST_BODY);
              continue;
            case S.OPEN_TAG:
              isMatch(nameBody, c) ? parser.tagName += c : (newTag(parser), c === ">" ? openTag(parser) : c === "/" ? parser.state = S.OPEN_TAG_SLASH : (isWhitespace(c) || strictFail(parser, "Invalid character in tag name"), parser.state = S.ATTRIB));
              continue;
            case S.OPEN_TAG_SLASH:
              c === ">" ? (openTag(parser, !0), closeTag(parser)) : (strictFail(parser, "Forward-slash in opening tag not followed by >"), parser.state = S.ATTRIB);
              continue;
            case S.ATTRIB:
              if (isWhitespace(c))
                continue;
              c === ">" ? openTag(parser) : c === "/" ? parser.state = S.OPEN_TAG_SLASH : isMatch(nameStart, c) ? (parser.attribName = c, parser.attribValue = "", parser.state = S.ATTRIB_NAME) : strictFail(parser, "Invalid attribute name");
              continue;
            case S.ATTRIB_NAME:
              c === "=" ? parser.state = S.ATTRIB_VALUE : c === ">" ? (strictFail(parser, "Attribute without value"), parser.attribValue = parser.attribName, attrib(parser), openTag(parser)) : isWhitespace(c) ? parser.state = S.ATTRIB_NAME_SAW_WHITE : isMatch(nameBody, c) ? parser.attribName += c : strictFail(parser, "Invalid attribute name");
              continue;
            case S.ATTRIB_NAME_SAW_WHITE:
              if (c === "=")
                parser.state = S.ATTRIB_VALUE;
              else {
                if (isWhitespace(c))
                  continue;
                strictFail(parser, "Attribute without value"), parser.tag.attributes[parser.attribName] = "", parser.attribValue = "", emitNode(parser, "onattribute", {
                  name: parser.attribName,
                  value: ""
                }), parser.attribName = "", c === ">" ? openTag(parser) : isMatch(nameStart, c) ? (parser.attribName = c, parser.state = S.ATTRIB_NAME) : (strictFail(parser, "Invalid attribute name"), parser.state = S.ATTRIB);
              }
              continue;
            case S.ATTRIB_VALUE:
              if (isWhitespace(c))
                continue;
              isQuote(c) ? (parser.q = c, parser.state = S.ATTRIB_VALUE_QUOTED) : (parser.opt.unquotedAttributeValues || error(parser, "Unquoted attribute value"), parser.state = S.ATTRIB_VALUE_UNQUOTED, parser.attribValue = c);
              continue;
            case S.ATTRIB_VALUE_QUOTED:
              if (c !== parser.q) {
                c === "&" ? parser.state = S.ATTRIB_VALUE_ENTITY_Q : parser.attribValue += c;
                continue;
              }
              attrib(parser), parser.q = "", parser.state = S.ATTRIB_VALUE_CLOSED;
              continue;
            case S.ATTRIB_VALUE_CLOSED:
              isWhitespace(c) ? parser.state = S.ATTRIB : c === ">" ? openTag(parser) : c === "/" ? parser.state = S.OPEN_TAG_SLASH : isMatch(nameStart, c) ? (strictFail(parser, "No whitespace between attributes"), parser.attribName = c, parser.attribValue = "", parser.state = S.ATTRIB_NAME) : strictFail(parser, "Invalid attribute name");
              continue;
            case S.ATTRIB_VALUE_UNQUOTED:
              if (!isAttribEnd(c)) {
                c === "&" ? parser.state = S.ATTRIB_VALUE_ENTITY_U : parser.attribValue += c;
                continue;
              }
              attrib(parser), c === ">" ? openTag(parser) : parser.state = S.ATTRIB;
              continue;
            case S.CLOSE_TAG:
              if (parser.tagName)
                c === ">" ? closeTag(parser) : isMatch(nameBody, c) ? parser.tagName += c : parser.script ? (parser.script += "</" + parser.tagName, parser.tagName = "", parser.state = S.SCRIPT) : (isWhitespace(c) || strictFail(parser, "Invalid tagname in closing tag"), parser.state = S.CLOSE_TAG_SAW_WHITE);
              else {
                if (isWhitespace(c))
                  continue;
                notMatch(nameStart, c) ? parser.script ? (parser.script += "</" + c, parser.state = S.SCRIPT) : strictFail(parser, "Invalid tagname in closing tag.") : parser.tagName = c;
              }
              continue;
            case S.CLOSE_TAG_SAW_WHITE:
              if (isWhitespace(c))
                continue;
              c === ">" ? closeTag(parser) : strictFail(parser, "Invalid characters in closing tag");
              continue;
            case S.TEXT_ENTITY:
            case S.ATTRIB_VALUE_ENTITY_Q:
            case S.ATTRIB_VALUE_ENTITY_U:
              var returnState, buffer;
              switch (parser.state) {
                case S.TEXT_ENTITY:
                  returnState = S.TEXT, buffer = "textNode";
                  break;
                case S.ATTRIB_VALUE_ENTITY_Q:
                  returnState = S.ATTRIB_VALUE_QUOTED, buffer = "attribValue";
                  break;
                case S.ATTRIB_VALUE_ENTITY_U:
                  returnState = S.ATTRIB_VALUE_UNQUOTED, buffer = "attribValue";
                  break;
              }
              if (c === ";") {
                var parsedEntity = parseEntity(parser);
                parser.opt.unparsedEntities && !Object.values(sax.XML_ENTITIES).includes(parsedEntity) ? (parser.entity = "", parser.state = returnState, parser.write(parsedEntity)) : (parser[buffer] += parsedEntity, parser.entity = "", parser.state = returnState);
              } else isMatch(parser.entity.length ? entityBody : entityStart, c) ? parser.entity += c : (strictFail(parser, "Invalid character in entity name"), parser[buffer] += "&" + parser.entity + c, parser.entity = "", parser.state = returnState);
              continue;
            default:
              throw new Error(parser, "Unknown state: " + parser.state);
          }
        return parser.position >= parser.bufferCheckPosition && checkBufferLength(parser), parser;
      }
      String.fromCodePoint || function() {
        var stringFromCharCode = String.fromCharCode, floor = Math.floor, fromCodePoint = function() {
          var MAX_SIZE = 16384, codeUnits = [], highSurrogate, lowSurrogate, index = -1, length = arguments.length;
          if (!length)
            return "";
          for (var result = ""; ++index < length; ) {
            var codePoint = Number(arguments[index]);
            if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
            codePoint < 0 || // not a valid Unicode code point
            codePoint > 1114111 || // not a valid Unicode code point
            floor(codePoint) !== codePoint)
              throw RangeError("Invalid code point: " + codePoint);
            codePoint <= 65535 ? codeUnits.push(codePoint) : (codePoint -= 65536, highSurrogate = (codePoint >> 10) + 55296, lowSurrogate = codePoint % 1024 + 56320, codeUnits.push(highSurrogate, lowSurrogate)), (index + 1 === length || codeUnits.length > MAX_SIZE) && (result += stringFromCharCode.apply(null, codeUnits), codeUnits.length = 0);
          }
          return result;
        };
        Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", {
          value: fromCodePoint,
          configurable: !0,
          writable: !0
        }) : String.fromCodePoint = fromCodePoint;
      }();
    })(typeof exports2 > "u" ? exports2.sax = {} : exports2);
  }
});

// node_modules/xml-js/lib/array-helper.js
var require_array_helper = __commonJS({
  "node_modules/xml-js/lib/array-helper.js"(exports2, module2) {
    module2.exports = {
      isArray: function(value) {
        return Array.isArray ? Array.isArray(value) : Object.prototype.toString.call(value) === "[object Array]";
      }
    };
  }
});

// node_modules/xml-js/lib/options-helper.js
var require_options_helper = __commonJS({
  "node_modules/xml-js/lib/options-helper.js"(exports2, module2) {
    var isArray = require_array_helper().isArray;
    module2.exports = {
      copyOptions: function(options) {
        var key, copy = {};
        for (key in options)
          options.hasOwnProperty(key) && (copy[key] = options[key]);
        return copy;
      },
      ensureFlagExists: function(item, options) {
        (!(item in options) || typeof options[item] != "boolean") && (options[item] = !1);
      },
      ensureSpacesExists: function(options) {
        (!("spaces" in options) || typeof options.spaces != "number" && typeof options.spaces != "string") && (options.spaces = 0);
      },
      ensureAlwaysArrayExists: function(options) {
        (!("alwaysArray" in options) || typeof options.alwaysArray != "boolean" && !isArray(options.alwaysArray)) && (options.alwaysArray = !1);
      },
      ensureKeyExists: function(key, options) {
        (!(key + "Key" in options) || typeof options[key + "Key"] != "string") && (options[key + "Key"] = options.compact ? "_" + key : key);
      },
      checkFnExists: function(key, options) {
        return key + "Fn" in options;
      }
    };
  }
});

// node_modules/xml-js/lib/xml2js.js
var require_xml2js = __commonJS({
  "node_modules/xml-js/lib/xml2js.js"(exports2, module2) {
    var sax = require_sax(), expat = { on: function() {
    }, parse: function() {
    } }, helper = require_options_helper(), isArray = require_array_helper().isArray, options, pureJsParser = !0, currentElement;
    function validateOptions(userOptions) {
      return options = helper.copyOptions(userOptions), helper.ensureFlagExists("ignoreDeclaration", options), helper.ensureFlagExists("ignoreInstruction", options), helper.ensureFlagExists("ignoreAttributes", options), helper.ensureFlagExists("ignoreText", options), helper.ensureFlagExists("ignoreComment", options), helper.ensureFlagExists("ignoreCdata", options), helper.ensureFlagExists("ignoreDoctype", options), helper.ensureFlagExists("compact", options), helper.ensureFlagExists("alwaysChildren", options), helper.ensureFlagExists("addParent", options), helper.ensureFlagExists("trim", options), helper.ensureFlagExists("nativeType", options), helper.ensureFlagExists("nativeTypeAttributes", options), helper.ensureFlagExists("sanitize", options), helper.ensureFlagExists("instructionHasAttributes", options), helper.ensureFlagExists("captureSpacesBetweenElements", options), helper.ensureAlwaysArrayExists(options), helper.ensureKeyExists("declaration", options), helper.ensureKeyExists("instruction", options), helper.ensureKeyExists("attributes", options), helper.ensureKeyExists("text", options), helper.ensureKeyExists("comment", options), helper.ensureKeyExists("cdata", options), helper.ensureKeyExists("doctype", options), helper.ensureKeyExists("type", options), helper.ensureKeyExists("name", options), helper.ensureKeyExists("elements", options), helper.ensureKeyExists("parent", options), helper.checkFnExists("doctype", options), helper.checkFnExists("instruction", options), helper.checkFnExists("cdata", options), helper.checkFnExists("comment", options), helper.checkFnExists("text", options), helper.checkFnExists("instructionName", options), helper.checkFnExists("elementName", options), helper.checkFnExists("attributeName", options), helper.checkFnExists("attributeValue", options), helper.checkFnExists("attributes", options), options;
    }
    function nativeType(value) {
      var nValue = Number(value);
      if (!isNaN(nValue))
        return nValue;
      var bValue = value.toLowerCase();
      return bValue === "true" ? !0 : bValue === "false" ? !1 : value;
    }
    function addField(type, value) {
      var key;
      if (options.compact) {
        if (!currentElement[options[type + "Key"]] && (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(options[type + "Key"]) !== -1 : options.alwaysArray) && (currentElement[options[type + "Key"]] = []), currentElement[options[type + "Key"]] && !isArray(currentElement[options[type + "Key"]]) && (currentElement[options[type + "Key"]] = [currentElement[options[type + "Key"]]]), type + "Fn" in options && typeof value == "string" && (value = options[type + "Fn"](value, currentElement)), type === "instruction" && ("instructionFn" in options || "instructionNameFn" in options)) {
          for (key in value)
            if (value.hasOwnProperty(key))
              if ("instructionFn" in options)
                value[key] = options.instructionFn(value[key], key, currentElement);
              else {
                var temp = value[key];
                delete value[key], value[options.instructionNameFn(key, temp, currentElement)] = temp;
              }
        }
        isArray(currentElement[options[type + "Key"]]) ? currentElement[options[type + "Key"]].push(value) : currentElement[options[type + "Key"]] = value;
      } else {
        currentElement[options.elementsKey] || (currentElement[options.elementsKey] = []);
        var element = {};
        if (element[options.typeKey] = type, type === "instruction") {
          for (key in value)
            if (value.hasOwnProperty(key))
              break;
          element[options.nameKey] = "instructionNameFn" in options ? options.instructionNameFn(key, value, currentElement) : key, options.instructionHasAttributes ? (element[options.attributesKey] = value[key][options.attributesKey], "instructionFn" in options && (element[options.attributesKey] = options.instructionFn(element[options.attributesKey], key, currentElement))) : ("instructionFn" in options && (value[key] = options.instructionFn(value[key], key, currentElement)), element[options.instructionKey] = value[key]);
        } else
          type + "Fn" in options && (value = options[type + "Fn"](value, currentElement)), element[options[type + "Key"]] = value;
        options.addParent && (element[options.parentKey] = currentElement), currentElement[options.elementsKey].push(element);
      }
    }
    function manipulateAttributes(attributes) {
      if ("attributesFn" in options && attributes && (attributes = options.attributesFn(attributes, currentElement)), (options.trim || "attributeValueFn" in options || "attributeNameFn" in options || options.nativeTypeAttributes) && attributes) {
        var key;
        for (key in attributes)
          if (attributes.hasOwnProperty(key) && (options.trim && (attributes[key] = attributes[key].trim()), options.nativeTypeAttributes && (attributes[key] = nativeType(attributes[key])), "attributeValueFn" in options && (attributes[key] = options.attributeValueFn(attributes[key], key, currentElement)), "attributeNameFn" in options)) {
            var temp = attributes[key];
            delete attributes[key], attributes[options.attributeNameFn(key, attributes[key], currentElement)] = temp;
          }
      }
      return attributes;
    }
    function onInstruction(instruction) {
      var attributes = {};
      if (instruction.body && (instruction.name.toLowerCase() === "xml" || options.instructionHasAttributes)) {
        for (var attrsRegExp = /([\w:-]+)\s*=\s*(?:"([^"]*)"|'([^']*)'|(\w+))\s*/g, match; (match = attrsRegExp.exec(instruction.body)) !== null; )
          attributes[match[1]] = match[2] || match[3] || match[4];
        attributes = manipulateAttributes(attributes);
      }
      if (instruction.name.toLowerCase() === "xml") {
        if (options.ignoreDeclaration)
          return;
        currentElement[options.declarationKey] = {}, Object.keys(attributes).length && (currentElement[options.declarationKey][options.attributesKey] = attributes), options.addParent && (currentElement[options.declarationKey][options.parentKey] = currentElement);
      } else {
        if (options.ignoreInstruction)
          return;
        options.trim && (instruction.body = instruction.body.trim());
        var value = {};
        options.instructionHasAttributes && Object.keys(attributes).length ? (value[instruction.name] = {}, value[instruction.name][options.attributesKey] = attributes) : value[instruction.name] = instruction.body, addField("instruction", value);
      }
    }
    function onStartElement(name2, attributes) {
      var element;
      if (typeof name2 == "object" && (attributes = name2.attributes, name2 = name2.name), attributes = manipulateAttributes(attributes), "elementNameFn" in options && (name2 = options.elementNameFn(name2, currentElement)), options.compact) {
        if (element = {}, !options.ignoreAttributes && attributes && Object.keys(attributes).length) {
          element[options.attributesKey] = {};
          var key;
          for (key in attributes)
            attributes.hasOwnProperty(key) && (element[options.attributesKey][key] = attributes[key]);
        }
        !(name2 in currentElement) && (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(name2) !== -1 : options.alwaysArray) && (currentElement[name2] = []), currentElement[name2] && !isArray(currentElement[name2]) && (currentElement[name2] = [currentElement[name2]]), isArray(currentElement[name2]) ? currentElement[name2].push(element) : currentElement[name2] = element;
      } else
        currentElement[options.elementsKey] || (currentElement[options.elementsKey] = []), element = {}, element[options.typeKey] = "element", element[options.nameKey] = name2, !options.ignoreAttributes && attributes && Object.keys(attributes).length && (element[options.attributesKey] = attributes), options.alwaysChildren && (element[options.elementsKey] = []), currentElement[options.elementsKey].push(element);
      element[options.parentKey] = currentElement, currentElement = element;
    }
    function onText(text) {
      options.ignoreText || !text.trim() && !options.captureSpacesBetweenElements || (options.trim && (text = text.trim()), options.nativeType && (text = nativeType(text)), options.sanitize && (text = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")), addField("text", text));
    }
    function onComment(comment) {
      options.ignoreComment || (options.trim && (comment = comment.trim()), addField("comment", comment));
    }
    function onEndElement(name2) {
      var parentElement = currentElement[options.parentKey];
      options.addParent || delete currentElement[options.parentKey], currentElement = parentElement;
    }
    function onCdata(cdata) {
      options.ignoreCdata || (options.trim && (cdata = cdata.trim()), addField("cdata", cdata));
    }
    function onDoctype(doctype) {
      options.ignoreDoctype || (doctype = doctype.replace(/^ /, ""), options.trim && (doctype = doctype.trim()), addField("doctype", doctype));
    }
    function onError(error) {
      error.note = error;
    }
    module2.exports = function(xml, userOptions) {
      var parser = pureJsParser ? sax.parser(!0, {}) : parser = new expat.Parser("UTF-8"), result = {};
      if (currentElement = result, options = validateOptions(userOptions), pureJsParser ? (parser.opt = { strictEntities: !0 }, parser.onopentag = onStartElement, parser.ontext = onText, parser.oncomment = onComment, parser.onclosetag = onEndElement, parser.onerror = onError, parser.oncdata = onCdata, parser.ondoctype = onDoctype, parser.onprocessinginstruction = onInstruction) : (parser.on("startElement", onStartElement), parser.on("text", onText), parser.on("comment", onComment), parser.on("endElement", onEndElement), parser.on("error", onError)), pureJsParser)
        parser.write(xml).close();
      else if (!parser.parse(xml))
        throw new Error("XML parsing error: " + parser.getError());
      if (result[options.elementsKey]) {
        var temp = result[options.elementsKey];
        delete result[options.elementsKey], result[options.elementsKey] = temp, delete result.text;
      }
      return result;
    };
  }
});

// node_modules/xml-js/lib/xml2json.js
var require_xml2json = __commonJS({
  "node_modules/xml-js/lib/xml2json.js"(exports2, module2) {
    var helper = require_options_helper(), xml2js = require_xml2js();
    function validateOptions(userOptions) {
      var options = helper.copyOptions(userOptions);
      return helper.ensureSpacesExists(options), options;
    }
    module2.exports = function(xml, userOptions) {
      var options, js, json, parentKey;
      return options = validateOptions(userOptions), js = xml2js(xml, options), parentKey = "compact" in options && options.compact ? "_parent" : "parent", "addParent" in options && options.addParent ? json = JSON.stringify(js, function(k, v) {
        return k === parentKey ? "_" : v;
      }, options.spaces) : json = JSON.stringify(js, null, options.spaces), json.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    };
  }
});

// node_modules/xml-js/lib/js2xml.js
var require_js2xml = __commonJS({
  "node_modules/xml-js/lib/js2xml.js"(exports2, module2) {
    var helper = require_options_helper(), isArray = require_array_helper().isArray, currentElement, currentElementName;
    function validateOptions(userOptions) {
      var options = helper.copyOptions(userOptions);
      return helper.ensureFlagExists("ignoreDeclaration", options), helper.ensureFlagExists("ignoreInstruction", options), helper.ensureFlagExists("ignoreAttributes", options), helper.ensureFlagExists("ignoreText", options), helper.ensureFlagExists("ignoreComment", options), helper.ensureFlagExists("ignoreCdata", options), helper.ensureFlagExists("ignoreDoctype", options), helper.ensureFlagExists("compact", options), helper.ensureFlagExists("indentText", options), helper.ensureFlagExists("indentCdata", options), helper.ensureFlagExists("indentAttributes", options), helper.ensureFlagExists("indentInstruction", options), helper.ensureFlagExists("fullTagEmptyElement", options), helper.ensureFlagExists("noQuotesForNativeAttributes", options), helper.ensureSpacesExists(options), typeof options.spaces == "number" && (options.spaces = Array(options.spaces + 1).join(" ")), helper.ensureKeyExists("declaration", options), helper.ensureKeyExists("instruction", options), helper.ensureKeyExists("attributes", options), helper.ensureKeyExists("text", options), helper.ensureKeyExists("comment", options), helper.ensureKeyExists("cdata", options), helper.ensureKeyExists("doctype", options), helper.ensureKeyExists("type", options), helper.ensureKeyExists("name", options), helper.ensureKeyExists("elements", options), helper.checkFnExists("doctype", options), helper.checkFnExists("instruction", options), helper.checkFnExists("cdata", options), helper.checkFnExists("comment", options), helper.checkFnExists("text", options), helper.checkFnExists("instructionName", options), helper.checkFnExists("elementName", options), helper.checkFnExists("attributeName", options), helper.checkFnExists("attributeValue", options), helper.checkFnExists("attributes", options), helper.checkFnExists("fullTagEmptyElement", options), options;
    }
    function writeIndentation(options, depth, firstLine) {
      return (!firstLine && options.spaces ? `
` : "") + Array(depth + 1).join(options.spaces);
    }
    function writeAttributes(attributes, options, depth) {
      if (options.ignoreAttributes)
        return "";
      "attributesFn" in options && (attributes = options.attributesFn(attributes, currentElementName, currentElement));
      var key, attr, attrName, quote, result = [];
      for (key in attributes)
        attributes.hasOwnProperty(key) && attributes[key] !== null && attributes[key] !== void 0 && (quote = options.noQuotesForNativeAttributes && typeof attributes[key] != "string" ? "" : '"', attr = "" + attributes[key], attr = attr.replace(/"/g, "&quot;"), attrName = "attributeNameFn" in options ? options.attributeNameFn(key, attr, currentElementName, currentElement) : key, result.push(options.spaces && options.indentAttributes ? writeIndentation(options, depth + 1, !1) : " "), result.push(attrName + "=" + quote + ("attributeValueFn" in options ? options.attributeValueFn(attr, key, currentElementName, currentElement) : attr) + quote));
      return attributes && Object.keys(attributes).length && options.spaces && options.indentAttributes && result.push(writeIndentation(options, depth, !1)), result.join("");
    }
    function writeDeclaration(declaration, options, depth) {
      return currentElement = declaration, currentElementName = "xml", options.ignoreDeclaration ? "" : "<?xml" + writeAttributes(declaration[options.attributesKey], options, depth) + "?>";
    }
    function writeInstruction(instruction, options, depth) {
      if (options.ignoreInstruction)
        return "";
      var key;
      for (key in instruction)
        if (instruction.hasOwnProperty(key))
          break;
      var instructionName = "instructionNameFn" in options ? options.instructionNameFn(key, instruction[key], currentElementName, currentElement) : key;
      if (typeof instruction[key] == "object")
        return currentElement = instruction, currentElementName = instructionName, "<?" + instructionName + writeAttributes(instruction[key][options.attributesKey], options, depth) + "?>";
      var instructionValue = instruction[key] ? instruction[key] : "";
      return "instructionFn" in options && (instructionValue = options.instructionFn(instructionValue, key, currentElementName, currentElement)), "<?" + instructionName + (instructionValue ? " " + instructionValue : "") + "?>";
    }
    function writeComment(comment, options) {
      return options.ignoreComment ? "" : "<!--" + ("commentFn" in options ? options.commentFn(comment, currentElementName, currentElement) : comment) + "-->";
    }
    function writeCdata(cdata, options) {
      return options.ignoreCdata ? "" : "<![CDATA[" + ("cdataFn" in options ? options.cdataFn(cdata, currentElementName, currentElement) : cdata.replace("]]>", "]]]]><![CDATA[>")) + "]]>";
    }
    function writeDoctype(doctype, options) {
      return options.ignoreDoctype ? "" : "<!DOCTYPE " + ("doctypeFn" in options ? options.doctypeFn(doctype, currentElementName, currentElement) : doctype) + ">";
    }
    function writeText(text, options) {
      return options.ignoreText ? "" : (text = "" + text, text = text.replace(/&amp;/g, "&"), text = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), "textFn" in options ? options.textFn(text, currentElementName, currentElement) : text);
    }
    function hasContent(element, options) {
      var i;
      if (element.elements && element.elements.length)
        for (i = 0; i < element.elements.length; ++i)
          switch (element.elements[i][options.typeKey]) {
            case "text":
              if (options.indentText)
                return !0;
              break;
            // skip to next key
            case "cdata":
              if (options.indentCdata)
                return !0;
              break;
            // skip to next key
            case "instruction":
              if (options.indentInstruction)
                return !0;
              break;
            // skip to next key
            case "doctype":
            case "comment":
            case "element":
              return !0;
            default:
              return !0;
          }
      return !1;
    }
    function writeElement(element, options, depth) {
      currentElement = element, currentElementName = element.name;
      var xml = [], elementName = "elementNameFn" in options ? options.elementNameFn(element.name, element) : element.name;
      xml.push("<" + elementName), element[options.attributesKey] && xml.push(writeAttributes(element[options.attributesKey], options, depth));
      var withClosingTag = element[options.elementsKey] && element[options.elementsKey].length || element[options.attributesKey] && element[options.attributesKey]["xml:space"] === "preserve";
      return withClosingTag || ("fullTagEmptyElementFn" in options ? withClosingTag = options.fullTagEmptyElementFn(element.name, element) : withClosingTag = options.fullTagEmptyElement), withClosingTag ? (xml.push(">"), element[options.elementsKey] && element[options.elementsKey].length && (xml.push(writeElements(element[options.elementsKey], options, depth + 1)), currentElement = element, currentElementName = element.name), xml.push(options.spaces && hasContent(element, options) ? `
` + Array(depth + 1).join(options.spaces) : ""), xml.push("</" + elementName + ">")) : xml.push("/>"), xml.join("");
    }
    function writeElements(elements, options, depth, firstLine) {
      return elements.reduce(function(xml, element) {
        var indent = writeIndentation(options, depth, firstLine && !xml);
        switch (element.type) {
          case "element":
            return xml + indent + writeElement(element, options, depth);
          case "comment":
            return xml + indent + writeComment(element[options.commentKey], options);
          case "doctype":
            return xml + indent + writeDoctype(element[options.doctypeKey], options);
          case "cdata":
            return xml + (options.indentCdata ? indent : "") + writeCdata(element[options.cdataKey], options);
          case "text":
            return xml + (options.indentText ? indent : "") + writeText(element[options.textKey], options);
          case "instruction":
            var instruction = {};
            return instruction[element[options.nameKey]] = element[options.attributesKey] ? element : element[options.instructionKey], xml + (options.indentInstruction ? indent : "") + writeInstruction(instruction, options, depth);
        }
      }, "");
    }
    function hasContentCompact(element, options, anyContent) {
      var key;
      for (key in element)
        if (element.hasOwnProperty(key))
          switch (key) {
            case options.parentKey:
            case options.attributesKey:
              break;
            // skip to next key
            case options.textKey:
              if (options.indentText || anyContent)
                return !0;
              break;
            // skip to next key
            case options.cdataKey:
              if (options.indentCdata || anyContent)
                return !0;
              break;
            // skip to next key
            case options.instructionKey:
              if (options.indentInstruction || anyContent)
                return !0;
              break;
            // skip to next key
            case options.doctypeKey:
            case options.commentKey:
              return !0;
            default:
              return !0;
          }
      return !1;
    }
    function writeElementCompact(element, name2, options, depth, indent) {
      currentElement = element, currentElementName = name2;
      var elementName = "elementNameFn" in options ? options.elementNameFn(name2, element) : name2;
      if (typeof element > "u" || element === null || element === "")
        return "fullTagEmptyElementFn" in options && options.fullTagEmptyElementFn(name2, element) || options.fullTagEmptyElement ? "<" + elementName + "></" + elementName + ">" : "<" + elementName + "/>";
      var xml = [];
      if (name2) {
        if (xml.push("<" + elementName), typeof element != "object")
          return xml.push(">" + writeText(element, options) + "</" + elementName + ">"), xml.join("");
        element[options.attributesKey] && xml.push(writeAttributes(element[options.attributesKey], options, depth));
        var withClosingTag = hasContentCompact(element, options, !0) || element[options.attributesKey] && element[options.attributesKey]["xml:space"] === "preserve";
        if (withClosingTag || ("fullTagEmptyElementFn" in options ? withClosingTag = options.fullTagEmptyElementFn(name2, element) : withClosingTag = options.fullTagEmptyElement), withClosingTag)
          xml.push(">");
        else
          return xml.push("/>"), xml.join("");
      }
      return xml.push(writeElementsCompact(element, options, depth + 1, !1)), currentElement = element, currentElementName = name2, name2 && xml.push((indent ? writeIndentation(options, depth, !1) : "") + "</" + elementName + ">"), xml.join("");
    }
    function writeElementsCompact(element, options, depth, firstLine) {
      var i, key, nodes, xml = [];
      for (key in element)
        if (element.hasOwnProperty(key))
          for (nodes = isArray(element[key]) ? element[key] : [element[key]], i = 0; i < nodes.length; ++i) {
            switch (key) {
              case options.declarationKey:
                xml.push(writeDeclaration(nodes[i], options, depth));
                break;
              case options.instructionKey:
                xml.push((options.indentInstruction ? writeIndentation(options, depth, firstLine) : "") + writeInstruction(nodes[i], options, depth));
                break;
              case options.attributesKey:
              case options.parentKey:
                break;
              // skip
              case options.textKey:
                xml.push((options.indentText ? writeIndentation(options, depth, firstLine) : "") + writeText(nodes[i], options));
                break;
              case options.cdataKey:
                xml.push((options.indentCdata ? writeIndentation(options, depth, firstLine) : "") + writeCdata(nodes[i], options));
                break;
              case options.doctypeKey:
                xml.push(writeIndentation(options, depth, firstLine) + writeDoctype(nodes[i], options));
                break;
              case options.commentKey:
                xml.push(writeIndentation(options, depth, firstLine) + writeComment(nodes[i], options));
                break;
              default:
                xml.push(writeIndentation(options, depth, firstLine) + writeElementCompact(nodes[i], key, options, depth, hasContentCompact(nodes[i], options)));
            }
            firstLine = firstLine && !xml.length;
          }
      return xml.join("");
    }
    module2.exports = function(js, options) {
      options = validateOptions(options);
      var xml = [];
      return currentElement = js, currentElementName = "_root_", options.compact ? xml.push(writeElementsCompact(js, options, 0, !0)) : (js[options.declarationKey] && xml.push(writeDeclaration(js[options.declarationKey], options, 0)), js[options.elementsKey] && js[options.elementsKey].length && xml.push(writeElements(js[options.elementsKey], options, 0, !xml.length))), xml.join("");
    };
  }
});

// node_modules/xml-js/lib/json2xml.js
var require_json2xml = __commonJS({
  "node_modules/xml-js/lib/json2xml.js"(exports2, module2) {
    var js2xml = require_js2xml();
    module2.exports = function(json, options) {
      json instanceof Buffer && (json = json.toString());
      var js = null;
      if (typeof json == "string")
        try {
          js = JSON.parse(json);
        } catch {
          throw new Error("The JSON structure is invalid");
        }
      else
        js = json;
      return js2xml(js, options);
    };
  }
});

// node_modules/xml-js/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/xml-js/lib/index.js"(exports2, module2) {
    var xml2js = require_xml2js(), xml2json = require_xml2json(), js2xml = require_js2xml(), json2xml = require_json2xml();
    module2.exports = {
      xml2js,
      xml2json,
      js2xml,
      json2xml
    };
  }
});

// node_modules/asn1/lib/ber/errors.js
var require_errors2 = __commonJS({
  "node_modules/asn1/lib/ber/errors.js"(exports2, module2) {
    module2.exports = {
      newInvalidAsn1Error: function(msg) {
        var e = new Error();
        return e.name = "InvalidAsn1Error", e.message = msg || "", e;
      }
    };
  }
});

// node_modules/asn1/lib/ber/types.js
var require_types = __commonJS({
  "node_modules/asn1/lib/ber/types.js"(exports2, module2) {
    module2.exports = {
      EOC: 0,
      Boolean: 1,
      Integer: 2,
      BitString: 3,
      OctetString: 4,
      Null: 5,
      OID: 6,
      ObjectDescriptor: 7,
      External: 8,
      Real: 9,
      // float
      Enumeration: 10,
      PDV: 11,
      Utf8String: 12,
      RelativeOID: 13,
      Sequence: 16,
      Set: 17,
      NumericString: 18,
      PrintableString: 19,
      T61String: 20,
      VideotexString: 21,
      IA5String: 22,
      UTCTime: 23,
      GeneralizedTime: 24,
      GraphicString: 25,
      VisibleString: 26,
      GeneralString: 28,
      UniversalString: 29,
      CharacterString: 30,
      BMPString: 31,
      Constructor: 32,
      Context: 128
    };
  }
});

// node_modules/safer-buffer/safer.js
var require_safer = __commonJS({
  "node_modules/safer-buffer/safer.js"(exports2, module2) {
    "use strict";
    var buffer = require("buffer"), Buffer3 = buffer.Buffer, safer = {}, key;
    for (key in buffer)
      buffer.hasOwnProperty(key) && (key === "SlowBuffer" || key === "Buffer" || (safer[key] = buffer[key]));
    var Safer = safer.Buffer = {};
    for (key in Buffer3)
      Buffer3.hasOwnProperty(key) && (key === "allocUnsafe" || key === "allocUnsafeSlow" || (Safer[key] = Buffer3[key]));
    safer.Buffer.prototype = Buffer3.prototype;
    (!Safer.from || Safer.from === Uint8Array.from) && (Safer.from = function(value, encodingOrOffset, length) {
      if (typeof value == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
      if (value && typeof value.length > "u")
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      return Buffer3(value, encodingOrOffset, length);
    });
    Safer.alloc || (Safer.alloc = function(size, fill, encoding) {
      if (typeof size != "number")
        throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
      if (size < 0 || size >= 2 * (1 << 30))
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      var buf = Buffer3(size);
      return !fill || fill.length === 0 ? buf.fill(0) : typeof encoding == "string" ? buf.fill(fill, encoding) : buf.fill(fill), buf;
    });
    if (!safer.kStringMaxLength)
      try {
        safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
      } catch {
      }
    safer.constants || (safer.constants = {
      MAX_LENGTH: safer.kMaxLength
    }, safer.kStringMaxLength && (safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength));
    module2.exports = safer;
  }
});

// node_modules/asn1/lib/ber/reader.js
var require_reader = __commonJS({
  "node_modules/asn1/lib/ber/reader.js"(exports2, module2) {
    var assert3 = require("assert"), Buffer3 = require_safer().Buffer, ASN1 = require_types(), errors = require_errors2(), newInvalidAsn1Error = errors.newInvalidAsn1Error;
    function Reader(data) {
      if (!data || !Buffer3.isBuffer(data))
        throw new TypeError("data must be a node Buffer");
      this._buf = data, this._size = data.length, this._len = 0, this._offset = 0;
    }
    Object.defineProperty(Reader.prototype, "length", {
      enumerable: !0,
      get: function() {
        return this._len;
      }
    });
    Object.defineProperty(Reader.prototype, "offset", {
      enumerable: !0,
      get: function() {
        return this._offset;
      }
    });
    Object.defineProperty(Reader.prototype, "remain", {
      get: function() {
        return this._size - this._offset;
      }
    });
    Object.defineProperty(Reader.prototype, "buffer", {
      get: function() {
        return this._buf.slice(this._offset);
      }
    });
    Reader.prototype.readByte = function(peek) {
      if (this._size - this._offset < 1)
        return null;
      var b = this._buf[this._offset] & 255;
      return peek || (this._offset += 1), b;
    };
    Reader.prototype.peek = function() {
      return this.readByte(!0);
    };
    Reader.prototype.readLength = function(offset) {
      if (offset === void 0 && (offset = this._offset), offset >= this._size)
        return null;
      var lenB = this._buf[offset++] & 255;
      if (lenB === null)
        return null;
      if ((lenB & 128) === 128) {
        if (lenB &= 127, lenB === 0)
          throw newInvalidAsn1Error("Indefinite length not supported");
        if (lenB > 4)
          throw newInvalidAsn1Error("encoding too long");
        if (this._size - offset < lenB)
          return null;
        this._len = 0;
        for (var i = 0; i < lenB; i++)
          this._len = (this._len << 8) + (this._buf[offset++] & 255);
      } else
        this._len = lenB;
      return offset;
    };
    Reader.prototype.readSequence = function(tag) {
      var seq = this.peek();
      if (seq === null)
        return null;
      if (tag !== void 0 && tag !== seq)
        throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + seq.toString(16));
      var o = this.readLength(this._offset + 1);
      return o === null ? null : (this._offset = o, seq);
    };
    Reader.prototype.readInt = function() {
      return this._readTag(ASN1.Integer);
    };
    Reader.prototype.readBoolean = function() {
      return this._readTag(ASN1.Boolean) !== 0;
    };
    Reader.prototype.readEnumeration = function() {
      return this._readTag(ASN1.Enumeration);
    };
    Reader.prototype.readString = function(tag, retbuf) {
      tag || (tag = ASN1.OctetString);
      var b = this.peek();
      if (b === null)
        return null;
      if (b !== tag)
        throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + b.toString(16));
      var o = this.readLength(this._offset + 1);
      if (o === null || this.length > this._size - o)
        return null;
      if (this._offset = o, this.length === 0)
        return retbuf ? Buffer3.alloc(0) : "";
      var str = this._buf.slice(this._offset, this._offset + this.length);
      return this._offset += this.length, retbuf ? str : str.toString("utf8");
    };
    Reader.prototype.readOID = function(tag) {
      tag || (tag = ASN1.OID);
      var b = this.readString(tag, !0);
      if (b === null)
        return null;
      for (var values = [], value = 0, i = 0; i < b.length; i++) {
        var byte = b[i] & 255;
        value <<= 7, value += byte & 127, byte & 128 || (values.push(value), value = 0);
      }
      return value = values.shift(), values.unshift(value % 40), values.unshift(value / 40 >> 0), values.join(".");
    };
    Reader.prototype._readTag = function(tag) {
      assert3.ok(tag !== void 0);
      var b = this.peek();
      if (b === null)
        return null;
      if (b !== tag)
        throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + b.toString(16));
      var o = this.readLength(this._offset + 1);
      if (o === null)
        return null;
      if (this.length > 4)
        throw newInvalidAsn1Error("Integer too long: " + this.length);
      if (this.length > this._size - o)
        return null;
      this._offset = o;
      for (var fb = this._buf[this._offset], value = 0, i = 0; i < this.length; i++)
        value <<= 8, value |= this._buf[this._offset++] & 255;
      return (fb & 128) === 128 && i !== 4 && (value -= 1 << i * 8), value >> 0;
    };
    module2.exports = Reader;
  }
});

// node_modules/asn1/lib/ber/writer.js
var require_writer = __commonJS({
  "node_modules/asn1/lib/ber/writer.js"(exports2, module2) {
    var assert3 = require("assert"), Buffer3 = require_safer().Buffer, ASN1 = require_types(), errors = require_errors2(), newInvalidAsn1Error = errors.newInvalidAsn1Error, DEFAULT_OPTS = {
      size: 1024,
      growthFactor: 8
    };
    function merge2(from, to) {
      assert3.ok(from), assert3.equal(typeof from, "object"), assert3.ok(to), assert3.equal(typeof to, "object");
      var keys = Object.getOwnPropertyNames(from);
      return keys.forEach(function(key) {
        if (!to[key]) {
          var value = Object.getOwnPropertyDescriptor(from, key);
          Object.defineProperty(to, key, value);
        }
      }), to;
    }
    function Writer(options) {
      options = merge2(DEFAULT_OPTS, options || {}), this._buf = Buffer3.alloc(options.size || 1024), this._size = this._buf.length, this._offset = 0, this._options = options, this._seq = [];
    }
    Object.defineProperty(Writer.prototype, "buffer", {
      get: function() {
        if (this._seq.length)
          throw newInvalidAsn1Error(this._seq.length + " unended sequence(s)");
        return this._buf.slice(0, this._offset);
      }
    });
    Writer.prototype.writeByte = function(b) {
      if (typeof b != "number")
        throw new TypeError("argument must be a Number");
      this._ensure(1), this._buf[this._offset++] = b;
    };
    Writer.prototype.writeInt = function(i, tag) {
      if (typeof i != "number")
        throw new TypeError("argument must be a Number");
      typeof tag != "number" && (tag = ASN1.Integer);
      for (var sz = 4; (!(i & 4286578688) || (i & 4286578688) === -8388608) && sz > 1; )
        sz--, i <<= 8;
      if (sz > 4)
        throw newInvalidAsn1Error("BER ints cannot be > 0xffffffff");
      for (this._ensure(2 + sz), this._buf[this._offset++] = tag, this._buf[this._offset++] = sz; sz-- > 0; )
        this._buf[this._offset++] = (i & 4278190080) >>> 24, i <<= 8;
    };
    Writer.prototype.writeNull = function() {
      this.writeByte(ASN1.Null), this.writeByte(0);
    };
    Writer.prototype.writeEnumeration = function(i, tag) {
      if (typeof i != "number")
        throw new TypeError("argument must be a Number");
      return typeof tag != "number" && (tag = ASN1.Enumeration), this.writeInt(i, tag);
    };
    Writer.prototype.writeBoolean = function(b, tag) {
      if (typeof b != "boolean")
        throw new TypeError("argument must be a Boolean");
      typeof tag != "number" && (tag = ASN1.Boolean), this._ensure(3), this._buf[this._offset++] = tag, this._buf[this._offset++] = 1, this._buf[this._offset++] = b ? 255 : 0;
    };
    Writer.prototype.writeString = function(s, tag) {
      if (typeof s != "string")
        throw new TypeError("argument must be a string (was: " + typeof s + ")");
      typeof tag != "number" && (tag = ASN1.OctetString);
      var len = Buffer3.byteLength(s);
      this.writeByte(tag), this.writeLength(len), len && (this._ensure(len), this._buf.write(s, this._offset), this._offset += len);
    };
    Writer.prototype.writeBuffer = function(buf, tag) {
      if (typeof tag != "number")
        throw new TypeError("tag must be a number");
      if (!Buffer3.isBuffer(buf))
        throw new TypeError("argument must be a buffer");
      this.writeByte(tag), this.writeLength(buf.length), this._ensure(buf.length), buf.copy(this._buf, this._offset, 0, buf.length), this._offset += buf.length;
    };
    Writer.prototype.writeStringArray = function(strings) {
      if (!strings instanceof Array)
        throw new TypeError("argument must be an Array[String]");
      var self2 = this;
      strings.forEach(function(s) {
        self2.writeString(s);
      });
    };
    Writer.prototype.writeOID = function(s, tag) {
      if (typeof s != "string")
        throw new TypeError("argument must be a string");
      if (typeof tag != "number" && (tag = ASN1.OID), !/^([0-9]+\.){3,}[0-9]+$/.test(s))
        throw new Error("argument is not a valid OID string");
      function encodeOctet(bytes2, octet) {
        octet < 128 ? bytes2.push(octet) : octet < 16384 ? (bytes2.push(octet >>> 7 | 128), bytes2.push(octet & 127)) : octet < 2097152 ? (bytes2.push(octet >>> 14 | 128), bytes2.push((octet >>> 7 | 128) & 255), bytes2.push(octet & 127)) : octet < 268435456 ? (bytes2.push(octet >>> 21 | 128), bytes2.push((octet >>> 14 | 128) & 255), bytes2.push((octet >>> 7 | 128) & 255), bytes2.push(octet & 127)) : (bytes2.push((octet >>> 28 | 128) & 255), bytes2.push((octet >>> 21 | 128) & 255), bytes2.push((octet >>> 14 | 128) & 255), bytes2.push((octet >>> 7 | 128) & 255), bytes2.push(octet & 127));
      }
      var tmp = s.split("."), bytes = [];
      bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10)), tmp.slice(2).forEach(function(b) {
        encodeOctet(bytes, parseInt(b, 10));
      });
      var self2 = this;
      this._ensure(2 + bytes.length), this.writeByte(tag), this.writeLength(bytes.length), bytes.forEach(function(b) {
        self2.writeByte(b);
      });
    };
    Writer.prototype.writeLength = function(len) {
      if (typeof len != "number")
        throw new TypeError("argument must be a Number");
      if (this._ensure(4), len <= 127)
        this._buf[this._offset++] = len;
      else if (len <= 255)
        this._buf[this._offset++] = 129, this._buf[this._offset++] = len;
      else if (len <= 65535)
        this._buf[this._offset++] = 130, this._buf[this._offset++] = len >> 8, this._buf[this._offset++] = len;
      else if (len <= 16777215)
        this._buf[this._offset++] = 131, this._buf[this._offset++] = len >> 16, this._buf[this._offset++] = len >> 8, this._buf[this._offset++] = len;
      else
        throw newInvalidAsn1Error("Length too long (> 4 bytes)");
    };
    Writer.prototype.startSequence = function(tag) {
      typeof tag != "number" && (tag = ASN1.Sequence | ASN1.Constructor), this.writeByte(tag), this._seq.push(this._offset), this._ensure(3), this._offset += 3;
    };
    Writer.prototype.endSequence = function() {
      var seq = this._seq.pop(), start = seq + 3, len = this._offset - start;
      if (len <= 127)
        this._shift(start, len, -2), this._buf[seq] = len;
      else if (len <= 255)
        this._shift(start, len, -1), this._buf[seq] = 129, this._buf[seq + 1] = len;
      else if (len <= 65535)
        this._buf[seq] = 130, this._buf[seq + 1] = len >> 8, this._buf[seq + 2] = len;
      else if (len <= 16777215)
        this._shift(start, len, 1), this._buf[seq] = 131, this._buf[seq + 1] = len >> 16, this._buf[seq + 2] = len >> 8, this._buf[seq + 3] = len;
      else
        throw newInvalidAsn1Error("Sequence too long");
    };
    Writer.prototype._shift = function(start, len, shift) {
      assert3.ok(start !== void 0), assert3.ok(len !== void 0), assert3.ok(shift), this._buf.copy(this._buf, start + shift, start, start + len), this._offset += shift;
    };
    Writer.prototype._ensure = function(len) {
      if (assert3.ok(len), this._size - this._offset < len) {
        var sz = this._size * this._options.growthFactor;
        sz - this._offset < len && (sz += len);
        var buf = Buffer3.alloc(sz);
        this._buf.copy(buf, 0, 0, this._offset), this._buf = buf, this._size = sz;
      }
    };
    module2.exports = Writer;
  }
});

// node_modules/asn1/lib/ber/index.js
var require_ber = __commonJS({
  "node_modules/asn1/lib/ber/index.js"(exports2, module2) {
    var errors = require_errors2(), types = require_types(), Reader = require_reader(), Writer = require_writer();
    module2.exports = {
      Reader,
      Writer
    };
    for (t in types)
      types.hasOwnProperty(t) && (module2.exports[t] = types[t]);
    var t;
    for (e in errors)
      errors.hasOwnProperty(e) && (module2.exports[e] = errors[e]);
    var e;
  }
});

// node_modules/asn1/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/asn1/lib/index.js"(exports2, module2) {
    var Ber = require_ber();
    module2.exports = {
      Ber,
      BerReader: Ber.Reader,
      BerWriter: Ber.Writer
    };
  }
});

// node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS({
  "node_modules/tweetnacl/nacl-fast.js"(exports2, module2) {
    (function(nacl) {
      "use strict";
      var gf = function(init) {
        var i, r = new Float64Array(16);
        if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
        return r;
      }, randombytes = function() {
        throw new Error("no PRNG");
      }, _0 = new Uint8Array(16), _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x, i, h, l) {
        x[i] = h >> 24 & 255, x[i + 1] = h >> 16 & 255, x[i + 2] = h >> 8 & 255, x[i + 3] = h & 255, x[i + 4] = l >> 24 & 255, x[i + 5] = l >> 16 & 255, x[i + 6] = l >> 8 & 255, x[i + 7] = l & 255;
      }
      function vn(x, xi, y, yi, n) {
        var i, d = 0;
        for (i = 0; i < n; i++) d |= x[xi + i] ^ y[yi + i];
        return (1 & d - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x, xi, y, yi) {
        return vn(x, xi, y, yi, 16);
      }
      function crypto_verify_32(x, xi, y, yi) {
        return vn(x, xi, y, yi, 32);
      }
      function core_salsa20(o, p, k, c) {
        for (var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24, x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u, i = 0; i < 20; i += 2)
          u = x0 + x12 | 0, x4 ^= u << 7 | u >>> 25, u = x4 + x0 | 0, x8 ^= u << 9 | u >>> 23, u = x8 + x4 | 0, x12 ^= u << 13 | u >>> 19, u = x12 + x8 | 0, x0 ^= u << 18 | u >>> 14, u = x5 + x1 | 0, x9 ^= u << 7 | u >>> 25, u = x9 + x5 | 0, x13 ^= u << 9 | u >>> 23, u = x13 + x9 | 0, x1 ^= u << 13 | u >>> 19, u = x1 + x13 | 0, x5 ^= u << 18 | u >>> 14, u = x10 + x6 | 0, x14 ^= u << 7 | u >>> 25, u = x14 + x10 | 0, x2 ^= u << 9 | u >>> 23, u = x2 + x14 | 0, x6 ^= u << 13 | u >>> 19, u = x6 + x2 | 0, x10 ^= u << 18 | u >>> 14, u = x15 + x11 | 0, x3 ^= u << 7 | u >>> 25, u = x3 + x15 | 0, x7 ^= u << 9 | u >>> 23, u = x7 + x3 | 0, x11 ^= u << 13 | u >>> 19, u = x11 + x7 | 0, x15 ^= u << 18 | u >>> 14, u = x0 + x3 | 0, x1 ^= u << 7 | u >>> 25, u = x1 + x0 | 0, x2 ^= u << 9 | u >>> 23, u = x2 + x1 | 0, x3 ^= u << 13 | u >>> 19, u = x3 + x2 | 0, x0 ^= u << 18 | u >>> 14, u = x5 + x4 | 0, x6 ^= u << 7 | u >>> 25, u = x6 + x5 | 0, x7 ^= u << 9 | u >>> 23, u = x7 + x6 | 0, x4 ^= u << 13 | u >>> 19, u = x4 + x7 | 0, x5 ^= u << 18 | u >>> 14, u = x10 + x9 | 0, x11 ^= u << 7 | u >>> 25, u = x11 + x10 | 0, x8 ^= u << 9 | u >>> 23, u = x8 + x11 | 0, x9 ^= u << 13 | u >>> 19, u = x9 + x8 | 0, x10 ^= u << 18 | u >>> 14, u = x15 + x14 | 0, x12 ^= u << 7 | u >>> 25, u = x12 + x15 | 0, x13 ^= u << 9 | u >>> 23, u = x13 + x12 | 0, x14 ^= u << 13 | u >>> 19, u = x14 + x13 | 0, x15 ^= u << 18 | u >>> 14;
        x0 = x0 + j0 | 0, x1 = x1 + j1 | 0, x2 = x2 + j2 | 0, x3 = x3 + j3 | 0, x4 = x4 + j4 | 0, x5 = x5 + j5 | 0, x6 = x6 + j6 | 0, x7 = x7 + j7 | 0, x8 = x8 + j8 | 0, x9 = x9 + j9 | 0, x10 = x10 + j10 | 0, x11 = x11 + j11 | 0, x12 = x12 + j12 | 0, x13 = x13 + j13 | 0, x14 = x14 + j14 | 0, x15 = x15 + j15 | 0, o[0] = x0 >>> 0 & 255, o[1] = x0 >>> 8 & 255, o[2] = x0 >>> 16 & 255, o[3] = x0 >>> 24 & 255, o[4] = x1 >>> 0 & 255, o[5] = x1 >>> 8 & 255, o[6] = x1 >>> 16 & 255, o[7] = x1 >>> 24 & 255, o[8] = x2 >>> 0 & 255, o[9] = x2 >>> 8 & 255, o[10] = x2 >>> 16 & 255, o[11] = x2 >>> 24 & 255, o[12] = x3 >>> 0 & 255, o[13] = x3 >>> 8 & 255, o[14] = x3 >>> 16 & 255, o[15] = x3 >>> 24 & 255, o[16] = x4 >>> 0 & 255, o[17] = x4 >>> 8 & 255, o[18] = x4 >>> 16 & 255, o[19] = x4 >>> 24 & 255, o[20] = x5 >>> 0 & 255, o[21] = x5 >>> 8 & 255, o[22] = x5 >>> 16 & 255, o[23] = x5 >>> 24 & 255, o[24] = x6 >>> 0 & 255, o[25] = x6 >>> 8 & 255, o[26] = x6 >>> 16 & 255, o[27] = x6 >>> 24 & 255, o[28] = x7 >>> 0 & 255, o[29] = x7 >>> 8 & 255, o[30] = x7 >>> 16 & 255, o[31] = x7 >>> 24 & 255, o[32] = x8 >>> 0 & 255, o[33] = x8 >>> 8 & 255, o[34] = x8 >>> 16 & 255, o[35] = x8 >>> 24 & 255, o[36] = x9 >>> 0 & 255, o[37] = x9 >>> 8 & 255, o[38] = x9 >>> 16 & 255, o[39] = x9 >>> 24 & 255, o[40] = x10 >>> 0 & 255, o[41] = x10 >>> 8 & 255, o[42] = x10 >>> 16 & 255, o[43] = x10 >>> 24 & 255, o[44] = x11 >>> 0 & 255, o[45] = x11 >>> 8 & 255, o[46] = x11 >>> 16 & 255, o[47] = x11 >>> 24 & 255, o[48] = x12 >>> 0 & 255, o[49] = x12 >>> 8 & 255, o[50] = x12 >>> 16 & 255, o[51] = x12 >>> 24 & 255, o[52] = x13 >>> 0 & 255, o[53] = x13 >>> 8 & 255, o[54] = x13 >>> 16 & 255, o[55] = x13 >>> 24 & 255, o[56] = x14 >>> 0 & 255, o[57] = x14 >>> 8 & 255, o[58] = x14 >>> 16 & 255, o[59] = x14 >>> 24 & 255, o[60] = x15 >>> 0 & 255, o[61] = x15 >>> 8 & 255, o[62] = x15 >>> 16 & 255, o[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o, p, k, c) {
        for (var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24, x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u, i = 0; i < 20; i += 2)
          u = x0 + x12 | 0, x4 ^= u << 7 | u >>> 25, u = x4 + x0 | 0, x8 ^= u << 9 | u >>> 23, u = x8 + x4 | 0, x12 ^= u << 13 | u >>> 19, u = x12 + x8 | 0, x0 ^= u << 18 | u >>> 14, u = x5 + x1 | 0, x9 ^= u << 7 | u >>> 25, u = x9 + x5 | 0, x13 ^= u << 9 | u >>> 23, u = x13 + x9 | 0, x1 ^= u << 13 | u >>> 19, u = x1 + x13 | 0, x5 ^= u << 18 | u >>> 14, u = x10 + x6 | 0, x14 ^= u << 7 | u >>> 25, u = x14 + x10 | 0, x2 ^= u << 9 | u >>> 23, u = x2 + x14 | 0, x6 ^= u << 13 | u >>> 19, u = x6 + x2 | 0, x10 ^= u << 18 | u >>> 14, u = x15 + x11 | 0, x3 ^= u << 7 | u >>> 25, u = x3 + x15 | 0, x7 ^= u << 9 | u >>> 23, u = x7 + x3 | 0, x11 ^= u << 13 | u >>> 19, u = x11 + x7 | 0, x15 ^= u << 18 | u >>> 14, u = x0 + x3 | 0, x1 ^= u << 7 | u >>> 25, u = x1 + x0 | 0, x2 ^= u << 9 | u >>> 23, u = x2 + x1 | 0, x3 ^= u << 13 | u >>> 19, u = x3 + x2 | 0, x0 ^= u << 18 | u >>> 14, u = x5 + x4 | 0, x6 ^= u << 7 | u >>> 25, u = x6 + x5 | 0, x7 ^= u << 9 | u >>> 23, u = x7 + x6 | 0, x4 ^= u << 13 | u >>> 19, u = x4 + x7 | 0, x5 ^= u << 18 | u >>> 14, u = x10 + x9 | 0, x11 ^= u << 7 | u >>> 25, u = x11 + x10 | 0, x8 ^= u << 9 | u >>> 23, u = x8 + x11 | 0, x9 ^= u << 13 | u >>> 19, u = x9 + x8 | 0, x10 ^= u << 18 | u >>> 14, u = x15 + x14 | 0, x12 ^= u << 7 | u >>> 25, u = x12 + x15 | 0, x13 ^= u << 9 | u >>> 23, u = x13 + x12 | 0, x14 ^= u << 13 | u >>> 19, u = x14 + x13 | 0, x15 ^= u << 18 | u >>> 14;
        o[0] = x0 >>> 0 & 255, o[1] = x0 >>> 8 & 255, o[2] = x0 >>> 16 & 255, o[3] = x0 >>> 24 & 255, o[4] = x5 >>> 0 & 255, o[5] = x5 >>> 8 & 255, o[6] = x5 >>> 16 & 255, o[7] = x5 >>> 24 & 255, o[8] = x10 >>> 0 & 255, o[9] = x10 >>> 8 & 255, o[10] = x10 >>> 16 & 255, o[11] = x10 >>> 24 & 255, o[12] = x15 >>> 0 & 255, o[13] = x15 >>> 8 & 255, o[14] = x15 >>> 16 & 255, o[15] = x15 >>> 24 & 255, o[16] = x6 >>> 0 & 255, o[17] = x6 >>> 8 & 255, o[18] = x6 >>> 16 & 255, o[19] = x6 >>> 24 & 255, o[20] = x7 >>> 0 & 255, o[21] = x7 >>> 8 & 255, o[22] = x7 >>> 16 & 255, o[23] = x7 >>> 24 & 255, o[24] = x8 >>> 0 & 255, o[25] = x8 >>> 8 & 255, o[26] = x8 >>> 16 & 255, o[27] = x8 >>> 24 & 255, o[28] = x9 >>> 0 & 255, o[29] = x9 >>> 8 & 255, o[30] = x9 >>> 16 & 255, o[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k, c) {
        core_salsa20(out, inp, k, c);
      }
      function crypto_core_hsalsa20(out, inp, k, c) {
        core_hsalsa20(out, inp, k, c);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64), u, i;
        for (i = 0; i < 16; i++) z[i] = 0;
        for (i = 0; i < 8; i++) z[i] = n[i];
        for (; b >= 64; ) {
          for (crypto_core_salsa20(x, z, k, sigma), i = 0; i < 64; i++) c[cpos + i] = m[mpos + i] ^ x[i];
          for (u = 1, i = 8; i < 16; i++)
            u = u + (z[i] & 255) | 0, z[i] = u & 255, u >>>= 8;
          b -= 64, cpos += 64, mpos += 64;
        }
        if (b > 0)
          for (crypto_core_salsa20(x, z, k, sigma), i = 0; i < b; i++) c[cpos + i] = m[mpos + i] ^ x[i];
        return 0;
      }
      function crypto_stream_salsa20(c, cpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64), u, i;
        for (i = 0; i < 16; i++) z[i] = 0;
        for (i = 0; i < 8; i++) z[i] = n[i];
        for (; b >= 64; ) {
          for (crypto_core_salsa20(x, z, k, sigma), i = 0; i < 64; i++) c[cpos + i] = x[i];
          for (u = 1, i = 8; i < 16; i++)
            u = u + (z[i] & 255) | 0, z[i] = u & 255, u >>>= 8;
          b -= 64, cpos += 64;
        }
        if (b > 0)
          for (crypto_core_salsa20(x, z, k, sigma), i = 0; i < b; i++) c[cpos + i] = x[i];
        return 0;
      }
      function crypto_stream(c, cpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        for (var sn = new Uint8Array(8), i = 0; i < 8; i++) sn[i] = n[i + 16];
        return crypto_stream_salsa20(c, cpos, d, sn, s);
      }
      function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        for (var sn = new Uint8Array(8), i = 0; i < 8; i++) sn[i] = n[i + 16];
        return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
      }
      var poly1305 = function(key) {
        this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = key[0] & 255 | (key[1] & 255) << 8, this.r[0] = t0 & 8191, t1 = key[2] & 255 | (key[3] & 255) << 8, this.r[1] = (t0 >>> 13 | t1 << 3) & 8191, t2 = key[4] & 255 | (key[5] & 255) << 8, this.r[2] = (t1 >>> 10 | t2 << 6) & 7939, t3 = key[6] & 255 | (key[7] & 255) << 8, this.r[3] = (t2 >>> 7 | t3 << 9) & 8191, t4 = key[8] & 255 | (key[9] & 255) << 8, this.r[4] = (t3 >>> 4 | t4 << 12) & 255, this.r[5] = t4 >>> 1 & 8190, t5 = key[10] & 255 | (key[11] & 255) << 8, this.r[6] = (t4 >>> 14 | t5 << 2) & 8191, t6 = key[12] & 255 | (key[13] & 255) << 8, this.r[7] = (t5 >>> 11 | t6 << 5) & 8065, t7 = key[14] & 255 | (key[15] & 255) << 8, this.r[8] = (t6 >>> 8 | t7 << 8) & 8191, this.r[9] = t7 >>> 5 & 127, this.pad[0] = key[16] & 255 | (key[17] & 255) << 8, this.pad[1] = key[18] & 255 | (key[19] & 255) << 8, this.pad[2] = key[20] & 255 | (key[21] & 255) << 8, this.pad[3] = key[22] & 255 | (key[23] & 255) << 8, this.pad[4] = key[24] & 255 | (key[25] & 255) << 8, this.pad[5] = key[26] & 255 | (key[27] & 255) << 8, this.pad[6] = key[28] & 255 | (key[29] & 255) << 8, this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m, mpos, bytes) {
        for (var hibit = this.fin ? 0 : 2048, t0, t1, t2, t3, t4, t5, t6, t7, c, d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9], r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9]; bytes >= 16; )
          t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8, h0 += t0 & 8191, t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8, h1 += (t0 >>> 13 | t1 << 3) & 8191, t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8, h2 += (t1 >>> 10 | t2 << 6) & 8191, t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8, h3 += (t2 >>> 7 | t3 << 9) & 8191, t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8, h4 += (t3 >>> 4 | t4 << 12) & 8191, h5 += t4 >>> 1 & 8191, t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8, h6 += (t4 >>> 14 | t5 << 2) & 8191, t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8, h7 += (t5 >>> 11 | t6 << 5) & 8191, t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8, h8 += (t6 >>> 8 | t7 << 8) & 8191, h9 += t7 >>> 5 | hibit, c = 0, d0 = c, d0 += h0 * r0, d0 += h1 * (5 * r9), d0 += h2 * (5 * r8), d0 += h3 * (5 * r7), d0 += h4 * (5 * r6), c = d0 >>> 13, d0 &= 8191, d0 += h5 * (5 * r5), d0 += h6 * (5 * r4), d0 += h7 * (5 * r3), d0 += h8 * (5 * r2), d0 += h9 * (5 * r1), c += d0 >>> 13, d0 &= 8191, d1 = c, d1 += h0 * r1, d1 += h1 * r0, d1 += h2 * (5 * r9), d1 += h3 * (5 * r8), d1 += h4 * (5 * r7), c = d1 >>> 13, d1 &= 8191, d1 += h5 * (5 * r6), d1 += h6 * (5 * r5), d1 += h7 * (5 * r4), d1 += h8 * (5 * r3), d1 += h9 * (5 * r2), c += d1 >>> 13, d1 &= 8191, d2 = c, d2 += h0 * r2, d2 += h1 * r1, d2 += h2 * r0, d2 += h3 * (5 * r9), d2 += h4 * (5 * r8), c = d2 >>> 13, d2 &= 8191, d2 += h5 * (5 * r7), d2 += h6 * (5 * r6), d2 += h7 * (5 * r5), d2 += h8 * (5 * r4), d2 += h9 * (5 * r3), c += d2 >>> 13, d2 &= 8191, d3 = c, d3 += h0 * r3, d3 += h1 * r2, d3 += h2 * r1, d3 += h3 * r0, d3 += h4 * (5 * r9), c = d3 >>> 13, d3 &= 8191, d3 += h5 * (5 * r8), d3 += h6 * (5 * r7), d3 += h7 * (5 * r6), d3 += h8 * (5 * r5), d3 += h9 * (5 * r4), c += d3 >>> 13, d3 &= 8191, d4 = c, d4 += h0 * r4, d4 += h1 * r3, d4 += h2 * r2, d4 += h3 * r1, d4 += h4 * r0, c = d4 >>> 13, d4 &= 8191, d4 += h5 * (5 * r9), d4 += h6 * (5 * r8), d4 += h7 * (5 * r7), d4 += h8 * (5 * r6), d4 += h9 * (5 * r5), c += d4 >>> 13, d4 &= 8191, d5 = c, d5 += h0 * r5, d5 += h1 * r4, d5 += h2 * r3, d5 += h3 * r2, d5 += h4 * r1, c = d5 >>> 13, d5 &= 8191, d5 += h5 * r0, d5 += h6 * (5 * r9), d5 += h7 * (5 * r8), d5 += h8 * (5 * r7), d5 += h9 * (5 * r6), c += d5 >>> 13, d5 &= 8191, d6 = c, d6 += h0 * r6, d6 += h1 * r5, d6 += h2 * r4, d6 += h3 * r3, d6 += h4 * r2, c = d6 >>> 13, d6 &= 8191, d6 += h5 * r1, d6 += h6 * r0, d6 += h7 * (5 * r9), d6 += h8 * (5 * r8), d6 += h9 * (5 * r7), c += d6 >>> 13, d6 &= 8191, d7 = c, d7 += h0 * r7, d7 += h1 * r6, d7 += h2 * r5, d7 += h3 * r4, d7 += h4 * r3, c = d7 >>> 13, d7 &= 8191, d7 += h5 * r2, d7 += h6 * r1, d7 += h7 * r0, d7 += h8 * (5 * r9), d7 += h9 * (5 * r8), c += d7 >>> 13, d7 &= 8191, d8 = c, d8 += h0 * r8, d8 += h1 * r7, d8 += h2 * r6, d8 += h3 * r5, d8 += h4 * r4, c = d8 >>> 13, d8 &= 8191, d8 += h5 * r3, d8 += h6 * r2, d8 += h7 * r1, d8 += h8 * r0, d8 += h9 * (5 * r9), c += d8 >>> 13, d8 &= 8191, d9 = c, d9 += h0 * r9, d9 += h1 * r8, d9 += h2 * r7, d9 += h3 * r6, d9 += h4 * r5, c = d9 >>> 13, d9 &= 8191, d9 += h5 * r4, d9 += h6 * r3, d9 += h7 * r2, d9 += h8 * r1, d9 += h9 * r0, c += d9 >>> 13, d9 &= 8191, c = (c << 2) + c | 0, c = c + d0 | 0, d0 = c & 8191, c = c >>> 13, d1 += c, h0 = d0, h1 = d1, h2 = d2, h3 = d3, h4 = d4, h5 = d5, h6 = d6, h7 = d7, h8 = d8, h9 = d9, mpos += 16, bytes -= 16;
        this.h[0] = h0, this.h[1] = h1, this.h[2] = h2, this.h[3] = h3, this.h[4] = h4, this.h[5] = h5, this.h[6] = h6, this.h[7] = h7, this.h[8] = h8, this.h[9] = h9;
      }, poly1305.prototype.finish = function(mac, macpos) {
        var g = new Uint16Array(10), c, mask, f, i;
        if (this.leftover) {
          for (i = this.leftover, this.buffer[i++] = 1; i < 16; i++) this.buffer[i] = 0;
          this.fin = 1, this.blocks(this.buffer, 0, 16);
        }
        for (c = this.h[1] >>> 13, this.h[1] &= 8191, i = 2; i < 10; i++)
          this.h[i] += c, c = this.h[i] >>> 13, this.h[i] &= 8191;
        for (this.h[0] += c * 5, c = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += c, c = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += c, g[0] = this.h[0] + 5, c = g[0] >>> 13, g[0] &= 8191, i = 1; i < 10; i++)
          g[i] = this.h[i] + c, c = g[i] >>> 13, g[i] &= 8191;
        for (g[9] -= 8192, mask = (c ^ 1) - 1, i = 0; i < 10; i++) g[i] &= mask;
        for (mask = ~mask, i = 0; i < 10; i++) this.h[i] = this.h[i] & mask | g[i];
        for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535, this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535, this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535, this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535, this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535, this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535, this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535, this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535, f = this.h[0] + this.pad[0], this.h[0] = f & 65535, i = 1; i < 8; i++)
          f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0, this.h[i] = f & 65535;
        mac[macpos + 0] = this.h[0] >>> 0 & 255, mac[macpos + 1] = this.h[0] >>> 8 & 255, mac[macpos + 2] = this.h[1] >>> 0 & 255, mac[macpos + 3] = this.h[1] >>> 8 & 255, mac[macpos + 4] = this.h[2] >>> 0 & 255, mac[macpos + 5] = this.h[2] >>> 8 & 255, mac[macpos + 6] = this.h[3] >>> 0 & 255, mac[macpos + 7] = this.h[3] >>> 8 & 255, mac[macpos + 8] = this.h[4] >>> 0 & 255, mac[macpos + 9] = this.h[4] >>> 8 & 255, mac[macpos + 10] = this.h[5] >>> 0 & 255, mac[macpos + 11] = this.h[5] >>> 8 & 255, mac[macpos + 12] = this.h[6] >>> 0 & 255, mac[macpos + 13] = this.h[6] >>> 8 & 255, mac[macpos + 14] = this.h[7] >>> 0 & 255, mac[macpos + 15] = this.h[7] >>> 8 & 255;
      }, poly1305.prototype.update = function(m, mpos, bytes) {
        var i, want;
        if (this.leftover) {
          for (want = 16 - this.leftover, want > bytes && (want = bytes), i = 0; i < want; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          if (bytes -= want, mpos += want, this.leftover += want, this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16), this.leftover = 0;
        }
        if (bytes >= 16 && (want = bytes - bytes % 16, this.blocks(m, mpos, want), mpos += want, bytes -= want), bytes) {
          for (i = 0; i < bytes; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          this.leftover += bytes;
        }
      };
      function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
        var s = new poly1305(k);
        return s.update(m, mpos, n), s.finish(out, outpos), 0;
      }
      function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
        var x = new Uint8Array(16);
        return crypto_onetimeauth(x, 0, m, mpos, n, k), crypto_verify_16(h, hpos, x, 0);
      }
      function crypto_secretbox(c, m, d, n, k) {
        var i;
        if (d < 32) return -1;
        for (crypto_stream_xor(c, 0, m, 0, d, n, k), crypto_onetimeauth(c, 16, c, 32, d - 32, c), i = 0; i < 16; i++) c[i] = 0;
        return 0;
      }
      function crypto_secretbox_open(m, c, d, n, k) {
        var i, x = new Uint8Array(32);
        if (d < 32 || (crypto_stream(x, 0, 32, n, k), crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0)) return -1;
        for (crypto_stream_xor(m, 0, c, 0, d, n, k), i = 0; i < 32; i++) m[i] = 0;
        return 0;
      }
      function set25519(r, a) {
        var i;
        for (i = 0; i < 16; i++) r[i] = a[i] | 0;
      }
      function car25519(o) {
        var i, v, c = 1;
        for (i = 0; i < 16; i++)
          v = o[i] + c + 65535, c = Math.floor(v / 65536), o[i] = v - c * 65536;
        o[0] += c - 1 + 37 * (c - 1);
      }
      function sel25519(p, q, b) {
        for (var t, c = ~(b - 1), i = 0; i < 16; i++)
          t = c & (p[i] ^ q[i]), p[i] ^= t, q[i] ^= t;
      }
      function pack25519(o, n) {
        var i, j, b, m = gf(), t = gf();
        for (i = 0; i < 16; i++) t[i] = n[i];
        for (car25519(t), car25519(t), car25519(t), j = 0; j < 2; j++) {
          for (m[0] = t[0] - 65517, i = 1; i < 15; i++)
            m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1), m[i - 1] &= 65535;
          m[15] = t[15] - 32767 - (m[14] >> 16 & 1), b = m[15] >> 16 & 1, m[14] &= 65535, sel25519(t, m, 1 - b);
        }
        for (i = 0; i < 16; i++)
          o[2 * i] = t[i] & 255, o[2 * i + 1] = t[i] >> 8;
      }
      function neq25519(a, b) {
        var c = new Uint8Array(32), d = new Uint8Array(32);
        return pack25519(c, a), pack25519(d, b), crypto_verify_32(c, 0, d, 0);
      }
      function par25519(a) {
        var d = new Uint8Array(32);
        return pack25519(d, a), d[0] & 1;
      }
      function unpack25519(o, n) {
        var i;
        for (i = 0; i < 16; i++) o[i] = n[2 * i] + (n[2 * i + 1] << 8);
        o[15] &= 32767;
      }
      function A(o, a, b) {
        for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
      }
      function Z(o, a, b) {
        for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
      }
      function M(o, a, b) {
        var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
        v = a[0], t0 += v * b0, t1 += v * b1, t2 += v * b2, t3 += v * b3, t4 += v * b4, t5 += v * b5, t6 += v * b6, t7 += v * b7, t8 += v * b8, t9 += v * b9, t10 += v * b10, t11 += v * b11, t12 += v * b12, t13 += v * b13, t14 += v * b14, t15 += v * b15, v = a[1], t1 += v * b0, t2 += v * b1, t3 += v * b2, t4 += v * b3, t5 += v * b4, t6 += v * b5, t7 += v * b6, t8 += v * b7, t9 += v * b8, t10 += v * b9, t11 += v * b10, t12 += v * b11, t13 += v * b12, t14 += v * b13, t15 += v * b14, t16 += v * b15, v = a[2], t2 += v * b0, t3 += v * b1, t4 += v * b2, t5 += v * b3, t6 += v * b4, t7 += v * b5, t8 += v * b6, t9 += v * b7, t10 += v * b8, t11 += v * b9, t12 += v * b10, t13 += v * b11, t14 += v * b12, t15 += v * b13, t16 += v * b14, t17 += v * b15, v = a[3], t3 += v * b0, t4 += v * b1, t5 += v * b2, t6 += v * b3, t7 += v * b4, t8 += v * b5, t9 += v * b6, t10 += v * b7, t11 += v * b8, t12 += v * b9, t13 += v * b10, t14 += v * b11, t15 += v * b12, t16 += v * b13, t17 += v * b14, t18 += v * b15, v = a[4], t4 += v * b0, t5 += v * b1, t6 += v * b2, t7 += v * b3, t8 += v * b4, t9 += v * b5, t10 += v * b6, t11 += v * b7, t12 += v * b8, t13 += v * b9, t14 += v * b10, t15 += v * b11, t16 += v * b12, t17 += v * b13, t18 += v * b14, t19 += v * b15, v = a[5], t5 += v * b0, t6 += v * b1, t7 += v * b2, t8 += v * b3, t9 += v * b4, t10 += v * b5, t11 += v * b6, t12 += v * b7, t13 += v * b8, t14 += v * b9, t15 += v * b10, t16 += v * b11, t17 += v * b12, t18 += v * b13, t19 += v * b14, t20 += v * b15, v = a[6], t6 += v * b0, t7 += v * b1, t8 += v * b2, t9 += v * b3, t10 += v * b4, t11 += v * b5, t12 += v * b6, t13 += v * b7, t14 += v * b8, t15 += v * b9, t16 += v * b10, t17 += v * b11, t18 += v * b12, t19 += v * b13, t20 += v * b14, t21 += v * b15, v = a[7], t7 += v * b0, t8 += v * b1, t9 += v * b2, t10 += v * b3, t11 += v * b4, t12 += v * b5, t13 += v * b6, t14 += v * b7, t15 += v * b8, t16 += v * b9, t17 += v * b10, t18 += v * b11, t19 += v * b12, t20 += v * b13, t21 += v * b14, t22 += v * b15, v = a[8], t8 += v * b0, t9 += v * b1, t10 += v * b2, t11 += v * b3, t12 += v * b4, t13 += v * b5, t14 += v * b6, t15 += v * b7, t16 += v * b8, t17 += v * b9, t18 += v * b10, t19 += v * b11, t20 += v * b12, t21 += v * b13, t22 += v * b14, t23 += v * b15, v = a[9], t9 += v * b0, t10 += v * b1, t11 += v * b2, t12 += v * b3, t13 += v * b4, t14 += v * b5, t15 += v * b6, t16 += v * b7, t17 += v * b8, t18 += v * b9, t19 += v * b10, t20 += v * b11, t21 += v * b12, t22 += v * b13, t23 += v * b14, t24 += v * b15, v = a[10], t10 += v * b0, t11 += v * b1, t12 += v * b2, t13 += v * b3, t14 += v * b4, t15 += v * b5, t16 += v * b6, t17 += v * b7, t18 += v * b8, t19 += v * b9, t20 += v * b10, t21 += v * b11, t22 += v * b12, t23 += v * b13, t24 += v * b14, t25 += v * b15, v = a[11], t11 += v * b0, t12 += v * b1, t13 += v * b2, t14 += v * b3, t15 += v * b4, t16 += v * b5, t17 += v * b6, t18 += v * b7, t19 += v * b8, t20 += v * b9, t21 += v * b10, t22 += v * b11, t23 += v * b12, t24 += v * b13, t25 += v * b14, t26 += v * b15, v = a[12], t12 += v * b0, t13 += v * b1, t14 += v * b2, t15 += v * b3, t16 += v * b4, t17 += v * b5, t18 += v * b6, t19 += v * b7, t20 += v * b8, t21 += v * b9, t22 += v * b10, t23 += v * b11, t24 += v * b12, t25 += v * b13, t26 += v * b14, t27 += v * b15, v = a[13], t13 += v * b0, t14 += v * b1, t15 += v * b2, t16 += v * b3, t17 += v * b4, t18 += v * b5, t19 += v * b6, t20 += v * b7, t21 += v * b8, t22 += v * b9, t23 += v * b10, t24 += v * b11, t25 += v * b12, t26 += v * b13, t27 += v * b14, t28 += v * b15, v = a[14], t14 += v * b0, t15 += v * b1, t16 += v * b2, t17 += v * b3, t18 += v * b4, t19 += v * b5, t20 += v * b6, t21 += v * b7, t22 += v * b8, t23 += v * b9, t24 += v * b10, t25 += v * b11, t26 += v * b12, t27 += v * b13, t28 += v * b14, t29 += v * b15, v = a[15], t15 += v * b0, t16 += v * b1, t17 += v * b2, t18 += v * b3, t19 += v * b4, t20 += v * b5, t21 += v * b6, t22 += v * b7, t23 += v * b8, t24 += v * b9, t25 += v * b10, t26 += v * b11, t27 += v * b12, t28 += v * b13, t29 += v * b14, t30 += v * b15, t0 += 38 * t16, t1 += 38 * t17, t2 += 38 * t18, t3 += 38 * t19, t4 += 38 * t20, t5 += 38 * t21, t6 += 38 * t22, t7 += 38 * t23, t8 += 38 * t24, t9 += 38 * t25, t10 += 38 * t26, t11 += 38 * t27, t12 += 38 * t28, t13 += 38 * t29, t14 += 38 * t30, c = 1, v = t0 + c + 65535, c = Math.floor(v / 65536), t0 = v - c * 65536, v = t1 + c + 65535, c = Math.floor(v / 65536), t1 = v - c * 65536, v = t2 + c + 65535, c = Math.floor(v / 65536), t2 = v - c * 65536, v = t3 + c + 65535, c = Math.floor(v / 65536), t3 = v - c * 65536, v = t4 + c + 65535, c = Math.floor(v / 65536), t4 = v - c * 65536, v = t5 + c + 65535, c = Math.floor(v / 65536), t5 = v - c * 65536, v = t6 + c + 65535, c = Math.floor(v / 65536), t6 = v - c * 65536, v = t7 + c + 65535, c = Math.floor(v / 65536), t7 = v - c * 65536, v = t8 + c + 65535, c = Math.floor(v / 65536), t8 = v - c * 65536, v = t9 + c + 65535, c = Math.floor(v / 65536), t9 = v - c * 65536, v = t10 + c + 65535, c = Math.floor(v / 65536), t10 = v - c * 65536, v = t11 + c + 65535, c = Math.floor(v / 65536), t11 = v - c * 65536, v = t12 + c + 65535, c = Math.floor(v / 65536), t12 = v - c * 65536, v = t13 + c + 65535, c = Math.floor(v / 65536), t13 = v - c * 65536, v = t14 + c + 65535, c = Math.floor(v / 65536), t14 = v - c * 65536, v = t15 + c + 65535, c = Math.floor(v / 65536), t15 = v - c * 65536, t0 += c - 1 + 37 * (c - 1), c = 1, v = t0 + c + 65535, c = Math.floor(v / 65536), t0 = v - c * 65536, v = t1 + c + 65535, c = Math.floor(v / 65536), t1 = v - c * 65536, v = t2 + c + 65535, c = Math.floor(v / 65536), t2 = v - c * 65536, v = t3 + c + 65535, c = Math.floor(v / 65536), t3 = v - c * 65536, v = t4 + c + 65535, c = Math.floor(v / 65536), t4 = v - c * 65536, v = t5 + c + 65535, c = Math.floor(v / 65536), t5 = v - c * 65536, v = t6 + c + 65535, c = Math.floor(v / 65536), t6 = v - c * 65536, v = t7 + c + 65535, c = Math.floor(v / 65536), t7 = v - c * 65536, v = t8 + c + 65535, c = Math.floor(v / 65536), t8 = v - c * 65536, v = t9 + c + 65535, c = Math.floor(v / 65536), t9 = v - c * 65536, v = t10 + c + 65535, c = Math.floor(v / 65536), t10 = v - c * 65536, v = t11 + c + 65535, c = Math.floor(v / 65536), t11 = v - c * 65536, v = t12 + c + 65535, c = Math.floor(v / 65536), t12 = v - c * 65536, v = t13 + c + 65535, c = Math.floor(v / 65536), t13 = v - c * 65536, v = t14 + c + 65535, c = Math.floor(v / 65536), t14 = v - c * 65536, v = t15 + c + 65535, c = Math.floor(v / 65536), t15 = v - c * 65536, t0 += c - 1 + 37 * (c - 1), o[0] = t0, o[1] = t1, o[2] = t2, o[3] = t3, o[4] = t4, o[5] = t5, o[6] = t6, o[7] = t7, o[8] = t8, o[9] = t9, o[10] = t10, o[11] = t11, o[12] = t12, o[13] = t13, o[14] = t14, o[15] = t15;
      }
      function S(o, a) {
        M(o, a, a);
      }
      function inv25519(o, i) {
        var c = gf(), a;
        for (a = 0; a < 16; a++) c[a] = i[a];
        for (a = 253; a >= 0; a--)
          S(c, c), a !== 2 && a !== 4 && M(c, c, i);
        for (a = 0; a < 16; a++) o[a] = c[a];
      }
      function pow2523(o, i) {
        var c = gf(), a;
        for (a = 0; a < 16; a++) c[a] = i[a];
        for (a = 250; a >= 0; a--)
          S(c, c), a !== 1 && M(c, c, i);
        for (a = 0; a < 16; a++) o[a] = c[a];
      }
      function crypto_scalarmult(q, n, p) {
        var z = new Uint8Array(32), x = new Float64Array(80), r, i, a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
        for (i = 0; i < 31; i++) z[i] = n[i];
        for (z[31] = n[31] & 127 | 64, z[0] &= 248, unpack25519(x, p), i = 0; i < 16; i++)
          b[i] = x[i], d[i] = a[i] = c[i] = 0;
        for (a[0] = d[0] = 1, i = 254; i >= 0; --i)
          r = z[i >>> 3] >>> (i & 7) & 1, sel25519(a, b, r), sel25519(c, d, r), A(e, a, c), Z(a, a, c), A(c, b, d), Z(b, b, d), S(d, e), S(f, a), M(a, c, a), M(c, b, e), A(e, a, c), Z(a, a, c), S(b, a), Z(c, d, f), M(a, c, _121665), A(a, a, d), M(c, c, a), M(a, d, f), M(d, b, x), S(b, e), sel25519(a, b, r), sel25519(c, d, r);
        for (i = 0; i < 16; i++)
          x[i + 16] = a[i], x[i + 32] = c[i], x[i + 48] = b[i], x[i + 64] = d[i];
        var x32 = x.subarray(32), x16 = x.subarray(16);
        return inv25519(x32, x32), M(x16, x16, x32), pack25519(q, x16), 0;
      }
      function crypto_scalarmult_base(q, n) {
        return crypto_scalarmult(q, n, _9);
      }
      function crypto_box_keypair(y, x) {
        return randombytes(x, 32), crypto_scalarmult_base(y, x);
      }
      function crypto_box_beforenm(k, y, x) {
        var s = new Uint8Array(32);
        return crypto_scalarmult(s, x, y), crypto_core_hsalsa20(k, _0, s, sigma);
      }
      var crypto_box_afternm = crypto_secretbox, crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c, m, d, n, y, x) {
        var k = new Uint8Array(32);
        return crypto_box_beforenm(k, y, x), crypto_box_afternm(c, m, d, n, k);
      }
      function crypto_box_open(m, c, d, n, y, x) {
        var k = new Uint8Array(32);
        return crypto_box_beforenm(k, y, x), crypto_box_open_afternm(m, c, d, n, k);
      }
      var K = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m, n) {
        for (var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d, ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7], pos2 = 0; n >= 128; ) {
          for (i = 0; i < 16; i++)
            j = 8 * i + pos2, wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3], wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
          for (i = 0; i < 80; i++)
            if (bh0 = ah0, bh1 = ah1, bh2 = ah2, bh3 = ah3, bh4 = ah4, bh5 = ah5, bh6 = ah6, bh7 = ah7, bl0 = al0, bl1 = al1, bl2 = al2, bl3 = al3, bl4 = al4, bl5 = al5, bl6 = al6, bl7 = al7, h = ah7, l = al7, a = l & 65535, b = l >>> 16, c = h & 65535, d = h >>> 16, h = (ah4 >>> 14 | al4 << 18) ^ (ah4 >>> 18 | al4 << 14) ^ (al4 >>> 9 | ah4 << 23), l = (al4 >>> 14 | ah4 << 18) ^ (al4 >>> 18 | ah4 << 14) ^ (ah4 >>> 9 | al4 << 23), a += l & 65535, b += l >>> 16, c += h & 65535, d += h >>> 16, h = ah4 & ah5 ^ ~ah4 & ah6, l = al4 & al5 ^ ~al4 & al6, a += l & 65535, b += l >>> 16, c += h & 65535, d += h >>> 16, h = K[i * 2], l = K[i * 2 + 1], a += l & 65535, b += l >>> 16, c += h & 65535, d += h >>> 16, h = wh[i % 16], l = wl[i % 16], a += l & 65535, b += l >>> 16, c += h & 65535, d += h >>> 16, b += a >>> 16, c += b >>> 16, d += c >>> 16, th = c & 65535 | d << 16, tl = a & 65535 | b << 16, h = th, l = tl, a = l & 65535, b = l >>> 16, c = h & 65535, d = h >>> 16, h = (ah0 >>> 28 | al0 << 4) ^ (al0 >>> 2 | ah0 << 30) ^ (al0 >>> 7 | ah0 << 25), l = (al0 >>> 28 | ah0 << 4) ^ (ah0 >>> 2 | al0 << 30) ^ (ah0 >>> 7 | al0 << 25), a += l & 65535, b += l >>> 16, c += h & 65535, d += h >>> 16, h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2, l = al0 & al1 ^ al0 & al2 ^ al1 & al2, a += l & 65535, b += l >>> 16, c += h & 65535, d += h >>> 16, b += a >>> 16, c += b >>> 16, d += c >>> 16, bh7 = c & 65535 | d << 16, bl7 = a & 65535 | b << 16, h = bh3, l = bl3, a = l & 65535, b = l >>> 16, c = h & 65535, d = h >>> 16, h = th, l = tl, a += l & 65535, b += l >>> 16, c += h & 65535, d += h >>> 16, b += a >>> 16, c += b >>> 16, d += c >>> 16, bh3 = c & 65535 | d << 16, bl3 = a & 65535 | b << 16, ah1 = bh0, ah2 = bh1, ah3 = bh2, ah4 = bh3, ah5 = bh4, ah6 = bh5, ah7 = bh6, ah0 = bh7, al1 = bl0, al2 = bl1, al3 = bl2, al4 = bl3, al5 = bl4, al6 = bl5, al7 = bl6, al0 = bl7, i % 16 === 15)
              for (j = 0; j < 16; j++)
                h = wh[j], l = wl[j], a = l & 65535, b = l >>> 16, c = h & 65535, d = h >>> 16, h = wh[(j + 9) % 16], l = wl[(j + 9) % 16], a += l & 65535, b += l >>> 16, c += h & 65535, d += h >>> 16, th = wh[(j + 1) % 16], tl = wl[(j + 1) % 16], h = (th >>> 1 | tl << 31) ^ (th >>> 8 | tl << 24) ^ th >>> 7, l = (tl >>> 1 | th << 31) ^ (tl >>> 8 | th << 24) ^ (tl >>> 7 | th << 25), a += l & 65535, b += l >>> 16, c += h & 65535, d += h >>> 16, th = wh[(j + 14) % 16], tl = wl[(j + 14) % 16], h = (th >>> 19 | tl << 13) ^ (tl >>> 29 | th << 3) ^ th >>> 6, l = (tl >>> 19 | th << 13) ^ (th >>> 29 | tl << 3) ^ (tl >>> 6 | th << 26), a += l & 65535, b += l >>> 16, c += h & 65535, d += h >>> 16, b += a >>> 16, c += b >>> 16, d += c >>> 16, wh[j] = c & 65535 | d << 16, wl[j] = a & 65535 | b << 16;
          h = ah0, l = al0, a = l & 65535, b = l >>> 16, c = h & 65535, d = h >>> 16, h = hh[0], l = hl[0], a += l & 65535, b += l >>> 16, c += h & 65535, d += h >>> 16, b += a >>> 16, c += b >>> 16, d += c >>> 16, hh[0] = ah0 = c & 65535 | d << 16, hl[0] = al0 = a & 65535 | b << 16, h = ah1, l = al1, a = l & 65535, b = l >>> 16, c = h & 65535, d = h >>> 16, h = hh[1], l = hl[1], a += l & 65535, b += l >>> 16, c += h & 65535, d += h >>> 16, b += a >>> 16, c += b >>> 16, d += c >>> 16, hh[1] = ah1 = c & 65535 | d << 16, hl[1] = al1 = a & 65535 | b << 16, h = ah2, l = al2, a = l & 65535, b = l >>> 16, c = h & 65535, d = h >>> 16, h = hh[2], l = hl[2], a += l & 65535, b += l >>> 16, c += h & 65535, d += h >>> 16, b += a >>> 16, c += b >>> 16, d += c >>> 16, hh[2] = ah2 = c & 65535 | d << 16, hl[2] = al2 = a & 65535 | b << 16, h = ah3, l = al3, a = l & 65535, b = l >>> 16, c = h & 65535, d = h >>> 16, h = hh[3], l = hl[3], a += l & 65535, b += l >>> 16, c += h & 65535, d += h >>> 16, b += a >>> 16, c += b >>> 16, d += c >>> 16, hh[3] = ah3 = c & 65535 | d << 16, hl[3] = al3 = a & 65535 | b << 16, h = ah4, l = al4, a = l & 65535, b = l >>> 16, c = h & 65535, d = h >>> 16, h = hh[4], l = hl[4], a += l & 65535, b += l >>> 16, c += h & 65535, d += h >>> 16, b += a >>> 16, c += b >>> 16, d += c >>> 16, hh[4] = ah4 = c & 65535 | d << 16, hl[4] = al4 = a & 65535 | b << 16, h = ah5, l = al5, a = l & 65535, b = l >>> 16, c = h & 65535, d = h >>> 16, h = hh[5], l = hl[5], a += l & 65535, b += l >>> 16, c += h & 65535, d += h >>> 16, b += a >>> 16, c += b >>> 16, d += c >>> 16, hh[5] = ah5 = c & 65535 | d << 16, hl[5] = al5 = a & 65535 | b << 16, h = ah6, l = al6, a = l & 65535, b = l >>> 16, c = h & 65535, d = h >>> 16, h = hh[6], l = hl[6], a += l & 65535, b += l >>> 16, c += h & 65535, d += h >>> 16, b += a >>> 16, c += b >>> 16, d += c >>> 16, hh[6] = ah6 = c & 65535 | d << 16, hl[6] = al6 = a & 65535 | b << 16, h = ah7, l = al7, a = l & 65535, b = l >>> 16, c = h & 65535, d = h >>> 16, h = hh[7], l = hl[7], a += l & 65535, b += l >>> 16, c += h & 65535, d += h >>> 16, b += a >>> 16, c += b >>> 16, d += c >>> 16, hh[7] = ah7 = c & 65535 | d << 16, hl[7] = al7 = a & 65535 | b << 16, pos2 += 128, n -= 128;
        }
        return n;
      }
      function crypto_hash(out, m, n) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
        for (hh[0] = 1779033703, hh[1] = 3144134277, hh[2] = 1013904242, hh[3] = 2773480762, hh[4] = 1359893119, hh[5] = 2600822924, hh[6] = 528734635, hh[7] = 1541459225, hl[0] = 4089235720, hl[1] = 2227873595, hl[2] = 4271175723, hl[3] = 1595750129, hl[4] = 2917565137, hl[5] = 725511199, hl[6] = 4215389547, hl[7] = 327033209, crypto_hashblocks_hl(hh, hl, m, n), n %= 128, i = 0; i < n; i++) x[i] = m[b - n + i];
        for (x[n] = 128, n = 256 - 128 * (n < 112 ? 1 : 0), x[n - 9] = 0, ts64(x, n - 8, b / 536870912 | 0, b << 3), crypto_hashblocks_hl(hh, hl, x, n), i = 0; i < 8; i++) ts64(out, 8 * i, hh[i], hl[i]);
        return 0;
      }
      function add(p, q) {
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
        Z(a, p[1], p[0]), Z(t, q[1], q[0]), M(a, a, t), A(b, p[0], p[1]), A(t, q[0], q[1]), M(b, b, t), M(c, p[3], q[3]), M(c, c, D2), M(d, p[2], q[2]), A(d, d, d), Z(e, b, a), Z(f, d, c), A(g, d, c), A(h, b, a), M(p[0], e, f), M(p[1], h, g), M(p[2], g, f), M(p[3], e, h);
      }
      function cswap(p, q, b) {
        var i;
        for (i = 0; i < 4; i++)
          sel25519(p[i], q[i], b);
      }
      function pack(r, p) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p[2]), M(tx, p[0], zi), M(ty, p[1], zi), pack25519(r, ty), r[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p, q, s) {
        var b, i;
        for (set25519(p[0], gf0), set25519(p[1], gf1), set25519(p[2], gf1), set25519(p[3], gf0), i = 255; i >= 0; --i)
          b = s[i / 8 | 0] >> (i & 7) & 1, cswap(p, q, b), add(q, p), add(p, p), cswap(p, q, b);
      }
      function scalarbase(p, s) {
        var q = [gf(), gf(), gf(), gf()];
        set25519(q[0], X), set25519(q[1], Y), set25519(q[2], gf1), M(q[3], X, Y), scalarmult(p, q, s);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d = new Uint8Array(64), p = [gf(), gf(), gf(), gf()], i;
        for (seeded || randombytes(sk, 32), crypto_hash(d, sk, 32), d[0] &= 248, d[31] &= 127, d[31] |= 64, scalarbase(p, d), pack(pk, p), i = 0; i < 32; i++) sk[i + 32] = pk[i];
        return 0;
      }
      var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r, x) {
        var carry, i, j, k;
        for (i = 63; i >= 32; --i) {
          for (carry = 0, j = i - 32, k = i - 12; j < k; ++j)
            x[j] += carry - 16 * x[i] * L[j - (i - 32)], carry = x[j] + 128 >> 8, x[j] -= carry * 256;
          x[j] += carry, x[i] = 0;
        }
        for (carry = 0, j = 0; j < 32; j++)
          x[j] += carry - (x[31] >> 4) * L[j], carry = x[j] >> 8, x[j] &= 255;
        for (j = 0; j < 32; j++) x[j] -= carry * L[j];
        for (i = 0; i < 32; i++)
          x[i + 1] += x[i] >> 8, r[i] = x[i] & 255;
      }
      function reduce(r) {
        var x = new Float64Array(64), i;
        for (i = 0; i < 64; i++) x[i] = r[i];
        for (i = 0; i < 64; i++) r[i] = 0;
        modL(r, x);
      }
      function crypto_sign(sm, m, n, sk) {
        var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64), i, j, x = new Float64Array(64), p = [gf(), gf(), gf(), gf()];
        crypto_hash(d, sk, 32), d[0] &= 248, d[31] &= 127, d[31] |= 64;
        var smlen = n + 64;
        for (i = 0; i < n; i++) sm[64 + i] = m[i];
        for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];
        for (crypto_hash(r, sm.subarray(32), n + 32), reduce(r), scalarbase(p, r), pack(sm, p), i = 32; i < 64; i++) sm[i] = sk[i];
        for (crypto_hash(h, sm, n + 64), reduce(h), i = 0; i < 64; i++) x[i] = 0;
        for (i = 0; i < 32; i++) x[i] = r[i];
        for (i = 0; i < 32; i++)
          for (j = 0; j < 32; j++)
            x[i + j] += h[i] * d[j];
        return modL(sm.subarray(32), x), smlen;
      }
      function unpackneg(r, p) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        return set25519(r[2], gf1), unpack25519(r[1], p), S(num, r[1]), M(den, num, D), Z(num, num, r[2]), A(den, r[2], den), S(den2, den), S(den4, den2), M(den6, den4, den2), M(t, den6, num), M(t, t, den), pow2523(t, t), M(t, t, num), M(t, t, den), M(t, t, den), M(r[0], t, den), S(chk, r[0]), M(chk, chk, den), neq25519(chk, num) && M(r[0], r[0], I), S(chk, r[0]), M(chk, chk, den), neq25519(chk, num) ? -1 : (par25519(r[0]) === p[31] >> 7 && Z(r[0], gf0, r[0]), M(r[3], r[0], r[1]), 0);
      }
      function crypto_sign_open(m, sm, n, pk) {
        var i, mlen, t = new Uint8Array(32), h = new Uint8Array(64), p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
        if (mlen = -1, n < 64 || unpackneg(q, pk)) return -1;
        for (i = 0; i < n; i++) m[i] = sm[i];
        for (i = 0; i < 32; i++) m[i + 32] = pk[i];
        if (crypto_hash(h, m, n), reduce(h), scalarmult(p, q, h), scalarbase(q, sm.subarray(32)), add(p, q), pack(t, p), n -= 64, crypto_verify_32(sm, 0, t, 0)) {
          for (i = 0; i < n; i++) m[i] = 0;
          return -1;
        }
        for (i = 0; i < n; i++) m[i] = sm[i + 64];
        return mlen = n, mlen;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES
      };
      function checkLengths(k, n) {
        if (k.length !== crypto_secretbox_KEYBYTES) throw new Error("bad key size");
        if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        var t, i;
        for (i = 0; i < arguments.length; i++)
          if ((t = Object.prototype.toString.call(arguments[i])) !== "[object Uint8Array]")
            throw new TypeError("unexpected type " + t + ", use Uint8Array");
      }
      function cleanup(arr) {
        for (var i = 0; i < arr.length; i++) arr[i] = 0;
      }
      nacl.util || (nacl.util = {}, nacl.util.decodeUTF8 = nacl.util.encodeUTF8 = nacl.util.encodeBase64 = nacl.util.decodeBase64 = function() {
        throw new Error("nacl.util moved into separate package: https://github.com/dchest/tweetnacl-util-js");
      }), nacl.randomBytes = function(n) {
        var b = new Uint8Array(n);
        return randombytes(b, n), b;
      }, nacl.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key), checkLengths(key, nonce);
        for (var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length), c = new Uint8Array(m.length), i = 0; i < msg.length; i++) m[i + crypto_secretbox_ZEROBYTES] = msg[i];
        return crypto_secretbox(c, m, m.length, nonce, key), c.subarray(crypto_secretbox_BOXZEROBYTES);
      }, nacl.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key), checkLengths(key, nonce);
        for (var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length), m = new Uint8Array(c.length), i = 0; i < box.length; i++) c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
        return c.length < 32 || crypto_secretbox_open(m, c, c.length, nonce, key) !== 0 ? !1 : m.subarray(crypto_secretbox_ZEROBYTES);
      }, nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES, nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES, nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES, nacl.scalarMult = function(n, p) {
        if (checkArrayTypes(n, p), n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        if (p.length !== crypto_scalarmult_BYTES) throw new Error("bad p size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        return crypto_scalarmult(q, n, p), q;
      }, nacl.scalarMult.base = function(n) {
        if (checkArrayTypes(n), n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        return crypto_scalarmult_base(q, n), q;
      }, nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES, nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES, nacl.box = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox(msg, nonce, k);
      }, nacl.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey), checkBoxLengths(publicKey, secretKey);
        var k = new Uint8Array(crypto_box_BEFORENMBYTES);
        return crypto_box_beforenm(k, publicKey, secretKey), k;
      }, nacl.box.after = nacl.secretbox, nacl.box.open = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox.open(msg, nonce, k);
      }, nacl.box.open.after = nacl.secretbox.open, nacl.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES), sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        return crypto_box_keypair(pk, sk), { publicKey: pk, secretKey: sk };
      }, nacl.box.keyPair.fromSecretKey = function(secretKey) {
        if (checkArrayTypes(secretKey), secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        return crypto_scalarmult_base(pk, secretKey), { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      }, nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES, nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES, nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES, nacl.box.nonceLength = crypto_box_NONCEBYTES, nacl.box.overheadLength = nacl.secretbox.overheadLength, nacl.sign = function(msg, secretKey) {
        if (checkArrayTypes(msg, secretKey), secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        return crypto_sign(signedMsg, msg, msg.length, secretKey), signedMsg;
      }, nacl.sign.open = function(signedMsg, publicKey) {
        if (arguments.length !== 2)
          throw new Error("nacl.sign.open accepts 2 arguments; did you mean to use nacl.sign.detached.verify?");
        if (checkArrayTypes(signedMsg, publicKey), publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length), mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0) return null;
        for (var m = new Uint8Array(mlen), i = 0; i < m.length; i++) m[i] = tmp[i];
        return m;
      }, nacl.sign.detached = function(msg, secretKey) {
        for (var signedMsg = nacl.sign(msg, secretKey), sig = new Uint8Array(crypto_sign_BYTES), i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
        return sig;
      }, nacl.sign.detached.verify = function(msg, sig, publicKey) {
        if (checkArrayTypes(msg, sig, publicKey), sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length), m = new Uint8Array(crypto_sign_BYTES + msg.length), i;
        for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
        for (i = 0; i < msg.length; i++) sm[i + crypto_sign_BYTES] = msg[i];
        return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
      }, nacl.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES), sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        return crypto_sign_keypair(pk, sk), { publicKey: pk, secretKey: sk };
      }, nacl.sign.keyPair.fromSecretKey = function(secretKey) {
        if (checkArrayTypes(secretKey), secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        for (var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES), i = 0; i < pk.length; i++) pk[i] = secretKey[32 + i];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      }, nacl.sign.keyPair.fromSeed = function(seed) {
        if (checkArrayTypes(seed), seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        for (var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES), sk = new Uint8Array(crypto_sign_SECRETKEYBYTES), i = 0; i < 32; i++) sk[i] = seed[i];
        return crypto_sign_keypair(pk, sk, !0), { publicKey: pk, secretKey: sk };
      }, nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES, nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES, nacl.sign.seedLength = crypto_sign_SEEDBYTES, nacl.sign.signatureLength = crypto_sign_BYTES, nacl.hash = function(msg) {
        checkArrayTypes(msg);
        var h = new Uint8Array(crypto_hash_BYTES);
        return crypto_hash(h, msg, msg.length), h;
      }, nacl.hash.hashLength = crypto_hash_BYTES, nacl.verify = function(x, y) {
        return checkArrayTypes(x, y), x.length === 0 || y.length === 0 || x.length !== y.length ? !1 : vn(x, 0, y, 0, x.length) === 0;
      }, nacl.setPRNG = function(fn) {
        randombytes = fn;
      }, function() {
        var crypto = typeof self < "u" ? self.crypto || self.msCrypto : null;
        if (crypto && crypto.getRandomValues) {
          var QUOTA = 65536;
          nacl.setPRNG(function(x, n) {
            var i, v = new Uint8Array(n);
            for (i = 0; i < n; i += QUOTA)
              crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
            for (i = 0; i < n; i++) x[i] = v[i];
            cleanup(v);
          });
        } else typeof require < "u" && (crypto = require("crypto"), crypto && crypto.randomBytes && nacl.setPRNG(function(x, n) {
          var i, v = crypto.randomBytes(n);
          for (i = 0; i < n; i++) x[i] = v[i];
          cleanup(v);
        }));
      }();
    })(typeof module2 < "u" && module2.exports ? module2.exports : self.nacl = self.nacl || {});
  }
});

// node_modules/bcrypt-pbkdf/index.js
var require_bcrypt_pbkdf = __commonJS({
  "node_modules/bcrypt-pbkdf/index.js"(exports2, module2) {
    "use strict";
    var crypto_hash_sha512 = require_nacl_fast().lowlevel.crypto_hash, BLF_J = 0, Blowfish = function() {
      this.S = [
        new Uint32Array([
          3509652390,
          2564797868,
          805139163,
          3491422135,
          3101798381,
          1780907670,
          3128725573,
          4046225305,
          614570311,
          3012652279,
          134345442,
          2240740374,
          1667834072,
          1901547113,
          2757295779,
          4103290238,
          227898511,
          1921955416,
          1904987480,
          2182433518,
          2069144605,
          3260701109,
          2620446009,
          720527379,
          3318853667,
          677414384,
          3393288472,
          3101374703,
          2390351024,
          1614419982,
          1822297739,
          2954791486,
          3608508353,
          3174124327,
          2024746970,
          1432378464,
          3864339955,
          2857741204,
          1464375394,
          1676153920,
          1439316330,
          715854006,
          3033291828,
          289532110,
          2706671279,
          2087905683,
          3018724369,
          1668267050,
          732546397,
          1947742710,
          3462151702,
          2609353502,
          2950085171,
          1814351708,
          2050118529,
          680887927,
          999245976,
          1800124847,
          3300911131,
          1713906067,
          1641548236,
          4213287313,
          1216130144,
          1575780402,
          4018429277,
          3917837745,
          3693486850,
          3949271944,
          596196993,
          3549867205,
          258830323,
          2213823033,
          772490370,
          2760122372,
          1774776394,
          2652871518,
          566650946,
          4142492826,
          1728879713,
          2882767088,
          1783734482,
          3629395816,
          2517608232,
          2874225571,
          1861159788,
          326777828,
          3124490320,
          2130389656,
          2716951837,
          967770486,
          1724537150,
          2185432712,
          2364442137,
          1164943284,
          2105845187,
          998989502,
          3765401048,
          2244026483,
          1075463327,
          1455516326,
          1322494562,
          910128902,
          469688178,
          1117454909,
          936433444,
          3490320968,
          3675253459,
          1240580251,
          122909385,
          2157517691,
          634681816,
          4142456567,
          3825094682,
          3061402683,
          2540495037,
          79693498,
          3249098678,
          1084186820,
          1583128258,
          426386531,
          1761308591,
          1047286709,
          322548459,
          995290223,
          1845252383,
          2603652396,
          3431023940,
          2942221577,
          3202600964,
          3727903485,
          1712269319,
          422464435,
          3234572375,
          1170764815,
          3523960633,
          3117677531,
          1434042557,
          442511882,
          3600875718,
          1076654713,
          1738483198,
          4213154764,
          2393238008,
          3677496056,
          1014306527,
          4251020053,
          793779912,
          2902807211,
          842905082,
          4246964064,
          1395751752,
          1040244610,
          2656851899,
          3396308128,
          445077038,
          3742853595,
          3577915638,
          679411651,
          2892444358,
          2354009459,
          1767581616,
          3150600392,
          3791627101,
          3102740896,
          284835224,
          4246832056,
          1258075500,
          768725851,
          2589189241,
          3069724005,
          3532540348,
          1274779536,
          3789419226,
          2764799539,
          1660621633,
          3471099624,
          4011903706,
          913787905,
          3497959166,
          737222580,
          2514213453,
          2928710040,
          3937242737,
          1804850592,
          3499020752,
          2949064160,
          2386320175,
          2390070455,
          2415321851,
          4061277028,
          2290661394,
          2416832540,
          1336762016,
          1754252060,
          3520065937,
          3014181293,
          791618072,
          3188594551,
          3933548030,
          2332172193,
          3852520463,
          3043980520,
          413987798,
          3465142937,
          3030929376,
          4245938359,
          2093235073,
          3534596313,
          375366246,
          2157278981,
          2479649556,
          555357303,
          3870105701,
          2008414854,
          3344188149,
          4221384143,
          3956125452,
          2067696032,
          3594591187,
          2921233993,
          2428461,
          544322398,
          577241275,
          1471733935,
          610547355,
          4027169054,
          1432588573,
          1507829418,
          2025931657,
          3646575487,
          545086370,
          48609733,
          2200306550,
          1653985193,
          298326376,
          1316178497,
          3007786442,
          2064951626,
          458293330,
          2589141269,
          3591329599,
          3164325604,
          727753846,
          2179363840,
          146436021,
          1461446943,
          4069977195,
          705550613,
          3059967265,
          3887724982,
          4281599278,
          3313849956,
          1404054877,
          2845806497,
          146425753,
          1854211946
        ]),
        new Uint32Array([
          1266315497,
          3048417604,
          3681880366,
          3289982499,
          290971e4,
          1235738493,
          2632868024,
          2414719590,
          3970600049,
          1771706367,
          1449415276,
          3266420449,
          422970021,
          1963543593,
          2690192192,
          3826793022,
          1062508698,
          1531092325,
          1804592342,
          2583117782,
          2714934279,
          4024971509,
          1294809318,
          4028980673,
          1289560198,
          2221992742,
          1669523910,
          35572830,
          157838143,
          1052438473,
          1016535060,
          1802137761,
          1753167236,
          1386275462,
          3080475397,
          2857371447,
          1040679964,
          2145300060,
          2390574316,
          1461121720,
          2956646967,
          4031777805,
          4028374788,
          33600511,
          2920084762,
          1018524850,
          629373528,
          3691585981,
          3515945977,
          2091462646,
          2486323059,
          586499841,
          988145025,
          935516892,
          3367335476,
          2599673255,
          2839830854,
          265290510,
          3972581182,
          2759138881,
          3795373465,
          1005194799,
          847297441,
          406762289,
          1314163512,
          1332590856,
          1866599683,
          4127851711,
          750260880,
          613907577,
          1450815602,
          3165620655,
          3734664991,
          3650291728,
          3012275730,
          3704569646,
          1427272223,
          778793252,
          1343938022,
          2676280711,
          2052605720,
          1946737175,
          3164576444,
          3914038668,
          3967478842,
          3682934266,
          1661551462,
          3294938066,
          4011595847,
          840292616,
          3712170807,
          616741398,
          312560963,
          711312465,
          1351876610,
          322626781,
          1910503582,
          271666773,
          2175563734,
          1594956187,
          70604529,
          3617834859,
          1007753275,
          1495573769,
          4069517037,
          2549218298,
          2663038764,
          504708206,
          2263041392,
          3941167025,
          2249088522,
          1514023603,
          1998579484,
          1312622330,
          694541497,
          2582060303,
          2151582166,
          1382467621,
          776784248,
          2618340202,
          3323268794,
          2497899128,
          2784771155,
          503983604,
          4076293799,
          907881277,
          423175695,
          432175456,
          1378068232,
          4145222326,
          3954048622,
          3938656102,
          3820766613,
          2793130115,
          2977904593,
          26017576,
          3274890735,
          3194772133,
          1700274565,
          1756076034,
          4006520079,
          3677328699,
          720338349,
          1533947780,
          354530856,
          688349552,
          3973924725,
          1637815568,
          332179504,
          3949051286,
          53804574,
          2852348879,
          3044236432,
          1282449977,
          3583942155,
          3416972820,
          4006381244,
          1617046695,
          2628476075,
          3002303598,
          1686838959,
          431878346,
          2686675385,
          1700445008,
          1080580658,
          1009431731,
          832498133,
          3223435511,
          2605976345,
          2271191193,
          2516031870,
          1648197032,
          4164389018,
          2548247927,
          300782431,
          375919233,
          238389289,
          3353747414,
          2531188641,
          2019080857,
          1475708069,
          455242339,
          2609103871,
          448939670,
          3451063019,
          1395535956,
          2413381860,
          1841049896,
          1491858159,
          885456874,
          4264095073,
          4001119347,
          1565136089,
          3898914787,
          1108368660,
          540939232,
          1173283510,
          2745871338,
          3681308437,
          4207628240,
          3343053890,
          4016749493,
          1699691293,
          1103962373,
          3625875870,
          2256883143,
          3830138730,
          1031889488,
          3479347698,
          1535977030,
          4236805024,
          3251091107,
          2132092099,
          1774941330,
          1199868427,
          1452454533,
          157007616,
          2904115357,
          342012276,
          595725824,
          1480756522,
          206960106,
          497939518,
          591360097,
          863170706,
          2375253569,
          3596610801,
          1814182875,
          2094937945,
          3421402208,
          1082520231,
          3463918190,
          2785509508,
          435703966,
          3908032597,
          1641649973,
          2842273706,
          3305899714,
          1510255612,
          2148256476,
          2655287854,
          3276092548,
          4258621189,
          236887753,
          3681803219,
          274041037,
          1734335097,
          3815195456,
          3317970021,
          1899903192,
          1026095262,
          4050517792,
          356393447,
          2410691914,
          3873677099,
          3682840055
        ]),
        new Uint32Array([
          3913112168,
          2491498743,
          4132185628,
          2489919796,
          1091903735,
          1979897079,
          3170134830,
          3567386728,
          3557303409,
          857797738,
          1136121015,
          1342202287,
          507115054,
          2535736646,
          337727348,
          3213592640,
          1301675037,
          2528481711,
          1895095763,
          1721773893,
          3216771564,
          62756741,
          2142006736,
          835421444,
          2531993523,
          1442658625,
          3659876326,
          2882144922,
          676362277,
          1392781812,
          170690266,
          3921047035,
          1759253602,
          3611846912,
          1745797284,
          664899054,
          1329594018,
          3901205900,
          3045908486,
          2062866102,
          2865634940,
          3543621612,
          3464012697,
          1080764994,
          553557557,
          3656615353,
          3996768171,
          991055499,
          499776247,
          1265440854,
          648242737,
          3940784050,
          980351604,
          3713745714,
          1749149687,
          3396870395,
          4211799374,
          3640570775,
          1161844396,
          3125318951,
          1431517754,
          545492359,
          4268468663,
          3499529547,
          1437099964,
          2702547544,
          3433638243,
          2581715763,
          2787789398,
          1060185593,
          1593081372,
          2418618748,
          4260947970,
          69676912,
          2159744348,
          86519011,
          2512459080,
          3838209314,
          1220612927,
          3339683548,
          133810670,
          1090789135,
          1078426020,
          1569222167,
          845107691,
          3583754449,
          4072456591,
          1091646820,
          628848692,
          1613405280,
          3757631651,
          526609435,
          236106946,
          48312990,
          2942717905,
          3402727701,
          1797494240,
          859738849,
          992217954,
          4005476642,
          2243076622,
          3870952857,
          3732016268,
          765654824,
          3490871365,
          2511836413,
          1685915746,
          3888969200,
          1414112111,
          2273134842,
          3281911079,
          4080962846,
          172450625,
          2569994100,
          980381355,
          4109958455,
          2819808352,
          2716589560,
          2568741196,
          3681446669,
          3329971472,
          1835478071,
          660984891,
          3704678404,
          4045999559,
          3422617507,
          3040415634,
          1762651403,
          1719377915,
          3470491036,
          2693910283,
          3642056355,
          3138596744,
          1364962596,
          2073328063,
          1983633131,
          926494387,
          3423689081,
          2150032023,
          4096667949,
          1749200295,
          3328846651,
          309677260,
          2016342300,
          1779581495,
          3079819751,
          111262694,
          1274766160,
          443224088,
          298511866,
          1025883608,
          3806446537,
          1145181785,
          168956806,
          3641502830,
          3584813610,
          1689216846,
          3666258015,
          3200248200,
          1692713982,
          2646376535,
          4042768518,
          1618508792,
          1610833997,
          3523052358,
          4130873264,
          2001055236,
          3610705100,
          2202168115,
          4028541809,
          2961195399,
          1006657119,
          2006996926,
          3186142756,
          1430667929,
          3210227297,
          1314452623,
          4074634658,
          4101304120,
          2273951170,
          1399257539,
          3367210612,
          3027628629,
          1190975929,
          2062231137,
          2333990788,
          2221543033,
          2438960610,
          1181637006,
          548689776,
          2362791313,
          3372408396,
          3104550113,
          3145860560,
          296247880,
          1970579870,
          3078560182,
          3769228297,
          1714227617,
          3291629107,
          3898220290,
          166772364,
          1251581989,
          493813264,
          448347421,
          195405023,
          2709975567,
          677966185,
          3703036547,
          1463355134,
          2715995803,
          1338867538,
          1343315457,
          2802222074,
          2684532164,
          233230375,
          2599980071,
          2000651841,
          3277868038,
          1638401717,
          4028070440,
          3237316320,
          6314154,
          819756386,
          300326615,
          590932579,
          1405279636,
          3267499572,
          3150704214,
          2428286686,
          3959192993,
          3461946742,
          1862657033,
          1266418056,
          963775037,
          2089974820,
          2263052895,
          1917689273,
          448879540,
          3550394620,
          3981727096,
          150775221,
          3627908307,
          1303187396,
          508620638,
          2975983352,
          2726630617,
          1817252668,
          1876281319,
          1457606340,
          908771278,
          3720792119,
          3617206836,
          2455994898,
          1729034894,
          1080033504
        ]),
        new Uint32Array([
          976866871,
          3556439503,
          2881648439,
          1522871579,
          1555064734,
          1336096578,
          3548522304,
          2579274686,
          3574697629,
          3205460757,
          3593280638,
          3338716283,
          3079412587,
          564236357,
          2993598910,
          1781952180,
          1464380207,
          3163844217,
          3332601554,
          1699332808,
          1393555694,
          1183702653,
          3581086237,
          1288719814,
          691649499,
          2847557200,
          2895455976,
          3193889540,
          2717570544,
          1781354906,
          1676643554,
          2592534050,
          3230253752,
          1126444790,
          2770207658,
          2633158820,
          2210423226,
          2615765581,
          2414155088,
          3127139286,
          673620729,
          2805611233,
          1269405062,
          4015350505,
          3341807571,
          4149409754,
          1057255273,
          2012875353,
          2162469141,
          2276492801,
          2601117357,
          993977747,
          3918593370,
          2654263191,
          753973209,
          36408145,
          2530585658,
          25011837,
          3520020182,
          2088578344,
          530523599,
          2918365339,
          1524020338,
          1518925132,
          3760827505,
          3759777254,
          1202760957,
          3985898139,
          3906192525,
          674977740,
          4174734889,
          2031300136,
          2019492241,
          3983892565,
          4153806404,
          3822280332,
          352677332,
          2297720250,
          60907813,
          90501309,
          3286998549,
          1016092578,
          2535922412,
          2839152426,
          457141659,
          509813237,
          4120667899,
          652014361,
          1966332200,
          2975202805,
          55981186,
          2327461051,
          676427537,
          3255491064,
          2882294119,
          3433927263,
          1307055953,
          942726286,
          933058658,
          2468411793,
          3933900994,
          4215176142,
          1361170020,
          2001714738,
          2830558078,
          3274259782,
          1222529897,
          1679025792,
          2729314320,
          3714953764,
          1770335741,
          151462246,
          3013232138,
          1682292957,
          1483529935,
          471910574,
          1539241949,
          458788160,
          3436315007,
          1807016891,
          3718408830,
          978976581,
          1043663428,
          3165965781,
          1927990952,
          4200891579,
          2372276910,
          3208408903,
          3533431907,
          1412390302,
          2931980059,
          4132332400,
          1947078029,
          3881505623,
          4168226417,
          2941484381,
          1077988104,
          1320477388,
          886195818,
          18198404,
          3786409e3,
          2509781533,
          112762804,
          3463356488,
          1866414978,
          891333506,
          18488651,
          661792760,
          1628790961,
          3885187036,
          3141171499,
          876946877,
          2693282273,
          1372485963,
          791857591,
          2686433993,
          3759982718,
          3167212022,
          3472953795,
          2716379847,
          445679433,
          3561995674,
          3504004811,
          3574258232,
          54117162,
          3331405415,
          2381918588,
          3769707343,
          4154350007,
          1140177722,
          4074052095,
          668550556,
          3214352940,
          367459370,
          261225585,
          2610173221,
          4209349473,
          3468074219,
          3265815641,
          314222801,
          3066103646,
          3808782860,
          282218597,
          3406013506,
          3773591054,
          379116347,
          1285071038,
          846784868,
          2669647154,
          3771962079,
          3550491691,
          2305946142,
          453669953,
          1268987020,
          3317592352,
          3279303384,
          3744833421,
          2610507566,
          3859509063,
          266596637,
          3847019092,
          517658769,
          3462560207,
          3443424879,
          370717030,
          4247526661,
          2224018117,
          4143653529,
          4112773975,
          2788324899,
          2477274417,
          1456262402,
          2901442914,
          1517677493,
          1846949527,
          2295493580,
          3734397586,
          2176403920,
          1280348187,
          1908823572,
          3871786941,
          846861322,
          1172426758,
          3287448474,
          3383383037,
          1655181056,
          3139813346,
          901632758,
          1897031941,
          2986607138,
          3066810236,
          3447102507,
          1393639104,
          373351379,
          950779232,
          625454576,
          3124240540,
          4148612726,
          2007998917,
          544563296,
          2244738638,
          2330496472,
          2058025392,
          1291430526,
          424198748,
          50039436,
          29584100,
          3605783033,
          2429876329,
          2791104160,
          1057563949,
          3255363231,
          3075367218,
          3463963227,
          1469046755,
          985887462
        ])
      ], this.P = new Uint32Array([
        608135816,
        2242054355,
        320440878,
        57701188,
        2752067618,
        698298832,
        137296536,
        3964562569,
        1160258022,
        953160567,
        3193202383,
        887688300,
        3232508343,
        3380367581,
        1065670069,
        3041331479,
        2450970073,
        2306472731
      ]);
    };
    function F(S, x8, i) {
      return (S[0][x8[i + 3]] + S[1][x8[i + 2]] ^ S[2][x8[i + 1]]) + S[3][x8[i]];
    }
    Blowfish.prototype.encipher = function(x, x8) {
      x8 === void 0 && (x8 = new Uint8Array(x.buffer), x.byteOffset !== 0 && (x8 = x8.subarray(x.byteOffset))), x[0] ^= this.P[0];
      for (var i = 1; i < 16; i += 2)
        x[1] ^= F(this.S, x8, 0) ^ this.P[i], x[0] ^= F(this.S, x8, 4) ^ this.P[i + 1];
      var t = x[0];
      x[0] = x[1] ^ this.P[17], x[1] = t;
    };
    Blowfish.prototype.decipher = function(x) {
      var x8 = new Uint8Array(x.buffer);
      x.byteOffset !== 0 && (x8 = x8.subarray(x.byteOffset)), x[0] ^= this.P[17];
      for (var i = 16; i > 0; i -= 2)
        x[1] ^= F(this.S, x8, 0) ^ this.P[i], x[0] ^= F(this.S, x8, 4) ^ this.P[i - 1];
      var t = x[0];
      x[0] = x[1] ^ this.P[0], x[1] = t;
    };
    function stream2word(data, databytes) {
      var i, temp = 0;
      for (i = 0; i < 4; i++, BLF_J++)
        BLF_J >= databytes && (BLF_J = 0), temp = temp << 8 | data[BLF_J];
      return temp;
    }
    Blowfish.prototype.expand0state = function(key, keybytes) {
      var d = new Uint32Array(2), i, k, d8 = new Uint8Array(d.buffer);
      for (i = 0, BLF_J = 0; i < 18; i++)
        this.P[i] ^= stream2word(key, keybytes);
      for (BLF_J = 0, i = 0; i < 18; i += 2)
        this.encipher(d, d8), this.P[i] = d[0], this.P[i + 1] = d[1];
      for (i = 0; i < 4; i++)
        for (k = 0; k < 256; k += 2)
          this.encipher(d, d8), this.S[i][k] = d[0], this.S[i][k + 1] = d[1];
    };
    Blowfish.prototype.expandstate = function(data, databytes, key, keybytes) {
      var d = new Uint32Array(2), i, k;
      for (i = 0, BLF_J = 0; i < 18; i++)
        this.P[i] ^= stream2word(key, keybytes);
      for (i = 0, BLF_J = 0; i < 18; i += 2)
        d[0] ^= stream2word(data, databytes), d[1] ^= stream2word(data, databytes), this.encipher(d), this.P[i] = d[0], this.P[i + 1] = d[1];
      for (i = 0; i < 4; i++)
        for (k = 0; k < 256; k += 2)
          d[0] ^= stream2word(data, databytes), d[1] ^= stream2word(data, databytes), this.encipher(d), this.S[i][k] = d[0], this.S[i][k + 1] = d[1];
      BLF_J = 0;
    };
    Blowfish.prototype.enc = function(data, blocks) {
      for (var i = 0; i < blocks; i++)
        this.encipher(data.subarray(i * 2));
    };
    Blowfish.prototype.dec = function(data, blocks) {
      for (var i = 0; i < blocks; i++)
        this.decipher(data.subarray(i * 2));
    };
    var BCRYPT_BLOCKS = 8, BCRYPT_HASHSIZE = 32;
    function bcrypt_hash(sha2pass, sha2salt, out) {
      var state = new Blowfish(), cdata = new Uint32Array(BCRYPT_BLOCKS), i, ciphertext = new Uint8Array([
        79,
        120,
        121,
        99,
        104,
        114,
        111,
        109,
        97,
        116,
        105,
        99,
        66,
        108,
        111,
        119,
        102,
        105,
        115,
        104,
        83,
        119,
        97,
        116,
        68,
        121,
        110,
        97,
        109,
        105,
        116,
        101
      ]);
      for (state.expandstate(sha2salt, 64, sha2pass, 64), i = 0; i < 64; i++)
        state.expand0state(sha2salt, 64), state.expand0state(sha2pass, 64);
      for (i = 0; i < BCRYPT_BLOCKS; i++)
        cdata[i] = stream2word(ciphertext, ciphertext.byteLength);
      for (i = 0; i < 64; i++)
        state.enc(cdata, cdata.byteLength / 8);
      for (i = 0; i < BCRYPT_BLOCKS; i++)
        out[4 * i + 3] = cdata[i] >>> 24, out[4 * i + 2] = cdata[i] >>> 16, out[4 * i + 1] = cdata[i] >>> 8, out[4 * i + 0] = cdata[i];
    }
    function bcrypt_pbkdf(pass, passlen, salt, saltlen, key, keylen, rounds) {
      var sha2pass = new Uint8Array(64), sha2salt = new Uint8Array(64), out = new Uint8Array(BCRYPT_HASHSIZE), tmpout = new Uint8Array(BCRYPT_HASHSIZE), countsalt = new Uint8Array(saltlen + 4), i, j, amt, stride, dest, count, origkeylen = keylen;
      if (rounds < 1 || passlen === 0 || saltlen === 0 || keylen === 0 || keylen > out.byteLength * out.byteLength || saltlen > 1 << 20)
        return -1;
      for (stride = Math.floor((keylen + out.byteLength - 1) / out.byteLength), amt = Math.floor((keylen + stride - 1) / stride), i = 0; i < saltlen; i++)
        countsalt[i] = salt[i];
      for (crypto_hash_sha512(sha2pass, pass, passlen), count = 1; keylen > 0; count++) {
        for (countsalt[saltlen + 0] = count >>> 24, countsalt[saltlen + 1] = count >>> 16, countsalt[saltlen + 2] = count >>> 8, countsalt[saltlen + 3] = count, crypto_hash_sha512(sha2salt, countsalt, saltlen + 4), bcrypt_hash(sha2pass, sha2salt, tmpout), i = out.byteLength; i--; )
          out[i] = tmpout[i];
        for (i = 1; i < rounds; i++)
          for (crypto_hash_sha512(sha2salt, tmpout, tmpout.byteLength), bcrypt_hash(sha2pass, sha2salt, tmpout), j = 0; j < out.byteLength; j++)
            out[j] ^= tmpout[j];
        for (amt = Math.min(amt, keylen), i = 0; i < amt && (dest = i * stride + (count - 1), !(dest >= origkeylen)); i++)
          key[dest] = out[i];
        keylen -= i;
      }
      return 0;
    }
    module2.exports = {
      BLOCKS: BCRYPT_BLOCKS,
      HASHSIZE: BCRYPT_HASHSIZE,
      hash: bcrypt_hash,
      pbkdf: bcrypt_pbkdf
    };
  }
});

// node_modules/cpu-features/build/Release/cpufeatures.node
var require_cpufeatures = __commonJS({
  "node_modules/cpu-features/build/Release/cpufeatures.node"(exports2, module2) {
    module2.exports = "./cpufeatures-BQHYZFM4.node";
  }
});

// node_modules/cpu-features/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/cpu-features/lib/index.js"(exports2, module2) {
    "use strict";
    var binding = require_cpufeatures();
    module2.exports = binding.getCPUInfo;
  }
});

// node_modules/ssh2/lib/protocol/constants.js
var require_constants6 = __commonJS({
  "node_modules/ssh2/lib/protocol/constants.js"(exports2, module2) {
    "use strict";
    var crypto = require("crypto"), cpuInfo;
    try {
      cpuInfo = require_lib5()();
    } catch {
    }
    var { bindingAvailable, CIPHER_INFO, MAC_INFO } = require_crypto(), eddsaSupported = (() => {
      if (typeof crypto.sign == "function" && typeof crypto.verify == "function") {
        let key = `-----BEGIN PRIVATE KEY-----\r
MC4CAQAwBQYDK2VwBCIEIHKj+sVa9WcD/q2DJUJaf43Kptc8xYuUQA4bOFj9vC8T\r
-----END PRIVATE KEY-----`, data = Buffer.from("a"), sig, verified;
        try {
          sig = crypto.sign(null, data, key), verified = crypto.verify(null, data, key, sig);
        } catch {
        }
        return Buffer.isBuffer(sig) && sig.length === 64 && verified === !0;
      }
      return !1;
    })(), curve25519Supported = typeof crypto.diffieHellman == "function" && typeof crypto.generateKeyPairSync == "function" && typeof crypto.createPublicKey == "function", DEFAULT_KEX = [
      // https://tools.ietf.org/html/rfc5656#section-10.1
      "ecdh-sha2-nistp256",
      "ecdh-sha2-nistp384",
      "ecdh-sha2-nistp521",
      // https://tools.ietf.org/html/rfc4419#section-4
      "diffie-hellman-group-exchange-sha256",
      // https://tools.ietf.org/html/rfc8268
      "diffie-hellman-group14-sha256",
      "diffie-hellman-group15-sha512",
      "diffie-hellman-group16-sha512",
      "diffie-hellman-group17-sha512",
      "diffie-hellman-group18-sha512"
    ];
    curve25519Supported && (DEFAULT_KEX.unshift("curve25519-sha256"), DEFAULT_KEX.unshift("curve25519-sha256@libssh.org"));
    var SUPPORTED_KEX = DEFAULT_KEX.concat([
      // https://tools.ietf.org/html/rfc4419#section-4
      "diffie-hellman-group-exchange-sha1",
      "diffie-hellman-group14-sha1",
      // REQUIRED
      "diffie-hellman-group1-sha1"
      // REQUIRED
    ]), DEFAULT_SERVER_HOST_KEY = [
      "ecdsa-sha2-nistp256",
      "ecdsa-sha2-nistp384",
      "ecdsa-sha2-nistp521",
      "rsa-sha2-512",
      // RFC 8332
      "rsa-sha2-256",
      // RFC 8332
      "ssh-rsa"
    ];
    eddsaSupported && DEFAULT_SERVER_HOST_KEY.unshift("ssh-ed25519");
    var SUPPORTED_SERVER_HOST_KEY = DEFAULT_SERVER_HOST_KEY.concat([
      "ssh-dss"
    ]), canUseCipher = (() => {
      let ciphers = crypto.getCiphers();
      return (name2) => ciphers.includes(CIPHER_INFO[name2].sslName);
    })(), DEFAULT_CIPHER = [
      // http://tools.ietf.org/html/rfc5647
      "aes128-gcm@openssh.com",
      "aes256-gcm@openssh.com",
      // http://tools.ietf.org/html/rfc4344#section-4
      "aes128-ctr",
      "aes192-ctr",
      "aes256-ctr"
    ];
    cpuInfo && cpuInfo.flags && !cpuInfo.flags.aes ? bindingAvailable ? DEFAULT_CIPHER.unshift("chacha20-poly1305@openssh.com") : DEFAULT_CIPHER.push("chacha20-poly1305@openssh.com") : bindingAvailable && cpuInfo && cpuInfo.arch === "x86" ? DEFAULT_CIPHER.splice(4, 0, "chacha20-poly1305@openssh.com") : DEFAULT_CIPHER.push("chacha20-poly1305@openssh.com");
    DEFAULT_CIPHER = DEFAULT_CIPHER.filter(canUseCipher);
    var SUPPORTED_CIPHER = DEFAULT_CIPHER.concat([
      "aes256-cbc",
      "aes192-cbc",
      "aes128-cbc",
      "blowfish-cbc",
      "3des-cbc",
      "aes128-gcm",
      "aes256-gcm",
      // http://tools.ietf.org/html/rfc4345#section-4:
      "arcfour256",
      "arcfour128",
      "cast128-cbc",
      "arcfour"
    ].filter(canUseCipher)), canUseMAC = (() => {
      let hashes = crypto.getHashes();
      return (name2) => hashes.includes(MAC_INFO[name2].sslName);
    })(), DEFAULT_MAC = [
      "hmac-sha2-256-etm@openssh.com",
      "hmac-sha2-512-etm@openssh.com",
      "hmac-sha1-etm@openssh.com",
      "hmac-sha2-256",
      "hmac-sha2-512",
      "hmac-sha1"
    ].filter(canUseMAC), SUPPORTED_MAC = DEFAULT_MAC.concat([
      "hmac-md5",
      "hmac-sha2-256-96",
      // first 96 bits of HMAC-SHA256
      "hmac-sha2-512-96",
      // first 96 bits of HMAC-SHA512
      "hmac-ripemd160",
      "hmac-sha1-96",
      // first 96 bits of HMAC-SHA1
      "hmac-md5-96"
      // first 96 bits of HMAC-MD5
    ].filter(canUseMAC)), DEFAULT_COMPRESSION = [
      "none",
      "zlib@openssh.com",
      // ZLIB (LZ77) compression, except
      // compression/decompression does not start until after
      // successful user authentication
      "zlib"
      // ZLIB (LZ77) compression
    ], SUPPORTED_COMPRESSION = DEFAULT_COMPRESSION.concat([]), COMPAT = {
      BAD_DHGEX: 1,
      OLD_EXIT: 2,
      DYN_RPORT_BUG: 4,
      BUG_DHGEX_LARGE: 8,
      IMPLY_RSA_SHA2_SIGALGS: 16
    };
    module2.exports = {
      MESSAGE: {
        // Transport layer protocol -- generic (1-19)
        DISCONNECT: 1,
        IGNORE: 2,
        UNIMPLEMENTED: 3,
        DEBUG: 4,
        SERVICE_REQUEST: 5,
        SERVICE_ACCEPT: 6,
        EXT_INFO: 7,
        // RFC 8308
        // Transport layer protocol -- algorithm negotiation (20-29)
        KEXINIT: 20,
        NEWKEYS: 21,
        // Transport layer protocol -- key exchange method-specific (30-49)
        KEXDH_INIT: 30,
        KEXDH_REPLY: 31,
        KEXDH_GEX_GROUP: 31,
        KEXDH_GEX_INIT: 32,
        KEXDH_GEX_REPLY: 33,
        KEXDH_GEX_REQUEST: 34,
        KEXECDH_INIT: 30,
        KEXECDH_REPLY: 31,
        // User auth protocol -- generic (50-59)
        USERAUTH_REQUEST: 50,
        USERAUTH_FAILURE: 51,
        USERAUTH_SUCCESS: 52,
        USERAUTH_BANNER: 53,
        // User auth protocol -- user auth method-specific (60-79)
        USERAUTH_PASSWD_CHANGEREQ: 60,
        USERAUTH_PK_OK: 60,
        USERAUTH_INFO_REQUEST: 60,
        USERAUTH_INFO_RESPONSE: 61,
        // Connection protocol -- generic (80-89)
        GLOBAL_REQUEST: 80,
        REQUEST_SUCCESS: 81,
        REQUEST_FAILURE: 82,
        // Connection protocol -- channel-related (90-127)
        CHANNEL_OPEN: 90,
        CHANNEL_OPEN_CONFIRMATION: 91,
        CHANNEL_OPEN_FAILURE: 92,
        CHANNEL_WINDOW_ADJUST: 93,
        CHANNEL_DATA: 94,
        CHANNEL_EXTENDED_DATA: 95,
        CHANNEL_EOF: 96,
        CHANNEL_CLOSE: 97,
        CHANNEL_REQUEST: 98,
        CHANNEL_SUCCESS: 99,
        CHANNEL_FAILURE: 100
        // Reserved for client protocols (128-191)
        // Local extensions (192-155)
      },
      DISCONNECT_REASON: {
        HOST_NOT_ALLOWED_TO_CONNECT: 1,
        PROTOCOL_ERROR: 2,
        KEY_EXCHANGE_FAILED: 3,
        RESERVED: 4,
        MAC_ERROR: 5,
        COMPRESSION_ERROR: 6,
        SERVICE_NOT_AVAILABLE: 7,
        PROTOCOL_VERSION_NOT_SUPPORTED: 8,
        HOST_KEY_NOT_VERIFIABLE: 9,
        CONNECTION_LOST: 10,
        BY_APPLICATION: 11,
        TOO_MANY_CONNECTIONS: 12,
        AUTH_CANCELED_BY_USER: 13,
        NO_MORE_AUTH_METHODS_AVAILABLE: 14,
        ILLEGAL_USER_NAME: 15
      },
      DISCONNECT_REASON_STR: void 0,
      CHANNEL_OPEN_FAILURE: {
        ADMINISTRATIVELY_PROHIBITED: 1,
        CONNECT_FAILED: 2,
        UNKNOWN_CHANNEL_TYPE: 3,
        RESOURCE_SHORTAGE: 4
      },
      TERMINAL_MODE: {
        TTY_OP_END: 0,
        // Indicates end of options.
        VINTR: 1,
        // Interrupt character; 255 if none. Similarly for the
        //  other characters.  Not all of these characters are
        //  supported on all systems.
        VQUIT: 2,
        // The quit character (sends SIGQUIT signal on POSIX
        //  systems).
        VERASE: 3,
        // Erase the character to left of the cursor.
        VKILL: 4,
        // Kill the current input line.
        VEOF: 5,
        // End-of-file character (sends EOF from the
        //  terminal).
        VEOL: 6,
        // End-of-line character in addition to carriage
        //  return and/or linefeed.
        VEOL2: 7,
        // Additional end-of-line character.
        VSTART: 8,
        // Continues paused output (normally control-Q).
        VSTOP: 9,
        // Pauses output (normally control-S).
        VSUSP: 10,
        // Suspends the current program.
        VDSUSP: 11,
        // Another suspend character.
        VREPRINT: 12,
        // Reprints the current input line.
        VWERASE: 13,
        // Erases a word left of cursor.
        VLNEXT: 14,
        // Enter the next character typed literally, even if
        //  it is a special character
        VFLUSH: 15,
        // Character to flush output.
        VSWTCH: 16,
        // Switch to a different shell layer.
        VSTATUS: 17,
        // Prints system status line (load, command, pid,
        //  etc).
        VDISCARD: 18,
        // Toggles the flushing of terminal output.
        IGNPAR: 30,
        // The ignore parity flag.  The parameter SHOULD be 0
        //  if this flag is FALSE, and 1 if it is TRUE.
        PARMRK: 31,
        // Mark parity and framing errors.
        INPCK: 32,
        // Enable checking of parity errors.
        ISTRIP: 33,
        // Strip 8th bit off characters.
        INLCR: 34,
        // Map NL into CR on input.
        IGNCR: 35,
        // Ignore CR on input.
        ICRNL: 36,
        // Map CR to NL on input.
        IUCLC: 37,
        // Translate uppercase characters to lowercase.
        IXON: 38,
        // Enable output flow control.
        IXANY: 39,
        // Any char will restart after stop.
        IXOFF: 40,
        // Enable input flow control.
        IMAXBEL: 41,
        // Ring bell on input queue full.
        ISIG: 50,
        // Enable signals INTR, QUIT, [D]SUSP.
        ICANON: 51,
        // Canonicalize input lines.
        XCASE: 52,
        // Enable input and output of uppercase characters by
        //  preceding their lowercase equivalents with "\".
        ECHO: 53,
        // Enable echoing.
        ECHOE: 54,
        // Visually erase chars.
        ECHOK: 55,
        // Kill character discards current line.
        ECHONL: 56,
        // Echo NL even if ECHO is off.
        NOFLSH: 57,
        // Don't flush after interrupt.
        TOSTOP: 58,
        // Stop background jobs from output.
        IEXTEN: 59,
        // Enable extensions.
        ECHOCTL: 60,
        // Echo control characters as ^(Char).
        ECHOKE: 61,
        // Visual erase for line kill.
        PENDIN: 62,
        // Retype pending input.
        OPOST: 70,
        // Enable output processing.
        OLCUC: 71,
        // Convert lowercase to uppercase.
        ONLCR: 72,
        // Map NL to CR-NL.
        OCRNL: 73,
        // Translate carriage return to newline (output).
        ONOCR: 74,
        // Translate newline to carriage return-newline
        //  (output).
        ONLRET: 75,
        // Newline performs a carriage return (output).
        CS7: 90,
        // 7 bit mode.
        CS8: 91,
        // 8 bit mode.
        PARENB: 92,
        // Parity enable.
        PARODD: 93,
        // Odd parity, else even.
        TTY_OP_ISPEED: 128,
        // Specifies the input baud rate in bits per second.
        TTY_OP_OSPEED: 129
        // Specifies the output baud rate in bits per second.
      },
      CHANNEL_EXTENDED_DATATYPE: {
        STDERR: 1
      },
      SIGNALS: [
        "ABRT",
        "ALRM",
        "FPE",
        "HUP",
        "ILL",
        "INT",
        "QUIT",
        "SEGV",
        "TERM",
        "USR1",
        "USR2",
        "KILL",
        "PIPE"
      ].reduce((cur, val) => ({ ...cur, [val]: 1 }), {}),
      COMPAT,
      COMPAT_CHECKS: [
        ["Cisco-1.25", COMPAT.BAD_DHGEX],
        [/^Cisco-1[.]/, COMPAT.BUG_DHGEX_LARGE],
        [/^[0-9.]+$/, COMPAT.OLD_EXIT],
        // old SSH.com implementations
        [/^OpenSSH_5[.][0-9]+/, COMPAT.DYN_RPORT_BUG],
        [/^OpenSSH_7[.]4/, COMPAT.IMPLY_RSA_SHA2_SIGALGS]
      ],
      // KEX proposal-related
      DEFAULT_KEX,
      SUPPORTED_KEX,
      DEFAULT_SERVER_HOST_KEY,
      SUPPORTED_SERVER_HOST_KEY,
      DEFAULT_CIPHER,
      SUPPORTED_CIPHER,
      DEFAULT_MAC,
      SUPPORTED_MAC,
      DEFAULT_COMPRESSION,
      SUPPORTED_COMPRESSION,
      curve25519Supported,
      eddsaSupported
    };
    module2.exports.DISCONNECT_REASON_BY_VALUE = Array.from(Object.entries(module2.exports.DISCONNECT_REASON)).reduce((obj, [key, value]) => ({ ...obj, [value]: key }), {});
  }
});

// node_modules/ssh2/lib/protocol/utils.js
var require_utils5 = __commonJS({
  "node_modules/ssh2/lib/protocol/utils.js"(exports2, module2) {
    "use strict";
    var Ber = require_lib4().Ber, DISCONNECT_REASON, FastBuffer = Buffer[Symbol.species], TypedArrayFill = Object.getPrototypeOf(Uint8Array.prototype).fill;
    function readUInt32BE(buf, offset) {
      return buf[offset++] * 16777216 + buf[offset++] * 65536 + buf[offset++] * 256 + buf[offset];
    }
    function bufferCopy(src, dest, srcStart, srcEnd, destStart) {
      destStart || (destStart = 0), srcEnd > src.length && (srcEnd = src.length);
      let nb = srcEnd - srcStart, destLeft = dest.length - destStart;
      return nb > destLeft && (nb = destLeft), dest.set(
        new Uint8Array(src.buffer, src.byteOffset + srcStart, nb),
        destStart
      ), nb;
    }
    function bufferSlice(buf, start, end) {
      return end === void 0 && (end = buf.length), new FastBuffer(buf.buffer, buf.byteOffset + start, end - start);
    }
    function makeBufferParser() {
      let pos2 = 0, buffer, self2 = {
        init: (buf, start) => {
          buffer = buf, pos2 = typeof start == "number" ? start : 0;
        },
        pos: () => pos2,
        length: () => buffer ? buffer.length : 0,
        avail: () => buffer && pos2 < buffer.length ? buffer.length - pos2 : 0,
        clear: () => {
          buffer = void 0;
        },
        readUInt32BE: () => {
          if (!(!buffer || pos2 + 3 >= buffer.length))
            return buffer[pos2++] * 16777216 + buffer[pos2++] * 65536 + buffer[pos2++] * 256 + buffer[pos2++];
        },
        readUInt64BE: (behavior) => {
          if (!(!buffer || pos2 + 7 >= buffer.length))
            switch (behavior) {
              case "always":
                return BigInt(`0x${buffer.hexSlice(pos2, pos2 += 8)}`);
              case "maybe":
                if (buffer[pos2] > 31)
                  return BigInt(`0x${buffer.hexSlice(pos2, pos2 += 8)}`);
              // FALLTHROUGH
              default:
                return buffer[pos2++] * 72057594037927940 + buffer[pos2++] * 281474976710656 + buffer[pos2++] * 1099511627776 + buffer[pos2++] * 4294967296 + buffer[pos2++] * 16777216 + buffer[pos2++] * 65536 + buffer[pos2++] * 256 + buffer[pos2++];
            }
        },
        skip: (n) => {
          buffer && n > 0 && (pos2 += n);
        },
        skipString: () => {
          let len = self2.readUInt32BE();
          if (len !== void 0)
            return pos2 += len, pos2 <= buffer.length ? len : void 0;
        },
        readByte: () => {
          if (buffer && pos2 < buffer.length)
            return buffer[pos2++];
        },
        readBool: () => {
          if (buffer && pos2 < buffer.length)
            return !!buffer[pos2++];
        },
        readList: () => {
          let list2 = self2.readString(!0);
          if (list2 !== void 0)
            return list2 ? list2.split(",") : [];
        },
        readString: (dest, maxLen) => {
          typeof dest == "number" && (maxLen = dest, dest = void 0);
          let len = self2.readUInt32BE();
          if (len !== void 0 && !(buffer.length - pos2 < len || typeof maxLen == "number" && len > maxLen))
            return dest ? Buffer.isBuffer(dest) ? bufferCopy(buffer, dest, pos2, pos2 += len) : buffer.utf8Slice(pos2, pos2 += len) : bufferSlice(buffer, pos2, pos2 += len);
        },
        readRaw: (len) => {
          if (buffer) {
            if (typeof len != "number")
              return bufferSlice(buffer, pos2, pos2 += buffer.length - pos2);
            if (buffer.length - pos2 >= len)
              return bufferSlice(buffer, pos2, pos2 += len);
          }
        }
      };
      return self2;
    }
    function makeError(msg, level, fatal) {
      let err = new Error(msg);
      return typeof level == "boolean" ? (fatal = level, err.level = "protocol") : err.level = level || "protocol", err.fatal = !!fatal, err;
    }
    function writeUInt32BE(buf, value, offset) {
      return buf[offset++] = value >>> 24, buf[offset++] = value >>> 16, buf[offset++] = value >>> 8, buf[offset++] = value, offset;
    }
    var utilBufferParser = makeBufferParser();
    module2.exports = {
      bufferCopy,
      bufferSlice,
      FastBuffer,
      bufferFill: (buf, value, start, end) => TypedArrayFill.call(buf, value, start, end),
      makeError,
      doFatalError: (protocol, msg, level, reason) => {
        let err;
        return DISCONNECT_REASON === void 0 && ({ DISCONNECT_REASON } = require_constants6()), msg instanceof Error ? (err = msg, typeof level != "number" ? reason = DISCONNECT_REASON.PROTOCOL_ERROR : reason = level) : err = makeError(msg, level, !0), typeof reason != "number" && (reason = DISCONNECT_REASON.PROTOCOL_ERROR), protocol.disconnect(reason), protocol._destruct(), protocol._onError(err), 1 / 0;
      },
      readUInt32BE,
      writeUInt32BE,
      writeUInt32LE: (buf, value, offset) => (buf[offset++] = value, buf[offset++] = value >>> 8, buf[offset++] = value >>> 16, buf[offset++] = value >>> 24, offset),
      makeBufferParser,
      bufferParser: makeBufferParser(),
      readString: (buffer, start, dest, maxLen) => {
        typeof dest == "number" && (maxLen = dest, dest = void 0), start === void 0 && (start = 0);
        let left = buffer.length - start;
        if (start < 0 || start >= buffer.length || left < 4)
          return;
        let len = readUInt32BE(buffer, start);
        if (left < 4 + len || typeof maxLen == "number" && len > maxLen)
          return;
        start += 4;
        let end = start + len;
        return buffer._pos = end, dest ? Buffer.isBuffer(dest) ? bufferCopy(buffer, dest, start, end) : buffer.utf8Slice(start, end) : bufferSlice(buffer, start, end);
      },
      sigSSHToASN1: (sig, type) => {
        switch (type) {
          case "ssh-dss": {
            if (sig.length > 40)
              return sig;
            let asnWriter = new Ber.Writer();
            asnWriter.startSequence();
            let r = sig.slice(0, 20), s = sig.slice(20);
            if (r[0] & 128) {
              let rNew = Buffer.allocUnsafe(21);
              rNew[0] = 0, r.copy(rNew, 1), r = rNew;
            } else r[0] === 0 && !(r[1] & 128) && (r = r.slice(1));
            if (s[0] & 128) {
              let sNew = Buffer.allocUnsafe(21);
              sNew[0] = 0, s.copy(sNew, 1), s = sNew;
            } else s[0] === 0 && !(s[1] & 128) && (s = s.slice(1));
            return asnWriter.writeBuffer(r, Ber.Integer), asnWriter.writeBuffer(s, Ber.Integer), asnWriter.endSequence(), asnWriter.buffer;
          }
          case "ecdsa-sha2-nistp256":
          case "ecdsa-sha2-nistp384":
          case "ecdsa-sha2-nistp521": {
            utilBufferParser.init(sig, 0);
            let r = utilBufferParser.readString(), s = utilBufferParser.readString();
            if (utilBufferParser.clear(), r === void 0 || s === void 0)
              return;
            let asnWriter = new Ber.Writer();
            return asnWriter.startSequence(), asnWriter.writeBuffer(r, Ber.Integer), asnWriter.writeBuffer(s, Ber.Integer), asnWriter.endSequence(), asnWriter.buffer;
          }
          default:
            return sig;
        }
      },
      convertSignature: (signature, keyType) => {
        switch (keyType) {
          case "ssh-dss": {
            if (signature.length <= 40)
              return signature;
            let asnReader = new Ber.Reader(signature);
            asnReader.readSequence();
            let r = asnReader.readString(Ber.Integer, !0), s = asnReader.readString(Ber.Integer, !0), rOffset = 0, sOffset = 0;
            if (r.length < 20) {
              let rNew = Buffer.allocUnsafe(20);
              rNew.set(r, 1), r = rNew, r[0] = 0;
            }
            if (s.length < 20) {
              let sNew = Buffer.allocUnsafe(20);
              sNew.set(s, 1), s = sNew, s[0] = 0;
            }
            r.length > 20 && r[0] === 0 && (rOffset = 1), s.length > 20 && s[0] === 0 && (sOffset = 1);
            let newSig = Buffer.allocUnsafe(r.length - rOffset + (s.length - sOffset));
            return bufferCopy(r, newSig, rOffset, r.length, 0), bufferCopy(s, newSig, sOffset, s.length, r.length - rOffset), newSig;
          }
          case "ecdsa-sha2-nistp256":
          case "ecdsa-sha2-nistp384":
          case "ecdsa-sha2-nistp521": {
            if (signature[0] === 0)
              return signature;
            let asnReader = new Ber.Reader(signature);
            asnReader.readSequence();
            let r = asnReader.readString(Ber.Integer, !0), s = asnReader.readString(Ber.Integer, !0);
            if (r === null || s === null)
              return;
            let newSig = Buffer.allocUnsafe(4 + r.length + 4 + s.length);
            return writeUInt32BE(newSig, r.length, 0), newSig.set(r, 4), writeUInt32BE(newSig, s.length, 4 + r.length), newSig.set(s, 8 + r.length), newSig;
          }
        }
        return signature;
      },
      sendPacket: (proto, packet, bypass) => !bypass && proto._kexinit !== void 0 ? (proto._queue === void 0 && (proto._queue = []), proto._queue.push(packet), proto._debug && proto._debug("Outbound: ... packet queued"), !1) : (proto._cipher.encrypt(packet), !0)
    };
  }
});

// node_modules/ssh2/lib/protocol/crypto/build/Release/sshcrypto.node
var require_sshcrypto = __commonJS({
  "node_modules/ssh2/lib/protocol/crypto/build/Release/sshcrypto.node"(exports2, module2) {
    module2.exports = "./sshcrypto-JA32PPSG.node";
  }
});

// node_modules/ssh2/lib/protocol/crypto/poly1305.js
var require_poly1305 = __commonJS({
  "node_modules/ssh2/lib/protocol/crypto/poly1305.js"(exports2, module2) {
    var createPoly1305 = function() {
      var _scriptDir = typeof document < "u" && document.currentScript ? document.currentScript.src : void 0;
      return typeof __filename < "u" && (_scriptDir = _scriptDir || __filename), function(createPoly13052) {
        createPoly13052 = createPoly13052 || {};
        var b;
        b || (b = typeof createPoly13052 < "u" ? createPoly13052 : {});
        var q, r;
        b.ready = new Promise(function(a, c) {
          q = a, r = c;
        });
        var u = {}, w;
        for (w in b) b.hasOwnProperty(w) && (u[w] = b[w]);
        var x = typeof window == "object", y = typeof importScripts == "function", z = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string", B = "", C, D, E, F, G;
        z ? (B = y ? require("path").dirname(B) + "/" : __dirname + "/", C = function(a, c) {
          var d = H(a);
          return d ? c ? d : d.toString() : (F || (F = require("fs")), G || (G = require("path")), a = G.normalize(a), F.readFileSync(a, c ? null : "utf8"));
        }, E = function(a) {
          return a = C(a, !0), a.buffer || (a = new Uint8Array(a)), assert3(a.buffer), a;
        }, D = function(a, c, d) {
          var e = H(a);
          e && c(e), F || (F = require("fs")), G || (G = require("path")), a = G.normalize(a), F.readFile(a, function(f, l) {
            f ? d(f) : c(l.buffer);
          });
        }, 1 < process.argv.length && process.argv[1].replace(/\\/g, "/"), process.argv.slice(2), b.inspect = function() {
          return "[Emscripten Module object]";
        }) : (x || y) && (y ? B = self.location.href : typeof document < "u" && document.currentScript && (B = document.currentScript.src), _scriptDir && (B = _scriptDir), B.indexOf("blob:") !== 0 ? B = B.substr(0, B.lastIndexOf("/") + 1) : B = "", C = function(a) {
          try {
            var c = new XMLHttpRequest();
            return c.open("GET", a, !1), c.send(null), c.responseText;
          } catch (f) {
            if (a = H(a)) {
              c = [];
              for (var d = 0; d < a.length; d++) {
                var e = a[d];
                255 < e && (ba && assert3(!1, "Character code " + e + " (" + String.fromCharCode(e) + ")  at offset " + d + " not in 0x00-0xFF."), e &= 255), c.push(String.fromCharCode(e));
              }
              return c.join("");
            }
            throw f;
          }
        }, y && (E = function(a) {
          try {
            var c = new XMLHttpRequest();
            return c.open("GET", a, !1), c.responseType = "arraybuffer", c.send(null), new Uint8Array(c.response);
          } catch (d) {
            if (a = H(a)) return a;
            throw d;
          }
        }), D = function(a, c, d) {
          var e = new XMLHttpRequest();
          e.open("GET", a, !0), e.responseType = "arraybuffer", e.onload = function() {
            if (e.status == 200 || e.status == 0 && e.response) c(e.response);
            else {
              var f = H(a);
              f ? c(f.buffer) : d();
            }
          }, e.onerror = d, e.send(null);
        }), b.print || console.log.bind(console);
        var I = b.printErr || console.warn.bind(console);
        for (w in u) u.hasOwnProperty(w) && (b[w] = u[w]);
        u = null;
        var J;
        b.wasmBinary && (J = b.wasmBinary);
        var noExitRuntime = b.noExitRuntime || !0;
        typeof WebAssembly != "object" && K("no native wasm support detected");
        var L, M = !1;
        function assert3(a, c) {
          a || K("Assertion failed: " + c);
        }
        function N(a) {
          var c = b["_" + a];
          return assert3(c, "Cannot call unknown function " + a + ", make sure it is exported"), c;
        }
        function ca(a, c, d, e) {
          var f = { string: function(g) {
            var p = 0;
            if (g != null && g !== 0) {
              var n = (g.length << 2) + 1;
              p = O(n);
              var k = p, h = P;
              if (0 < n) {
                n = k + n - 1;
                for (var v = 0; v < g.length; ++v) {
                  var m = g.charCodeAt(v);
                  if (55296 <= m && 57343 >= m) {
                    var oa = g.charCodeAt(++v);
                    m = 65536 + ((m & 1023) << 10) | oa & 1023;
                  }
                  if (127 >= m) {
                    if (k >= n) break;
                    h[k++] = m;
                  } else {
                    if (2047 >= m) {
                      if (k + 1 >= n) break;
                      h[k++] = 192 | m >> 6;
                    } else {
                      if (65535 >= m) {
                        if (k + 2 >= n) break;
                        h[k++] = 224 | m >> 12;
                      } else {
                        if (k + 3 >= n) break;
                        h[k++] = 240 | m >> 18, h[k++] = 128 | m >> 12 & 63;
                      }
                      h[k++] = 128 | m >> 6 & 63;
                    }
                    h[k++] = 128 | m & 63;
                  }
                }
                h[k] = 0;
              }
            }
            return p;
          }, array: function(g) {
            var p = O(g.length);
            return Q.set(g, p), p;
          } }, l = N(a), A = [];
          if (a = 0, e) for (var t = 0; t < e.length; t++) {
            var aa = f[d[t]];
            aa ? (a === 0 && (a = da()), A[t] = aa(e[t])) : A[t] = e[t];
          }
          return d = l.apply(null, A), d = function(g) {
            if (c === "string") if (g) {
              for (var p = P, n = g + NaN, k = g; p[k] && !(k >= n); ) ++k;
              if (16 < k - g && p.subarray && ea) g = ea.decode(p.subarray(g, k));
              else {
                for (n = ""; g < k; ) {
                  var h = p[g++];
                  if (h & 128) {
                    var v = p[g++] & 63;
                    if ((h & 224) == 192) n += String.fromCharCode((h & 31) << 6 | v);
                    else {
                      var m = p[g++] & 63;
                      h = (h & 240) == 224 ? (h & 15) << 12 | v << 6 | m : (h & 7) << 18 | v << 12 | m << 6 | p[g++] & 63, 65536 > h ? n += String.fromCharCode(h) : (h -= 65536, n += String.fromCharCode(55296 | h >> 10, 56320 | h & 1023));
                    }
                  } else n += String.fromCharCode(h);
                }
                g = n;
              }
            } else g = "";
            else g = c === "boolean" ? !!g : g;
            return g;
          }(d), a !== 0 && fa(a), d;
        }
        var ea = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0, ha, Q, P;
        function ia() {
          var a = L.buffer;
          ha = a, b.HEAP8 = Q = new Int8Array(a), b.HEAP16 = new Int16Array(a), b.HEAP32 = new Int32Array(a), b.HEAPU8 = P = new Uint8Array(a), b.HEAPU16 = new Uint16Array(a), b.HEAPU32 = new Uint32Array(a), b.HEAPF32 = new Float32Array(a), b.HEAPF64 = new Float64Array(a);
        }
        var R, ja = [], ka = [], la = [];
        function ma() {
          var a = b.preRun.shift();
          ja.unshift(a);
        }
        var S = 0, T = null, U = null;
        b.preloadedImages = {}, b.preloadedAudios = {};
        function K(a) {
          throw b.onAbort && b.onAbort(a), I(a), M = !0, a = new WebAssembly.RuntimeError("abort(" + a + "). Build with -s ASSERTIONS=1 for more info."), r(a), a;
        }
        var V = "data:application/octet-stream;base64,", W;
        if (W = "data:application/octet-stream;base64,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", !W.startsWith(V)) {
          var na = W;
          W = b.locateFile ? b.locateFile(na, B) : B + na;
        }
        function pa() {
          var a = W;
          try {
            if (a == W && J) return new Uint8Array(J);
            var c = H(a);
            if (c) return c;
            if (E) return E(a);
            throw "both async and sync fetching of the wasm failed";
          } catch (d) {
            K(d);
          }
        }
        function qa() {
          if (!J && (x || y)) {
            if (typeof fetch == "function" && !W.startsWith("file://")) return fetch(W, { credentials: "same-origin" }).then(function(a) {
              if (!a.ok) throw "failed to load wasm binary file at '" + W + "'";
              return a.arrayBuffer();
            }).catch(function() {
              return pa();
            });
            if (D) return new Promise(function(a, c) {
              D(W, function(d) {
                a(new Uint8Array(d));
              }, c);
            });
          }
          return Promise.resolve().then(function() {
            return pa();
          });
        }
        function X(a) {
          for (; 0 < a.length; ) {
            var c = a.shift();
            if (typeof c == "function") c(b);
            else {
              var d = c.m;
              typeof d == "number" ? c.l === void 0 ? R.get(d)() : R.get(d)(c.l) : d(c.l === void 0 ? null : c.l);
            }
          }
        }
        var ba = !1, ra = typeof atob == "function" ? atob : function(a) {
          var c = "", d = 0;
          a = a.replace(/[^A-Za-z0-9\+\/=]/g, "");
          do {
            var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(d++)), f = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(d++)), l = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(d++)), A = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(d++));
            e = e << 2 | f >> 4, f = (f & 15) << 4 | l >> 2;
            var t = (l & 3) << 6 | A;
            c += String.fromCharCode(e), l !== 64 && (c += String.fromCharCode(f)), A !== 64 && (c += String.fromCharCode(t));
          } while (d < a.length);
          return c;
        };
        function H(a) {
          if (a.startsWith(V)) {
            if (a = a.slice(V.length), typeof z == "boolean" && z) {
              var c = Buffer.from(a, "base64");
              c = new Uint8Array(c.buffer, c.byteOffset, c.byteLength);
            } else try {
              var d = ra(a), e = new Uint8Array(d.length);
              for (a = 0; a < d.length; ++a) e[a] = d.charCodeAt(a);
              c = e;
            } catch {
              throw Error("Converting base64 string to bytes failed.");
            }
            return c;
          }
        }
        var sa = { a: function(a) {
          var c = P.length;
          if (a >>>= 0, 2147483648 < a) return !1;
          for (var d = 1; 4 >= d; d *= 2) {
            var e = c * (1 + 0.2 / d);
            e = Math.min(e, a + 100663296), e = Math.max(a, e), 0 < e % 65536 && (e += 65536 - e % 65536);
            a: {
              try {
                L.grow(Math.min(2147483648, e) - ha.byteLength + 65535 >>> 16), ia();
                var f = 1;
                break a;
              } catch {
              }
              f = void 0;
            }
            if (f) return !0;
          }
          return !1;
        } };
        (function() {
          function a(f) {
            b.asm = f.exports, L = b.asm.b, ia(), R = b.asm.j, ka.unshift(b.asm.c), S--, b.monitorRunDependencies && b.monitorRunDependencies(S), S == 0 && (T !== null && (clearInterval(T), T = null), U && (f = U, U = null, f()));
          }
          function c(f) {
            a(f.instance);
          }
          function d(f) {
            return qa().then(function(l) {
              return WebAssembly.instantiate(l, e);
            }).then(f, function(l) {
              I("failed to asynchronously prepare wasm: " + l), K(l);
            });
          }
          var e = { a: sa };
          if (S++, b.monitorRunDependencies && b.monitorRunDependencies(S), b.instantiateWasm) try {
            return b.instantiateWasm(
              e,
              a
            );
          } catch (f) {
            return I("Module.instantiateWasm callback failed with error: " + f), !1;
          }
          return function() {
            return J || typeof WebAssembly.instantiateStreaming != "function" || W.startsWith(V) || W.startsWith("file://") || typeof fetch != "function" ? d(c) : fetch(W, { credentials: "same-origin" }).then(function(f) {
              return WebAssembly.instantiateStreaming(f, e).then(c, function(l) {
                return I("wasm streaming compile failed: " + l), I("falling back to ArrayBuffer instantiation"), d(c);
              });
            });
          }().catch(r), {};
        })(), b.___wasm_call_ctors = function() {
          return (b.___wasm_call_ctors = b.asm.c).apply(null, arguments);
        }, b._poly1305_auth = function() {
          return (b._poly1305_auth = b.asm.d).apply(null, arguments);
        };
        var da = b.stackSave = function() {
          return (da = b.stackSave = b.asm.e).apply(null, arguments);
        }, fa = b.stackRestore = function() {
          return (fa = b.stackRestore = b.asm.f).apply(null, arguments);
        }, O = b.stackAlloc = function() {
          return (O = b.stackAlloc = b.asm.g).apply(null, arguments);
        };
        b._malloc = function() {
          return (b._malloc = b.asm.h).apply(null, arguments);
        }, b._free = function() {
          return (b._free = b.asm.i).apply(null, arguments);
        }, b.cwrap = function(a, c, d, e) {
          d = d || [];
          var f = d.every(function(l) {
            return l === "number";
          });
          return c !== "string" && f && !e ? N(a) : function() {
            return ca(a, c, d, arguments);
          };
        };
        var Y;
        U = function ta() {
          Y || Z(), Y || (U = ta);
        };
        function Z() {
          function a() {
            if (!Y && (Y = !0, b.calledRun = !0, !M)) {
              if (X(ka), q(b), b.onRuntimeInitialized && b.onRuntimeInitialized(), b.postRun) for (typeof b.postRun == "function" && (b.postRun = [b.postRun]); b.postRun.length; ) {
                var c = b.postRun.shift();
                la.unshift(c);
              }
              X(la);
            }
          }
          if (!(0 < S)) {
            if (b.preRun) for (typeof b.preRun == "function" && (b.preRun = [b.preRun]); b.preRun.length; ) ma();
            X(ja), 0 < S || (b.setStatus ? (b.setStatus("Running..."), setTimeout(function() {
              setTimeout(function() {
                b.setStatus("");
              }, 1), a();
            }, 1)) : a());
          }
        }
        if (b.run = Z, b.preInit) for (typeof b.preInit == "function" && (b.preInit = [b.preInit]); 0 < b.preInit.length; ) b.preInit.pop()();
        return Z(), createPoly13052.ready;
      };
    }();
    typeof exports2 == "object" && typeof module2 == "object" ? module2.exports = createPoly1305 : typeof define == "function" && define.amd ? define([], function() {
      return createPoly1305;
    }) : typeof exports2 == "object" && (exports2.createPoly1305 = createPoly1305);
  }
});

// node_modules/ssh2/lib/protocol/crypto.js
var require_crypto = __commonJS({
  "node_modules/ssh2/lib/protocol/crypto.js"(exports2, module2) {
    "use strict";
    var {
      createCipheriv,
      createDecipheriv,
      createHmac,
      randomFillSync,
      timingSafeEqual
    } = require("crypto"), { readUInt32BE, writeUInt32BE } = require_utils5(), FastBuffer = Buffer[Symbol.species], MAX_SEQNO = 2 ** 32 - 1, EMPTY_BUFFER = Buffer.alloc(0), BUF_INT = Buffer.alloc(4), DISCARD_CACHE = /* @__PURE__ */ new Map(), MAX_PACKET_SIZE = 35e3, binding, AESGCMCipher, ChaChaPolyCipher, GenericCipher, AESGCMDecipher, ChaChaPolyDecipher, GenericDecipher;
    try {
      binding = require_sshcrypto(), {
        AESGCMCipher,
        ChaChaPolyCipher,
        GenericCipher,
        AESGCMDecipher,
        ChaChaPolyDecipher,
        GenericDecipher
      } = binding;
    } catch {
    }
    var CIPHER_STREAM = 1, CIPHER_INFO = (() => {
      function info(sslName, blockLen, keyLen, ivLen, authLen, discardLen, flags) {
        return {
          sslName,
          blockLen,
          keyLen,
          ivLen: ivLen !== 0 || flags & CIPHER_STREAM ? ivLen : blockLen,
          authLen,
          discardLen,
          stream: !!(flags & CIPHER_STREAM)
        };
      }
      return {
        "chacha20-poly1305@openssh.com": info("chacha20", 8, 64, 0, 16, 0, CIPHER_STREAM),
        "aes128-gcm": info("aes-128-gcm", 16, 16, 12, 16, 0, CIPHER_STREAM),
        "aes256-gcm": info("aes-256-gcm", 16, 32, 12, 16, 0, CIPHER_STREAM),
        "aes128-gcm@openssh.com": info("aes-128-gcm", 16, 16, 12, 16, 0, CIPHER_STREAM),
        "aes256-gcm@openssh.com": info("aes-256-gcm", 16, 32, 12, 16, 0, CIPHER_STREAM),
        "aes128-cbc": info("aes-128-cbc", 16, 16, 0, 0, 0, 0),
        "aes192-cbc": info("aes-192-cbc", 16, 24, 0, 0, 0, 0),
        "aes256-cbc": info("aes-256-cbc", 16, 32, 0, 0, 0, 0),
        "rijndael-cbc@lysator.liu.se": info("aes-256-cbc", 16, 32, 0, 0, 0, 0),
        "3des-cbc": info("des-ede3-cbc", 8, 24, 0, 0, 0, 0),
        "blowfish-cbc": info("bf-cbc", 8, 16, 0, 0, 0, 0),
        "idea-cbc": info("idea-cbc", 8, 16, 0, 0, 0, 0),
        "cast128-cbc": info("cast-cbc", 8, 16, 0, 0, 0, 0),
        "aes128-ctr": info("aes-128-ctr", 16, 16, 16, 0, 0, CIPHER_STREAM),
        "aes192-ctr": info("aes-192-ctr", 16, 24, 16, 0, 0, CIPHER_STREAM),
        "aes256-ctr": info("aes-256-ctr", 16, 32, 16, 0, 0, CIPHER_STREAM),
        "3des-ctr": info("des-ede3", 8, 24, 8, 0, 0, CIPHER_STREAM),
        "blowfish-ctr": info("bf-ecb", 8, 16, 8, 0, 0, CIPHER_STREAM),
        "cast128-ctr": info("cast5-ecb", 8, 16, 8, 0, 0, CIPHER_STREAM),
        /* The "arcfour128" algorithm is the RC4 cipher, as described in
               [SCHNEIER], using a 128-bit key.  The first 1536 bytes of keystream
               generated by the cipher MUST be discarded, and the first byte of the
               first encrypted packet MUST be encrypted using the 1537th byte of
               keystream.
        
               -- http://tools.ietf.org/html/rfc4345#section-4 */
        arcfour: info("rc4", 8, 16, 0, 0, 1536, CIPHER_STREAM),
        arcfour128: info("rc4", 8, 16, 0, 0, 1536, CIPHER_STREAM),
        arcfour256: info("rc4", 8, 32, 0, 0, 1536, CIPHER_STREAM),
        arcfour512: info("rc4", 8, 64, 0, 0, 1536, CIPHER_STREAM)
      };
    })(), MAC_INFO = (() => {
      function info(sslName, len, actualLen, isETM) {
        return {
          sslName,
          len,
          actualLen,
          isETM
        };
      }
      return {
        "hmac-md5": info("md5", 16, 16, !1),
        "hmac-md5-96": info("md5", 16, 12, !1),
        "hmac-ripemd160": info("ripemd160", 20, 20, !1),
        "hmac-sha1": info("sha1", 20, 20, !1),
        "hmac-sha1-etm@openssh.com": info("sha1", 20, 20, !0),
        "hmac-sha1-96": info("sha1", 20, 12, !1),
        "hmac-sha2-256": info("sha256", 32, 32, !1),
        "hmac-sha2-256-etm@openssh.com": info("sha256", 32, 32, !0),
        "hmac-sha2-256-96": info("sha256", 32, 12, !1),
        "hmac-sha2-512": info("sha512", 64, 64, !1),
        "hmac-sha2-512-etm@openssh.com": info("sha512", 64, 64, !0),
        "hmac-sha2-512-96": info("sha512", 64, 12, !1)
      };
    })(), NullCipher = class {
      constructor(seqno, onWrite) {
        this.outSeqno = seqno, this._onWrite = onWrite, this._dead = !1;
      }
      free() {
        this._dead = !0;
      }
      allocPacket(payloadLen) {
        let pktLen = 5 + payloadLen, padLen = 8 - (pktLen & 7);
        padLen < 4 && (padLen += 8), pktLen += padLen;
        let packet = Buffer.allocUnsafe(pktLen);
        return writeUInt32BE(packet, pktLen - 4, 0), packet[4] = padLen, randomFillSync(packet, 5 + payloadLen, padLen), packet;
      }
      encrypt(packet) {
        this._dead || (this._onWrite(packet), this.outSeqno = this.outSeqno + 1 >>> 0);
      }
    }, POLY1305_ZEROS = Buffer.alloc(32), POLY1305_OUT_COMPUTE = Buffer.alloc(16), POLY1305_WASM_MODULE, POLY1305_RESULT_MALLOC, poly1305_auth, ChaChaPolyCipherNative = class {
      constructor(config) {
        let enc = config.outbound;
        this.outSeqno = enc.seqno, this._onWrite = enc.onWrite, this._encKeyMain = enc.cipherKey.slice(0, 32), this._encKeyPktLen = enc.cipherKey.slice(32), this._dead = !1;
      }
      free() {
        this._dead = !0;
      }
      allocPacket(payloadLen) {
        let pktLen = 5 + payloadLen, padLen = 8 - (pktLen - 4 & 7);
        padLen < 4 && (padLen += 8), pktLen += padLen;
        let packet = Buffer.allocUnsafe(pktLen);
        return writeUInt32BE(packet, pktLen - 4, 0), packet[4] = padLen, randomFillSync(packet, 5 + payloadLen, padLen), packet;
      }
      encrypt(packet) {
        if (this._dead)
          return;
        POLY1305_OUT_COMPUTE[0] = 0, writeUInt32BE(POLY1305_OUT_COMPUTE, this.outSeqno, 12);
        let polyKey = createCipheriv("chacha20", this._encKeyMain, POLY1305_OUT_COMPUTE).update(POLY1305_ZEROS), pktLenEnc = createCipheriv("chacha20", this._encKeyPktLen, POLY1305_OUT_COMPUTE).update(packet.slice(0, 4));
        this._onWrite(pktLenEnc), POLY1305_OUT_COMPUTE[0] = 1;
        let payloadEnc = createCipheriv("chacha20", this._encKeyMain, POLY1305_OUT_COMPUTE).update(packet.slice(4));
        this._onWrite(payloadEnc), poly1305_auth(
          POLY1305_RESULT_MALLOC,
          pktLenEnc,
          pktLenEnc.length,
          payloadEnc,
          payloadEnc.length,
          polyKey
        );
        let mac = Buffer.allocUnsafe(16);
        mac.set(
          new Uint8Array(
            POLY1305_WASM_MODULE.HEAPU8.buffer,
            POLY1305_RESULT_MALLOC,
            16
          ),
          0
        ), this._onWrite(mac), this.outSeqno = this.outSeqno + 1 >>> 0;
      }
    }, ChaChaPolyCipherBinding = class {
      constructor(config) {
        let enc = config.outbound;
        this.outSeqno = enc.seqno, this._onWrite = enc.onWrite, this._instance = new ChaChaPolyCipher(enc.cipherKey), this._dead = !1;
      }
      free() {
        this._dead = !0, this._instance.free();
      }
      allocPacket(payloadLen) {
        let pktLen = 5 + payloadLen, padLen = 8 - (pktLen - 4 & 7);
        padLen < 4 && (padLen += 8), pktLen += padLen;
        let packet = Buffer.allocUnsafe(
          pktLen + 16
          /* MAC */
        );
        return writeUInt32BE(packet, pktLen - 4, 0), packet[4] = padLen, randomFillSync(packet, 5 + payloadLen, padLen), packet;
      }
      encrypt(packet) {
        this._dead || (this._instance.encrypt(packet, this.outSeqno), this._onWrite(packet), this.outSeqno = this.outSeqno + 1 >>> 0);
      }
    }, AESGCMCipherNative = class {
      constructor(config) {
        let enc = config.outbound;
        this.outSeqno = enc.seqno, this._onWrite = enc.onWrite, this._encSSLName = enc.cipherInfo.sslName, this._encKey = enc.cipherKey, this._encIV = enc.cipherIV, this._dead = !1;
      }
      free() {
        this._dead = !0;
      }
      allocPacket(payloadLen) {
        let pktLen = 5 + payloadLen, padLen = 16 - (pktLen - 4 & 15);
        padLen < 4 && (padLen += 16), pktLen += padLen;
        let packet = Buffer.allocUnsafe(pktLen);
        return writeUInt32BE(packet, pktLen - 4, 0), packet[4] = padLen, randomFillSync(packet, 5 + payloadLen, padLen), packet;
      }
      encrypt(packet) {
        if (this._dead)
          return;
        let cipher = createCipheriv(this._encSSLName, this._encKey, this._encIV);
        cipher.setAutoPadding(!1);
        let lenData = packet.slice(0, 4);
        cipher.setAAD(lenData), this._onWrite(lenData);
        let encrypted = cipher.update(packet.slice(4));
        this._onWrite(encrypted);
        let final = cipher.final();
        final.length && this._onWrite(final);
        let tag = cipher.getAuthTag();
        this._onWrite(tag), ivIncrement(this._encIV), this.outSeqno = this.outSeqno + 1 >>> 0;
      }
    }, AESGCMCipherBinding = class {
      constructor(config) {
        let enc = config.outbound;
        this.outSeqno = enc.seqno, this._onWrite = enc.onWrite, this._instance = new AESGCMCipher(
          enc.cipherInfo.sslName,
          enc.cipherKey,
          enc.cipherIV
        ), this._dead = !1;
      }
      free() {
        this._dead = !0, this._instance.free();
      }
      allocPacket(payloadLen) {
        let pktLen = 5 + payloadLen, padLen = 16 - (pktLen - 4 & 15);
        padLen < 4 && (padLen += 16), pktLen += padLen;
        let packet = Buffer.allocUnsafe(
          pktLen + 16
          /* authTag */
        );
        return writeUInt32BE(packet, pktLen - 4, 0), packet[4] = padLen, randomFillSync(packet, 5 + payloadLen, padLen), packet;
      }
      encrypt(packet) {
        this._dead || (this._instance.encrypt(packet), this._onWrite(packet), this.outSeqno = this.outSeqno + 1 >>> 0);
      }
    }, GenericCipherNative = class {
      constructor(config) {
        let enc = config.outbound;
        this.outSeqno = enc.seqno, this._onWrite = enc.onWrite, this._encBlockLen = enc.cipherInfo.blockLen, this._cipherInstance = createCipheriv(
          enc.cipherInfo.sslName,
          enc.cipherKey,
          enc.cipherIV
        ), this._macSSLName = enc.macInfo.sslName, this._macKey = enc.macKey, this._macActualLen = enc.macInfo.actualLen, this._macETM = enc.macInfo.isETM, this._aadLen = this._macETM ? 4 : 0, this._dead = !1;
        let discardLen = enc.cipherInfo.discardLen;
        if (discardLen) {
          let discard = DISCARD_CACHE.get(discardLen);
          discard === void 0 && (discard = Buffer.alloc(discardLen), DISCARD_CACHE.set(discardLen, discard)), this._cipherInstance.update(discard);
        }
      }
      free() {
        this._dead = !0;
      }
      allocPacket(payloadLen) {
        let blockLen = this._encBlockLen, pktLen = 5 + payloadLen, padLen = blockLen - (pktLen - this._aadLen & blockLen - 1);
        padLen < 4 && (padLen += blockLen), pktLen += padLen;
        let packet = Buffer.allocUnsafe(pktLen);
        return writeUInt32BE(packet, pktLen - 4, 0), packet[4] = padLen, randomFillSync(packet, 5 + payloadLen, padLen), packet;
      }
      encrypt(packet) {
        if (this._dead)
          return;
        let mac;
        if (this._macETM) {
          let lenBytes = new Uint8Array(packet.buffer, packet.byteOffset, 4), encrypted = this._cipherInstance.update(
            new Uint8Array(
              packet.buffer,
              packet.byteOffset + 4,
              packet.length - 4
            )
          );
          this._onWrite(lenBytes), this._onWrite(encrypted), mac = createHmac(this._macSSLName, this._macKey), writeUInt32BE(BUF_INT, this.outSeqno, 0), mac.update(BUF_INT), mac.update(lenBytes), mac.update(encrypted);
        } else {
          let encrypted = this._cipherInstance.update(packet);
          this._onWrite(encrypted), mac = createHmac(this._macSSLName, this._macKey), writeUInt32BE(BUF_INT, this.outSeqno, 0), mac.update(BUF_INT), mac.update(packet);
        }
        let digest = mac.digest();
        digest.length > this._macActualLen && (digest = digest.slice(0, this._macActualLen)), this._onWrite(digest), this.outSeqno = this.outSeqno + 1 >>> 0;
      }
    }, GenericCipherBinding = class {
      constructor(config) {
        let enc = config.outbound;
        this.outSeqno = enc.seqno, this._onWrite = enc.onWrite, this._encBlockLen = enc.cipherInfo.blockLen, this._macLen = enc.macInfo.len, this._macActualLen = enc.macInfo.actualLen, this._aadLen = enc.macInfo.isETM ? 4 : 0, this._instance = new GenericCipher(
          enc.cipherInfo.sslName,
          enc.cipherKey,
          enc.cipherIV,
          enc.macInfo.sslName,
          enc.macKey,
          enc.macInfo.isETM
        ), this._dead = !1;
      }
      free() {
        this._dead = !0, this._instance.free();
      }
      allocPacket(payloadLen) {
        let blockLen = this._encBlockLen, pktLen = 5 + payloadLen, padLen = blockLen - (pktLen - this._aadLen & blockLen - 1);
        padLen < 4 && (padLen += blockLen), pktLen += padLen;
        let packet = Buffer.allocUnsafe(pktLen + this._macLen);
        return writeUInt32BE(packet, pktLen - 4, 0), packet[4] = padLen, randomFillSync(packet, 5 + payloadLen, padLen), packet;
      }
      encrypt(packet) {
        this._dead || (this._instance.encrypt(packet, this.outSeqno), this._macActualLen < this._macLen && (packet = new FastBuffer(
          packet.buffer,
          packet.byteOffset,
          packet.length - (this._macLen - this._macActualLen)
        )), this._onWrite(packet), this.outSeqno = this.outSeqno + 1 >>> 0);
      }
    }, NullDecipher = class {
      constructor(seqno, onPayload) {
        this.inSeqno = seqno, this._onPayload = onPayload, this._len = 0, this._lenBytes = 0, this._packet = null, this._packetPos = 0;
      }
      free() {
      }
      decrypt(data, p, dataLen) {
        for (; p < dataLen; ) {
          if (this._lenBytes < 4) {
            let nb = Math.min(4 - this._lenBytes, dataLen - p);
            for (this._lenBytes += nb; nb--; )
              this._len = (this._len << 8) + data[p++];
            if (this._lenBytes < 4)
              return;
            if (this._len > MAX_PACKET_SIZE || this._len < 8 || 4 + this._len & 7)
              throw new Error("Bad packet length");
            if (p >= dataLen)
              return;
          }
          if (this._packetPos < this._len) {
            let nb = Math.min(this._len - this._packetPos, dataLen - p), chunk;
            if (p !== 0 || nb !== dataLen ? chunk = new Uint8Array(data.buffer, data.byteOffset + p, nb) : chunk = data, nb === this._len ? this._packet = chunk : (this._packet || (this._packet = Buffer.allocUnsafe(this._len)), this._packet.set(chunk, this._packetPos)), p += nb, this._packetPos += nb, this._packetPos < this._len)
              return;
          }
          let payload = this._packet ? new FastBuffer(
            this._packet.buffer,
            this._packet.byteOffset + 1,
            this._packet.length - this._packet[0] - 1
          ) : EMPTY_BUFFER;
          this.inSeqno = this.inSeqno + 1 >>> 0, this._len = 0, this._lenBytes = 0, this._packet = null, this._packetPos = 0;
          {
            let ret = this._onPayload(payload);
            if (ret !== void 0)
              return ret === !1 ? p : ret;
          }
        }
      }
    }, ChaChaPolyDecipherNative = class {
      constructor(config) {
        let dec = config.inbound;
        this.inSeqno = dec.seqno, this._onPayload = dec.onPayload, this._decKeyMain = dec.decipherKey.slice(0, 32), this._decKeyPktLen = dec.decipherKey.slice(32), this._len = 0, this._lenBuf = Buffer.alloc(4), this._lenPos = 0, this._packet = null, this._pktLen = 0, this._mac = Buffer.allocUnsafe(16), this._calcMac = Buffer.allocUnsafe(16), this._macPos = 0;
      }
      free() {
      }
      decrypt(data, p, dataLen) {
        for (; p < dataLen; ) {
          if (this._lenPos < 4) {
            let nb = Math.min(4 - this._lenPos, dataLen - p);
            for (; nb--; )
              this._lenBuf[this._lenPos++] = data[p++];
            if (this._lenPos < 4)
              return;
            POLY1305_OUT_COMPUTE[0] = 0, writeUInt32BE(POLY1305_OUT_COMPUTE, this.inSeqno, 12);
            let decLenBytes = createDecipheriv("chacha20", this._decKeyPktLen, POLY1305_OUT_COMPUTE).update(this._lenBuf);
            if (this._len = readUInt32BE(decLenBytes, 0), this._len > MAX_PACKET_SIZE || this._len < 8 || this._len & 7)
              throw new Error("Bad packet length");
          }
          if (this._pktLen < this._len) {
            if (p >= dataLen)
              return;
            let nb = Math.min(this._len - this._pktLen, dataLen - p), encrypted;
            if (p !== 0 || nb !== dataLen ? encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb) : encrypted = data, nb === this._len ? this._packet = encrypted : (this._packet || (this._packet = Buffer.allocUnsafe(this._len)), this._packet.set(encrypted, this._pktLen)), p += nb, this._pktLen += nb, this._pktLen < this._len || p >= dataLen)
              return;
          }
          {
            let nb = Math.min(16 - this._macPos, dataLen - p);
            if (p !== 0 || nb !== dataLen ? this._mac.set(
              new Uint8Array(data.buffer, data.byteOffset + p, nb),
              this._macPos
            ) : this._mac.set(data, this._macPos), p += nb, this._macPos += nb, this._macPos < 16)
              return;
          }
          POLY1305_OUT_COMPUTE[0] = 0, writeUInt32BE(POLY1305_OUT_COMPUTE, this.inSeqno, 12);
          let polyKey = createCipheriv("chacha20", this._decKeyMain, POLY1305_OUT_COMPUTE).update(POLY1305_ZEROS);
          if (poly1305_auth(
            POLY1305_RESULT_MALLOC,
            this._lenBuf,
            4,
            this._packet,
            this._packet.length,
            polyKey
          ), this._calcMac.set(
            new Uint8Array(
              POLY1305_WASM_MODULE.HEAPU8.buffer,
              POLY1305_RESULT_MALLOC,
              16
            ),
            0
          ), !timingSafeEqual(this._calcMac, this._mac))
            throw new Error("Invalid MAC");
          POLY1305_OUT_COMPUTE[0] = 1;
          let packet = createDecipheriv("chacha20", this._decKeyMain, POLY1305_OUT_COMPUTE).update(this._packet), payload = new FastBuffer(
            packet.buffer,
            packet.byteOffset + 1,
            packet.length - packet[0] - 1
          );
          this.inSeqno = this.inSeqno + 1 >>> 0, this._len = 0, this._lenPos = 0, this._packet = null, this._pktLen = 0, this._macPos = 0;
          {
            let ret = this._onPayload(payload);
            if (ret !== void 0)
              return ret === !1 ? p : ret;
          }
        }
      }
    }, ChaChaPolyDecipherBinding = class {
      constructor(config) {
        let dec = config.inbound;
        this.inSeqno = dec.seqno, this._onPayload = dec.onPayload, this._instance = new ChaChaPolyDecipher(dec.decipherKey), this._len = 0, this._lenBuf = Buffer.alloc(4), this._lenPos = 0, this._packet = null, this._pktLen = 0, this._mac = Buffer.allocUnsafe(16), this._macPos = 0;
      }
      free() {
        this._instance.free();
      }
      decrypt(data, p, dataLen) {
        for (; p < dataLen; ) {
          if (this._lenPos < 4) {
            let nb = Math.min(4 - this._lenPos, dataLen - p);
            for (; nb--; )
              this._lenBuf[this._lenPos++] = data[p++];
            if (this._lenPos < 4)
              return;
            if (this._len = this._instance.decryptLen(this._lenBuf, this.inSeqno), this._len > MAX_PACKET_SIZE || this._len < 8 || this._len & 7)
              throw new Error("Bad packet length");
            if (p >= dataLen)
              return;
          }
          if (this._pktLen < this._len) {
            let nb = Math.min(this._len - this._pktLen, dataLen - p), encrypted;
            if (p !== 0 || nb !== dataLen ? encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb) : encrypted = data, nb === this._len ? this._packet = encrypted : (this._packet || (this._packet = Buffer.allocUnsafe(this._len)), this._packet.set(encrypted, this._pktLen)), p += nb, this._pktLen += nb, this._pktLen < this._len || p >= dataLen)
              return;
          }
          {
            let nb = Math.min(16 - this._macPos, dataLen - p);
            if (p !== 0 || nb !== dataLen ? this._mac.set(
              new Uint8Array(data.buffer, data.byteOffset + p, nb),
              this._macPos
            ) : this._mac.set(data, this._macPos), p += nb, this._macPos += nb, this._macPos < 16)
              return;
          }
          this._instance.decrypt(this._packet, this._mac, this.inSeqno);
          let payload = new FastBuffer(
            this._packet.buffer,
            this._packet.byteOffset + 1,
            this._packet.length - this._packet[0] - 1
          );
          this.inSeqno = this.inSeqno + 1 >>> 0, this._len = 0, this._lenPos = 0, this._packet = null, this._pktLen = 0, this._macPos = 0;
          {
            let ret = this._onPayload(payload);
            if (ret !== void 0)
              return ret === !1 ? p : ret;
          }
        }
      }
    }, AESGCMDecipherNative = class {
      constructor(config) {
        let dec = config.inbound;
        this.inSeqno = dec.seqno, this._onPayload = dec.onPayload, this._decipherInstance = null, this._decipherSSLName = dec.decipherInfo.sslName, this._decipherKey = dec.decipherKey, this._decipherIV = dec.decipherIV, this._len = 0, this._lenBytes = 0, this._packet = null, this._packetPos = 0, this._pktLen = 0, this._tag = Buffer.allocUnsafe(16), this._tagPos = 0;
      }
      free() {
      }
      decrypt(data, p, dataLen) {
        for (; p < dataLen; ) {
          if (this._lenBytes < 4) {
            let nb = Math.min(4 - this._lenBytes, dataLen - p);
            for (this._lenBytes += nb; nb--; )
              this._len = (this._len << 8) + data[p++];
            if (this._lenBytes < 4)
              return;
            if (this._len + 20 > MAX_PACKET_SIZE || this._len < 16 || this._len & 15)
              throw new Error("Bad packet length");
            this._decipherInstance = createDecipheriv(
              this._decipherSSLName,
              this._decipherKey,
              this._decipherIV
            ), this._decipherInstance.setAutoPadding(!1), this._decipherInstance.setAAD(intToBytes(this._len));
          }
          if (this._pktLen < this._len) {
            if (p >= dataLen)
              return;
            let nb = Math.min(this._len - this._pktLen, dataLen - p), decrypted;
            if (p !== 0 || nb !== dataLen ? decrypted = this._decipherInstance.update(
              new Uint8Array(data.buffer, data.byteOffset + p, nb)
            ) : decrypted = this._decipherInstance.update(data), decrypted.length && (nb === this._len ? this._packet = decrypted : (this._packet || (this._packet = Buffer.allocUnsafe(this._len)), this._packet.set(decrypted, this._packetPos)), this._packetPos += decrypted.length), p += nb, this._pktLen += nb, this._pktLen < this._len || p >= dataLen)
              return;
          }
          {
            let nb = Math.min(16 - this._tagPos, dataLen - p);
            if (p !== 0 || nb !== dataLen ? this._tag.set(
              new Uint8Array(data.buffer, data.byteOffset + p, nb),
              this._tagPos
            ) : this._tag.set(data, this._tagPos), p += nb, this._tagPos += nb, this._tagPos < 16)
              return;
          }
          {
            this._decipherInstance.setAuthTag(this._tag);
            let decrypted = this._decipherInstance.final();
            decrypted.length && (this._packet ? this._packet.set(decrypted, this._packetPos) : this._packet = decrypted);
          }
          let payload = this._packet ? new FastBuffer(
            this._packet.buffer,
            this._packet.byteOffset + 1,
            this._packet.length - this._packet[0] - 1
          ) : EMPTY_BUFFER;
          this.inSeqno = this.inSeqno + 1 >>> 0, ivIncrement(this._decipherIV), this._len = 0, this._lenBytes = 0, this._packet = null, this._packetPos = 0, this._pktLen = 0, this._tagPos = 0;
          {
            let ret = this._onPayload(payload);
            if (ret !== void 0)
              return ret === !1 ? p : ret;
          }
        }
      }
    }, AESGCMDecipherBinding = class {
      constructor(config) {
        let dec = config.inbound;
        this.inSeqno = dec.seqno, this._onPayload = dec.onPayload, this._instance = new AESGCMDecipher(
          dec.decipherInfo.sslName,
          dec.decipherKey,
          dec.decipherIV
        ), this._len = 0, this._lenBytes = 0, this._packet = null, this._pktLen = 0, this._tag = Buffer.allocUnsafe(16), this._tagPos = 0;
      }
      free() {
      }
      decrypt(data, p, dataLen) {
        for (; p < dataLen; ) {
          if (this._lenBytes < 4) {
            let nb = Math.min(4 - this._lenBytes, dataLen - p);
            for (this._lenBytes += nb; nb--; )
              this._len = (this._len << 8) + data[p++];
            if (this._lenBytes < 4)
              return;
            if (this._len + 20 > MAX_PACKET_SIZE || this._len < 16 || this._len & 15)
              throw new Error(`Bad packet length: ${this._len}`);
          }
          if (this._pktLen < this._len) {
            if (p >= dataLen)
              return;
            let nb = Math.min(this._len - this._pktLen, dataLen - p), encrypted;
            if (p !== 0 || nb !== dataLen ? encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb) : encrypted = data, nb === this._len ? this._packet = encrypted : (this._packet || (this._packet = Buffer.allocUnsafe(this._len)), this._packet.set(encrypted, this._pktLen)), p += nb, this._pktLen += nb, this._pktLen < this._len || p >= dataLen)
              return;
          }
          {
            let nb = Math.min(16 - this._tagPos, dataLen - p);
            if (p !== 0 || nb !== dataLen ? this._tag.set(
              new Uint8Array(data.buffer, data.byteOffset + p, nb),
              this._tagPos
            ) : this._tag.set(data, this._tagPos), p += nb, this._tagPos += nb, this._tagPos < 16)
              return;
          }
          this._instance.decrypt(this._packet, this._len, this._tag);
          let payload = new FastBuffer(
            this._packet.buffer,
            this._packet.byteOffset + 1,
            this._packet.length - this._packet[0] - 1
          );
          this.inSeqno = this.inSeqno + 1 >>> 0, this._len = 0, this._lenBytes = 0, this._packet = null, this._pktLen = 0, this._tagPos = 0;
          {
            let ret = this._onPayload(payload);
            if (ret !== void 0)
              return ret === !1 ? p : ret;
          }
        }
      }
    }, GenericDecipherNative = class {
      constructor(config) {
        let dec = config.inbound;
        this.inSeqno = dec.seqno, this._onPayload = dec.onPayload, this._decipherInstance = createDecipheriv(
          dec.decipherInfo.sslName,
          dec.decipherKey,
          dec.decipherIV
        ), this._decipherInstance.setAutoPadding(!1), this._block = Buffer.allocUnsafe(
          dec.macInfo.isETM ? 4 : dec.decipherInfo.blockLen
        ), this._blockSize = dec.decipherInfo.blockLen, this._blockPos = 0, this._len = 0, this._packet = null, this._packetPos = 0, this._pktLen = 0, this._mac = Buffer.allocUnsafe(dec.macInfo.actualLen), this._macPos = 0, this._macSSLName = dec.macInfo.sslName, this._macKey = dec.macKey, this._macActualLen = dec.macInfo.actualLen, this._macETM = dec.macInfo.isETM, this._macInstance = null;
        let discardLen = dec.decipherInfo.discardLen;
        if (discardLen) {
          let discard = DISCARD_CACHE.get(discardLen);
          discard === void 0 && (discard = Buffer.alloc(discardLen), DISCARD_CACHE.set(discardLen, discard)), this._decipherInstance.update(discard);
        }
      }
      free() {
      }
      decrypt(data, p, dataLen) {
        for (; p < dataLen; ) {
          if (this._blockPos < this._block.length) {
            let nb = Math.min(this._block.length - this._blockPos, dataLen - p);
            if (p !== 0 || nb !== dataLen || nb < data.length ? this._block.set(
              new Uint8Array(data.buffer, data.byteOffset + p, nb),
              this._blockPos
            ) : this._block.set(data, this._blockPos), p += nb, this._blockPos += nb, this._blockPos < this._block.length)
              return;
            let decrypted, need;
            if (this._macETM ? this._len = need = readUInt32BE(this._block, 0) : (decrypted = this._decipherInstance.update(this._block), this._len = readUInt32BE(decrypted, 0), need = 4 + this._len - this._blockSize), this._len > MAX_PACKET_SIZE || this._len < 5 || need & this._blockSize - 1)
              throw new Error("Bad packet length");
            if (this._macInstance = createHmac(this._macSSLName, this._macKey), writeUInt32BE(BUF_INT, this.inSeqno, 0), this._macInstance.update(BUF_INT), this._macETM ? this._macInstance.update(this._block) : (this._macInstance.update(new Uint8Array(
              decrypted.buffer,
              decrypted.byteOffset,
              4
            )), this._pktLen = decrypted.length - 4, this._packetPos = this._pktLen, this._packet = Buffer.allocUnsafe(this._len), this._packet.set(
              new Uint8Array(
                decrypted.buffer,
                decrypted.byteOffset + 4,
                this._packetPos
              ),
              0
            )), p >= dataLen)
              return;
          }
          if (this._pktLen < this._len) {
            let nb = Math.min(this._len - this._pktLen, dataLen - p), encrypted;
            p !== 0 || nb !== dataLen ? encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb) : encrypted = data, this._macETM && this._macInstance.update(encrypted);
            let decrypted = this._decipherInstance.update(encrypted);
            if (decrypted.length && (nb === this._len ? this._packet = decrypted : (this._packet || (this._packet = Buffer.allocUnsafe(this._len)), this._packet.set(decrypted, this._packetPos)), this._packetPos += decrypted.length), p += nb, this._pktLen += nb, this._pktLen < this._len || p >= dataLen)
              return;
          }
          {
            let nb = Math.min(this._macActualLen - this._macPos, dataLen - p);
            if (p !== 0 || nb !== dataLen ? this._mac.set(
              new Uint8Array(data.buffer, data.byteOffset + p, nb),
              this._macPos
            ) : this._mac.set(data, this._macPos), p += nb, this._macPos += nb, this._macPos < this._macActualLen)
              return;
          }
          this._macETM || this._macInstance.update(this._packet);
          let calculated = this._macInstance.digest();
          if (this._macActualLen < calculated.length && (calculated = new Uint8Array(
            calculated.buffer,
            calculated.byteOffset,
            this._macActualLen
          )), !timingSafeEquals(calculated, this._mac))
            throw new Error("Invalid MAC");
          let payload = new FastBuffer(
            this._packet.buffer,
            this._packet.byteOffset + 1,
            this._packet.length - this._packet[0] - 1
          );
          this.inSeqno = this.inSeqno + 1 >>> 0, this._blockPos = 0, this._len = 0, this._packet = null, this._packetPos = 0, this._pktLen = 0, this._macPos = 0, this._macInstance = null;
          {
            let ret = this._onPayload(payload);
            if (ret !== void 0)
              return ret === !1 ? p : ret;
          }
        }
      }
    }, GenericDecipherBinding = class {
      constructor(config) {
        let dec = config.inbound;
        this.inSeqno = dec.seqno, this._onPayload = dec.onPayload, this._instance = new GenericDecipher(
          dec.decipherInfo.sslName,
          dec.decipherKey,
          dec.decipherIV,
          dec.macInfo.sslName,
          dec.macKey,
          dec.macInfo.isETM,
          dec.macInfo.actualLen
        ), this._block = Buffer.allocUnsafe(
          dec.macInfo.isETM || dec.decipherInfo.stream ? 4 : dec.decipherInfo.blockLen
        ), this._blockPos = 0, this._len = 0, this._packet = null, this._pktLen = 0, this._mac = Buffer.allocUnsafe(dec.macInfo.actualLen), this._macPos = 0, this._macActualLen = dec.macInfo.actualLen, this._macETM = dec.macInfo.isETM;
      }
      free() {
        this._instance.free();
      }
      decrypt(data, p, dataLen) {
        for (; p < dataLen; ) {
          if (this._blockPos < this._block.length) {
            let nb = Math.min(this._block.length - this._blockPos, dataLen - p);
            if (p !== 0 || nb !== dataLen || nb < data.length ? this._block.set(
              new Uint8Array(data.buffer, data.byteOffset + p, nb),
              this._blockPos
            ) : this._block.set(data, this._blockPos), p += nb, this._blockPos += nb, this._blockPos < this._block.length)
              return;
            let need;
            if (this._macETM ? this._len = need = readUInt32BE(this._block, 0) : (this._instance.decryptBlock(this._block), this._len = readUInt32BE(this._block, 0), need = 4 + this._len - this._block.length), this._len > MAX_PACKET_SIZE || this._len < 5 || need & this._block.length - 1)
              throw new Error("Bad packet length");
            if (this._macETM || (this._pktLen = this._block.length - 4, this._pktLen && (this._packet = Buffer.allocUnsafe(this._len), this._packet.set(
              new Uint8Array(
                this._block.buffer,
                this._block.byteOffset + 4,
                this._pktLen
              ),
              0
            ))), p >= dataLen)
              return;
          }
          if (this._pktLen < this._len) {
            let nb = Math.min(this._len - this._pktLen, dataLen - p), encrypted;
            if (p !== 0 || nb !== dataLen ? encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb) : encrypted = data, nb === this._len ? this._packet = encrypted : (this._packet || (this._packet = Buffer.allocUnsafe(this._len)), this._packet.set(encrypted, this._pktLen)), p += nb, this._pktLen += nb, this._pktLen < this._len || p >= dataLen)
              return;
          }
          {
            let nb = Math.min(this._macActualLen - this._macPos, dataLen - p);
            if (p !== 0 || nb !== dataLen ? this._mac.set(
              new Uint8Array(data.buffer, data.byteOffset + p, nb),
              this._macPos
            ) : this._mac.set(data, this._macPos), p += nb, this._macPos += nb, this._macPos < this._macActualLen)
              return;
          }
          this._instance.decrypt(
            this._packet,
            this.inSeqno,
            this._block,
            this._mac
          );
          let payload = new FastBuffer(
            this._packet.buffer,
            this._packet.byteOffset + 1,
            this._packet.length - this._packet[0] - 1
          );
          this.inSeqno = this.inSeqno + 1 >>> 0, this._blockPos = 0, this._len = 0, this._packet = null, this._pktLen = 0, this._macPos = 0, this._macInstance = null;
          {
            let ret = this._onPayload(payload);
            if (ret !== void 0)
              return ret === !1 ? p : ret;
          }
        }
      }
    };
    function ivIncrement(iv) {
      ++iv[11] >>> 8 && ++iv[10] >>> 8 && ++iv[9] >>> 8 && ++iv[8] >>> 8 && ++iv[7] >>> 8 && ++iv[6] >>> 8 && ++iv[5] >>> 8 && ++iv[4] >>> 8;
    }
    var intToBytes = (() => {
      let ret = Buffer.alloc(4);
      return (n) => (ret[0] = n >>> 24, ret[1] = n >>> 16, ret[2] = n >>> 8, ret[3] = n, ret);
    })();
    function timingSafeEquals(a, b) {
      return a.length !== b.length ? (timingSafeEqual(a, a), !1) : timingSafeEqual(a, b);
    }
    function createCipher(config) {
      if (typeof config != "object" || config === null)
        throw new Error("Invalid config");
      if (typeof config.outbound != "object" || config.outbound === null)
        throw new Error("Invalid outbound");
      let outbound = config.outbound;
      if (typeof outbound.onWrite != "function")
        throw new Error("Invalid outbound.onWrite");
      if (typeof outbound.cipherInfo != "object" || outbound.cipherInfo === null)
        throw new Error("Invalid outbound.cipherInfo");
      if (!Buffer.isBuffer(outbound.cipherKey) || outbound.cipherKey.length !== outbound.cipherInfo.keyLen)
        throw new Error("Invalid outbound.cipherKey");
      if (outbound.cipherInfo.ivLen && (!Buffer.isBuffer(outbound.cipherIV) || outbound.cipherIV.length !== outbound.cipherInfo.ivLen))
        throw new Error("Invalid outbound.cipherIV");
      if (typeof outbound.seqno != "number" || outbound.seqno < 0 || outbound.seqno > MAX_SEQNO)
        throw new Error("Invalid outbound.seqno");
      let forceNative = !!outbound.forceNative;
      switch (outbound.cipherInfo.sslName) {
        case "aes-128-gcm":
        case "aes-256-gcm":
          return AESGCMCipher && !forceNative ? new AESGCMCipherBinding(config) : new AESGCMCipherNative(config);
        case "chacha20":
          return ChaChaPolyCipher && !forceNative ? new ChaChaPolyCipherBinding(config) : new ChaChaPolyCipherNative(config);
        default: {
          if (typeof outbound.macInfo != "object" || outbound.macInfo === null)
            throw new Error("Invalid outbound.macInfo");
          if (!Buffer.isBuffer(outbound.macKey) || outbound.macKey.length !== outbound.macInfo.len)
            throw new Error("Invalid outbound.macKey");
          return GenericCipher && !forceNative ? new GenericCipherBinding(config) : new GenericCipherNative(config);
        }
      }
    }
    function createDecipher(config) {
      if (typeof config != "object" || config === null)
        throw new Error("Invalid config");
      if (typeof config.inbound != "object" || config.inbound === null)
        throw new Error("Invalid inbound");
      let inbound = config.inbound;
      if (typeof inbound.onPayload != "function")
        throw new Error("Invalid inbound.onPayload");
      if (typeof inbound.decipherInfo != "object" || inbound.decipherInfo === null)
        throw new Error("Invalid inbound.decipherInfo");
      if (!Buffer.isBuffer(inbound.decipherKey) || inbound.decipherKey.length !== inbound.decipherInfo.keyLen)
        throw new Error("Invalid inbound.decipherKey");
      if (inbound.decipherInfo.ivLen && (!Buffer.isBuffer(inbound.decipherIV) || inbound.decipherIV.length !== inbound.decipherInfo.ivLen))
        throw new Error("Invalid inbound.decipherIV");
      if (typeof inbound.seqno != "number" || inbound.seqno < 0 || inbound.seqno > MAX_SEQNO)
        throw new Error("Invalid inbound.seqno");
      let forceNative = !!inbound.forceNative;
      switch (inbound.decipherInfo.sslName) {
        case "aes-128-gcm":
        case "aes-256-gcm":
          return AESGCMDecipher && !forceNative ? new AESGCMDecipherBinding(config) : new AESGCMDecipherNative(config);
        case "chacha20":
          return ChaChaPolyDecipher && !forceNative ? new ChaChaPolyDecipherBinding(config) : new ChaChaPolyDecipherNative(config);
        default: {
          if (typeof inbound.macInfo != "object" || inbound.macInfo === null)
            throw new Error("Invalid inbound.macInfo");
          if (!Buffer.isBuffer(inbound.macKey) || inbound.macKey.length !== inbound.macInfo.len)
            throw new Error("Invalid inbound.macKey");
          return GenericDecipher && !forceNative ? new GenericDecipherBinding(config) : new GenericDecipherNative(config);
        }
      }
    }
    module2.exports = {
      CIPHER_INFO,
      MAC_INFO,
      bindingAvailable: !!binding,
      init: new Promise(async (resolve2, reject) => {
        try {
          POLY1305_WASM_MODULE = await require_poly1305()(), POLY1305_RESULT_MALLOC = POLY1305_WASM_MODULE._malloc(16), poly1305_auth = POLY1305_WASM_MODULE.cwrap(
            "poly1305_auth",
            null,
            ["number", "array", "number", "array", "number", "array"]
          );
        } catch (ex) {
          return reject(ex);
        }
        resolve2();
      }),
      NullCipher,
      createCipher,
      NullDecipher,
      createDecipher
    };
  }
});

// node_modules/ssh2/lib/protocol/keyParser.js
var require_keyParser = __commonJS({
  "node_modules/ssh2/lib/protocol/keyParser.js"(exports2, module2) {
    "use strict";
    var {
      createDecipheriv,
      createECDH,
      createHash,
      createHmac,
      createSign,
      createVerify,
      getCiphers,
      sign: sign_,
      verify: verify_
    } = require("crypto"), supportedOpenSSLCiphers = getCiphers(), { Ber } = require_lib4(), bcrypt_pbkdf = require_bcrypt_pbkdf().pbkdf, { CIPHER_INFO } = require_crypto(), { eddsaSupported, SUPPORTED_CIPHER } = require_constants6(), {
      bufferSlice,
      makeBufferParser,
      readString,
      readUInt32BE,
      writeUInt32BE
    } = require_utils5(), SYM_HASH_ALGO = Symbol("Hash Algorithm"), SYM_PRIV_PEM = Symbol("Private key PEM"), SYM_PUB_PEM = Symbol("Public key PEM"), SYM_PUB_SSH = Symbol("Public key SSH"), SYM_DECRYPTED = Symbol("Decrypted Key"), CIPHER_INFO_OPENSSL = /* @__PURE__ */ Object.create(null);
    {
      let keys = Object.keys(CIPHER_INFO);
      for (let i = 0; i < keys.length; ++i) {
        let cipherName = CIPHER_INFO[keys[i]].sslName;
        !cipherName || CIPHER_INFO_OPENSSL[cipherName] || (CIPHER_INFO_OPENSSL[cipherName] = CIPHER_INFO[keys[i]]);
      }
    }
    var binaryKeyParser = makeBufferParser();
    function makePEM(type, data) {
      data = data.base64Slice(0, data.length);
      let formatted = data.replace(/.{64}/g, `$&
`);
      return data.length & 63 && (formatted += `
`), `-----BEGIN ${type} KEY-----
${formatted}-----END ${type} KEY-----`;
    }
    function combineBuffers(buf1, buf2) {
      let result = Buffer.allocUnsafe(buf1.length + buf2.length);
      return result.set(buf1, 0), result.set(buf2, buf1.length), result;
    }
    function skipFields(buf, nfields) {
      let bufLen = buf.length, pos2 = buf._pos || 0;
      for (let i = 0; i < nfields; ++i) {
        let left = bufLen - pos2;
        if (pos2 >= bufLen || left < 4)
          return !1;
        let len = readUInt32BE(buf, pos2);
        if (left < 4 + len)
          return !1;
        pos2 += 4 + len;
      }
      return buf._pos = pos2, !0;
    }
    function genOpenSSLRSAPub(n, e) {
      let asnWriter = new Ber.Writer();
      return asnWriter.startSequence(), asnWriter.startSequence(), asnWriter.writeOID("1.2.840.113549.1.1.1"), asnWriter.writeNull(), asnWriter.endSequence(), asnWriter.startSequence(Ber.BitString), asnWriter.writeByte(0), asnWriter.startSequence(), asnWriter.writeBuffer(n, Ber.Integer), asnWriter.writeBuffer(e, Ber.Integer), asnWriter.endSequence(), asnWriter.endSequence(), asnWriter.endSequence(), makePEM("PUBLIC", asnWriter.buffer);
    }
    function genOpenSSHRSAPub(n, e) {
      let publicKey = Buffer.allocUnsafe(15 + e.length + 4 + n.length);
      writeUInt32BE(publicKey, 7, 0), publicKey.utf8Write("ssh-rsa", 4, 7);
      let i = 11;
      return writeUInt32BE(publicKey, e.length, i), publicKey.set(e, i += 4), writeUInt32BE(publicKey, n.length, i += e.length), publicKey.set(n, i + 4), publicKey;
    }
    var genOpenSSLRSAPriv = /* @__PURE__ */ (() => {
      function genRSAASN1Buf(n, e, d, p, q, dmp1, dmq1, iqmp) {
        let asnWriter = new Ber.Writer();
        return asnWriter.startSequence(), asnWriter.writeInt(0, Ber.Integer), asnWriter.writeBuffer(n, Ber.Integer), asnWriter.writeBuffer(e, Ber.Integer), asnWriter.writeBuffer(d, Ber.Integer), asnWriter.writeBuffer(p, Ber.Integer), asnWriter.writeBuffer(q, Ber.Integer), asnWriter.writeBuffer(dmp1, Ber.Integer), asnWriter.writeBuffer(dmq1, Ber.Integer), asnWriter.writeBuffer(iqmp, Ber.Integer), asnWriter.endSequence(), asnWriter.buffer;
      }
      function bigIntFromBuffer(buf) {
        return BigInt(`0x${buf.hexSlice(0, buf.length)}`);
      }
      function bigIntToBuffer(bn) {
        let hex = bn.toString(16);
        if (hex.length & 1)
          hex = `0${hex}`;
        else {
          let sigbit = hex.charCodeAt(0);
          (sigbit === 56 || sigbit === 57 || sigbit >= 97 && sigbit <= 102) && (hex = `00${hex}`);
        }
        return Buffer.from(hex, "hex");
      }
      return function(n, e, d, iqmp, p, q) {
        let bn_d = bigIntFromBuffer(d), dmp1 = bigIntToBuffer(bn_d % (bigIntFromBuffer(p) - 1n)), dmq1 = bigIntToBuffer(bn_d % (bigIntFromBuffer(q) - 1n));
        return makePEM(
          "RSA PRIVATE",
          genRSAASN1Buf(n, e, d, p, q, dmp1, dmq1, iqmp)
        );
      };
    })();
    function genOpenSSLDSAPub(p, q, g, y) {
      let asnWriter = new Ber.Writer();
      return asnWriter.startSequence(), asnWriter.startSequence(), asnWriter.writeOID("1.2.840.10040.4.1"), asnWriter.startSequence(), asnWriter.writeBuffer(p, Ber.Integer), asnWriter.writeBuffer(q, Ber.Integer), asnWriter.writeBuffer(g, Ber.Integer), asnWriter.endSequence(), asnWriter.endSequence(), asnWriter.startSequence(Ber.BitString), asnWriter.writeByte(0), asnWriter.writeBuffer(y, Ber.Integer), asnWriter.endSequence(), asnWriter.endSequence(), makePEM("PUBLIC", asnWriter.buffer);
    }
    function genOpenSSHDSAPub(p, q, g, y) {
      let publicKey = Buffer.allocUnsafe(
        15 + p.length + 4 + q.length + 4 + g.length + 4 + y.length
      );
      writeUInt32BE(publicKey, 7, 0), publicKey.utf8Write("ssh-dss", 4, 7);
      let i = 11;
      return writeUInt32BE(publicKey, p.length, i), publicKey.set(p, i += 4), writeUInt32BE(publicKey, q.length, i += p.length), publicKey.set(q, i += 4), writeUInt32BE(publicKey, g.length, i += q.length), publicKey.set(g, i += 4), writeUInt32BE(publicKey, y.length, i += g.length), publicKey.set(y, i + 4), publicKey;
    }
    function genOpenSSLDSAPriv(p, q, g, y, x) {
      let asnWriter = new Ber.Writer();
      return asnWriter.startSequence(), asnWriter.writeInt(0, Ber.Integer), asnWriter.writeBuffer(p, Ber.Integer), asnWriter.writeBuffer(q, Ber.Integer), asnWriter.writeBuffer(g, Ber.Integer), asnWriter.writeBuffer(y, Ber.Integer), asnWriter.writeBuffer(x, Ber.Integer), asnWriter.endSequence(), makePEM("DSA PRIVATE", asnWriter.buffer);
    }
    function genOpenSSLEdPub(pub) {
      let asnWriter = new Ber.Writer();
      return asnWriter.startSequence(), asnWriter.startSequence(), asnWriter.writeOID("1.3.101.112"), asnWriter.endSequence(), asnWriter.startSequence(Ber.BitString), asnWriter.writeByte(0), asnWriter._ensure(pub.length), asnWriter._buf.set(pub, asnWriter._offset), asnWriter._offset += pub.length, asnWriter.endSequence(), asnWriter.endSequence(), makePEM("PUBLIC", asnWriter.buffer);
    }
    function genOpenSSHEdPub(pub) {
      let publicKey = Buffer.allocUnsafe(19 + pub.length);
      return writeUInt32BE(publicKey, 11, 0), publicKey.utf8Write("ssh-ed25519", 4, 11), writeUInt32BE(publicKey, pub.length, 15), publicKey.set(pub, 19), publicKey;
    }
    function genOpenSSLEdPriv(priv) {
      let asnWriter = new Ber.Writer();
      return asnWriter.startSequence(), asnWriter.writeInt(0, Ber.Integer), asnWriter.startSequence(), asnWriter.writeOID("1.3.101.112"), asnWriter.endSequence(), asnWriter.startSequence(Ber.OctetString), asnWriter.writeBuffer(priv, Ber.OctetString), asnWriter.endSequence(), asnWriter.endSequence(), makePEM("PRIVATE", asnWriter.buffer);
    }
    function genOpenSSLECDSAPub(oid, Q) {
      let asnWriter = new Ber.Writer();
      return asnWriter.startSequence(), asnWriter.startSequence(), asnWriter.writeOID("1.2.840.10045.2.1"), asnWriter.writeOID(oid), asnWriter.endSequence(), asnWriter.startSequence(Ber.BitString), asnWriter.writeByte(0), asnWriter._ensure(Q.length), asnWriter._buf.set(Q, asnWriter._offset), asnWriter._offset += Q.length, asnWriter.endSequence(), asnWriter.endSequence(), makePEM("PUBLIC", asnWriter.buffer);
    }
    function genOpenSSHECDSAPub(oid, Q) {
      let curveName;
      switch (oid) {
        case "1.2.840.10045.3.1.7":
          curveName = "nistp256";
          break;
        case "1.3.132.0.34":
          curveName = "nistp384";
          break;
        case "1.3.132.0.35":
          curveName = "nistp521";
          break;
        default:
          return;
      }
      let publicKey = Buffer.allocUnsafe(39 + Q.length);
      return writeUInt32BE(publicKey, 19, 0), publicKey.utf8Write(`ecdsa-sha2-${curveName}`, 4, 19), writeUInt32BE(publicKey, 8, 23), publicKey.utf8Write(curveName, 27, 8), writeUInt32BE(publicKey, Q.length, 35), publicKey.set(Q, 39), publicKey;
    }
    function genOpenSSLECDSAPriv(oid, pub, priv) {
      let asnWriter = new Ber.Writer();
      return asnWriter.startSequence(), asnWriter.writeInt(1, Ber.Integer), asnWriter.writeBuffer(priv, Ber.OctetString), asnWriter.startSequence(160), asnWriter.writeOID(oid), asnWriter.endSequence(), asnWriter.startSequence(161), asnWriter.startSequence(Ber.BitString), asnWriter.writeByte(0), asnWriter._ensure(pub.length), asnWriter._buf.set(pub, asnWriter._offset), asnWriter._offset += pub.length, asnWriter.endSequence(), asnWriter.endSequence(), asnWriter.endSequence(), makePEM("EC PRIVATE", asnWriter.buffer);
    }
    function genOpenSSLECDSAPubFromPriv(curveName, priv) {
      let tempECDH = createECDH(curveName);
      return tempECDH.setPrivateKey(priv), tempECDH.getPublicKey();
    }
    var BaseKey = {
      sign: typeof sign_ == "function" ? function(data, algo) {
        let pem = this[SYM_PRIV_PEM];
        if (pem === null)
          return new Error("No private key available");
        (!algo || typeof algo != "string") && (algo = this[SYM_HASH_ALGO]);
        try {
          return sign_(algo, data, pem);
        } catch (ex) {
          return ex;
        }
      } : function(data, algo) {
        let pem = this[SYM_PRIV_PEM];
        if (pem === null)
          return new Error("No private key available");
        (!algo || typeof algo != "string") && (algo = this[SYM_HASH_ALGO]);
        let signature = createSign(algo);
        signature.update(data);
        try {
          return signature.sign(pem);
        } catch (ex) {
          return ex;
        }
      },
      verify: typeof verify_ == "function" ? function(data, signature, algo) {
        let pem = this[SYM_PUB_PEM];
        if (pem === null)
          return new Error("No public key available");
        (!algo || typeof algo != "string") && (algo = this[SYM_HASH_ALGO]);
        try {
          return verify_(algo, data, pem, signature);
        } catch (ex) {
          return ex;
        }
      } : function(data, signature, algo) {
        let pem = this[SYM_PUB_PEM];
        if (pem === null)
          return new Error("No public key available");
        (!algo || typeof algo != "string") && (algo = this[SYM_HASH_ALGO]);
        let verifier = createVerify(algo);
        verifier.update(data);
        try {
          return verifier.verify(pem, signature);
        } catch (ex) {
          return ex;
        }
      },
      isPrivateKey: function() {
        return this[SYM_PRIV_PEM] !== null;
      },
      getPrivatePEM: function() {
        return this[SYM_PRIV_PEM];
      },
      getPublicPEM: function() {
        return this[SYM_PUB_PEM];
      },
      getPublicSSH: function() {
        return this[SYM_PUB_SSH];
      },
      equals: function(key) {
        let parsed = parseKey(key);
        return parsed instanceof Error ? !1 : this.type === parsed.type && this[SYM_PRIV_PEM] === parsed[SYM_PRIV_PEM] && this[SYM_PUB_PEM] === parsed[SYM_PUB_PEM] && this[SYM_PUB_SSH].equals(parsed[SYM_PUB_SSH]);
      }
    };
    function OpenSSH_Private(type, comment, privPEM, pubPEM, pubSSH, algo, decrypted) {
      this.type = type, this.comment = comment, this[SYM_PRIV_PEM] = privPEM, this[SYM_PUB_PEM] = pubPEM, this[SYM_PUB_SSH] = pubSSH, this[SYM_HASH_ALGO] = algo, this[SYM_DECRYPTED] = decrypted;
    }
    OpenSSH_Private.prototype = BaseKey;
    {
      let parseOpenSSHPrivKeys = function(data, nkeys, decrypted) {
        let keys = [];
        if (data.length < 8)
          return new Error("Malformed OpenSSH private key");
        let check1 = readUInt32BE(data, 0), check2 = readUInt32BE(data, 4);
        if (check1 !== check2)
          return decrypted ? new Error(
            "OpenSSH key integrity check failed -- bad passphrase?"
          ) : new Error("OpenSSH key integrity check failed");
        data._pos = 8;
        let i, oid;
        for (i = 0; i < nkeys; ++i) {
          let algo, privPEM, pubPEM, pubSSH, type = readString(data, data._pos, !0);
          if (type === void 0)
            return new Error("Malformed OpenSSH private key");
          switch (type) {
            case "ssh-rsa": {
              let n = readString(data, data._pos);
              if (n === void 0)
                return new Error("Malformed OpenSSH private key");
              let e = readString(data, data._pos);
              if (e === void 0)
                return new Error("Malformed OpenSSH private key");
              let d = readString(data, data._pos);
              if (d === void 0)
                return new Error("Malformed OpenSSH private key");
              let iqmp = readString(data, data._pos);
              if (iqmp === void 0)
                return new Error("Malformed OpenSSH private key");
              let p = readString(data, data._pos);
              if (p === void 0)
                return new Error("Malformed OpenSSH private key");
              let q = readString(data, data._pos);
              if (q === void 0)
                return new Error("Malformed OpenSSH private key");
              pubPEM = genOpenSSLRSAPub(n, e), pubSSH = genOpenSSHRSAPub(n, e), privPEM = genOpenSSLRSAPriv(n, e, d, iqmp, p, q), algo = "sha1";
              break;
            }
            case "ssh-dss": {
              let p = readString(data, data._pos);
              if (p === void 0)
                return new Error("Malformed OpenSSH private key");
              let q = readString(data, data._pos);
              if (q === void 0)
                return new Error("Malformed OpenSSH private key");
              let g = readString(data, data._pos);
              if (g === void 0)
                return new Error("Malformed OpenSSH private key");
              let y = readString(data, data._pos);
              if (y === void 0)
                return new Error("Malformed OpenSSH private key");
              let x = readString(data, data._pos);
              if (x === void 0)
                return new Error("Malformed OpenSSH private key");
              pubPEM = genOpenSSLDSAPub(p, q, g, y), pubSSH = genOpenSSHDSAPub(p, q, g, y), privPEM = genOpenSSLDSAPriv(p, q, g, y, x), algo = "sha1";
              break;
            }
            case "ssh-ed25519": {
              if (!eddsaSupported)
                return new Error(`Unsupported OpenSSH private key type: ${type}`);
              let edpub = readString(data, data._pos);
              if (edpub === void 0 || edpub.length !== 32)
                return new Error("Malformed OpenSSH private key");
              let edpriv = readString(data, data._pos);
              if (edpriv === void 0 || edpriv.length !== 64)
                return new Error("Malformed OpenSSH private key");
              pubPEM = genOpenSSLEdPub(edpub), pubSSH = genOpenSSHEdPub(edpub), privPEM = genOpenSSLEdPriv(bufferSlice(edpriv, 0, 32)), algo = null;
              break;
            }
            case "ecdsa-sha2-nistp256":
              algo = "sha256", oid = "1.2.840.10045.3.1.7";
            // FALLTHROUGH
            case "ecdsa-sha2-nistp384":
              algo === void 0 && (algo = "sha384", oid = "1.3.132.0.34");
            // FALLTHROUGH
            case "ecdsa-sha2-nistp521": {
              if (algo === void 0 && (algo = "sha512", oid = "1.3.132.0.35"), !skipFields(data, 1))
                return new Error("Malformed OpenSSH private key");
              let ecpub = readString(data, data._pos);
              if (ecpub === void 0)
                return new Error("Malformed OpenSSH private key");
              let ecpriv = readString(data, data._pos);
              if (ecpriv === void 0)
                return new Error("Malformed OpenSSH private key");
              pubPEM = genOpenSSLECDSAPub(oid, ecpub), pubSSH = genOpenSSHECDSAPub(oid, ecpub), privPEM = genOpenSSLECDSAPriv(oid, ecpub, ecpriv);
              break;
            }
            default:
              return new Error(`Unsupported OpenSSH private key type: ${type}`);
          }
          let privComment = readString(data, data._pos, !0);
          if (privComment === void 0)
            return new Error("Malformed OpenSSH private key");
          keys.push(
            new OpenSSH_Private(
              type,
              privComment,
              privPEM,
              pubPEM,
              pubSSH,
              algo,
              decrypted
            )
          );
        }
        let cnt = 0;
        for (i = data._pos; i < data.length; ++i)
          if (data[i] !== ++cnt % 255)
            return new Error("Malformed OpenSSH private key");
        return keys;
      }, regexp = /^-----BEGIN OPENSSH PRIVATE KEY-----(?:\r\n|\n)([\s\S]+)(?:\r\n|\n)-----END OPENSSH PRIVATE KEY-----$/;
      OpenSSH_Private.parse = (str, passphrase) => {
        let m = regexp.exec(str);
        if (m === null)
          return null;
        let ret, data = Buffer.from(m[1], "base64");
        if (data.length < 31)
          return new Error("Malformed OpenSSH private key");
        let magic = data.utf8Slice(0, 15);
        if (magic !== "openssh-key-v1\0")
          return new Error(`Unsupported OpenSSH key magic: ${magic}`);
        let cipherName = readString(data, 15, !0);
        if (cipherName === void 0)
          return new Error("Malformed OpenSSH private key");
        if (cipherName !== "none" && SUPPORTED_CIPHER.indexOf(cipherName) === -1)
          return new Error(`Unsupported cipher for OpenSSH key: ${cipherName}`);
        let kdfName = readString(data, data._pos, !0);
        if (kdfName === void 0)
          return new Error("Malformed OpenSSH private key");
        if (kdfName !== "none") {
          if (cipherName === "none")
            return new Error("Malformed OpenSSH private key");
          if (kdfName !== "bcrypt")
            return new Error(`Unsupported kdf name for OpenSSH key: ${kdfName}`);
          if (!passphrase)
            return new Error(
              "Encrypted private OpenSSH key detected, but no passphrase given"
            );
        } else if (cipherName !== "none")
          return new Error("Malformed OpenSSH private key");
        let encInfo, cipherKey, cipherIV;
        cipherName !== "none" && (encInfo = CIPHER_INFO[cipherName]);
        let kdfOptions = readString(data, data._pos);
        if (kdfOptions === void 0)
          return new Error("Malformed OpenSSH private key");
        if (kdfOptions.length)
          switch (kdfName) {
            case "none":
              return new Error("Malformed OpenSSH private key");
            case "bcrypt": {
              let salt = readString(kdfOptions, 0);
              if (salt === void 0 || kdfOptions._pos + 4 > kdfOptions.length)
                return new Error("Malformed OpenSSH private key");
              let rounds = readUInt32BE(kdfOptions, kdfOptions._pos), gen = Buffer.allocUnsafe(encInfo.keyLen + encInfo.ivLen);
              if (bcrypt_pbkdf(
                passphrase,
                passphrase.length,
                salt,
                salt.length,
                gen,
                gen.length,
                rounds
              ) !== 0)
                return new Error("Failed to generate information to decrypt key");
              cipherKey = bufferSlice(gen, 0, encInfo.keyLen), cipherIV = bufferSlice(gen, encInfo.keyLen, gen.length);
              break;
            }
          }
        else if (kdfName !== "none")
          return new Error("Malformed OpenSSH private key");
        if (data._pos + 3 >= data.length)
          return new Error("Malformed OpenSSH private key");
        let keyCount = readUInt32BE(data, data._pos);
        if (data._pos += 4, keyCount > 0) {
          for (let i = 0; i < keyCount; ++i) {
            let pubData = readString(data, data._pos);
            if (pubData === void 0)
              return new Error("Malformed OpenSSH private key");
            if (readString(pubData, 0, !0) === void 0)
              return new Error("Malformed OpenSSH private key");
          }
          let privBlob = readString(data, data._pos);
          if (privBlob === void 0)
            return new Error("Malformed OpenSSH private key");
          if (cipherKey !== void 0) {
            if (privBlob.length < encInfo.blockLen || privBlob.length % encInfo.blockLen !== 0)
              return new Error("Malformed OpenSSH private key");
            try {
              let options = { authTagLength: encInfo.authLen }, decipher = createDecipheriv(
                encInfo.sslName,
                cipherKey,
                cipherIV,
                options
              );
              if (decipher.setAutoPadding(!1), encInfo.authLen > 0) {
                if (data.length - data._pos < encInfo.authLen)
                  return new Error("Malformed OpenSSH private key");
                decipher.setAuthTag(
                  bufferSlice(data, data._pos, data._pos += encInfo.authLen)
                );
              }
              privBlob = combineBuffers(
                decipher.update(privBlob),
                decipher.final()
              );
            } catch (ex) {
              return ex;
            }
          }
          if (data._pos !== data.length)
            return new Error("Malformed OpenSSH private key");
          ret = parseOpenSSHPrivKeys(privBlob, keyCount, cipherKey !== void 0);
        } else
          ret = [];
        return ret instanceof Error ? ret : ret[0];
      };
    }
    function OpenSSH_Old_Private(type, comment, privPEM, pubPEM, pubSSH, algo, decrypted) {
      this.type = type, this.comment = comment, this[SYM_PRIV_PEM] = privPEM, this[SYM_PUB_PEM] = pubPEM, this[SYM_PUB_SSH] = pubSSH, this[SYM_HASH_ALGO] = algo, this[SYM_DECRYPTED] = decrypted;
    }
    OpenSSH_Old_Private.prototype = BaseKey;
    {
      let regexp = /^-----BEGIN (RSA|DSA|EC) PRIVATE KEY-----(?:\r\n|\n)((?:[^:]+:\s*[\S].*(?:\r\n|\n))*)([\s\S]+)(?:\r\n|\n)-----END (RSA|DSA|EC) PRIVATE KEY-----$/;
      OpenSSH_Old_Private.parse = (str, passphrase) => {
        let m = regexp.exec(str);
        if (m === null)
          return null;
        let privBlob = Buffer.from(m[3], "base64"), headers = m[2], decrypted = !1;
        if (headers !== void 0) {
          headers = headers.split(/\r\n|\n/g);
          for (let i = 0; i < headers.length; ++i) {
            let header = headers[i], sepIdx = header.indexOf(":");
            if (header.slice(0, sepIdx) === "DEK-Info") {
              let val = header.slice(sepIdx + 2);
              if (sepIdx = val.indexOf(","), sepIdx === -1)
                continue;
              let cipherName = val.slice(0, sepIdx).toLowerCase();
              if (supportedOpenSSLCiphers.indexOf(cipherName) === -1)
                return new Error(
                  `Cipher (${cipherName}) not supported for encrypted OpenSSH private key`
                );
              let encInfo = CIPHER_INFO_OPENSSL[cipherName];
              if (!encInfo)
                return new Error(
                  `Cipher (${cipherName}) not supported for encrypted OpenSSH private key`
                );
              let cipherIV = Buffer.from(val.slice(sepIdx + 1), "hex");
              if (cipherIV.length !== encInfo.ivLen)
                return new Error("Malformed encrypted OpenSSH private key");
              if (!passphrase)
                return new Error(
                  "Encrypted OpenSSH private key detected, but no passphrase given"
                );
              let ivSlice = bufferSlice(cipherIV, 0, 8), cipherKey = createHash("md5").update(passphrase).update(ivSlice).digest();
              for (; cipherKey.length < encInfo.keyLen; )
                cipherKey = combineBuffers(
                  cipherKey,
                  createHash("md5").update(cipherKey).update(passphrase).update(ivSlice).digest()
                );
              cipherKey.length > encInfo.keyLen && (cipherKey = bufferSlice(cipherKey, 0, encInfo.keyLen));
              try {
                let decipher = createDecipheriv(cipherName, cipherKey, cipherIV);
                decipher.setAutoPadding(!1), privBlob = combineBuffers(
                  decipher.update(privBlob),
                  decipher.final()
                ), decrypted = !0;
              } catch (ex) {
                return ex;
              }
            }
          }
        }
        let type, privPEM, pubPEM, pubSSH, algo, reader, errMsg = "Malformed OpenSSH private key";
        switch (decrypted && (errMsg += ". Bad passphrase?"), m[1]) {
          case "RSA":
            type = "ssh-rsa", privPEM = makePEM("RSA PRIVATE", privBlob);
            try {
              reader = new Ber.Reader(privBlob), reader.readSequence(), reader.readInt();
              let n = reader.readString(Ber.Integer, !0);
              if (n === null)
                return new Error(errMsg);
              let e = reader.readString(Ber.Integer, !0);
              if (e === null)
                return new Error(errMsg);
              pubPEM = genOpenSSLRSAPub(n, e), pubSSH = genOpenSSHRSAPub(n, e);
            } catch {
              return new Error(errMsg);
            }
            algo = "sha1";
            break;
          case "DSA":
            type = "ssh-dss", privPEM = makePEM("DSA PRIVATE", privBlob);
            try {
              reader = new Ber.Reader(privBlob), reader.readSequence(), reader.readInt();
              let p = reader.readString(Ber.Integer, !0);
              if (p === null)
                return new Error(errMsg);
              let q = reader.readString(Ber.Integer, !0);
              if (q === null)
                return new Error(errMsg);
              let g = reader.readString(Ber.Integer, !0);
              if (g === null)
                return new Error(errMsg);
              let y = reader.readString(Ber.Integer, !0);
              if (y === null)
                return new Error(errMsg);
              pubPEM = genOpenSSLDSAPub(p, q, g, y), pubSSH = genOpenSSHDSAPub(p, q, g, y);
            } catch {
              return new Error(errMsg);
            }
            algo = "sha1";
            break;
          case "EC": {
            let ecSSLName, ecPriv, ecOID;
            try {
              reader = new Ber.Reader(privBlob), reader.readSequence(), reader.readInt(), ecPriv = reader.readString(Ber.OctetString, !0), reader.readByte();
              let offset = reader.readLength();
              if (offset !== null) {
                if (reader._offset = offset, ecOID = reader.readOID(), ecOID === null)
                  return new Error(errMsg);
                switch (ecOID) {
                  case "1.2.840.10045.3.1.7":
                    ecSSLName = "prime256v1", type = "ecdsa-sha2-nistp256", algo = "sha256";
                    break;
                  case "1.3.132.0.34":
                    ecSSLName = "secp384r1", type = "ecdsa-sha2-nistp384", algo = "sha384";
                    break;
                  case "1.3.132.0.35":
                    ecSSLName = "secp521r1", type = "ecdsa-sha2-nistp521", algo = "sha512";
                    break;
                  default:
                    return new Error(`Unsupported private key EC OID: ${ecOID}`);
                }
              } else
                return new Error(errMsg);
            } catch {
              return new Error(errMsg);
            }
            privPEM = makePEM("EC PRIVATE", privBlob);
            let pubBlob = genOpenSSLECDSAPubFromPriv(ecSSLName, ecPriv);
            pubPEM = genOpenSSLECDSAPub(ecOID, pubBlob), pubSSH = genOpenSSHECDSAPub(ecOID, pubBlob);
            break;
          }
        }
        return new OpenSSH_Old_Private(
          type,
          "",
          privPEM,
          pubPEM,
          pubSSH,
          algo,
          decrypted
        );
      };
    }
    function PPK_Private(type, comment, privPEM, pubPEM, pubSSH, algo, decrypted) {
      this.type = type, this.comment = comment, this[SYM_PRIV_PEM] = privPEM, this[SYM_PUB_PEM] = pubPEM, this[SYM_PUB_SSH] = pubSSH, this[SYM_HASH_ALGO] = algo, this[SYM_DECRYPTED] = decrypted;
    }
    PPK_Private.prototype = BaseKey;
    {
      let EMPTY_PASSPHRASE = Buffer.alloc(0), PPK_IV = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), PPK_PP1 = Buffer.from([0, 0, 0, 0]), PPK_PP2 = Buffer.from([0, 0, 0, 1]), regexp = /^PuTTY-User-Key-File-2: (ssh-(?:rsa|dss))\r?\nEncryption: (aes256-cbc|none)\r?\nComment: ([^\r\n]*)\r?\nPublic-Lines: \d+\r?\n([\s\S]+?)\r?\nPrivate-Lines: \d+\r?\n([\s\S]+?)\r?\nPrivate-MAC: ([^\r\n]+)/;
      PPK_Private.parse = (str, passphrase) => {
        let m = regexp.exec(str);
        if (m === null)
          return null;
        let cipherName = m[2], encrypted = cipherName !== "none";
        if (encrypted && !passphrase)
          return new Error(
            "Encrypted PPK private key detected, but no passphrase given"
          );
        let privBlob = Buffer.from(m[5], "base64");
        if (encrypted) {
          let encInfo = CIPHER_INFO[cipherName], cipherKey = combineBuffers(
            createHash("sha1").update(PPK_PP1).update(passphrase).digest(),
            createHash("sha1").update(PPK_PP2).update(passphrase).digest()
          );
          cipherKey.length > encInfo.keyLen && (cipherKey = bufferSlice(cipherKey, 0, encInfo.keyLen));
          try {
            let decipher = createDecipheriv(encInfo.sslName, cipherKey, PPK_IV);
            decipher.setAutoPadding(!1), privBlob = combineBuffers(
              decipher.update(privBlob),
              decipher.final()
            );
          } catch (ex) {
            return ex;
          }
        }
        let type = m[1], comment = m[3], pubBlob = Buffer.from(m[4], "base64"), mac = m[6], typeLen = type.length, cipherNameLen = cipherName.length, commentLen = Buffer.byteLength(comment), pubLen = pubBlob.length, privLen = privBlob.length, macData = Buffer.allocUnsafe(4 + typeLen + 4 + cipherNameLen + 4 + commentLen + 4 + pubLen + 4 + privLen), p = 0;
        if (writeUInt32BE(macData, typeLen, p), macData.utf8Write(type, p += 4, typeLen), writeUInt32BE(macData, cipherNameLen, p += typeLen), macData.utf8Write(cipherName, p += 4, cipherNameLen), writeUInt32BE(macData, commentLen, p += cipherNameLen), macData.utf8Write(comment, p += 4, commentLen), writeUInt32BE(macData, pubLen, p += commentLen), macData.set(pubBlob, p += 4), writeUInt32BE(macData, privLen, p += pubLen), macData.set(privBlob, p + 4), passphrase || (passphrase = EMPTY_PASSPHRASE), createHmac(
          "sha1",
          createHash("sha1").update("putty-private-key-file-mac-key").update(passphrase).digest()
        ).update(macData).digest("hex") !== mac)
          return encrypted ? new Error(
            "PPK private key integrity check failed -- bad passphrase?"
          ) : new Error("PPK private key integrity check failed");
        let pubPEM, pubSSH, privPEM;
        switch (pubBlob._pos = 0, skipFields(pubBlob, 1), type) {
          case "ssh-rsa": {
            let e = readString(pubBlob, pubBlob._pos);
            if (e === void 0)
              return new Error("Malformed PPK public key");
            let n = readString(pubBlob, pubBlob._pos);
            if (n === void 0)
              return new Error("Malformed PPK public key");
            let d = readString(privBlob, 0);
            if (d === void 0)
              return new Error("Malformed PPK private key");
            let p2 = readString(privBlob, privBlob._pos);
            if (p2 === void 0)
              return new Error("Malformed PPK private key");
            let q = readString(privBlob, privBlob._pos);
            if (q === void 0)
              return new Error("Malformed PPK private key");
            let iqmp = readString(privBlob, privBlob._pos);
            if (iqmp === void 0)
              return new Error("Malformed PPK private key");
            pubPEM = genOpenSSLRSAPub(n, e), pubSSH = genOpenSSHRSAPub(n, e), privPEM = genOpenSSLRSAPriv(n, e, d, iqmp, p2, q);
            break;
          }
          case "ssh-dss": {
            let p2 = readString(pubBlob, pubBlob._pos);
            if (p2 === void 0)
              return new Error("Malformed PPK public key");
            let q = readString(pubBlob, pubBlob._pos);
            if (q === void 0)
              return new Error("Malformed PPK public key");
            let g = readString(pubBlob, pubBlob._pos);
            if (g === void 0)
              return new Error("Malformed PPK public key");
            let y = readString(pubBlob, pubBlob._pos);
            if (y === void 0)
              return new Error("Malformed PPK public key");
            let x = readString(privBlob, 0);
            if (x === void 0)
              return new Error("Malformed PPK private key");
            pubPEM = genOpenSSLDSAPub(p2, q, g, y), pubSSH = genOpenSSHDSAPub(p2, q, g, y), privPEM = genOpenSSLDSAPriv(p2, q, g, y, x);
            break;
          }
        }
        return new PPK_Private(
          type,
          comment,
          privPEM,
          pubPEM,
          pubSSH,
          "sha1",
          encrypted
        );
      };
    }
    function OpenSSH_Public(type, comment, pubPEM, pubSSH, algo) {
      this.type = type, this.comment = comment, this[SYM_PRIV_PEM] = null, this[SYM_PUB_PEM] = pubPEM, this[SYM_PUB_SSH] = pubSSH, this[SYM_HASH_ALGO] = algo, this[SYM_DECRYPTED] = !1;
    }
    OpenSSH_Public.prototype = BaseKey;
    {
      let regexp;
      eddsaSupported ? regexp = /^(((?:ssh-(?:rsa|dss|ed25519))|ecdsa-sha2-nistp(?:256|384|521))(?:-cert-v0[01]@openssh.com)?) ([A-Z0-9a-z/+=]+)(?:$|\s+([\S].*)?)$/ : regexp = /^(((?:ssh-(?:rsa|dss))|ecdsa-sha2-nistp(?:256|384|521))(?:-cert-v0[01]@openssh.com)?) ([A-Z0-9a-z/+=]+)(?:$|\s+([\S].*)?)$/, OpenSSH_Public.parse = (str) => {
        let m = regexp.exec(str);
        if (m === null)
          return null;
        let fullType = m[1], baseType = m[2], data = Buffer.from(m[3], "base64"), comment = m[4] || "", type = readString(data, data._pos, !0);
        return type === void 0 || type.indexOf(baseType) !== 0 ? new Error("Malformed OpenSSH public key") : parseDER(data, baseType, comment, fullType);
      };
    }
    function RFC4716_Public(type, comment, pubPEM, pubSSH, algo) {
      this.type = type, this.comment = comment, this[SYM_PRIV_PEM] = null, this[SYM_PUB_PEM] = pubPEM, this[SYM_PUB_SSH] = pubSSH, this[SYM_HASH_ALGO] = algo, this[SYM_DECRYPTED] = !1;
    }
    RFC4716_Public.prototype = BaseKey;
    {
      let regexp = /^---- BEGIN SSH2 PUBLIC KEY ----(?:\r?\n)((?:.{0,72}\r?\n)+)---- END SSH2 PUBLIC KEY ----$/, RE_DATA = /^[A-Z0-9a-z/+=\r\n]+$/, RE_HEADER = /^([\x21-\x39\x3B-\x7E]{1,64}): ((?:[^\\]*\\\r?\n)*[^\r\n]+)\r?\n/gm, RE_HEADER_ENDS = /\\\r?\n/g;
      RFC4716_Public.parse = (str) => {
        let m = regexp.exec(str);
        if (m === null)
          return null;
        let body = m[1], dataStart = 0, comment = "";
        for (; m = RE_HEADER.exec(body); ) {
          let headerName = m[1], headerValue = m[2].replace(RE_HEADER_ENDS, "");
          if (headerValue.length > 1024)
            return RE_HEADER.lastIndex = 0, new Error("Malformed RFC4716 public key");
          dataStart = RE_HEADER.lastIndex, headerName.toLowerCase() === "comment" && (comment = headerValue, comment.length > 1 && comment.charCodeAt(0) === 34 && comment.charCodeAt(comment.length - 1) === 34 && (comment = comment.slice(1, -1)));
        }
        let data = body.slice(dataStart);
        if (!RE_DATA.test(data))
          return new Error("Malformed RFC4716 public key");
        data = Buffer.from(data, "base64");
        let type = readString(data, 0, !0);
        if (type === void 0)
          return new Error("Malformed RFC4716 public key");
        let pubPEM = null, pubSSH = null;
        switch (type) {
          case "ssh-rsa": {
            let e = readString(data, data._pos);
            if (e === void 0)
              return new Error("Malformed RFC4716 public key");
            let n = readString(data, data._pos);
            if (n === void 0)
              return new Error("Malformed RFC4716 public key");
            pubPEM = genOpenSSLRSAPub(n, e), pubSSH = genOpenSSHRSAPub(n, e);
            break;
          }
          case "ssh-dss": {
            let p = readString(data, data._pos);
            if (p === void 0)
              return new Error("Malformed RFC4716 public key");
            let q = readString(data, data._pos);
            if (q === void 0)
              return new Error("Malformed RFC4716 public key");
            let g = readString(data, data._pos);
            if (g === void 0)
              return new Error("Malformed RFC4716 public key");
            let y = readString(data, data._pos);
            if (y === void 0)
              return new Error("Malformed RFC4716 public key");
            pubPEM = genOpenSSLDSAPub(p, q, g, y), pubSSH = genOpenSSHDSAPub(p, q, g, y);
            break;
          }
          default:
            return new Error("Malformed RFC4716 public key");
        }
        return new RFC4716_Public(type, comment, pubPEM, pubSSH, "sha1");
      };
    }
    function parseDER(data, baseType, comment, fullType) {
      if (!isSupportedKeyType(baseType))
        return new Error(`Unsupported OpenSSH public key type: ${baseType}`);
      let algo, oid, pubPEM = null, pubSSH = null;
      switch (baseType) {
        case "ssh-rsa": {
          let e = readString(data, data._pos || 0);
          if (e === void 0)
            return new Error("Malformed OpenSSH public key");
          let n = readString(data, data._pos);
          if (n === void 0)
            return new Error("Malformed OpenSSH public key");
          pubPEM = genOpenSSLRSAPub(n, e), pubSSH = genOpenSSHRSAPub(n, e), algo = "sha1";
          break;
        }
        case "ssh-dss": {
          let p = readString(data, data._pos || 0);
          if (p === void 0)
            return new Error("Malformed OpenSSH public key");
          let q = readString(data, data._pos);
          if (q === void 0)
            return new Error("Malformed OpenSSH public key");
          let g = readString(data, data._pos);
          if (g === void 0)
            return new Error("Malformed OpenSSH public key");
          let y = readString(data, data._pos);
          if (y === void 0)
            return new Error("Malformed OpenSSH public key");
          pubPEM = genOpenSSLDSAPub(p, q, g, y), pubSSH = genOpenSSHDSAPub(p, q, g, y), algo = "sha1";
          break;
        }
        case "ssh-ed25519": {
          let edpub = readString(data, data._pos || 0);
          if (edpub === void 0 || edpub.length !== 32)
            return new Error("Malformed OpenSSH public key");
          pubPEM = genOpenSSLEdPub(edpub), pubSSH = genOpenSSHEdPub(edpub), algo = null;
          break;
        }
        case "ecdsa-sha2-nistp256":
          algo = "sha256", oid = "1.2.840.10045.3.1.7";
        // FALLTHROUGH
        case "ecdsa-sha2-nistp384":
          algo === void 0 && (algo = "sha384", oid = "1.3.132.0.34");
        // FALLTHROUGH
        case "ecdsa-sha2-nistp521": {
          if (algo === void 0 && (algo = "sha512", oid = "1.3.132.0.35"), !skipFields(data, 1))
            return new Error("Malformed OpenSSH public key");
          let ecpub = readString(data, data._pos || 0);
          if (ecpub === void 0)
            return new Error("Malformed OpenSSH public key");
          pubPEM = genOpenSSLECDSAPub(oid, ecpub), pubSSH = genOpenSSHECDSAPub(oid, ecpub);
          break;
        }
        default:
          return new Error(`Unsupported OpenSSH public key type: ${baseType}`);
      }
      return new OpenSSH_Public(fullType, comment, pubPEM, pubSSH, algo);
    }
    function isSupportedKeyType(type) {
      switch (type) {
        case "ssh-rsa":
        case "ssh-dss":
        case "ecdsa-sha2-nistp256":
        case "ecdsa-sha2-nistp384":
        case "ecdsa-sha2-nistp521":
          return !0;
        case "ssh-ed25519":
          if (eddsaSupported)
            return !0;
        // FALLTHROUGH
        default:
          return !1;
      }
    }
    function isParsedKey(val) {
      return val ? typeof val[SYM_DECRYPTED] == "boolean" : !1;
    }
    function parseKey(data, passphrase) {
      if (isParsedKey(data))
        return data;
      let origBuffer;
      if (Buffer.isBuffer(data))
        origBuffer = data, data = data.utf8Slice(0, data.length).trim();
      else if (typeof data == "string")
        data = data.trim();
      else
        return new Error("Key data must be a Buffer or string");
      if (passphrase != null) {
        if (typeof passphrase == "string")
          passphrase = Buffer.from(passphrase);
        else if (!Buffer.isBuffer(passphrase))
          return new Error("Passphrase must be a string or Buffer when supplied");
      }
      let ret;
      if ((ret = OpenSSH_Private.parse(data, passphrase)) !== null || (ret = OpenSSH_Old_Private.parse(data, passphrase)) !== null || (ret = PPK_Private.parse(data, passphrase)) !== null || (ret = OpenSSH_Public.parse(data)) !== null || (ret = RFC4716_Public.parse(data)) !== null)
        return ret;
      if (origBuffer) {
        binaryKeyParser.init(origBuffer, 0);
        let type = binaryKeyParser.readString(!0);
        type !== void 0 && (data = binaryKeyParser.readRaw(), data !== void 0 && (ret = parseDER(data, type, "", type), ret instanceof Error && (ret = null))), binaryKeyParser.clear();
      }
      return ret || new Error("Unsupported key format");
    }
    module2.exports = {
      isParsedKey,
      isSupportedKeyType,
      parseDERKey: (data, type) => parseDER(data, type, "", type),
      parseKey
    };
  }
});

// node_modules/ssh2/lib/agent.js
var require_agent2 = __commonJS({
  "node_modules/ssh2/lib/agent.js"(exports2, module2) {
    "use strict";
    var { Socket } = require("net"), { Duplex } = require("stream"), { resolve: resolve2 } = require("path"), { readFile } = require("fs"), { execFile, spawn } = require("child_process"), { isParsedKey, parseKey } = require_keyParser(), {
      makeBufferParser,
      readUInt32BE,
      writeUInt32BE,
      writeUInt32LE
    } = require_utils5();
    function once(cb) {
      let called = !1;
      return (...args) => {
        called || (called = !0, cb(...args));
      };
    }
    function concat(buf1, buf2) {
      let combined = Buffer.allocUnsafe(buf1.length + buf2.length);
      return buf1.copy(combined, 0), buf2.copy(combined, buf1.length), combined;
    }
    function noop2() {
    }
    var EMPTY_BUF = Buffer.alloc(0), binaryParser = makeBufferParser(), BaseAgent = class {
      getIdentities(cb) {
        cb(new Error("Missing getIdentities() implementation"));
      }
      sign(pubKey, data, options, cb) {
        typeof options == "function" && (cb = options), cb(new Error("Missing sign() implementation"));
      }
    }, OpenSSHAgent = class extends BaseAgent {
      constructor(socketPath) {
        super(), this.socketPath = socketPath;
      }
      getStream(cb) {
        cb = once(cb);
        let sock = new Socket();
        sock.on("connect", () => {
          cb(null, sock);
        }), sock.on("close", onFail).on("end", onFail).on("error", onFail), sock.connect(this.socketPath);
        function onFail() {
          try {
            sock.destroy();
          } catch {
          }
          cb(new Error("Failed to connect to agent"));
        }
      }
      getIdentities(cb) {
        cb = once(cb), this.getStream((err, stream) => {
          function onFail(err2) {
            if (stream)
              try {
                stream.destroy();
              } catch {
              }
            err2 || (err2 = new Error("Failed to retrieve identities from agent")), cb(err2);
          }
          if (err)
            return onFail(err);
          let protocol = new AgentProtocol(!0);
          protocol.on("error", onFail), protocol.pipe(stream).pipe(protocol), stream.on("close", onFail).on("end", onFail).on("error", onFail), protocol.getIdentities((err2, keys) => {
            if (err2)
              return onFail(err2);
            try {
              stream.destroy();
            } catch {
            }
            cb(null, keys);
          });
        });
      }
      sign(pubKey, data, options, cb) {
        typeof options == "function" ? (cb = options, options = void 0) : (typeof options != "object" || options === null) && (options = void 0), cb = once(cb), this.getStream((err, stream) => {
          function onFail(err2) {
            if (stream)
              try {
                stream.destroy();
              } catch {
              }
            err2 || (err2 = new Error("Failed to sign data with agent")), cb(err2);
          }
          if (err)
            return onFail(err);
          let protocol = new AgentProtocol(!0);
          protocol.on("error", onFail), protocol.pipe(stream).pipe(protocol), stream.on("close", onFail).on("end", onFail).on("error", onFail), protocol.sign(pubKey, data, options, (err2, sig) => {
            if (err2)
              return onFail(err2);
            try {
              stream.destroy();
            } catch {
            }
            cb(null, sig);
          });
        });
      }
    }, PageantAgent = (() => {
      let EXEPATH = resolve2(__dirname, "..", "util/pagent.exe"), ERROR2 = {
        10: new Error("Invalid pagent.exe arguments"),
        11: new Error("Pageant is not running"),
        12: new Error("pagent.exe could not create an mmap"),
        13: new Error("pagent.exe could not set mode for stdin"),
        14: new Error("pagent.exe could not set mode for stdout"),
        15: new Error("pagent.exe did not get expected input payload")
      };
      function destroy(stream) {
        stream.buffer = null, stream.proc && (stream.proc.kill(), stream.proc = void 0);
      }
      class PageantSocket extends Duplex {
        constructor() {
          super(), this.proc = void 0, this.buffer = null;
        }
        _read(n) {
        }
        _write(data, encoding, cb) {
          if (this.buffer === null)
            this.buffer = data;
          else {
            let newBuffer = Buffer.allocUnsafe(this.buffer.length + data.length);
            this.buffer.copy(newBuffer, 0), data.copy(newBuffer, this.buffer.length), this.buffer = newBuffer;
          }
          if (this.buffer.length < 4)
            return cb();
          let len = readUInt32BE(this.buffer, 0);
          if (this.buffer.length - 4 < len)
            return cb();
          if (data = this.buffer.slice(0, 4 + len), this.buffer.length > 4 + len)
            return cb(new Error("Unexpected multiple agent requests"));
          this.buffer = null;
          let error, proc2 = this.proc = spawn(EXEPATH, [data.length]);
          proc2.stdout.on("data", (data2) => {
            this.push(data2);
          }), proc2.on("error", (err) => {
            error = err, cb(error);
          }), proc2.on("close", (code2) => {
            if (this.proc = void 0, !error) {
              if (error = ERROR2[code2])
                return cb(error);
              cb();
            }
          }), proc2.stdin.end(data);
        }
        _final(cb) {
          destroy(this), cb();
        }
        _destroy(err, cb) {
          destroy(this), cb();
        }
      }
      return class extends OpenSSHAgent {
        getStream(cb) {
          cb(null, new PageantSocket());
        }
      };
    })(), CygwinAgent = /* @__PURE__ */ (() => {
      let RE_CYGWIN_SOCK = /^!<socket >(\d+) s ([A-Z0-9]{8}-[A-Z0-9]{8}-[A-Z0-9]{8}-[A-Z0-9]{8})/;
      return class extends OpenSSHAgent {
        getStream(cb) {
          cb = once(cb);
          let socketPath = this.socketPath, triedCygpath = !1;
          readFile(socketPath, function readCygsocket(err, data) {
            if (err) {
              if (triedCygpath)
                return cb(new Error("Invalid cygwin unix socket path"));
              execFile("cygpath", ["-w", socketPath], (err2, stdout, stderr) => {
                if (err2 || stdout.length === 0)
                  return cb(new Error("Invalid cygwin unix socket path"));
                triedCygpath = !0, socketPath = stdout.toString().replace(/[\r\n]/g, ""), readFile(socketPath, readCygsocket);
              });
              return;
            }
            let m = RE_CYGWIN_SOCK.exec(data.toString("ascii"));
            if (!m)
              return cb(new Error("Malformed cygwin unix socket file"));
            let state, bc = 0, isRetrying = !1, inBuf = [], sock, credsBuf = Buffer.alloc(12), port = parseInt(m[1], 10), secret = m[2].replace(/-/g, ""), secretBuf = Buffer.allocUnsafe(16);
            for (let i = 0, j = 0; j < 32; ++i, j += 2)
              secretBuf[i] = parseInt(secret.substring(j, j + 2), 16);
            for (let i = 0; i < 16; i += 4)
              writeUInt32LE(secretBuf, readUInt32BE(secretBuf, i), i);
            tryConnect();
            function _onconnect() {
              bc = 0, state = "secret", sock.write(secretBuf);
            }
            function _ondata(data2) {
              if (bc += data2.length, state === "secret") {
                bc === 16 && (bc = 0, state = "creds", sock.write(credsBuf));
                return;
              }
              if (state === "creds" && (isRetrying || inBuf.push(data2), bc === 12)) {
                if (sock.removeListener("connect", _onconnect), sock.removeListener("data", _ondata), sock.removeListener("error", onFail), sock.removeListener("end", onFail), sock.removeListener("close", onFail), isRetrying)
                  return cb(null, sock);
                isRetrying = !0, credsBuf = Buffer.concat(inBuf), writeUInt32LE(credsBuf, process.pid, 0), sock.on("error", () => {
                }), sock.destroy(), tryConnect();
              }
            }
            function onFail() {
              cb(new Error("Problem negotiating cygwin unix socket security"));
            }
            function tryConnect() {
              sock = new Socket(), sock.on("connect", _onconnect), sock.on("data", _ondata), sock.on("error", onFail), sock.on("end", onFail), sock.on("close", onFail), sock.connect(port);
            }
          });
        }
      };
    })(), WINDOWS_PIPE_REGEX = /^[/\\][/\\]\.[/\\]pipe[/\\].+/;
    function createAgent(path8) {
      return process.platform === "win32" && !WINDOWS_PIPE_REGEX.test(path8) ? path8 === "pageant" ? new PageantAgent() : new CygwinAgent(path8) : new OpenSSHAgent(path8);
    }
    var AgentProtocol = (() => {
      function processResponses(protocol) {
        let ret;
        for (; protocol[SYM_REQS].length; ) {
          let nextResponse = protocol[SYM_REQS][0][SYM_RESP];
          if (nextResponse === void 0)
            break;
          protocol[SYM_REQS].shift(), ret = protocol.push(nextResponse);
        }
        return ret;
      }
      let SYM_TYPE = Symbol("Inbound Request Type"), SYM_RESP = Symbol("Inbound Request Response"), SYM_CTX = Symbol("Inbound Request Context");
      class AgentInboundRequest {
        constructor(type, ctx) {
          this[SYM_TYPE] = type, this[SYM_RESP] = void 0, this[SYM_CTX] = ctx;
        }
        hasResponded() {
          return this[SYM_RESP] !== void 0;
        }
        getType() {
          return this[SYM_TYPE];
        }
        getContext() {
          return this[SYM_CTX];
        }
      }
      function respond(protocol, req, data) {
        return req[SYM_RESP] = data, processResponses(protocol);
      }
      function cleanup(protocol) {
        if (protocol[SYM_BUFFER] = null, protocol[SYM_MODE] === 0) {
          let reqs = protocol[SYM_REQS];
          if (reqs && reqs.length) {
            protocol[SYM_REQS] = [];
            for (let req of reqs)
              req.cb(new Error("No reply from server"));
          }
        }
        try {
          protocol.end();
        } catch {
        }
        setImmediate(() => {
          protocol[SYM_ENDED] || protocol.emit("end"), protocol[SYM_CLOSED] || protocol.emit("close");
        });
      }
      function onClose() {
        this[SYM_CLOSED] = !0;
      }
      function onEnd() {
        this[SYM_ENDED] = !0;
      }
      let SYM_REQS = Symbol("Requests"), SYM_MODE = Symbol("Agent Protocol Role"), SYM_BUFFER = Symbol("Agent Protocol Buffer"), SYM_MSGLEN = Symbol("Agent Protocol Current Message Length"), SYM_CLOSED = Symbol("Agent Protocol Closed"), SYM_ENDED = Symbol("Agent Protocol Ended");
      return class extends Duplex {
        /*
            Notes:
              - `constraint` type consists of:
                   byte                    constraint_type
                   byte[]                  constraint_data
                where `constraint_type` is one of:
                  * SSH_AGENT_CONSTRAIN_LIFETIME
                    - `constraint_data` consists of:
                         uint32                  seconds
                  * SSH_AGENT_CONSTRAIN_CONFIRM
                    - `constraint_data` N/A
                  * SSH_AGENT_CONSTRAIN_EXTENSION
                    - `constraint_data` consists of:
                         string                  extension name
                         byte[]                  extension-specific details
        */
        constructor(isClient) {
          super({ autoDestroy: !0, emitClose: !1 }), this[SYM_MODE] = isClient ? 0 : 1, this[SYM_REQS] = [], this[SYM_BUFFER] = null, this[SYM_MSGLEN] = -1, this.once("end", onEnd), this.once("close", onClose);
        }
        _read(n) {
        }
        _write(data, encoding, cb) {
          this[SYM_BUFFER] === null ? this[SYM_BUFFER] = data : this[SYM_BUFFER] = concat(this[SYM_BUFFER], data);
          let buffer = this[SYM_BUFFER], bufferLen = buffer.length, p = 0;
          for (; p < bufferLen && !(bufferLen < 5 || (this[SYM_MSGLEN] === -1 && (this[SYM_MSGLEN] = readUInt32BE(buffer, p)), bufferLen < 4 + this[SYM_MSGLEN])); ) {
            let msgType = buffer[p += 4];
            if (++p, this[SYM_MODE] === 0) {
              if (this[SYM_REQS].length === 0)
                return cb(new Error("Received unexpected message from server"));
              let req = this[SYM_REQS].shift();
              switch (msgType) {
                case 5:
                  req.cb(new Error("Agent responded with failure"));
                  break;
                case 12: {
                  if (req.type !== 11)
                    return cb(new Error("Agent responded with wrong message type"));
                  binaryParser.init(buffer, p);
                  let numKeys = binaryParser.readUInt32BE();
                  if (numKeys === void 0)
                    return binaryParser.clear(), cb(new Error("Malformed agent response"));
                  let keys = [];
                  for (let i = 0; i < numKeys; ++i) {
                    let pubKey = binaryParser.readString();
                    if (pubKey === void 0)
                      return binaryParser.clear(), cb(new Error("Malformed agent response"));
                    let comment = binaryParser.readString(!0);
                    if (comment === void 0)
                      return binaryParser.clear(), cb(new Error("Malformed agent response"));
                    pubKey = parseKey(pubKey), !(pubKey instanceof Error) && (pubKey.comment = pubKey.comment || comment, keys.push(pubKey));
                  }
                  p = binaryParser.pos(), binaryParser.clear(), req.cb(null, keys);
                  break;
                }
                case 14: {
                  if (req.type !== 13)
                    return cb(new Error("Agent responded with wrong message type"));
                  binaryParser.init(buffer, p);
                  let signature = binaryParser.readString();
                  if (p = binaryParser.pos(), binaryParser.clear(), signature === void 0)
                    return cb(new Error("Malformed agent response"));
                  if (binaryParser.init(signature, 0), binaryParser.readString(!0), signature = binaryParser.readString(), binaryParser.clear(), signature === void 0)
                    return cb(new Error("Malformed OpenSSH signature format"));
                  req.cb(null, signature);
                  break;
                }
                default:
                  return cb(
                    new Error("Agent responded with unsupported message type")
                  );
              }
            } else
              switch (msgType) {
                case 11: {
                  let req = new AgentInboundRequest(msgType);
                  this[SYM_REQS].push(req), this.emit("identities", req);
                  break;
                }
                case 13: {
                  binaryParser.init(buffer, p);
                  let pubKey = binaryParser.readString(), data2 = binaryParser.readString(), flagsVal = binaryParser.readUInt32BE();
                  if (p = binaryParser.pos(), binaryParser.clear(), flagsVal === void 0) {
                    let req2 = new AgentInboundRequest(msgType);
                    return this[SYM_REQS].push(req2), this.failureReply(req2);
                  }
                  if (pubKey = parseKey(pubKey), pubKey instanceof Error) {
                    let req2 = new AgentInboundRequest(msgType);
                    return this[SYM_REQS].push(req2), this.failureReply(req2);
                  }
                  let flags = {
                    hash: void 0
                  }, ctx;
                  pubKey.type === "ssh-rsa" && (flagsVal & 2 ? (ctx = "rsa-sha2-256", flags.hash = "sha256") : flagsVal & 4 && (ctx = "rsa-sha2-512", flags.hash = "sha512")), ctx === void 0 && (ctx = pubKey.type);
                  let req = new AgentInboundRequest(msgType, ctx);
                  this[SYM_REQS].push(req), this.emit("sign", req, pubKey, data2, flags);
                  break;
                }
                default: {
                  let req = new AgentInboundRequest(msgType);
                  this[SYM_REQS].push(req), this.failureReply(req);
                }
              }
            if (this[SYM_MSGLEN] = -1, p === bufferLen) {
              this[SYM_BUFFER] = null;
              break;
            } else
              this[SYM_BUFFER] = buffer = buffer.slice(p), bufferLen = buffer.length, p = 0;
          }
          cb();
        }
        _destroy(err, cb) {
          cleanup(this), cb();
        }
        _final(cb) {
          cleanup(this), cb();
        }
        // Client->Server messages =================================================
        sign(pubKey, data, options, cb) {
          if (this[SYM_MODE] !== 0)
            throw new Error("Client-only method called with server role");
          typeof options == "function" ? (cb = options, options = void 0) : (typeof options != "object" || options === null) && (options = void 0);
          let flags = 0;
          if (pubKey = parseKey(pubKey), pubKey instanceof Error)
            throw new Error("Invalid public key argument");
          if (pubKey.type === "ssh-rsa" && options)
            switch (options.hash) {
              case "sha256":
                flags = 2;
                break;
              case "sha512":
                flags = 4;
                break;
            }
          pubKey = pubKey.getPublicSSH();
          let type = 13, keyLen = pubKey.length, dataLen = data.length, p = 0, buf = Buffer.allocUnsafe(9 + keyLen + 4 + dataLen + 4);
          return writeUInt32BE(buf, buf.length - 4, p), buf[p += 4] = type, writeUInt32BE(buf, keyLen, ++p), pubKey.copy(buf, p += 4), writeUInt32BE(buf, dataLen, p += keyLen), data.copy(buf, p += 4), writeUInt32BE(buf, flags, p += dataLen), typeof cb != "function" && (cb = noop2), this[SYM_REQS].push({ type, cb }), this.push(buf);
        }
        getIdentities(cb) {
          if (this[SYM_MODE] !== 0)
            throw new Error("Client-only method called with server role");
          let type = 11, p = 0, buf = Buffer.allocUnsafe(5);
          return writeUInt32BE(buf, buf.length - 4, p), buf[p += 4] = type, typeof cb != "function" && (cb = noop2), this[SYM_REQS].push({ type, cb }), this.push(buf);
        }
        // Server->Client messages =================================================
        failureReply(req) {
          if (this[SYM_MODE] !== 1)
            throw new Error("Server-only method called with client role");
          if (!(req instanceof AgentInboundRequest))
            throw new Error("Wrong request argument");
          if (req.hasResponded())
            return !0;
          let p = 0, buf = Buffer.allocUnsafe(5);
          return writeUInt32BE(buf, buf.length - 4, p), buf[p += 4] = 5, respond(this, req, buf);
        }
        getIdentitiesReply(req, keys) {
          if (this[SYM_MODE] !== 1)
            throw new Error("Server-only method called with client role");
          if (!(req instanceof AgentInboundRequest))
            throw new Error("Wrong request argument");
          if (req.hasResponded())
            return !0;
          if (req.getType() !== 11)
            throw new Error("Invalid response to request");
          if (!Array.isArray(keys))
            throw new Error("Keys argument must be an array");
          let totalKeysLen = 4, newKeys = [];
          for (let i = 0; i < keys.length; ++i) {
            let entry = keys[i];
            if (typeof entry != "object" || entry === null)
              throw new Error(`Invalid key entry: ${entry}`);
            let pubKey, comment;
            if (isParsedKey(entry))
              pubKey = entry;
            else if (isParsedKey(entry.pubKey))
              pubKey = entry.pubKey;
            else if (typeof entry.pubKey != "object" || entry.pubKey === null || ({ pubKey, comment } = entry.pubKey, pubKey = parseKey(pubKey), pubKey instanceof Error))
              continue;
            comment = pubKey.comment || comment, pubKey = pubKey.getPublicSSH(), totalKeysLen += 4 + pubKey.length, comment && typeof comment == "string" ? comment = Buffer.from(comment) : Buffer.isBuffer(comment) || (comment = EMPTY_BUF), totalKeysLen += 4 + comment.length, newKeys.push({ pubKey, comment });
          }
          let p = 0, buf = Buffer.allocUnsafe(5 + totalKeysLen);
          writeUInt32BE(buf, buf.length - 4, p), buf[p += 4] = 12, writeUInt32BE(buf, newKeys.length, ++p), p += 4;
          for (let i = 0; i < newKeys.length; ++i) {
            let { pubKey, comment } = newKeys[i];
            writeUInt32BE(buf, pubKey.length, p), pubKey.copy(buf, p += 4), writeUInt32BE(buf, comment.length, p += pubKey.length), p += 4, comment.length && (comment.copy(buf, p), p += comment.length);
          }
          return respond(this, req, buf);
        }
        signReply(req, signature) {
          if (this[SYM_MODE] !== 1)
            throw new Error("Server-only method called with client role");
          if (!(req instanceof AgentInboundRequest))
            throw new Error("Wrong request argument");
          if (req.hasResponded())
            return !0;
          if (req.getType() !== 13)
            throw new Error("Invalid response to request");
          if (!Buffer.isBuffer(signature))
            throw new Error("Signature argument must be a Buffer");
          if (signature.length === 0)
            throw new Error("Signature argument must be non-empty");
          let p = 0, sigFormat = req.getContext(), sigFormatLen = Buffer.byteLength(sigFormat), buf = Buffer.allocUnsafe(
            13 + sigFormatLen + 4 + signature.length
          );
          return writeUInt32BE(buf, buf.length - 4, p), buf[p += 4] = 14, writeUInt32BE(buf, 4 + sigFormatLen + 4 + signature.length, ++p), writeUInt32BE(buf, sigFormatLen, p += 4), buf.utf8Write(sigFormat, p += 4, sigFormatLen), writeUInt32BE(buf, signature.length, p += sigFormatLen), signature.copy(buf, p += 4), respond(this, req, buf);
        }
      };
    })(), SYM_AGENT = Symbol("Agent"), SYM_AGENT_KEYS = Symbol("Agent Keys"), SYM_AGENT_KEYS_IDX = Symbol("Agent Keys Index"), SYM_AGENT_CBS = Symbol("Agent Init Callbacks"), AgentContext = class {
      constructor(agent) {
        if (typeof agent == "string")
          agent = createAgent(agent);
        else if (!isAgent(agent))
          throw new Error("Invalid agent argument");
        this[SYM_AGENT] = agent, this[SYM_AGENT_KEYS] = null, this[SYM_AGENT_KEYS_IDX] = -1, this[SYM_AGENT_CBS] = null;
      }
      init(cb) {
        if (typeof cb != "function" && (cb = noop2), this[SYM_AGENT_KEYS] === null)
          if (this[SYM_AGENT_CBS] === null) {
            this[SYM_AGENT_CBS] = [cb];
            let doCbs = (...args) => {
              process.nextTick(() => {
                let cbs = this[SYM_AGENT_CBS];
                this[SYM_AGENT_CBS] = null;
                for (let cb2 of cbs)
                  cb2(...args);
              });
            };
            this[SYM_AGENT].getIdentities(once((err, keys) => {
              if (err)
                return doCbs(err);
              if (!Array.isArray(keys))
                return doCbs(new Error(
                  "Agent implementation failed to provide keys"
                ));
              let newKeys = [];
              for (let key of keys)
                key = parseKey(key), !(key instanceof Error) && newKeys.push(key);
              this[SYM_AGENT_KEYS] = newKeys, this[SYM_AGENT_KEYS_IDX] = -1, doCbs();
            }));
          } else
            this[SYM_AGENT_CBS].push(cb);
        else
          process.nextTick(cb);
      }
      nextKey() {
        return this[SYM_AGENT_KEYS] === null || ++this[SYM_AGENT_KEYS_IDX] >= this[SYM_AGENT_KEYS].length ? !1 : this[SYM_AGENT_KEYS][this[SYM_AGENT_KEYS_IDX]];
      }
      currentKey() {
        return this[SYM_AGENT_KEYS] === null || this[SYM_AGENT_KEYS_IDX] >= this[SYM_AGENT_KEYS].length ? null : this[SYM_AGENT_KEYS][this[SYM_AGENT_KEYS_IDX]];
      }
      pos() {
        return this[SYM_AGENT_KEYS] === null || this[SYM_AGENT_KEYS_IDX] >= this[SYM_AGENT_KEYS].length ? -1 : this[SYM_AGENT_KEYS_IDX];
      }
      reset() {
        this[SYM_AGENT_KEYS_IDX] = -1;
      }
      sign(...args) {
        this[SYM_AGENT].sign(...args);
      }
    };
    function isAgent(val) {
      return val instanceof BaseAgent;
    }
    module2.exports = {
      AgentContext,
      AgentProtocol,
      BaseAgent,
      createAgent,
      CygwinAgent,
      isAgent,
      OpenSSHAgent,
      PageantAgent
    };
  }
});

// node_modules/ssh2/lib/protocol/zlib.js
var require_zlib = __commonJS({
  "node_modules/ssh2/lib/protocol/zlib.js"(exports2, module2) {
    "use strict";
    var { kMaxLength } = require("buffer"), {
      createInflate,
      constants: {
        DEFLATE,
        INFLATE,
        Z_DEFAULT_CHUNK,
        Z_DEFAULT_COMPRESSION,
        Z_DEFAULT_MEMLEVEL,
        Z_DEFAULT_STRATEGY,
        Z_DEFAULT_WINDOWBITS,
        Z_PARTIAL_FLUSH
      }
    } = require("zlib"), ZlibHandle = createInflate()._handle.constructor;
    function processCallback() {
      throw new Error("Should not get here");
    }
    function zlibOnError(message, errno, code2) {
      let self2 = this._owner, error = new Error(message);
      error.errno = errno, error.code = code2, self2._err = error;
    }
    function _close2(engine) {
      engine._handle && (engine._handle.close(), engine._handle = null);
    }
    var Zlib2 = class {
      constructor(mode) {
        let windowBits = Z_DEFAULT_WINDOWBITS, level = Z_DEFAULT_COMPRESSION, memLevel = Z_DEFAULT_MEMLEVEL, strategy = Z_DEFAULT_STRATEGY, dictionary = void 0;
        this._err = void 0, this._writeState = new Uint32Array(2), this._chunkSize = Z_DEFAULT_CHUNK, this._maxOutputLength = kMaxLength, this._outBuffer = Buffer.allocUnsafe(this._chunkSize), this._outOffset = 0, this._handle = new ZlibHandle(mode), this._handle._owner = this, this._handle.onerror = zlibOnError, this._handle.init(
          windowBits,
          level,
          memLevel,
          strategy,
          this._writeState,
          processCallback,
          dictionary
        );
      }
      writeSync(chunk, retChunks) {
        let handle = this._handle;
        if (!handle)
          throw new Error("Invalid Zlib instance");
        let availInBefore = chunk.length, availOutBefore = this._chunkSize - this._outOffset, inOff = 0, availOutAfter, availInAfter, buffers, nread = 0, state = this._writeState, buffer = this._outBuffer, offset = this._outOffset, chunkSize = this._chunkSize;
        for (; ; ) {
          if (handle.writeSync(
            Z_PARTIAL_FLUSH,
            chunk,
            // in
            inOff,
            // in_off
            availInBefore,
            // in_len
            buffer,
            // out
            offset,
            // out_off
            availOutBefore
          ), this._err)
            throw this._err;
          availOutAfter = state[0], availInAfter = state[1];
          let inDelta = availInBefore - availInAfter, have = availOutBefore - availOutAfter;
          if (have > 0) {
            let out = offset === 0 && have === buffer.length ? buffer : buffer.slice(offset, offset + have);
            if (offset += have, buffers ? buffers.push === void 0 ? buffers = [buffers, out] : buffers.push(out) : buffers = out, nread += out.byteLength, nread > this._maxOutputLength)
              throw _close2(this), new Error(
                `Output length exceeded maximum of ${this._maxOutputLength}`
              );
          } else if (have !== 0)
            throw new Error("have should not go down");
          if ((availOutAfter === 0 || offset >= chunkSize) && (availOutBefore = chunkSize, offset = 0, buffer = Buffer.allocUnsafe(chunkSize)), availOutAfter === 0)
            inOff += inDelta, availInBefore = availInAfter;
          else
            break;
        }
        if (this._outBuffer = buffer, this._outOffset = offset, nread === 0 && (buffers = Buffer.alloc(0)), retChunks)
          return buffers.totalLen = nread, buffers;
        if (buffers.push === void 0)
          return buffers;
        let output = Buffer.allocUnsafe(nread);
        for (let i = 0, p = 0; i < buffers.length; ++i) {
          let buf = buffers[i];
          output.set(buf, p), p += buf.length;
        }
        return output;
      }
    }, ZlibPacketWriter = class {
      constructor(protocol) {
        this.allocStart = 0, this.allocStartKEX = 0, this._protocol = protocol, this._zlib = new Zlib2(DEFLATE);
      }
      cleanup() {
        this._zlib && _close2(this._zlib);
      }
      alloc(payloadSize, force) {
        return Buffer.allocUnsafe(payloadSize);
      }
      finalize(payload, force) {
        if (this._protocol._kexinit === void 0 || force) {
          let output = this._zlib.writeSync(payload, !0), packet = this._protocol._cipher.allocPacket(output.totalLen);
          if (output.push === void 0)
            packet.set(output, 5);
          else
            for (let i = 0, p = 5; i < output.length; ++i) {
              let chunk = output[i];
              packet.set(chunk, p), p += chunk.length;
            }
          return packet;
        }
        return payload;
      }
    }, PacketWriter = class {
      constructor(protocol) {
        this.allocStart = 5, this.allocStartKEX = 5, this._protocol = protocol;
      }
      cleanup() {
      }
      alloc(payloadSize, force) {
        return this._protocol._kexinit === void 0 || force ? this._protocol._cipher.allocPacket(payloadSize) : Buffer.allocUnsafe(payloadSize);
      }
      finalize(packet, force) {
        return packet;
      }
    }, ZlibPacketReader = class {
      constructor() {
        this._zlib = new Zlib2(INFLATE);
      }
      cleanup() {
        this._zlib && _close2(this._zlib);
      }
      read(data) {
        return this._zlib.writeSync(data, !1);
      }
    }, PacketReader = class {
      cleanup() {
      }
      read(data) {
        return data;
      }
    };
    module2.exports = {
      PacketReader,
      PacketWriter,
      ZlibPacketReader,
      ZlibPacketWriter
    };
  }
});

// node_modules/ssh2/lib/protocol/handlers.misc.js
var require_handlers_misc = __commonJS({
  "node_modules/ssh2/lib/protocol/handlers.misc.js"(exports2, module2) {
    "use strict";
    var {
      bufferSlice,
      bufferParser,
      doFatalError,
      sigSSHToASN1,
      writeUInt32BE
    } = require_utils5(), {
      CHANNEL_OPEN_FAILURE,
      COMPAT,
      MESSAGE,
      TERMINAL_MODE
    } = require_constants6(), {
      parseKey
    } = require_keyParser(), TERMINAL_MODE_BY_VALUE = Array.from(Object.entries(TERMINAL_MODE)).reduce((obj, [key, value]) => ({ ...obj, [key]: value }), {});
    module2.exports = {
      // Transport layer protocol ==================================================
      [MESSAGE.DISCONNECT]: (self2, payload) => {
        bufferParser.init(payload, 1);
        let reason = bufferParser.readUInt32BE(), desc = bufferParser.readString(!0), lang = bufferParser.readString();
        if (bufferParser.clear(), lang === void 0)
          return doFatalError(
            self2,
            "Inbound: Malformed DISCONNECT packet"
          );
        self2._debug && self2._debug(
          `Inbound: Received DISCONNECT (${reason}, "${desc}")`
        );
        let handler = self2._handlers.DISCONNECT;
        handler && handler(self2, reason, desc);
      },
      [MESSAGE.IGNORE]: (self2, payload) => {
        self2._debug && self2._debug("Inbound: Received IGNORE");
      },
      [MESSAGE.UNIMPLEMENTED]: (self2, payload) => {
        bufferParser.init(payload, 1);
        let seqno = bufferParser.readUInt32BE();
        if (bufferParser.clear(), seqno === void 0)
          return doFatalError(
            self2,
            "Inbound: Malformed UNIMPLEMENTED packet"
          );
        self2._debug && self2._debug(`Inbound: Received UNIMPLEMENTED (seqno ${seqno})`);
      },
      [MESSAGE.DEBUG]: (self2, payload) => {
        bufferParser.init(payload, 1);
        let display = bufferParser.readBool(), msg = bufferParser.readString(!0), lang = bufferParser.readString();
        if (bufferParser.clear(), lang === void 0)
          return doFatalError(
            self2,
            "Inbound: Malformed DEBUG packet"
          );
        self2._debug && self2._debug("Inbound: Received DEBUG");
        let handler = self2._handlers.DEBUG;
        handler && handler(self2, display, msg);
      },
      [MESSAGE.SERVICE_REQUEST]: (self2, payload) => {
        bufferParser.init(payload, 1);
        let name2 = bufferParser.readString(!0);
        if (bufferParser.clear(), name2 === void 0)
          return doFatalError(
            self2,
            "Inbound: Malformed SERVICE_REQUEST packet"
          );
        self2._debug && self2._debug(`Inbound: Received SERVICE_REQUEST (${name2})`);
        let handler = self2._handlers.SERVICE_REQUEST;
        handler && handler(self2, name2);
      },
      [MESSAGE.SERVICE_ACCEPT]: (self2, payload) => {
        bufferParser.init(payload, 1);
        let name2 = bufferParser.readString(!0);
        if (bufferParser.clear(), name2 === void 0)
          return doFatalError(
            self2,
            "Inbound: Malformed SERVICE_ACCEPT packet"
          );
        self2._debug && self2._debug(`Inbound: Received SERVICE_ACCEPT (${name2})`);
        let handler = self2._handlers.SERVICE_ACCEPT;
        handler && handler(self2, name2);
      },
      [MESSAGE.EXT_INFO]: (self2, payload) => {
        bufferParser.init(payload, 1);
        let numExts = bufferParser.readUInt32BE(), exts;
        if (numExts !== void 0) {
          exts = [];
          for (let i = 0; i < numExts; ++i) {
            let name2 = bufferParser.readString(!0), data = bufferParser.readString();
            if (data !== void 0)
              switch (name2) {
                case "server-sig-algs": {
                  let algs = data.latin1Slice(0, data.length).split(",");
                  exts.push({ name: name2, algs });
                  continue;
                }
                default:
                  continue;
              }
            exts = void 0;
            break;
          }
        }
        if (bufferParser.clear(), exts === void 0)
          return doFatalError(self2, "Inbound: Malformed EXT_INFO packet");
        self2._debug && self2._debug("Inbound: Received EXT_INFO");
        let handler = self2._handlers.EXT_INFO;
        handler && handler(self2, exts);
      },
      // User auth protocol -- generic =============================================
      [MESSAGE.USERAUTH_REQUEST]: (self2, payload) => {
        bufferParser.init(payload, 1);
        let user = bufferParser.readString(!0), service = bufferParser.readString(!0), method = bufferParser.readString(!0), methodData, methodDesc;
        switch (method) {
          case "none":
            methodData = null;
            break;
          case "password": {
            let isChange = bufferParser.readBool();
            if (isChange !== void 0 && (methodData = bufferParser.readString(!0), methodData !== void 0 && isChange)) {
              let newPassword = bufferParser.readString(!0);
              newPassword !== void 0 ? methodData = { oldPassword: methodData, newPassword } : methodData = void 0;
            }
            break;
          }
          case "publickey": {
            let hasSig = bufferParser.readBool();
            if (hasSig !== void 0) {
              let keyAlgo = bufferParser.readString(!0), realKeyAlgo = keyAlgo, key = bufferParser.readString(), hashAlgo;
              switch (keyAlgo) {
                case "rsa-sha2-256":
                  realKeyAlgo = "ssh-rsa", hashAlgo = "sha256";
                  break;
                case "rsa-sha2-512":
                  realKeyAlgo = "ssh-rsa", hashAlgo = "sha512";
                  break;
              }
              if (hasSig) {
                let blobEnd = bufferParser.pos(), signature = bufferParser.readString();
                if (signature !== void 0 && (signature.length > 4 + keyAlgo.length + 4 && signature.utf8Slice(4, 4 + keyAlgo.length) === keyAlgo && (signature = bufferSlice(signature, 4 + keyAlgo.length + 4)), signature = sigSSHToASN1(signature, realKeyAlgo), signature)) {
                  let sessionID = self2._kex.sessionID, blob = Buffer.allocUnsafe(4 + sessionID.length + blobEnd);
                  writeUInt32BE(blob, sessionID.length, 0), blob.set(sessionID, 4), blob.set(
                    new Uint8Array(payload.buffer, payload.byteOffset, blobEnd),
                    4 + sessionID.length
                  ), methodData = {
                    keyAlgo: realKeyAlgo,
                    key,
                    signature,
                    blob,
                    hashAlgo
                  };
                }
              } else
                methodData = { keyAlgo: realKeyAlgo, key, hashAlgo }, methodDesc = "publickey -- check";
            }
            break;
          }
          case "hostbased": {
            let keyAlgo = bufferParser.readString(!0), realKeyAlgo = keyAlgo, key = bufferParser.readString(), localHostname = bufferParser.readString(!0), localUsername = bufferParser.readString(!0), hashAlgo;
            switch (keyAlgo) {
              case "rsa-sha2-256":
                realKeyAlgo = "ssh-rsa", hashAlgo = "sha256";
                break;
              case "rsa-sha2-512":
                realKeyAlgo = "ssh-rsa", hashAlgo = "sha512";
                break;
            }
            let blobEnd = bufferParser.pos(), signature = bufferParser.readString();
            if (signature !== void 0 && (signature.length > 4 + keyAlgo.length + 4 && signature.utf8Slice(4, 4 + keyAlgo.length) === keyAlgo && (signature = bufferSlice(signature, 4 + keyAlgo.length + 4)), signature = sigSSHToASN1(signature, realKeyAlgo), signature !== void 0)) {
              let sessionID = self2._kex.sessionID, blob = Buffer.allocUnsafe(4 + sessionID.length + blobEnd);
              writeUInt32BE(blob, sessionID.length, 0), blob.set(sessionID, 4), blob.set(
                new Uint8Array(payload.buffer, payload.byteOffset, blobEnd),
                4 + sessionID.length
              ), methodData = {
                keyAlgo: realKeyAlgo,
                key,
                signature,
                blob,
                localHostname,
                localUsername,
                hashAlgo
              };
            }
            break;
          }
          case "keyboard-interactive":
            bufferParser.skipString(), methodData = bufferParser.readList();
            break;
          default:
            method !== void 0 && (methodData = bufferParser.readRaw());
        }
        if (bufferParser.clear(), methodData === void 0)
          return doFatalError(
            self2,
            "Inbound: Malformed USERAUTH_REQUEST packet"
          );
        methodDesc === void 0 && (methodDesc = method), self2._authsQueue.push(method), self2._debug && self2._debug(`Inbound: Received USERAUTH_REQUEST (${methodDesc})`);
        let handler = self2._handlers.USERAUTH_REQUEST;
        handler && handler(self2, user, service, method, methodData);
      },
      [MESSAGE.USERAUTH_FAILURE]: (self2, payload) => {
        bufferParser.init(payload, 1);
        let authMethods = bufferParser.readList(), partialSuccess = bufferParser.readBool();
        if (bufferParser.clear(), partialSuccess === void 0)
          return doFatalError(
            self2,
            "Inbound: Malformed USERAUTH_FAILURE packet"
          );
        self2._debug && self2._debug(`Inbound: Received USERAUTH_FAILURE (${authMethods})`), self2._authsQueue.shift();
        let handler = self2._handlers.USERAUTH_FAILURE;
        handler && handler(self2, authMethods, partialSuccess);
      },
      [MESSAGE.USERAUTH_SUCCESS]: (self2, payload) => {
        self2._debug && self2._debug("Inbound: Received USERAUTH_SUCCESS"), self2._authsQueue.shift();
        let handler = self2._handlers.USERAUTH_SUCCESS;
        handler && handler(self2);
      },
      [MESSAGE.USERAUTH_BANNER]: (self2, payload) => {
        bufferParser.init(payload, 1);
        let msg = bufferParser.readString(!0), lang = bufferParser.readString();
        if (bufferParser.clear(), lang === void 0)
          return doFatalError(
            self2,
            "Inbound: Malformed USERAUTH_BANNER packet"
          );
        self2._debug && self2._debug("Inbound: Received USERAUTH_BANNER");
        let handler = self2._handlers.USERAUTH_BANNER;
        handler && handler(self2, msg);
      },
      // User auth protocol -- method-specific =====================================
      60: (self2, payload) => {
        if (!self2._authsQueue.length) {
          self2._debug && self2._debug("Inbound: Received payload type 60 without auth");
          return;
        }
        switch (self2._authsQueue[0]) {
          case "password": {
            bufferParser.init(payload, 1);
            let prompt = bufferParser.readString(!0), lang = bufferParser.readString();
            if (bufferParser.clear(), lang === void 0)
              return doFatalError(
                self2,
                "Inbound: Malformed USERAUTH_PASSWD_CHANGEREQ packet"
              );
            self2._debug && self2._debug("Inbound: Received USERAUTH_PASSWD_CHANGEREQ");
            let handler = self2._handlers.USERAUTH_PASSWD_CHANGEREQ;
            handler && handler(self2, prompt);
            break;
          }
          case "publickey": {
            bufferParser.init(payload, 1);
            let keyAlgo = bufferParser.readString(!0), key = bufferParser.readString();
            if (bufferParser.clear(), key === void 0)
              return doFatalError(
                self2,
                "Inbound: Malformed USERAUTH_PK_OK packet"
              );
            self2._debug && self2._debug("Inbound: Received USERAUTH_PK_OK"), self2._authsQueue.shift();
            let handler = self2._handlers.USERAUTH_PK_OK;
            handler && handler(self2, keyAlgo, key);
            break;
          }
          case "keyboard-interactive": {
            bufferParser.init(payload, 1);
            let name2 = bufferParser.readString(!0), instructions = bufferParser.readString(!0);
            bufferParser.readString();
            let numPrompts = bufferParser.readUInt32BE(), prompts;
            if (numPrompts !== void 0) {
              prompts = new Array(numPrompts);
              let i;
              for (i = 0; i < numPrompts; ++i) {
                let prompt = bufferParser.readString(!0), echo = bufferParser.readBool();
                if (echo === void 0)
                  break;
                prompts[i] = { prompt, echo };
              }
              i !== numPrompts && (prompts = void 0);
            }
            if (bufferParser.clear(), prompts === void 0)
              return doFatalError(
                self2,
                "Inbound: Malformed USERAUTH_INFO_REQUEST packet"
              );
            self2._debug && self2._debug("Inbound: Received USERAUTH_INFO_REQUEST");
            let handler = self2._handlers.USERAUTH_INFO_REQUEST;
            handler && handler(self2, name2, instructions, prompts);
            break;
          }
          default:
            self2._debug && self2._debug("Inbound: Received unexpected payload type 60");
        }
      },
      61: (self2, payload) => {
        if (!self2._authsQueue.length) {
          self2._debug && self2._debug("Inbound: Received payload type 61 without auth");
          return;
        }
        if (self2._authsQueue[0] !== "keyboard-interactive")
          return doFatalError(
            self2,
            "Inbound: Received unexpected payload type 61"
          );
        bufferParser.init(payload, 1);
        let numResponses = bufferParser.readUInt32BE(), responses;
        if (numResponses !== void 0) {
          responses = new Array(numResponses);
          let i;
          for (i = 0; i < numResponses; ++i) {
            let response = bufferParser.readString(!0);
            if (response === void 0)
              break;
            responses[i] = response;
          }
          i !== numResponses && (responses = void 0);
        }
        if (bufferParser.clear(), responses === void 0)
          return doFatalError(
            self2,
            "Inbound: Malformed USERAUTH_INFO_RESPONSE packet"
          );
        self2._debug && self2._debug("Inbound: Received USERAUTH_INFO_RESPONSE");
        let handler = self2._handlers.USERAUTH_INFO_RESPONSE;
        handler && handler(self2, responses);
      },
      // Connection protocol -- generic ============================================
      [MESSAGE.GLOBAL_REQUEST]: (self2, payload) => {
        bufferParser.init(payload, 1);
        let name2 = bufferParser.readString(!0), wantReply = bufferParser.readBool(), data;
        if (wantReply !== void 0)
          switch (name2) {
            case "tcpip-forward":
            case "cancel-tcpip-forward": {
              let bindAddr = bufferParser.readString(!0), bindPort = bufferParser.readUInt32BE();
              bindPort !== void 0 && (data = { bindAddr, bindPort });
              break;
            }
            case "streamlocal-forward@openssh.com":
            case "cancel-streamlocal-forward@openssh.com": {
              let socketPath = bufferParser.readString(!0);
              socketPath !== void 0 && (data = { socketPath });
              break;
            }
            case "no-more-sessions@openssh.com":
              data = null;
              break;
            case "hostkeys-00@openssh.com": {
              for (data = []; bufferParser.avail() > 0; ) {
                let keyRaw = bufferParser.readString();
                if (keyRaw === void 0) {
                  data = void 0;
                  break;
                }
                let key = parseKey(keyRaw);
                key instanceof Error || data.push(key);
              }
              break;
            }
            default:
              data = bufferParser.readRaw();
          }
        if (bufferParser.clear(), data === void 0)
          return doFatalError(
            self2,
            "Inbound: Malformed GLOBAL_REQUEST packet"
          );
        self2._debug && self2._debug(`Inbound: GLOBAL_REQUEST (${name2})`);
        let handler = self2._handlers.GLOBAL_REQUEST;
        handler ? handler(self2, name2, wantReply, data) : self2.requestFailure();
      },
      [MESSAGE.REQUEST_SUCCESS]: (self2, payload) => {
        let data = payload.length > 1 ? bufferSlice(payload, 1) : null;
        self2._debug && self2._debug("Inbound: REQUEST_SUCCESS");
        let handler = self2._handlers.REQUEST_SUCCESS;
        handler && handler(self2, data);
      },
      [MESSAGE.REQUEST_FAILURE]: (self2, payload) => {
        self2._debug && self2._debug("Inbound: Received REQUEST_FAILURE");
        let handler = self2._handlers.REQUEST_FAILURE;
        handler && handler(self2);
      },
      // Connection protocol -- channel-related ====================================
      [MESSAGE.CHANNEL_OPEN]: (self2, payload) => {
        bufferParser.init(payload, 1);
        let type = bufferParser.readString(!0), sender = bufferParser.readUInt32BE(), window2 = bufferParser.readUInt32BE(), packetSize = bufferParser.readUInt32BE(), channelInfo;
        switch (type) {
          case "forwarded-tcpip":
          // S->C
          case "direct-tcpip": {
            let destIP = bufferParser.readString(!0), destPort = bufferParser.readUInt32BE(), srcIP = bufferParser.readString(!0), srcPort = bufferParser.readUInt32BE();
            srcPort !== void 0 && (channelInfo = {
              type,
              sender,
              window: window2,
              packetSize,
              data: { destIP, destPort, srcIP, srcPort }
            });
            break;
          }
          case "forwarded-streamlocal@openssh.com":
          // S->C
          case "direct-streamlocal@openssh.com": {
            let socketPath = bufferParser.readString(!0);
            socketPath !== void 0 && (channelInfo = {
              type,
              sender,
              window: window2,
              packetSize,
              data: { socketPath }
            });
            break;
          }
          case "x11": {
            let srcIP = bufferParser.readString(!0), srcPort = bufferParser.readUInt32BE();
            srcPort !== void 0 && (channelInfo = {
              type,
              sender,
              window: window2,
              packetSize,
              data: { srcIP, srcPort }
            });
            break;
          }
          default:
            channelInfo = {
              type,
              sender,
              window: window2,
              packetSize,
              data: {}
            };
        }
        if (bufferParser.clear(), channelInfo === void 0)
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_OPEN packet"
          );
        self2._debug && self2._debug(`Inbound: CHANNEL_OPEN (s:${sender}, ${type})`);
        let handler = self2._handlers.CHANNEL_OPEN;
        handler ? handler(self2, channelInfo) : self2.channelOpenFail(
          channelInfo.sender,
          CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED,
          "",
          ""
        );
      },
      [MESSAGE.CHANNEL_OPEN_CONFIRMATION]: (self2, payload) => {
        bufferParser.init(payload, 1);
        let recipient = bufferParser.readUInt32BE(), sender = bufferParser.readUInt32BE(), window2 = bufferParser.readUInt32BE(), packetSize = bufferParser.readUInt32BE(), data = bufferParser.avail() ? bufferParser.readRaw() : void 0;
        if (bufferParser.clear(), packetSize === void 0)
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_OPEN_CONFIRMATION packet"
          );
        self2._debug && self2._debug(
          `Inbound: CHANNEL_OPEN_CONFIRMATION (r:${recipient}, s:${sender})`
        );
        let handler = self2._handlers.CHANNEL_OPEN_CONFIRMATION;
        handler && handler(self2, { recipient, sender, window: window2, packetSize, data });
      },
      [MESSAGE.CHANNEL_OPEN_FAILURE]: (self2, payload) => {
        bufferParser.init(payload, 1);
        let recipient = bufferParser.readUInt32BE(), reason = bufferParser.readUInt32BE(), description = bufferParser.readString(!0), lang = bufferParser.readString();
        if (bufferParser.clear(), lang === void 0)
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_OPEN_FAILURE packet"
          );
        self2._debug && self2._debug(`Inbound: CHANNEL_OPEN_FAILURE (r:${recipient})`);
        let handler = self2._handlers.CHANNEL_OPEN_FAILURE;
        handler && handler(self2, recipient, reason, description);
      },
      [MESSAGE.CHANNEL_WINDOW_ADJUST]: (self2, payload) => {
        bufferParser.init(payload, 1);
        let recipient = bufferParser.readUInt32BE(), bytesToAdd = bufferParser.readUInt32BE();
        if (bufferParser.clear(), bytesToAdd === void 0)
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_WINDOW_ADJUST packet"
          );
        self2._debug && self2._debug(
          `Inbound: CHANNEL_WINDOW_ADJUST (r:${recipient}, ${bytesToAdd})`
        );
        let handler = self2._handlers.CHANNEL_WINDOW_ADJUST;
        handler && handler(self2, recipient, bytesToAdd);
      },
      [MESSAGE.CHANNEL_DATA]: (self2, payload) => {
        bufferParser.init(payload, 1);
        let recipient = bufferParser.readUInt32BE(), data = bufferParser.readString();
        if (bufferParser.clear(), data === void 0)
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_DATA packet"
          );
        self2._debug && self2._debug(`Inbound: CHANNEL_DATA (r:${recipient}, ${data.length})`);
        let handler = self2._handlers.CHANNEL_DATA;
        handler && handler(self2, recipient, data);
      },
      [MESSAGE.CHANNEL_EXTENDED_DATA]: (self2, payload) => {
        bufferParser.init(payload, 1);
        let recipient = bufferParser.readUInt32BE(), type = bufferParser.readUInt32BE(), data = bufferParser.readString();
        if (bufferParser.clear(), data === void 0)
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_EXTENDED_DATA packet"
          );
        self2._debug && self2._debug(
          `Inbound: CHANNEL_EXTENDED_DATA (r:${recipient}, ${data.length})`
        );
        let handler = self2._handlers.CHANNEL_EXTENDED_DATA;
        handler && handler(self2, recipient, data, type);
      },
      [MESSAGE.CHANNEL_EOF]: (self2, payload) => {
        bufferParser.init(payload, 1);
        let recipient = bufferParser.readUInt32BE();
        if (bufferParser.clear(), recipient === void 0)
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_EOF packet"
          );
        self2._debug && self2._debug(`Inbound: CHANNEL_EOF (r:${recipient})`);
        let handler = self2._handlers.CHANNEL_EOF;
        handler && handler(self2, recipient);
      },
      [MESSAGE.CHANNEL_CLOSE]: (self2, payload) => {
        bufferParser.init(payload, 1);
        let recipient = bufferParser.readUInt32BE();
        if (bufferParser.clear(), recipient === void 0)
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_CLOSE packet"
          );
        self2._debug && self2._debug(`Inbound: CHANNEL_CLOSE (r:${recipient})`);
        let handler = self2._handlers.CHANNEL_CLOSE;
        handler && handler(self2, recipient);
      },
      [MESSAGE.CHANNEL_REQUEST]: (self2, payload) => {
        bufferParser.init(payload, 1);
        let recipient = bufferParser.readUInt32BE(), type = bufferParser.readString(!0), wantReply = bufferParser.readBool(), data;
        if (wantReply !== void 0)
          switch (type) {
            case "exit-status":
              data = bufferParser.readUInt32BE(), self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`
              );
              break;
            case "exit-signal": {
              let signal, coreDumped;
              if (self2._compatFlags & COMPAT.OLD_EXIT) {
                let num = bufferParser.readUInt32BE();
                switch (num) {
                  case 1:
                    signal = "HUP";
                    break;
                  case 2:
                    signal = "INT";
                    break;
                  case 3:
                    signal = "QUIT";
                    break;
                  case 6:
                    signal = "ABRT";
                    break;
                  case 9:
                    signal = "KILL";
                    break;
                  case 14:
                    signal = "ALRM";
                    break;
                  case 15:
                    signal = "TERM";
                    break;
                  default:
                    num !== void 0 && (signal = `UNKNOWN (${num})`);
                }
                coreDumped = !1;
              } else
                signal = bufferParser.readString(!0), coreDumped = bufferParser.readBool(), coreDumped === void 0 && (signal = void 0);
              let errorMessage = bufferParser.readString(!0);
              bufferParser.skipString() !== void 0 && (data = { signal, coreDumped, errorMessage }), self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${signal})`
              );
              break;
            }
            case "pty-req": {
              let term = bufferParser.readString(!0), cols = bufferParser.readUInt32BE(), rows = bufferParser.readUInt32BE(), width = bufferParser.readUInt32BE(), height = bufferParser.readUInt32BE(), modesBinary = bufferParser.readString();
              if (modesBinary !== void 0) {
                bufferParser.init(modesBinary, 1);
                let modes = {};
                for (; bufferParser.avail(); ) {
                  let opcode = bufferParser.readByte();
                  if (opcode === TERMINAL_MODE.TTY_OP_END)
                    break;
                  let name2 = TERMINAL_MODE_BY_VALUE[opcode], value = bufferParser.readUInt32BE();
                  if (opcode === void 0 || name2 === void 0 || value === void 0) {
                    modes = void 0;
                    break;
                  }
                  modes[name2] = value;
                }
                modes !== void 0 && (data = { term, cols, rows, width, height, modes });
              }
              self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`
              );
              break;
            }
            case "window-change": {
              let cols = bufferParser.readUInt32BE(), rows = bufferParser.readUInt32BE(), width = bufferParser.readUInt32BE(), height = bufferParser.readUInt32BE();
              height !== void 0 && (data = { cols, rows, width, height }), self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`
              );
              break;
            }
            case "x11-req": {
              let single = bufferParser.readBool(), protocol = bufferParser.readString(!0), cookie = bufferParser.readString(), screen = bufferParser.readUInt32BE();
              screen !== void 0 && (data = { single, protocol, cookie, screen }), self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`
              );
              break;
            }
            case "env": {
              let name2 = bufferParser.readString(!0), value = bufferParser.readString(!0);
              value !== void 0 && (data = { name: name2, value }), self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${name2}=${value})`
              );
              break;
            }
            case "shell":
              data = null, self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`
              );
              break;
            case "exec":
              data = bufferParser.readString(!0), self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`
              );
              break;
            case "subsystem":
              data = bufferParser.readString(!0), self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`
              );
              break;
            case "signal":
              data = bufferParser.readString(!0), self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`
              );
              break;
            case "xon-xoff":
              data = bufferParser.readBool(), self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`
              );
              break;
            case "auth-agent-req@openssh.com":
              data = null, self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`
              );
              break;
            default:
              data = bufferParser.avail() ? bufferParser.readRaw() : null, self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`
              );
          }
        if (bufferParser.clear(), data === void 0)
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_REQUEST packet"
          );
        let handler = self2._handlers.CHANNEL_REQUEST;
        handler && handler(self2, recipient, type, wantReply, data);
      },
      [MESSAGE.CHANNEL_SUCCESS]: (self2, payload) => {
        bufferParser.init(payload, 1);
        let recipient = bufferParser.readUInt32BE();
        if (bufferParser.clear(), recipient === void 0)
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_SUCCESS packet"
          );
        self2._debug && self2._debug(`Inbound: CHANNEL_SUCCESS (r:${recipient})`);
        let handler = self2._handlers.CHANNEL_SUCCESS;
        handler && handler(self2, recipient);
      },
      [MESSAGE.CHANNEL_FAILURE]: (self2, payload) => {
        bufferParser.init(payload, 1);
        let recipient = bufferParser.readUInt32BE();
        if (bufferParser.clear(), recipient === void 0)
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_FAILURE packet"
          );
        self2._debug && self2._debug(`Inbound: CHANNEL_FAILURE (r:${recipient})`);
        let handler = self2._handlers.CHANNEL_FAILURE;
        handler && handler(self2, recipient);
      }
    };
  }
});

// node_modules/ssh2/lib/protocol/handlers.js
var require_handlers = __commonJS({
  "node_modules/ssh2/lib/protocol/handlers.js"(exports2, module2) {
    "use strict";
    var MESSAGE_HANDLERS = new Array(256);
    [
      require_kex().HANDLERS,
      require_handlers_misc()
    ].forEach((handlers) => {
      for (let [type, handler] of Object.entries(handlers))
        type = +type, isFinite(type) && type >= 0 && type < MESSAGE_HANDLERS.length && (MESSAGE_HANDLERS[type] = handler);
    });
    module2.exports = MESSAGE_HANDLERS;
  }
});

// node_modules/ssh2/lib/protocol/kex.js
var require_kex = __commonJS({
  "node_modules/ssh2/lib/protocol/kex.js"(exports2, module2) {
    "use strict";
    var {
      createDiffieHellman,
      createDiffieHellmanGroup,
      createECDH,
      createHash,
      createPublicKey,
      diffieHellman,
      generateKeyPairSync,
      randomFillSync
    } = require("crypto"), { Ber } = require_lib4(), {
      COMPAT,
      curve25519Supported,
      DEFAULT_KEX,
      DEFAULT_SERVER_HOST_KEY,
      DEFAULT_CIPHER,
      DEFAULT_MAC,
      DEFAULT_COMPRESSION,
      DISCONNECT_REASON,
      MESSAGE
    } = require_constants6(), {
      CIPHER_INFO,
      createCipher,
      createDecipher,
      MAC_INFO
    } = require_crypto(), { parseDERKey } = require_keyParser(), {
      bufferFill,
      bufferParser,
      convertSignature,
      doFatalError,
      FastBuffer,
      sigSSHToASN1,
      writeUInt32BE
    } = require_utils5(), {
      PacketReader,
      PacketWriter,
      ZlibPacketReader,
      ZlibPacketWriter
    } = require_zlib(), MESSAGE_HANDLERS, GEX_MIN_BITS = 2048, GEX_MAX_BITS = 8192, EMPTY_BUFFER = Buffer.alloc(0);
    function kexinit(self2) {
      let payload;
      if (self2._compatFlags & COMPAT.BAD_DHGEX) {
        let entry = self2._offer.lists.kex, kex = entry.array, found = !1;
        for (let i = 0; i < kex.length; ++i)
          kex[i].includes("group-exchange") && (found || (found = !0, kex = kex.slice()), kex.splice(i--, 1));
        if (found) {
          let len = 17 + self2._offer.totalSize + 1 + 4, newKexBuf = Buffer.from(kex.join(","));
          len -= entry.buffer.length - newKexBuf.length;
          let all = self2._offer.lists.all, rest = new Uint8Array(
            all.buffer,
            all.byteOffset + 4 + entry.buffer.length,
            all.length - (4 + entry.buffer.length)
          );
          payload = Buffer.allocUnsafe(len), writeUInt32BE(payload, newKexBuf.length, 17), payload.set(newKexBuf, 21), payload.set(rest, 21 + newKexBuf.length);
        }
      }
      payload === void 0 && (payload = Buffer.allocUnsafe(17 + self2._offer.totalSize + 1 + 4), self2._offer.copyAllTo(payload, 17)), self2._debug && self2._debug("Outbound: Sending KEXINIT"), payload[0] = MESSAGE.KEXINIT, randomFillSync(payload, 1, 16), bufferFill(payload, 0, payload.length - 5), self2._kexinit = payload, self2._packetRW.write.allocStart = 0;
      {
        let p = self2._packetRW.write.allocStartKEX, packet = self2._packetRW.write.alloc(payload.length, !0);
        packet.set(payload, p), self2._cipher.encrypt(self2._packetRW.write.finalize(packet, !0));
      }
    }
    function handleKexInit(self2, payload) {
      let init = {
        kex: void 0,
        serverHostKey: void 0,
        cs: {
          cipher: void 0,
          mac: void 0,
          compress: void 0,
          lang: void 0
        },
        sc: {
          cipher: void 0,
          mac: void 0,
          compress: void 0,
          lang: void 0
        }
      };
      if (bufferParser.init(payload, 17), (init.kex = bufferParser.readList()) === void 0 || (init.serverHostKey = bufferParser.readList()) === void 0 || (init.cs.cipher = bufferParser.readList()) === void 0 || (init.sc.cipher = bufferParser.readList()) === void 0 || (init.cs.mac = bufferParser.readList()) === void 0 || (init.sc.mac = bufferParser.readList()) === void 0 || (init.cs.compress = bufferParser.readList()) === void 0 || (init.sc.compress = bufferParser.readList()) === void 0 || (init.cs.lang = bufferParser.readList()) === void 0 || (init.sc.lang = bufferParser.readList()) === void 0)
        return bufferParser.clear(), doFatalError(
          self2,
          "Received malformed KEXINIT",
          "handshake",
          DISCONNECT_REASON.KEY_EXCHANGE_FAILED
        );
      let pos2 = bufferParser.pos(), firstFollows = pos2 < payload.length && payload[pos2] === 1;
      bufferParser.clear();
      let local = self2._offer, remote = init, localKex = local.lists.kex.array;
      if (self2._compatFlags & COMPAT.BAD_DHGEX) {
        let found = !1;
        for (let i2 = 0; i2 < localKex.length; ++i2)
          localKex[i2].indexOf("group-exchange") !== -1 && (found || (found = !0, localKex = localKex.slice()), localKex.splice(i2--, 1));
      }
      let clientList, serverList, i, debug = self2._debug;
      debug && debug("Inbound: Handshake in progress"), debug && debug(`Handshake: (local) KEX method: ${localKex}`), debug && debug(`Handshake: (remote) KEX method: ${remote.kex}`);
      let remoteExtInfoEnabled;
      if (self2._server ? (serverList = localKex, clientList = remote.kex, remoteExtInfoEnabled = clientList.indexOf("ext-info-c") !== -1) : (serverList = remote.kex, clientList = localKex, remoteExtInfoEnabled = serverList.indexOf("ext-info-s") !== -1), self2._strictMode === void 0 && (self2._server ? self2._strictMode = clientList.indexOf("kex-strict-c-v00@openssh.com") !== -1 : self2._strictMode = serverList.indexOf("kex-strict-s-v00@openssh.com") !== -1, self2._strictMode && (debug && debug("Handshake: strict KEX mode enabled"), self2._decipher.inSeqno !== 1)))
        return debug && debug("Handshake: KEXINIT not first packet in strict KEX mode"), doFatalError(
          self2,
          "Handshake failed: KEXINIT not first packet in strict KEX mode",
          "handshake",
          DISCONNECT_REASON.KEY_EXCHANGE_FAILED
        );
      for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i) ;
      if (i === clientList.length)
        return debug && debug("Handshake: no matching key exchange algorithm"), doFatalError(
          self2,
          "Handshake failed: no matching key exchange algorithm",
          "handshake",
          DISCONNECT_REASON.KEY_EXCHANGE_FAILED
        );
      init.kex = clientList[i], debug && debug(`Handshake: KEX algorithm: ${clientList[i]}`), firstFollows && (!remote.kex.length || clientList[i] !== remote.kex[0]) && (self2._skipNextInboundPacket = !0);
      let localSrvHostKey = local.lists.serverHostKey.array;
      for (debug && debug(`Handshake: (local) Host key format: ${localSrvHostKey}`), debug && debug(
        `Handshake: (remote) Host key format: ${remote.serverHostKey}`
      ), self2._server ? (serverList = localSrvHostKey, clientList = remote.serverHostKey) : (serverList = remote.serverHostKey, clientList = localSrvHostKey), i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i) ;
      if (i === clientList.length)
        return debug && debug("Handshake: No matching host key format"), doFatalError(
          self2,
          "Handshake failed: no matching host key format",
          "handshake",
          DISCONNECT_REASON.KEY_EXCHANGE_FAILED
        );
      init.serverHostKey = clientList[i], debug && debug(`Handshake: Host key format: ${clientList[i]}`);
      let localCSCipher = local.lists.cs.cipher.array;
      for (debug && debug(`Handshake: (local) C->S cipher: ${localCSCipher}`), debug && debug(`Handshake: (remote) C->S cipher: ${remote.cs.cipher}`), self2._server ? (serverList = localCSCipher, clientList = remote.cs.cipher) : (serverList = remote.cs.cipher, clientList = localCSCipher), i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i) ;
      if (i === clientList.length)
        return debug && debug("Handshake: No matching C->S cipher"), doFatalError(
          self2,
          "Handshake failed: no matching C->S cipher",
          "handshake",
          DISCONNECT_REASON.KEY_EXCHANGE_FAILED
        );
      init.cs.cipher = clientList[i], debug && debug(`Handshake: C->S Cipher: ${clientList[i]}`);
      let localSCCipher = local.lists.sc.cipher.array;
      for (debug && debug(`Handshake: (local) S->C cipher: ${localSCCipher}`), debug && debug(`Handshake: (remote) S->C cipher: ${remote.sc.cipher}`), self2._server ? (serverList = localSCCipher, clientList = remote.sc.cipher) : (serverList = remote.sc.cipher, clientList = localSCCipher), i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i) ;
      if (i === clientList.length)
        return debug && debug("Handshake: No matching S->C cipher"), doFatalError(
          self2,
          "Handshake failed: no matching S->C cipher",
          "handshake",
          DISCONNECT_REASON.KEY_EXCHANGE_FAILED
        );
      init.sc.cipher = clientList[i], debug && debug(`Handshake: S->C cipher: ${clientList[i]}`);
      let localCSMAC = local.lists.cs.mac.array;
      if (debug && debug(`Handshake: (local) C->S MAC: ${localCSMAC}`), debug && debug(`Handshake: (remote) C->S MAC: ${remote.cs.mac}`), CIPHER_INFO[init.cs.cipher].authLen > 0)
        init.cs.mac = "", debug && debug("Handshake: C->S MAC: <implicit>");
      else {
        for (self2._server ? (serverList = localCSMAC, clientList = remote.cs.mac) : (serverList = remote.cs.mac, clientList = localCSMAC), i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i) ;
        if (i === clientList.length)
          return debug && debug("Handshake: No matching C->S MAC"), doFatalError(
            self2,
            "Handshake failed: no matching C->S MAC",
            "handshake",
            DISCONNECT_REASON.KEY_EXCHANGE_FAILED
          );
        init.cs.mac = clientList[i], debug && debug(`Handshake: C->S MAC: ${clientList[i]}`);
      }
      let localSCMAC = local.lists.sc.mac.array;
      if (debug && debug(`Handshake: (local) S->C MAC: ${localSCMAC}`), debug && debug(`Handshake: (remote) S->C MAC: ${remote.sc.mac}`), CIPHER_INFO[init.sc.cipher].authLen > 0)
        init.sc.mac = "", debug && debug("Handshake: S->C MAC: <implicit>");
      else {
        for (self2._server ? (serverList = localSCMAC, clientList = remote.sc.mac) : (serverList = remote.sc.mac, clientList = localSCMAC), i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i) ;
        if (i === clientList.length)
          return debug && debug("Handshake: No matching S->C MAC"), doFatalError(
            self2,
            "Handshake failed: no matching S->C MAC",
            "handshake",
            DISCONNECT_REASON.KEY_EXCHANGE_FAILED
          );
        init.sc.mac = clientList[i], debug && debug(`Handshake: S->C MAC: ${clientList[i]}`);
      }
      let localCSCompress = local.lists.cs.compress.array;
      for (debug && debug(`Handshake: (local) C->S compression: ${localCSCompress}`), debug && debug(`Handshake: (remote) C->S compression: ${remote.cs.compress}`), self2._server ? (serverList = localCSCompress, clientList = remote.cs.compress) : (serverList = remote.cs.compress, clientList = localCSCompress), i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i) ;
      if (i === clientList.length)
        return debug && debug("Handshake: No matching C->S compression"), doFatalError(
          self2,
          "Handshake failed: no matching C->S compression",
          "handshake",
          DISCONNECT_REASON.KEY_EXCHANGE_FAILED
        );
      init.cs.compress = clientList[i], debug && debug(`Handshake: C->S compression: ${clientList[i]}`);
      let localSCCompress = local.lists.sc.compress.array;
      for (debug && debug(`Handshake: (local) S->C compression: ${localSCCompress}`), debug && debug(`Handshake: (remote) S->C compression: ${remote.sc.compress}`), self2._server ? (serverList = localSCCompress, clientList = remote.sc.compress) : (serverList = remote.sc.compress, clientList = localSCCompress), i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i) ;
      if (i === clientList.length)
        return debug && debug("Handshake: No matching S->C compression"), doFatalError(
          self2,
          "Handshake failed: no matching S->C compression",
          "handshake",
          DISCONNECT_REASON.KEY_EXCHANGE_FAILED
        );
      init.sc.compress = clientList[i], debug && debug(`Handshake: S->C compression: ${clientList[i]}`), init.cs.lang = "", init.sc.lang = "", self2._kex && (self2._kexinit || kexinit(self2), self2._decipher._onPayload = onKEXPayload.bind(self2, { firstPacket: !1 })), self2._kex = createKeyExchange(init, self2, payload), self2._kex.remoteExtInfoEnabled = remoteExtInfoEnabled, self2._kex.start();
    }
    var createKeyExchange = /* @__PURE__ */ (() => {
      function convertToMpint(buf) {
        let idx = 0, length = buf.length;
        for (; buf[idx] === 0; )
          ++idx, --length;
        let newBuf;
        return buf[idx] & 128 ? (newBuf = Buffer.allocUnsafe(1 + length), newBuf[0] = 0, buf.copy(newBuf, 1, idx), buf = newBuf) : length !== buf.length && (newBuf = Buffer.allocUnsafe(length), buf.copy(newBuf, 0, idx), buf = newBuf), buf;
      }
      class KeyExchange {
        constructor(negotiated, protocol, remoteKexinit) {
          this._protocol = protocol, this.sessionID = protocol._kex ? protocol._kex.sessionID : void 0, this.negotiated = negotiated, this.remoteExtInfoEnabled = !1, this._step = 1, this._public = null, this._dh = null, this._sentNEWKEYS = !1, this._receivedNEWKEYS = !1, this._finished = !1, this._hostVerified = !1, this._kexinit = protocol._kexinit, this._remoteKexinit = remoteKexinit, this._identRaw = protocol._identRaw, this._remoteIdentRaw = protocol._remoteIdentRaw, this._hostKey = void 0, this._dhData = void 0, this._sig = void 0;
        }
        finish(scOnly) {
          if (this._finished)
            return !1;
          this._finished = !0;
          let isServer = this._protocol._server, negotiated = this.negotiated, pubKey = this.convertPublicKey(this._dhData), secret = this.computeSecret(this._dhData);
          if (secret instanceof Error)
            return secret.message = `Error while computing DH secret (${this.type}): ${secret.message}`, secret.level = "handshake", doFatalError(
              this._protocol,
              secret,
              DISCONNECT_REASON.KEY_EXCHANGE_FAILED
            );
          let hash = createHash(this.hashName);
          hashString(hash, isServer ? this._remoteIdentRaw : this._identRaw), hashString(hash, isServer ? this._identRaw : this._remoteIdentRaw), hashString(hash, isServer ? this._remoteKexinit : this._kexinit), hashString(hash, isServer ? this._kexinit : this._remoteKexinit);
          let serverPublicHostKey = isServer ? this._hostKey.getPublicSSH() : this._hostKey;
          if (hashString(hash, serverPublicHostKey), this.type === "groupex") {
            let params = this.getDHParams(), num = Buffer.allocUnsafe(4);
            writeUInt32BE(num, this._minBits, 0), hash.update(num), writeUInt32BE(num, this._prefBits, 0), hash.update(num), writeUInt32BE(num, this._maxBits, 0), hash.update(num), hashString(hash, params.prime), hashString(hash, params.generator);
          }
          hashString(hash, isServer ? pubKey : this.getPublicKey());
          let serverPublicKey = isServer ? this.getPublicKey() : pubKey;
          hashString(hash, serverPublicKey), hashString(hash, secret);
          let exchangeHash = hash.digest();
          if (isServer) {
            let hashAlgo;
            switch (this.negotiated.serverHostKey) {
              case "rsa-sha2-256":
                hashAlgo = "sha256";
                break;
              case "rsa-sha2-512":
                hashAlgo = "sha512";
                break;
            }
            this._protocol._debug && this._protocol._debug(
              "Generating signature ..."
            );
            let signature = this._hostKey.sign(exchangeHash, hashAlgo);
            if (signature instanceof Error)
              return doFatalError(
                this._protocol,
                `Handshake failed: signature generation failed for ${this._hostKey.type} host key: ${signature.message}`,
                "handshake",
                DISCONNECT_REASON.KEY_EXCHANGE_FAILED
              );
            if (signature = convertSignature(signature, this._hostKey.type), signature === !1)
              return doFatalError(
                this._protocol,
                `Handshake failed: signature conversion failed for ${this._hostKey.type} host key`,
                "handshake",
                DISCONNECT_REASON.KEY_EXCHANGE_FAILED
              );
            let sigType = this.negotiated.serverHostKey, sigTypeLen = Buffer.byteLength(sigType), sigLen = 4 + sigTypeLen + 4 + signature.length, p = this._protocol._packetRW.write.allocStartKEX, packet = this._protocol._packetRW.write.alloc(
              5 + serverPublicHostKey.length + 4 + serverPublicKey.length + 4 + sigLen,
              !0
            );
            if (packet[p] = MESSAGE.KEXDH_REPLY, writeUInt32BE(packet, serverPublicHostKey.length, ++p), packet.set(serverPublicHostKey, p += 4), writeUInt32BE(
              packet,
              serverPublicKey.length,
              p += serverPublicHostKey.length
            ), packet.set(serverPublicKey, p += 4), writeUInt32BE(packet, sigLen, p += serverPublicKey.length), writeUInt32BE(packet, sigTypeLen, p += 4), packet.utf8Write(sigType, p += 4, sigTypeLen), writeUInt32BE(packet, signature.length, p += sigTypeLen), packet.set(signature, p += 4), this._protocol._debug) {
              let type;
              switch (this.type) {
                case "group":
                  type = "KEXDH_REPLY";
                  break;
                case "groupex":
                  type = "KEXDH_GEX_REPLY";
                  break;
                default:
                  type = "KEXECDH_REPLY";
              }
              this._protocol._debug(`Outbound: Sending ${type}`);
            }
            this._protocol._cipher.encrypt(
              this._protocol._packetRW.write.finalize(packet, !0)
            );
          } else {
            bufferParser.init(this._sig, 0);
            let sigType = bufferParser.readString(!0);
            if (!sigType)
              return doFatalError(
                this._protocol,
                "Malformed packet while reading signature",
                "handshake",
                DISCONNECT_REASON.KEY_EXCHANGE_FAILED
              );
            if (sigType !== negotiated.serverHostKey)
              return doFatalError(
                this._protocol,
                `Wrong signature type: ${sigType}, expected: ${negotiated.serverHostKey}`,
                "handshake",
                DISCONNECT_REASON.KEY_EXCHANGE_FAILED
              );
            let sigValue = bufferParser.readString();
            if (bufferParser.clear(), sigValue === void 0)
              return doFatalError(
                this._protocol,
                "Malformed packet while reading signature",
                "handshake",
                DISCONNECT_REASON.KEY_EXCHANGE_FAILED
              );
            if (!(sigValue = sigSSHToASN1(sigValue, sigType)))
              return doFatalError(
                this._protocol,
                "Malformed signature",
                "handshake",
                DISCONNECT_REASON.KEY_EXCHANGE_FAILED
              );
            let parsedHostKey;
            {
              bufferParser.init(this._hostKey, 0);
              let name2 = bufferParser.readString(!0), hostKey = this._hostKey.slice(bufferParser.pos());
              if (bufferParser.clear(), parsedHostKey = parseDERKey(hostKey, name2), parsedHostKey instanceof Error)
                return parsedHostKey.level = "handshake", doFatalError(
                  this._protocol,
                  parsedHostKey,
                  DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                );
            }
            let hashAlgo;
            switch (this.negotiated.serverHostKey) {
              case "rsa-sha2-256":
                hashAlgo = "sha256";
                break;
              case "rsa-sha2-512":
                hashAlgo = "sha512";
                break;
            }
            this._protocol._debug && this._protocol._debug("Verifying signature ...");
            let verified = parsedHostKey.verify(exchangeHash, sigValue, hashAlgo);
            if (verified !== !0)
              return verified instanceof Error ? this._protocol._debug && this._protocol._debug(
                `Signature verification failed: ${verified.stack}`
              ) : this._protocol._debug && this._protocol._debug(
                "Signature verification failed"
              ), doFatalError(
                this._protocol,
                "Handshake failed: signature verification failed",
                "handshake",
                DISCONNECT_REASON.KEY_EXCHANGE_FAILED
              );
            this._protocol._debug && this._protocol._debug("Verified signature");
          }
          (isServer || !scOnly) && trySendNEWKEYS(this);
          let hsCipherConfig, hsWrite, completeHandshake = (partial) => {
            if (hsCipherConfig)
              return trySendNEWKEYS(this), hsCipherConfig.outbound.seqno = this._protocol._cipher.outSeqno, this._protocol._cipher.free(), this._protocol._cipher = createCipher(hsCipherConfig), this._protocol._packetRW.write = hsWrite, hsCipherConfig = void 0, hsWrite = void 0, this._protocol._onHandshakeComplete(negotiated), !1;
            this.sessionID || (this.sessionID = exchangeHash);
            {
              let newSecret = Buffer.allocUnsafe(4 + secret.length);
              writeUInt32BE(newSecret, secret.length, 0), newSecret.set(secret, 4), secret = newSecret;
            }
            let csCipherInfo = CIPHER_INFO[negotiated.cs.cipher], scCipherInfo = CIPHER_INFO[negotiated.sc.cipher], csIV = generateKEXVal(
              csCipherInfo.ivLen,
              this.hashName,
              secret,
              exchangeHash,
              this.sessionID,
              "A"
            ), scIV = generateKEXVal(
              scCipherInfo.ivLen,
              this.hashName,
              secret,
              exchangeHash,
              this.sessionID,
              "B"
            ), csKey = generateKEXVal(
              csCipherInfo.keyLen,
              this.hashName,
              secret,
              exchangeHash,
              this.sessionID,
              "C"
            ), scKey = generateKEXVal(
              scCipherInfo.keyLen,
              this.hashName,
              secret,
              exchangeHash,
              this.sessionID,
              "D"
            ), csMacInfo, csMacKey;
            csCipherInfo.authLen || (csMacInfo = MAC_INFO[negotiated.cs.mac], csMacKey = generateKEXVal(
              csMacInfo.len,
              this.hashName,
              secret,
              exchangeHash,
              this.sessionID,
              "E"
            ));
            let scMacInfo, scMacKey;
            scCipherInfo.authLen || (scMacInfo = MAC_INFO[negotiated.sc.mac], scMacKey = generateKEXVal(
              scMacInfo.len,
              this.hashName,
              secret,
              exchangeHash,
              this.sessionID,
              "F"
            ));
            let config = {
              inbound: {
                onPayload: this._protocol._onPayload,
                seqno: this._protocol._decipher.inSeqno,
                decipherInfo: isServer ? csCipherInfo : scCipherInfo,
                decipherIV: isServer ? csIV : scIV,
                decipherKey: isServer ? csKey : scKey,
                macInfo: isServer ? csMacInfo : scMacInfo,
                macKey: isServer ? csMacKey : scMacKey
              },
              outbound: {
                onWrite: this._protocol._onWrite,
                seqno: this._protocol._cipher.outSeqno,
                cipherInfo: isServer ? scCipherInfo : csCipherInfo,
                cipherIV: isServer ? scIV : csIV,
                cipherKey: isServer ? scKey : csKey,
                macInfo: isServer ? scMacInfo : csMacInfo,
                macKey: isServer ? scMacKey : csMacKey
              }
            };
            this._protocol._decipher.free(), hsCipherConfig = config, this._protocol._decipher = createDecipher(config);
            let rw = {
              read: void 0,
              write: void 0
            };
            switch (negotiated.cs.compress) {
              case "zlib":
                isServer ? rw.read = new ZlibPacketReader() : rw.write = new ZlibPacketWriter(this._protocol);
                break;
              case "zlib@openssh.com":
                if (this._protocol._authenticated) {
                  isServer ? rw.read = new ZlibPacketReader() : rw.write = new ZlibPacketWriter(this._protocol);
                  break;
                }
              // FALLTHROUGH
              default:
                isServer ? rw.read = new PacketReader() : rw.write = new PacketWriter(this._protocol);
            }
            switch (negotiated.sc.compress) {
              case "zlib":
                isServer ? rw.write = new ZlibPacketWriter(this._protocol) : rw.read = new ZlibPacketReader();
                break;
              case "zlib@openssh.com":
                if (this._protocol._authenticated) {
                  isServer ? rw.write = new ZlibPacketWriter(this._protocol) : rw.read = new ZlibPacketReader();
                  break;
                }
              // FALLTHROUGH
              default:
                isServer ? rw.write = new PacketWriter(this._protocol) : rw.read = new PacketReader();
            }
            return this._protocol._packetRW.read.cleanup(), this._protocol._packetRW.write.cleanup(), this._protocol._packetRW.read = rw.read, hsWrite = rw.write, this._public = null, this._dh = null, this._kexinit = this._protocol._kexinit = void 0, this._remoteKexinit = void 0, this._identRaw = void 0, this._remoteIdentRaw = void 0, this._hostKey = void 0, this._dhData = void 0, this._sig = void 0, partial ? !1 : completeHandshake();
          };
          if ((isServer || scOnly) && (this.finish = completeHandshake), !isServer)
            return completeHandshake(scOnly);
        }
        start() {
          if (!this._protocol._server) {
            if (this._protocol._debug) {
              let type;
              switch (this.type) {
                case "group":
                  type = "KEXDH_INIT";
                  break;
                default:
                  type = "KEXECDH_INIT";
              }
              this._protocol._debug(`Outbound: Sending ${type}`);
            }
            let pubKey = this.getPublicKey(), p = this._protocol._packetRW.write.allocStartKEX, packet = this._protocol._packetRW.write.alloc(
              5 + pubKey.length,
              !0
            );
            packet[p] = MESSAGE.KEXDH_INIT, writeUInt32BE(packet, pubKey.length, ++p), packet.set(pubKey, p += 4), this._protocol._cipher.encrypt(
              this._protocol._packetRW.write.finalize(packet, !0)
            );
          }
        }
        getPublicKey() {
          this.generateKeys();
          let key = this._public;
          if (key)
            return this.convertPublicKey(key);
        }
        convertPublicKey(key) {
          let newKey, idx = 0, len = key.length;
          for (; key[idx] === 0; )
            ++idx, --len;
          return key[idx] & 128 ? (newKey = Buffer.allocUnsafe(1 + len), newKey[0] = 0, key.copy(newKey, 1, idx), newKey) : (len !== key.length && (newKey = Buffer.allocUnsafe(len), key.copy(newKey, 0, idx), key = newKey), key);
        }
        computeSecret(otherPublicKey) {
          this.generateKeys();
          try {
            return convertToMpint(this._dh.computeSecret(otherPublicKey));
          } catch (ex) {
            return ex;
          }
        }
        parse(payload) {
          let type = payload[0];
          switch (this._step) {
            case 1:
              if (this._protocol._server) {
                if (type !== MESSAGE.KEXDH_INIT)
                  return doFatalError(
                    this._protocol,
                    `Received packet ${type} instead of ${MESSAGE.KEXDH_INIT}`,
                    "handshake",
                    DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                  );
                this._protocol._debug && this._protocol._debug(
                  "Received DH Init"
                ), bufferParser.init(payload, 1);
                let dhData = bufferParser.readString();
                if (bufferParser.clear(), dhData === void 0)
                  return doFatalError(
                    this._protocol,
                    "Received malformed KEX*_INIT",
                    "handshake",
                    DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                  );
                this._dhData = dhData;
                let hostKey = this._protocol._hostKeys[this.negotiated.serverHostKey];
                Array.isArray(hostKey) && (hostKey = hostKey[0]), this._hostKey = hostKey, this.finish();
              } else {
                if (type !== MESSAGE.KEXDH_REPLY)
                  return doFatalError(
                    this._protocol,
                    `Received packet ${type} instead of ${MESSAGE.KEXDH_REPLY}`,
                    "handshake",
                    DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                  );
                this._protocol._debug && this._protocol._debug(
                  "Received DH Reply"
                ), bufferParser.init(payload, 1);
                let hostPubKey, dhData, sig;
                if ((hostPubKey = bufferParser.readString()) === void 0 || (dhData = bufferParser.readString()) === void 0 || (sig = bufferParser.readString()) === void 0)
                  return bufferParser.clear(), doFatalError(
                    this._protocol,
                    "Received malformed KEX*_REPLY",
                    "handshake",
                    DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                  );
                bufferParser.clear(), bufferParser.init(hostPubKey, 0);
                let hostPubKeyType = bufferParser.readString(!0);
                if (bufferParser.clear(), hostPubKeyType === void 0)
                  return doFatalError(
                    this._protocol,
                    "Received malformed host public key",
                    "handshake",
                    DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                  );
                if (hostPubKeyType !== this.negotiated.serverHostKey)
                  switch (this.negotiated.serverHostKey) {
                    case "rsa-sha2-256":
                    case "rsa-sha2-512":
                      if (hostPubKeyType === "ssh-rsa")
                        break;
                    // FALLTHROUGH
                    default:
                      return doFatalError(
                        this._protocol,
                        "Host key does not match negotiated type",
                        "handshake",
                        DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                      );
                  }
                this._hostKey = hostPubKey, this._dhData = dhData, this._sig = sig;
                let checked = !1, ret;
                if (this._protocol._hostVerifier === void 0 ? (ret = !0, this._protocol._debug && this._protocol._debug(
                  "Host accepted by default (no verification)"
                )) : ret = this._protocol._hostVerifier(hostPubKey, (permitted) => {
                  if (!checked) {
                    if (checked = !0, permitted === !1)
                      return this._protocol._debug && this._protocol._debug(
                        "Host denied (verification failed)"
                      ), doFatalError(
                        this._protocol,
                        "Host denied (verification failed)",
                        "handshake",
                        DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                      );
                    this._protocol._debug && this._protocol._debug(
                      "Host accepted (verified)"
                    ), this._hostVerified = !0, this._receivedNEWKEYS ? this.finish() : trySendNEWKEYS(this);
                  }
                }), ret === void 0) {
                  ++this._step;
                  return;
                }
                if (checked = !0, ret === !1)
                  return this._protocol._debug && this._protocol._debug(
                    "Host denied (verification failed)"
                  ), doFatalError(
                    this._protocol,
                    "Host denied (verification failed)",
                    "handshake",
                    DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                  );
                this._protocol._debug && this._protocol._debug(
                  "Host accepted (verified)"
                ), this._hostVerified = !0, trySendNEWKEYS(this);
              }
              ++this._step;
              break;
            case 2:
              return type !== MESSAGE.NEWKEYS ? doFatalError(
                this._protocol,
                `Received packet ${type} instead of ${MESSAGE.NEWKEYS}`,
                "handshake",
                DISCONNECT_REASON.KEY_EXCHANGE_FAILED
              ) : (this._protocol._debug && this._protocol._debug(
                "Inbound: NEWKEYS"
              ), this._receivedNEWKEYS = !0, this._protocol._strictMode && (this._protocol._decipher.inSeqno = 0), ++this._step, this.finish(!this._protocol._server && !this._hostVerified));
            default:
              return doFatalError(
                this._protocol,
                `Received unexpected packet ${type} after NEWKEYS`,
                "handshake",
                DISCONNECT_REASON.KEY_EXCHANGE_FAILED
              );
          }
        }
      }
      class Curve25519Exchange extends KeyExchange {
        constructor(hashName, ...args) {
          super(...args), this.type = "25519", this.hashName = hashName, this._keys = null;
        }
        generateKeys() {
          this._keys || (this._keys = generateKeyPairSync("x25519"));
        }
        getPublicKey() {
          return this.generateKeys(), this._keys.publicKey.export({ type: "spki", format: "der" }).slice(-32);
        }
        convertPublicKey(key) {
          let newKey, idx = 0, len = key.length;
          for (; key[idx] === 0; )
            ++idx, --len;
          return key.length === 32 || len !== key.length && (newKey = Buffer.allocUnsafe(len), key.copy(newKey, 0, idx), key = newKey), key;
        }
        computeSecret(otherPublicKey) {
          this.generateKeys();
          try {
            let asnWriter = new Ber.Writer();
            return asnWriter.startSequence(), asnWriter.startSequence(), asnWriter.writeOID("1.3.101.110"), asnWriter.endSequence(), asnWriter.startSequence(Ber.BitString), asnWriter.writeByte(0), asnWriter._ensure(otherPublicKey.length), otherPublicKey.copy(
              asnWriter._buf,
              asnWriter._offset,
              0,
              otherPublicKey.length
            ), asnWriter._offset += otherPublicKey.length, asnWriter.endSequence(), asnWriter.endSequence(), convertToMpint(diffieHellman({
              privateKey: this._keys.privateKey,
              publicKey: createPublicKey({
                key: asnWriter.buffer,
                type: "spki",
                format: "der"
              })
            }));
          } catch (ex) {
            return ex;
          }
        }
      }
      class ECDHExchange extends KeyExchange {
        constructor(curveName, hashName, ...args) {
          super(...args), this.type = "ecdh", this.curveName = curveName, this.hashName = hashName;
        }
        generateKeys() {
          this._dh || (this._dh = createECDH(this.curveName), this._public = this._dh.generateKeys());
        }
      }
      class DHGroupExchange extends KeyExchange {
        constructor(hashName, ...args) {
          super(...args), this.type = "groupex", this.hashName = hashName, this._prime = null, this._generator = null, this._minBits = GEX_MIN_BITS, this._prefBits = dhEstimate(this.negotiated), this._protocol._compatFlags & COMPAT.BUG_DHGEX_LARGE && (this._prefBits = Math.min(this._prefBits, 4096)), this._maxBits = GEX_MAX_BITS;
        }
        start() {
          if (this._protocol._server)
            return;
          this._protocol._debug && this._protocol._debug(
            "Outbound: Sending KEXDH_GEX_REQUEST"
          );
          let p = this._protocol._packetRW.write.allocStartKEX, packet = this._protocol._packetRW.write.alloc(
            13,
            !0
          );
          packet[p] = MESSAGE.KEXDH_GEX_REQUEST, writeUInt32BE(packet, this._minBits, ++p), writeUInt32BE(packet, this._prefBits, p += 4), writeUInt32BE(packet, this._maxBits, p += 4), this._protocol._cipher.encrypt(
            this._protocol._packetRW.write.finalize(packet, !0)
          );
        }
        generateKeys() {
          !this._dh && this._prime && this._generator && (this._dh = createDiffieHellman(this._prime, this._generator), this._public = this._dh.generateKeys());
        }
        setDHParams(prime, generator) {
          if (!Buffer.isBuffer(prime))
            throw new Error("Invalid prime value");
          if (!Buffer.isBuffer(generator))
            throw new Error("Invalid generator value");
          this._prime = prime, this._generator = generator;
        }
        getDHParams() {
          if (this._dh)
            return {
              prime: convertToMpint(this._dh.getPrime()),
              generator: convertToMpint(this._dh.getGenerator())
            };
        }
        parse(payload) {
          let type = payload[0];
          switch (this._step) {
            case 1: {
              if (this._protocol._server)
                return type !== MESSAGE.KEXDH_GEX_REQUEST ? doFatalError(
                  this._protocol,
                  `Received packet ${type} instead of ` + MESSAGE.KEXDH_GEX_REQUEST,
                  "handshake",
                  DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                ) : doFatalError(
                  this._protocol,
                  "Group exchange not implemented for server",
                  "handshake",
                  DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                );
              if (type !== MESSAGE.KEXDH_GEX_GROUP)
                return doFatalError(
                  this._protocol,
                  `Received packet ${type} instead of ${MESSAGE.KEXDH_GEX_GROUP}`,
                  "handshake",
                  DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                );
              this._protocol._debug && this._protocol._debug(
                "Received DH GEX Group"
              ), bufferParser.init(payload, 1);
              let prime, gen;
              if ((prime = bufferParser.readString()) === void 0 || (gen = bufferParser.readString()) === void 0)
                return bufferParser.clear(), doFatalError(
                  this._protocol,
                  "Received malformed KEXDH_GEX_GROUP",
                  "handshake",
                  DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                );
              bufferParser.clear(), this.setDHParams(prime, gen), this.generateKeys();
              let pubkey = this.getPublicKey();
              this._protocol._debug && this._protocol._debug(
                "Outbound: Sending KEXDH_GEX_INIT"
              );
              let p = this._protocol._packetRW.write.allocStartKEX, packet = this._protocol._packetRW.write.alloc(5 + pubkey.length, !0);
              packet[p] = MESSAGE.KEXDH_GEX_INIT, writeUInt32BE(packet, pubkey.length, ++p), packet.set(pubkey, p += 4), this._protocol._cipher.encrypt(
                this._protocol._packetRW.write.finalize(packet, !0)
              ), ++this._step;
              break;
            }
            case 2:
              if (this._protocol._server)
                return type !== MESSAGE.KEXDH_GEX_INIT ? doFatalError(
                  this._protocol,
                  `Received packet ${type} instead of ${MESSAGE.KEXDH_GEX_INIT}`,
                  "handshake",
                  DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                ) : (this._protocol._debug && this._protocol._debug(
                  "Received DH GEX Init"
                ), doFatalError(
                  this._protocol,
                  "Group exchange not implemented for server",
                  "handshake",
                  DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                ));
              if (type !== MESSAGE.KEXDH_GEX_REPLY)
                return doFatalError(
                  this._protocol,
                  `Received packet ${type} instead of ${MESSAGE.KEXDH_GEX_REPLY}`,
                  "handshake",
                  DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                );
              this._protocol._debug && this._protocol._debug(
                "Received DH GEX Reply"
              ), this._step = 1, payload[0] = MESSAGE.KEXDH_REPLY, this.parse = KeyExchange.prototype.parse, this.parse(payload);
          }
        }
      }
      class DHExchange extends KeyExchange {
        constructor(groupName, hashName, ...args) {
          super(...args), this.type = "group", this.groupName = groupName, this.hashName = hashName;
        }
        start() {
          if (!this._protocol._server) {
            this._protocol._debug && this._protocol._debug(
              "Outbound: Sending KEXDH_INIT"
            );
            let pubKey = this.getPublicKey(), p = this._protocol._packetRW.write.allocStartKEX, packet = this._protocol._packetRW.write.alloc(5 + pubKey.length, !0);
            packet[p] = MESSAGE.KEXDH_INIT, writeUInt32BE(packet, pubKey.length, ++p), packet.set(pubKey, p += 4), this._protocol._cipher.encrypt(
              this._protocol._packetRW.write.finalize(packet, !0)
            );
          }
        }
        generateKeys() {
          this._dh || (this._dh = createDiffieHellmanGroup(this.groupName), this._public = this._dh.generateKeys());
        }
        getDHParams() {
          if (this._dh)
            return {
              prime: convertToMpint(this._dh.getPrime()),
              generator: convertToMpint(this._dh.getGenerator())
            };
        }
      }
      return (negotiated, ...args) => {
        if (typeof negotiated != "object" || negotiated === null)
          throw new Error("Invalid negotiated argument");
        let kexType = negotiated.kex;
        if (typeof kexType == "string") {
          switch (args = [negotiated, ...args], kexType) {
            case "curve25519-sha256":
            case "curve25519-sha256@libssh.org":
              if (!curve25519Supported)
                break;
              return new Curve25519Exchange("sha256", ...args);
            case "ecdh-sha2-nistp256":
              return new ECDHExchange("prime256v1", "sha256", ...args);
            case "ecdh-sha2-nistp384":
              return new ECDHExchange("secp384r1", "sha384", ...args);
            case "ecdh-sha2-nistp521":
              return new ECDHExchange("secp521r1", "sha512", ...args);
            case "diffie-hellman-group1-sha1":
              return new DHExchange("modp2", "sha1", ...args);
            case "diffie-hellman-group14-sha1":
              return new DHExchange("modp14", "sha1", ...args);
            case "diffie-hellman-group14-sha256":
              return new DHExchange("modp14", "sha256", ...args);
            case "diffie-hellman-group15-sha512":
              return new DHExchange("modp15", "sha512", ...args);
            case "diffie-hellman-group16-sha512":
              return new DHExchange("modp16", "sha512", ...args);
            case "diffie-hellman-group17-sha512":
              return new DHExchange("modp17", "sha512", ...args);
            case "diffie-hellman-group18-sha512":
              return new DHExchange("modp18", "sha512", ...args);
            case "diffie-hellman-group-exchange-sha1":
              return new DHGroupExchange("sha1", ...args);
            case "diffie-hellman-group-exchange-sha256":
              return new DHGroupExchange("sha256", ...args);
          }
          throw new Error(`Unsupported key exchange algorithm: ${kexType}`);
        }
        throw new Error(`Invalid key exchange type: ${kexType}`);
      };
    })(), KexInit = /* @__PURE__ */ (() => {
      let KEX_PROPERTY_NAMES = [
        "kex",
        "serverHostKey",
        ["cs", "cipher"],
        ["sc", "cipher"],
        ["cs", "mac"],
        ["sc", "mac"],
        ["cs", "compress"],
        ["sc", "compress"],
        ["cs", "lang"],
        ["sc", "lang"]
      ];
      return class {
        constructor(obj) {
          if (typeof obj != "object" || obj === null)
            throw new TypeError("Argument must be an object");
          let lists = {
            kex: void 0,
            serverHostKey: void 0,
            cs: {
              cipher: void 0,
              mac: void 0,
              compress: void 0,
              lang: void 0
            },
            sc: {
              cipher: void 0,
              mac: void 0,
              compress: void 0,
              lang: void 0
            },
            all: void 0
          }, totalSize = 0;
          for (let prop of KEX_PROPERTY_NAMES) {
            let base, val, desc, key;
            if (typeof prop == "string")
              base = lists, val = obj[prop], desc = key = prop;
            else {
              let parent = prop[0];
              base = lists[parent], key = prop[1], val = obj[parent][key], desc = `${parent}.${key}`;
            }
            let entry = { array: void 0, buffer: void 0 };
            if (Buffer.isBuffer(val))
              entry.array = ("" + val).split(","), entry.buffer = val, totalSize += 4 + val.length;
            else {
              if (typeof val == "string" && (val = val.split(",")), Array.isArray(val))
                entry.array = val, entry.buffer = Buffer.from(val.join(","));
              else
                throw new TypeError(`Invalid \`${desc}\` type: ${typeof val}`);
              totalSize += 4 + entry.buffer.length;
            }
            base[key] = entry;
          }
          let all = Buffer.allocUnsafe(totalSize);
          lists.all = all;
          let allPos = 0;
          for (let prop of KEX_PROPERTY_NAMES) {
            let data;
            typeof prop == "string" ? data = lists[prop].buffer : data = lists[prop[0]][prop[1]].buffer, allPos = writeUInt32BE(all, data.length, allPos), all.set(data, allPos), allPos += data.length;
          }
          this.totalSize = totalSize, this.lists = lists;
        }
        copyAllTo(buf, offset) {
          let src = this.lists.all;
          if (typeof offset != "number")
            throw new TypeError(`Invalid offset value: ${typeof offset}`);
          if (buf.length - offset < src.length)
            throw new Error("Insufficient space to copy list");
          return buf.set(src, offset), src.length;
        }
      };
    })(), hashString = (() => {
      let LEN = Buffer.allocUnsafe(4);
      return (hash, buf) => {
        writeUInt32BE(LEN, buf.length, 0), hash.update(LEN), hash.update(buf);
      };
    })();
    function generateKEXVal(len, hashName, secret, exchangeHash, sessionID, char) {
      let ret;
      if (len) {
        let digest = createHash(hashName).update(secret).update(exchangeHash).update(char).update(sessionID).digest();
        for (; digest.length < len; ) {
          let chunk = createHash(hashName).update(secret).update(exchangeHash).update(digest).digest(), extended = Buffer.allocUnsafe(digest.length + chunk.length);
          extended.set(digest, 0), extended.set(chunk, digest.length), digest = extended;
        }
        digest.length === len ? ret = digest : ret = new FastBuffer(digest.buffer, digest.byteOffset, len);
      } else
        ret = EMPTY_BUFFER;
      return ret;
    }
    function onKEXPayload(state, payload) {
      if (payload.length === 0) {
        this._debug && this._debug("Inbound: Skipping empty packet payload");
        return;
      }
      if (this._skipNextInboundPacket) {
        this._skipNextInboundPacket = !1;
        return;
      }
      payload = this._packetRW.read.read(payload);
      let type = payload[0];
      if (!this._strictMode)
        switch (type) {
          case MESSAGE.IGNORE:
          case MESSAGE.UNIMPLEMENTED:
          case MESSAGE.DEBUG:
            return MESSAGE_HANDLERS || (MESSAGE_HANDLERS = require_handlers()), MESSAGE_HANDLERS[type](this, payload);
        }
      switch (type) {
        case MESSAGE.DISCONNECT:
          return MESSAGE_HANDLERS || (MESSAGE_HANDLERS = require_handlers()), MESSAGE_HANDLERS[type](this, payload);
        case MESSAGE.KEXINIT:
          return state.firstPacket ? (state.firstPacket = !1, handleKexInit(this, payload)) : doFatalError(
            this,
            "Received extra KEXINIT during handshake",
            "handshake",
            DISCONNECT_REASON.KEY_EXCHANGE_FAILED
          );
        default:
          if (type < 20 || type > 49)
            return doFatalError(
              this,
              `Received unexpected packet type ${type}`,
              "handshake",
              DISCONNECT_REASON.KEY_EXCHANGE_FAILED
            );
      }
      return this._kex.parse(payload);
    }
    function dhEstimate(neg) {
      let csCipher = CIPHER_INFO[neg.cs.cipher], scCipher = CIPHER_INFO[neg.sc.cipher], bits = Math.max(
        0,
        csCipher.sslName === "des-ede3-cbc" ? 14 : csCipher.keyLen,
        csCipher.blockLen,
        csCipher.ivLen,
        scCipher.sslName === "des-ede3-cbc" ? 14 : scCipher.keyLen,
        scCipher.blockLen,
        scCipher.ivLen
      ) * 8;
      return bits <= 112 ? 2048 : bits <= 128 ? 3072 : bits <= 192 ? 7680 : 8192;
    }
    function trySendNEWKEYS(kex) {
      if (!kex._sentNEWKEYS) {
        kex._protocol._debug && kex._protocol._debug(
          "Outbound: Sending NEWKEYS"
        );
        let p = kex._protocol._packetRW.write.allocStartKEX, packet = kex._protocol._packetRW.write.alloc(1, !0);
        packet[p] = MESSAGE.NEWKEYS, kex._protocol._cipher.encrypt(
          kex._protocol._packetRW.write.finalize(packet, !0)
        ), kex._sentNEWKEYS = !0, kex._protocol._strictMode && (kex._protocol._cipher.outSeqno = 0);
      }
    }
    module2.exports = {
      KexInit,
      kexinit,
      onKEXPayload,
      DEFAULT_KEXINIT_CLIENT: new KexInit({
        kex: DEFAULT_KEX.concat(["ext-info-c", "kex-strict-c-v00@openssh.com"]),
        serverHostKey: DEFAULT_SERVER_HOST_KEY,
        cs: {
          cipher: DEFAULT_CIPHER,
          mac: DEFAULT_MAC,
          compress: DEFAULT_COMPRESSION,
          lang: []
        },
        sc: {
          cipher: DEFAULT_CIPHER,
          mac: DEFAULT_MAC,
          compress: DEFAULT_COMPRESSION,
          lang: []
        }
      }),
      DEFAULT_KEXINIT_SERVER: new KexInit({
        kex: DEFAULT_KEX.concat(["kex-strict-s-v00@openssh.com"]),
        serverHostKey: DEFAULT_SERVER_HOST_KEY,
        cs: {
          cipher: DEFAULT_CIPHER,
          mac: DEFAULT_MAC,
          compress: DEFAULT_COMPRESSION,
          lang: []
        },
        sc: {
          cipher: DEFAULT_CIPHER,
          mac: DEFAULT_MAC,
          compress: DEFAULT_COMPRESSION,
          lang: []
        }
      }),
      HANDLERS: {
        [MESSAGE.KEXINIT]: handleKexInit
      }
    };
  }
});

// node_modules/ssh2/package.json
var require_package = __commonJS({
  "node_modules/ssh2/package.json"(exports2, module2) {
    module2.exports = {
      name: "ssh2",
      version: "1.16.0",
      author: "Brian White <mscdex@mscdex.net>",
      description: "SSH2 client and server modules written in pure JavaScript for node.js",
      main: "./lib/index.js",
      engines: {
        node: ">=10.16.0"
      },
      dependencies: {
        asn1: "^0.2.6",
        "bcrypt-pbkdf": "^1.0.2"
      },
      devDependencies: {
        "@mscdex/eslint-config": "^1.1.0",
        eslint: "^7.32.0"
      },
      optionalDependencies: {
        "cpu-features": "~0.0.10",
        nan: "^2.20.0"
      },
      scripts: {
        install: "node install.js",
        rebuild: "node install.js",
        test: "node test/test.js",
        lint: "eslint --cache --report-unused-disable-directives --ext=.js .eslintrc.js examples lib test",
        "lint:fix": "npm run lint -- --fix"
      },
      keywords: [
        "ssh",
        "ssh2",
        "sftp",
        "secure",
        "shell",
        "exec",
        "remote",
        "client"
      ],
      licenses: [
        {
          type: "MIT",
          url: "http://github.com/mscdex/ssh2/raw/master/LICENSE"
        }
      ],
      repository: {
        type: "git",
        url: "http://github.com/mscdex/ssh2.git"
      }
    };
  }
});

// node_modules/ssh2/lib/protocol/Protocol.js
var require_Protocol = __commonJS({
  "node_modules/ssh2/lib/protocol/Protocol.js"(exports2, module2) {
    "use strict";
    var { inspect } = require("util"), { bindingAvailable, NullCipher, NullDecipher } = require_crypto(), {
      COMPAT_CHECKS,
      DISCONNECT_REASON,
      eddsaSupported,
      MESSAGE,
      SIGNALS,
      TERMINAL_MODE
    } = require_constants6(), {
      DEFAULT_KEXINIT_CLIENT,
      DEFAULT_KEXINIT_SERVER,
      KexInit,
      kexinit,
      onKEXPayload
    } = require_kex(), {
      parseKey
    } = require_keyParser(), MESSAGE_HANDLERS = require_handlers(), {
      bufferCopy,
      bufferFill,
      bufferSlice,
      convertSignature,
      sendPacket,
      writeUInt32BE
    } = require_utils5(), {
      PacketReader,
      PacketWriter,
      ZlibPacketReader,
      ZlibPacketWriter
    } = require_zlib(), MODULE_VER = require_package().version, VALID_DISCONNECT_REASONS = new Map(
      Object.values(DISCONNECT_REASON).map((n) => [n, 1])
    ), IDENT_RAW = Buffer.from(`SSH-2.0-ssh2js${MODULE_VER}`), IDENT = Buffer.from(`${IDENT_RAW}\r
`), MAX_LINE_LEN = 8192, MAX_LINES = 1024, PING_PAYLOAD = Buffer.from([
      MESSAGE.GLOBAL_REQUEST,
      // "keepalive@openssh.com"
      0,
      0,
      0,
      21,
      107,
      101,
      101,
      112,
      97,
      108,
      105,
      118,
      101,
      64,
      111,
      112,
      101,
      110,
      115,
      115,
      104,
      46,
      99,
      111,
      109,
      // Request a reply
      1
    ]), NO_TERMINAL_MODES_BUFFER = Buffer.from([TERMINAL_MODE.TTY_OP_END]);
    function noop2() {
    }
    var Protocol = class {
      constructor(config) {
        let onWrite = config.onWrite;
        if (typeof onWrite != "function")
          throw new Error("Missing onWrite function");
        this._onWrite = (data) => {
          onWrite(data);
        };
        let onError = config.onError;
        if (typeof onError != "function")
          throw new Error("Missing onError function");
        this._onError = (err) => {
          onError(err);
        };
        let debug = config.debug;
        this._debug = typeof debug == "function" ? (msg) => {
          debug(msg);
        } : void 0;
        let onHeader = config.onHeader;
        this._onHeader = typeof onHeader == "function" ? (...args) => {
          onHeader(...args);
        } : noop2;
        let onPacket = config.onPacket;
        this._onPacket = typeof onPacket == "function" ? () => {
          onPacket();
        } : noop2;
        let onHandshakeComplete = config.onHandshakeComplete;
        typeof onHandshakeComplete != "function" && (onHandshakeComplete = noop2);
        let firstHandshake;
        this._onHandshakeComplete = (...args) => {
          this._debug && this._debug("Handshake completed"), firstHandshake === void 0 ? firstHandshake = !0 : firstHandshake = !1;
          let oldQueue = this._queue;
          if (oldQueue) {
            this._queue = void 0, this._debug && this._debug(
              `Draining outbound queue (${oldQueue.length}) ...`
            );
            for (let i = 0; i < oldQueue.length; ++i) {
              let data = oldQueue[i], finalized = this._packetRW.write.finalize(data);
              if (finalized === data) {
                let packet = this._cipher.allocPacket(data.length);
                packet.set(data, 5), finalized = packet;
              }
              sendPacket(this, finalized);
            }
            this._debug && this._debug("... finished draining outbound queue");
          }
          firstHandshake && this._server && this._kex.remoteExtInfoEnabled && sendExtInfo(this), onHandshakeComplete(...args);
        }, this._queue = void 0;
        let messageHandlers = config.messageHandlers;
        typeof messageHandlers == "object" && messageHandlers !== null ? this._handlers = messageHandlers : this._handlers = {}, this._onPayload = onPayload.bind(this), this._server = !!config.server, this._banner = void 0;
        let greeting;
        if (this._server) {
          if (typeof config.hostKeys != "object" || config.hostKeys === null)
            throw new Error("Missing server host key(s)");
          this._hostKeys = config.hostKeys, typeof config.greeting == "string" && config.greeting.length && (greeting = config.greeting.slice(-2) === `\r
` ? config.greeting : `${config.greeting}\r
`), typeof config.banner == "string" && config.banner.length && (this._banner = config.banner.slice(-2) === `\r
` ? config.banner : `${config.banner}\r
`);
        } else
          this._hostKeys = void 0;
        let offer = config.offer;
        typeof offer != "object" || offer === null ? offer = this._server ? DEFAULT_KEXINIT_SERVER : DEFAULT_KEXINIT_CLIENT : offer.constructor !== KexInit && (this._server ? offer.kex = offer.kex.concat(["kex-strict-s-v00@openssh.com"]) : offer.kex = offer.kex.concat([
          "ext-info-c",
          "kex-strict-c-v00@openssh.com"
        ]), offer = new KexInit(offer)), this._kex = void 0, this._strictMode = void 0, this._kexinit = void 0, this._offer = offer, this._cipher = new NullCipher(0, this._onWrite), this._decipher = void 0, this._skipNextInboundPacket = !1, this._packetRW = {
          read: new PacketReader(),
          write: new PacketWriter(this)
        }, this._hostVerifier = !this._server && typeof config.hostVerifier == "function" ? config.hostVerifier : void 0, this._parse = parseHeader, this._buffer = void 0, this._authsQueue = [], this._authenticated = !1, this._remoteIdentRaw = void 0;
        let sentIdent;
        if (typeof config.ident == "string")
          this._identRaw = Buffer.from(`SSH-2.0-${config.ident}`), sentIdent = Buffer.allocUnsafe(this._identRaw.length + 2), sentIdent.set(this._identRaw, 0), sentIdent[sentIdent.length - 2] = 13, sentIdent[sentIdent.length - 1] = 10;
        else if (Buffer.isBuffer(config.ident)) {
          let fullIdent = Buffer.allocUnsafe(8 + config.ident.length);
          fullIdent.latin1Write("SSH-2.0-", 0, 8), fullIdent.set(config.ident, 8), this._identRaw = fullIdent, sentIdent = Buffer.allocUnsafe(fullIdent.length + 2), sentIdent.set(fullIdent, 0), sentIdent[sentIdent.length - 2] = 13, sentIdent[sentIdent.length - 1] = 10;
        } else
          this._identRaw = IDENT_RAW, sentIdent = IDENT;
        this._compatFlags = 0, this._debug && (bindingAvailable ? this._debug("Custom crypto binding available") : this._debug("Custom crypto binding not available")), this._debug && this._debug(
          `Local ident: ${inspect(this._identRaw.toString())}`
        ), this.start = () => {
          this.start = void 0, greeting && this._onWrite(greeting), this._onWrite(sentIdent);
        };
      }
      _destruct(reason) {
        this._packetRW.read.cleanup(), this._packetRW.write.cleanup(), this._cipher && this._cipher.free(), this._decipher && this._decipher.free(), (typeof reason != "string" || reason.length === 0) && (reason = "fatal error"), this.parse = () => {
          throw new Error(`Instance unusable after ${reason}`);
        }, this._onWrite = () => {
          throw new Error(`Instance unusable after ${reason}`);
        }, this._destruct = void 0;
      }
      cleanup() {
        this._destruct && this._destruct();
      }
      parse(chunk, i, len) {
        for (; i < len; )
          i = this._parse(chunk, i, len);
      }
      // Protocol message API
      // ===========================================================================
      // Common/Shared =============================================================
      // ===========================================================================
      // Global
      // ------
      disconnect(reason) {
        let p = this._packetRW.write.allocStartKEX, packet = this._packetRW.write.alloc(13, !0), end = p + 13;
        VALID_DISCONNECT_REASONS.has(reason) || (reason = DISCONNECT_REASON.PROTOCOL_ERROR), packet[p] = MESSAGE.DISCONNECT, writeUInt32BE(packet, reason, ++p), packet.fill(0, p += 4, end), this._debug && this._debug(`Outbound: Sending DISCONNECT (${reason})`), sendPacket(this, this._packetRW.write.finalize(packet, !0), !0);
      }
      ping() {
        let p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(PING_PAYLOAD.length);
        packet.set(PING_PAYLOAD, p), this._debug && this._debug(
          "Outbound: Sending ping (GLOBAL_REQUEST: keepalive@openssh.com)"
        ), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      rekey() {
        this._kexinit === void 0 ? (this._debug && this._debug("Outbound: Initiated explicit rekey"), this._queue = [], kexinit(this)) : this._debug && this._debug("Outbound: Ignoring rekey during handshake");
      }
      // 'ssh-connection' service-specific
      // ---------------------------------
      requestSuccess(data) {
        let p = this._packetRW.write.allocStart, packet;
        Buffer.isBuffer(data) ? (packet = this._packetRW.write.alloc(1 + data.length), packet[p] = MESSAGE.REQUEST_SUCCESS, packet.set(data, ++p)) : (packet = this._packetRW.write.alloc(1), packet[p] = MESSAGE.REQUEST_SUCCESS), this._debug && this._debug("Outbound: Sending REQUEST_SUCCESS"), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      requestFailure() {
        let p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(1);
        packet[p] = MESSAGE.REQUEST_FAILURE, this._debug && this._debug("Outbound: Sending REQUEST_FAILURE"), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelSuccess(chan) {
        let p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(5);
        packet[p] = MESSAGE.CHANNEL_SUCCESS, writeUInt32BE(packet, chan, ++p), this._debug && this._debug(`Outbound: Sending CHANNEL_SUCCESS (r:${chan})`), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelFailure(chan) {
        let p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(5);
        packet[p] = MESSAGE.CHANNEL_FAILURE, writeUInt32BE(packet, chan, ++p), this._debug && this._debug(`Outbound: Sending CHANNEL_FAILURE (r:${chan})`), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelEOF(chan) {
        let p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(5);
        packet[p] = MESSAGE.CHANNEL_EOF, writeUInt32BE(packet, chan, ++p), this._debug && this._debug(`Outbound: Sending CHANNEL_EOF (r:${chan})`), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelClose(chan) {
        let p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(5);
        packet[p] = MESSAGE.CHANNEL_CLOSE, writeUInt32BE(packet, chan, ++p), this._debug && this._debug(`Outbound: Sending CHANNEL_CLOSE (r:${chan})`), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelWindowAdjust(chan, amount) {
        let p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(9);
        packet[p] = MESSAGE.CHANNEL_WINDOW_ADJUST, writeUInt32BE(packet, chan, ++p), writeUInt32BE(packet, amount, p += 4), this._debug && this._debug(
          `Outbound: Sending CHANNEL_WINDOW_ADJUST (r:${chan}, ${amount})`
        ), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelData(chan, data) {
        let isBuffer = Buffer.isBuffer(data), dataLen = isBuffer ? data.length : Buffer.byteLength(data), p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(9 + dataLen);
        packet[p] = MESSAGE.CHANNEL_DATA, writeUInt32BE(packet, chan, ++p), writeUInt32BE(packet, dataLen, p += 4), isBuffer ? packet.set(data, p += 4) : packet.utf8Write(data, p += 4, dataLen), this._debug && this._debug(
          `Outbound: Sending CHANNEL_DATA (r:${chan}, ${dataLen})`
        ), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelExtData(chan, data, type) {
        let isBuffer = Buffer.isBuffer(data), dataLen = isBuffer ? data.length : Buffer.byteLength(data), p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(13 + dataLen);
        packet[p] = MESSAGE.CHANNEL_EXTENDED_DATA, writeUInt32BE(packet, chan, ++p), writeUInt32BE(packet, type, p += 4), writeUInt32BE(packet, dataLen, p += 4), isBuffer ? packet.set(data, p += 4) : packet.utf8Write(data, p += 4, dataLen), this._debug && this._debug(`Outbound: Sending CHANNEL_EXTENDED_DATA (r:${chan})`), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelOpenConfirm(remote, local, initWindow, maxPacket) {
        let p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(17);
        packet[p] = MESSAGE.CHANNEL_OPEN_CONFIRMATION, writeUInt32BE(packet, remote, ++p), writeUInt32BE(packet, local, p += 4), writeUInt32BE(packet, initWindow, p += 4), writeUInt32BE(packet, maxPacket, p += 4), this._debug && this._debug(
          `Outbound: Sending CHANNEL_OPEN_CONFIRMATION (r:${remote}, l:${local})`
        ), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelOpenFail(remote, reason, desc) {
        typeof desc != "string" && (desc = "");
        let descLen = Buffer.byteLength(desc), p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(13 + descLen + 4);
        packet[p] = MESSAGE.CHANNEL_OPEN_FAILURE, writeUInt32BE(packet, remote, ++p), writeUInt32BE(packet, reason, p += 4), writeUInt32BE(packet, descLen, p += 4), p += 4, descLen && (packet.utf8Write(desc, p, descLen), p += descLen), writeUInt32BE(packet, 0, p), this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN_FAILURE (r:${remote})`), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      // ===========================================================================
      // Client-specific ===========================================================
      // ===========================================================================
      // Global
      // ------
      service(name2) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let nameLen = Buffer.byteLength(name2), p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(5 + nameLen);
        packet[p] = MESSAGE.SERVICE_REQUEST, writeUInt32BE(packet, nameLen, ++p), packet.utf8Write(name2, p += 4, nameLen), this._debug && this._debug(`Outbound: Sending SERVICE_REQUEST (${name2})`), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      // 'ssh-userauth' service-specific
      // -------------------------------
      authPassword(username, password, newPassword) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let userLen = Buffer.byteLength(username), passLen = Buffer.byteLength(password), newPassLen = newPassword ? Buffer.byteLength(newPassword) : 0, p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(
          5 + userLen + 4 + 14 + 4 + 8 + 1 + 4 + passLen + (newPassword ? 4 + newPassLen : 0)
        );
        packet[p] = MESSAGE.USERAUTH_REQUEST, writeUInt32BE(packet, userLen, ++p), packet.utf8Write(username, p += 4, userLen), writeUInt32BE(packet, 14, p += userLen), packet.utf8Write("ssh-connection", p += 4, 14), writeUInt32BE(packet, 8, p += 14), packet.utf8Write("password", p += 4, 8), packet[p += 8] = newPassword ? 1 : 0, writeUInt32BE(packet, passLen, ++p), Buffer.isBuffer(password) ? bufferCopy(password, packet, 0, passLen, p += 4) : packet.utf8Write(password, p += 4, passLen), newPassword ? (writeUInt32BE(packet, newPassLen, p += passLen), Buffer.isBuffer(newPassword) ? bufferCopy(newPassword, packet, 0, newPassLen, p += 4) : packet.utf8Write(newPassword, p += 4, newPassLen), this._debug && this._debug(
          "Outbound: Sending USERAUTH_REQUEST (changed password)"
        )) : this._debug && this._debug(
          "Outbound: Sending USERAUTH_REQUEST (password)"
        ), this._authsQueue.push("password"), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      authPK(username, pubKey, keyAlgo, cbSign) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        if (pubKey = parseKey(pubKey), pubKey instanceof Error)
          throw new Error("Invalid key");
        let keyType = pubKey.type;
        pubKey = pubKey.getPublicSSH(), typeof keyAlgo == "function" && (cbSign = keyAlgo, keyAlgo = void 0), keyAlgo || (keyAlgo = keyType);
        let userLen = Buffer.byteLength(username), algoLen = Buffer.byteLength(keyAlgo), pubKeyLen = pubKey.length, sessionID = this._kex.sessionID, sesLen = sessionID.length, payloadLen = (cbSign ? 4 + sesLen : 0) + 1 + 4 + userLen + 4 + 14 + 4 + 9 + 1 + 4 + algoLen + 4 + pubKeyLen, packet, p;
        if (cbSign ? (packet = Buffer.allocUnsafe(payloadLen), p = 0, writeUInt32BE(packet, sesLen, p), packet.set(sessionID, p += 4), p += sesLen) : (packet = this._packetRW.write.alloc(payloadLen), p = this._packetRW.write.allocStart), packet[p] = MESSAGE.USERAUTH_REQUEST, writeUInt32BE(packet, userLen, ++p), packet.utf8Write(username, p += 4, userLen), writeUInt32BE(packet, 14, p += userLen), packet.utf8Write("ssh-connection", p += 4, 14), writeUInt32BE(packet, 9, p += 14), packet.utf8Write("publickey", p += 4, 9), packet[p += 9] = cbSign ? 1 : 0, writeUInt32BE(packet, algoLen, ++p), packet.utf8Write(keyAlgo, p += 4, algoLen), writeUInt32BE(packet, pubKeyLen, p += algoLen), packet.set(pubKey, p += 4), !cbSign) {
          this._authsQueue.push("publickey"), this._debug && this._debug(
            "Outbound: Sending USERAUTH_REQUEST (publickey -- check)"
          ), sendPacket(this, this._packetRW.write.finalize(packet));
          return;
        }
        cbSign(packet, (signature) => {
          if (signature = convertSignature(signature, keyType), signature === !1)
            throw new Error("Error while converting handshake signature");
          let sigLen = signature.length;
          p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(
            5 + userLen + 4 + 14 + 4 + 9 + 1 + 4 + algoLen + 4 + pubKeyLen + 4 + 4 + algoLen + 4 + sigLen
          ), packet[p] = MESSAGE.USERAUTH_REQUEST, writeUInt32BE(packet, userLen, ++p), packet.utf8Write(username, p += 4, userLen), writeUInt32BE(packet, 14, p += userLen), packet.utf8Write("ssh-connection", p += 4, 14), writeUInt32BE(packet, 9, p += 14), packet.utf8Write("publickey", p += 4, 9), packet[p += 9] = 1, writeUInt32BE(packet, algoLen, ++p), packet.utf8Write(keyAlgo, p += 4, algoLen), writeUInt32BE(packet, pubKeyLen, p += algoLen), packet.set(pubKey, p += 4), writeUInt32BE(packet, 4 + algoLen + 4 + sigLen, p += pubKeyLen), writeUInt32BE(packet, algoLen, p += 4), packet.utf8Write(keyAlgo, p += 4, algoLen), writeUInt32BE(packet, sigLen, p += algoLen), packet.set(signature, p += 4), this._authsQueue.push("publickey"), this._debug && this._debug(
            "Outbound: Sending USERAUTH_REQUEST (publickey)"
          ), sendPacket(this, this._packetRW.write.finalize(packet));
        });
      }
      authHostbased(username, pubKey, hostname, userlocal, keyAlgo, cbSign) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        if (pubKey = parseKey(pubKey), pubKey instanceof Error)
          throw new Error("Invalid key");
        let keyType = pubKey.type;
        pubKey = pubKey.getPublicSSH(), typeof keyAlgo == "function" && (cbSign = keyAlgo, keyAlgo = void 0), keyAlgo || (keyAlgo = keyType);
        let userLen = Buffer.byteLength(username), algoLen = Buffer.byteLength(keyAlgo), pubKeyLen = pubKey.length, sessionID = this._kex.sessionID, sesLen = sessionID.length, hostnameLen = Buffer.byteLength(hostname), userlocalLen = Buffer.byteLength(userlocal), data = Buffer.allocUnsafe(
          4 + sesLen + 1 + 4 + userLen + 4 + 14 + 4 + 9 + 4 + algoLen + 4 + pubKeyLen + 4 + hostnameLen + 4 + userlocalLen
        ), p = 0;
        writeUInt32BE(data, sesLen, p), data.set(sessionID, p += 4), data[p += sesLen] = MESSAGE.USERAUTH_REQUEST, writeUInt32BE(data, userLen, ++p), data.utf8Write(username, p += 4, userLen), writeUInt32BE(data, 14, p += userLen), data.utf8Write("ssh-connection", p += 4, 14), writeUInt32BE(data, 9, p += 14), data.utf8Write("hostbased", p += 4, 9), writeUInt32BE(data, algoLen, p += 9), data.utf8Write(keyAlgo, p += 4, algoLen), writeUInt32BE(data, pubKeyLen, p += algoLen), data.set(pubKey, p += 4), writeUInt32BE(data, hostnameLen, p += pubKeyLen), data.utf8Write(hostname, p += 4, hostnameLen), writeUInt32BE(data, userlocalLen, p += hostnameLen), data.utf8Write(userlocal, p += 4, userlocalLen), cbSign(data, (signature) => {
          if (signature = convertSignature(signature, keyType), !signature)
            throw new Error("Error while converting handshake signature");
          let sigLen = signature.length, reqDataLen = data.length - sesLen - 4;
          p = this._packetRW.write.allocStart;
          let packet = this._packetRW.write.alloc(
            reqDataLen + 4 + 4 + algoLen + 4 + sigLen
          );
          bufferCopy(data, packet, 4 + sesLen, data.length, p), writeUInt32BE(packet, 4 + algoLen + 4 + sigLen, p += reqDataLen), writeUInt32BE(packet, algoLen, p += 4), packet.utf8Write(keyAlgo, p += 4, algoLen), writeUInt32BE(packet, sigLen, p += algoLen), packet.set(signature, p += 4), this._authsQueue.push("hostbased"), this._debug && this._debug(
            "Outbound: Sending USERAUTH_REQUEST (hostbased)"
          ), sendPacket(this, this._packetRW.write.finalize(packet));
        });
      }
      authKeyboard(username) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let userLen = Buffer.byteLength(username), p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(
          5 + userLen + 4 + 14 + 4 + 20 + 4 + 4
        );
        packet[p] = MESSAGE.USERAUTH_REQUEST, writeUInt32BE(packet, userLen, ++p), packet.utf8Write(username, p += 4, userLen), writeUInt32BE(packet, 14, p += userLen), packet.utf8Write("ssh-connection", p += 4, 14), writeUInt32BE(packet, 20, p += 14), packet.utf8Write("keyboard-interactive", p += 4, 20), writeUInt32BE(packet, 0, p += 20), writeUInt32BE(packet, 0, p += 4), this._authsQueue.push("keyboard-interactive"), this._debug && this._debug(
          "Outbound: Sending USERAUTH_REQUEST (keyboard-interactive)"
        ), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      authNone(username) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let userLen = Buffer.byteLength(username), p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(5 + userLen + 4 + 14 + 4 + 4);
        packet[p] = MESSAGE.USERAUTH_REQUEST, writeUInt32BE(packet, userLen, ++p), packet.utf8Write(username, p += 4, userLen), writeUInt32BE(packet, 14, p += userLen), packet.utf8Write("ssh-connection", p += 4, 14), writeUInt32BE(packet, 4, p += 14), packet.utf8Write("none", p += 4, 4), this._authsQueue.push("none"), this._debug && this._debug("Outbound: Sending USERAUTH_REQUEST (none)"), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      authInfoRes(responses) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let responsesTotalLen = 0, responseLens;
        if (responses) {
          responseLens = new Array(responses.length);
          for (let i = 0; i < responses.length; ++i) {
            let len = Buffer.byteLength(responses[i]);
            responseLens[i] = len, responsesTotalLen += 4 + len;
          }
        }
        let p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(5 + responsesTotalLen);
        if (packet[p] = MESSAGE.USERAUTH_INFO_RESPONSE, responses) {
          writeUInt32BE(packet, responses.length, ++p), p += 4;
          for (let i = 0; i < responses.length; ++i) {
            let len = responseLens[i];
            writeUInt32BE(packet, len, p), p += 4, len && (packet.utf8Write(responses[i], p, len), p += len);
          }
        } else
          writeUInt32BE(packet, 0, ++p);
        this._debug && this._debug("Outbound: Sending USERAUTH_INFO_RESPONSE"), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      // 'ssh-connection' service-specific
      // ---------------------------------
      tcpipForward(bindAddr, bindPort, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let addrLen = Buffer.byteLength(bindAddr), p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(23 + addrLen + 4);
        packet[p] = MESSAGE.GLOBAL_REQUEST, writeUInt32BE(packet, 13, ++p), packet.utf8Write("tcpip-forward", p += 4, 13), packet[p += 13] = wantReply === void 0 || wantReply === !0 ? 1 : 0, writeUInt32BE(packet, addrLen, ++p), packet.utf8Write(bindAddr, p += 4, addrLen), writeUInt32BE(packet, bindPort, p += addrLen), this._debug && this._debug("Outbound: Sending GLOBAL_REQUEST (tcpip-forward)"), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      cancelTcpipForward(bindAddr, bindPort, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let addrLen = Buffer.byteLength(bindAddr), p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(30 + addrLen + 4);
        packet[p] = MESSAGE.GLOBAL_REQUEST, writeUInt32BE(packet, 20, ++p), packet.utf8Write("cancel-tcpip-forward", p += 4, 20), packet[p += 20] = wantReply === void 0 || wantReply === !0 ? 1 : 0, writeUInt32BE(packet, addrLen, ++p), packet.utf8Write(bindAddr, p += 4, addrLen), writeUInt32BE(packet, bindPort, p += addrLen), this._debug && this._debug("Outbound: Sending GLOBAL_REQUEST (cancel-tcpip-forward)"), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_streamLocalForward(socketPath, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let socketPathLen = Buffer.byteLength(socketPath), p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(
          41 + socketPathLen
        );
        packet[p] = MESSAGE.GLOBAL_REQUEST, writeUInt32BE(packet, 31, ++p), packet.utf8Write("streamlocal-forward@openssh.com", p += 4, 31), packet[p += 31] = wantReply === void 0 || wantReply === !0 ? 1 : 0, writeUInt32BE(packet, socketPathLen, ++p), packet.utf8Write(socketPath, p += 4, socketPathLen), this._debug && this._debug(
          "Outbound: Sending GLOBAL_REQUEST (streamlocal-forward@openssh.com)"
        ), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_cancelStreamLocalForward(socketPath, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let socketPathLen = Buffer.byteLength(socketPath), p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(
          48 + socketPathLen
        );
        packet[p] = MESSAGE.GLOBAL_REQUEST, writeUInt32BE(packet, 38, ++p), packet.utf8Write("cancel-streamlocal-forward@openssh.com", p += 4, 38), packet[p += 38] = wantReply === void 0 || wantReply === !0 ? 1 : 0, writeUInt32BE(packet, socketPathLen, ++p), packet.utf8Write(socketPath, p += 4, socketPathLen), this._debug && this._debug(
          "Outbound: Sending GLOBAL_REQUEST (cancel-streamlocal-forward@openssh.com)"
        ), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      directTcpip(chan, initWindow, maxPacket, cfg) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let srcLen = Buffer.byteLength(cfg.srcIP), dstLen = Buffer.byteLength(cfg.dstIP), p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(
          33 + srcLen + 4 + 4 + dstLen + 4
        );
        packet[p] = MESSAGE.CHANNEL_OPEN, writeUInt32BE(packet, 12, ++p), packet.utf8Write("direct-tcpip", p += 4, 12), writeUInt32BE(packet, chan, p += 12), writeUInt32BE(packet, initWindow, p += 4), writeUInt32BE(packet, maxPacket, p += 4), writeUInt32BE(packet, dstLen, p += 4), packet.utf8Write(cfg.dstIP, p += 4, dstLen), writeUInt32BE(packet, cfg.dstPort, p += dstLen), writeUInt32BE(packet, srcLen, p += 4), packet.utf8Write(cfg.srcIP, p += 4, srcLen), writeUInt32BE(packet, cfg.srcPort, p += srcLen), this._debug && this._debug(
          `Outbound: Sending CHANNEL_OPEN (r:${chan}, direct-tcpip)`
        ), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_directStreamLocal(chan, initWindow, maxPacket, cfg) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let pathLen = Buffer.byteLength(cfg.socketPath), p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(
          51 + pathLen + 4 + 4
        );
        packet[p] = MESSAGE.CHANNEL_OPEN, writeUInt32BE(packet, 30, ++p), packet.utf8Write("direct-streamlocal@openssh.com", p += 4, 30), writeUInt32BE(packet, chan, p += 30), writeUInt32BE(packet, initWindow, p += 4), writeUInt32BE(packet, maxPacket, p += 4), writeUInt32BE(packet, pathLen, p += 4), packet.utf8Write(cfg.socketPath, p += 4, pathLen), bufferFill(packet, 0, p += pathLen, p + 8), this._debug && this._debug(
          `Outbound: Sending CHANNEL_OPEN (r:${chan}, direct-streamlocal@openssh.com)`
        ), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_noMoreSessions(wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(34);
        packet[p] = MESSAGE.GLOBAL_REQUEST, writeUInt32BE(packet, 28, ++p), packet.utf8Write("no-more-sessions@openssh.com", p += 4, 28), packet[p += 28] = wantReply === void 0 || wantReply === !0 ? 1 : 0, this._debug && this._debug(
          "Outbound: Sending GLOBAL_REQUEST (no-more-sessions@openssh.com)"
        ), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      session(chan, initWindow, maxPacket) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(24);
        packet[p] = MESSAGE.CHANNEL_OPEN, writeUInt32BE(packet, 7, ++p), packet.utf8Write("session", p += 4, 7), writeUInt32BE(packet, chan, p += 7), writeUInt32BE(packet, initWindow, p += 4), writeUInt32BE(packet, maxPacket, p += 4), this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN (r:${chan}, session)`), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      windowChange(chan, rows, cols, height, width) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(
          39
        );
        packet[p] = MESSAGE.CHANNEL_REQUEST, writeUInt32BE(packet, chan, ++p), writeUInt32BE(packet, 13, p += 4), packet.utf8Write("window-change", p += 4, 13), packet[p += 13] = 0, writeUInt32BE(packet, cols, ++p), writeUInt32BE(packet, rows, p += 4), writeUInt32BE(packet, width, p += 4), writeUInt32BE(packet, height, p += 4), this._debug && this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${chan}, window-change)`
        ), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      pty(chan, rows, cols, height, width, term, modes, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        (!term || !term.length) && (term = "vt100"), modes && !Buffer.isBuffer(modes) && !Array.isArray(modes) && typeof modes == "object" && modes !== null && (modes = modesToBytes(modes)), (!modes || !modes.length) && (modes = NO_TERMINAL_MODES_BUFFER);
        let termLen = term.length, modesLen = modes.length, p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(
          21 + termLen + 4 + 4 + 4 + 4 + 4 + modesLen
        );
        if (packet[p] = MESSAGE.CHANNEL_REQUEST, writeUInt32BE(packet, chan, ++p), writeUInt32BE(packet, 7, p += 4), packet.utf8Write("pty-req", p += 4, 7), packet[p += 7] = wantReply === void 0 || wantReply === !0 ? 1 : 0, writeUInt32BE(packet, termLen, ++p), packet.utf8Write(term, p += 4, termLen), writeUInt32BE(packet, cols, p += termLen), writeUInt32BE(packet, rows, p += 4), writeUInt32BE(packet, width, p += 4), writeUInt32BE(packet, height, p += 4), writeUInt32BE(packet, modesLen, p += 4), p += 4, Array.isArray(modes))
          for (let i = 0; i < modesLen; ++i)
            packet[p++] = modes[i];
        else Buffer.isBuffer(modes) && packet.set(modes, p);
        this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, pty-req)`), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      shell(chan, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(15);
        packet[p] = MESSAGE.CHANNEL_REQUEST, writeUInt32BE(packet, chan, ++p), writeUInt32BE(packet, 5, p += 4), packet.utf8Write("shell", p += 4, 5), packet[p += 5] = wantReply === void 0 || wantReply === !0 ? 1 : 0, this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, shell)`), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      exec(chan, cmd, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let isBuf = Buffer.isBuffer(cmd), cmdLen = isBuf ? cmd.length : Buffer.byteLength(cmd), p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(18 + cmdLen);
        packet[p] = MESSAGE.CHANNEL_REQUEST, writeUInt32BE(packet, chan, ++p), writeUInt32BE(packet, 4, p += 4), packet.utf8Write("exec", p += 4, 4), packet[p += 4] = wantReply === void 0 || wantReply === !0 ? 1 : 0, writeUInt32BE(packet, cmdLen, ++p), isBuf ? packet.set(cmd, p += 4) : packet.utf8Write(cmd, p += 4, cmdLen), this._debug && this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${chan}, exec: ${cmd})`
        ), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      signal(chan, signal) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let origSignal = signal;
        if (signal = signal.toUpperCase(), signal.slice(0, 3) === "SIG" && (signal = signal.slice(3)), SIGNALS[signal] !== 1)
          throw new Error(`Invalid signal: ${origSignal}`);
        let signalLen = signal.length, p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(
          20 + signalLen
        );
        packet[p] = MESSAGE.CHANNEL_REQUEST, writeUInt32BE(packet, chan, ++p), writeUInt32BE(packet, 6, p += 4), packet.utf8Write("signal", p += 4, 6), packet[p += 6] = 0, writeUInt32BE(packet, signalLen, ++p), packet.utf8Write(signal, p += 4, signalLen), this._debug && this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${chan}, signal: ${signal})`
        ), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      env(chan, key, val, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let keyLen = Buffer.byteLength(key), isBuf = Buffer.isBuffer(val), valLen = isBuf ? val.length : Buffer.byteLength(val), p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(
          17 + keyLen + 4 + valLen
        );
        packet[p] = MESSAGE.CHANNEL_REQUEST, writeUInt32BE(packet, chan, ++p), writeUInt32BE(packet, 3, p += 4), packet.utf8Write("env", p += 4, 3), packet[p += 3] = wantReply === void 0 || wantReply === !0 ? 1 : 0, writeUInt32BE(packet, keyLen, ++p), packet.utf8Write(key, p += 4, keyLen), writeUInt32BE(packet, valLen, p += keyLen), isBuf ? packet.set(val, p += 4) : packet.utf8Write(val, p += 4, valLen), this._debug && this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${chan}, env: ${key}=${val})`
        ), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      x11Forward(chan, cfg, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let protocol = cfg.protocol, cookie = cfg.cookie, isBufProto = Buffer.isBuffer(protocol), protoLen = isBufProto ? protocol.length : Buffer.byteLength(protocol), isBufCookie = Buffer.isBuffer(cookie), cookieLen = isBufCookie ? cookie.length : Buffer.byteLength(cookie), p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(
          22 + protoLen + 4 + cookieLen + 4
        );
        packet[p] = MESSAGE.CHANNEL_REQUEST, writeUInt32BE(packet, chan, ++p), writeUInt32BE(packet, 7, p += 4), packet.utf8Write("x11-req", p += 4, 7), packet[p += 7] = wantReply === void 0 || wantReply === !0 ? 1 : 0, packet[++p] = cfg.single ? 1 : 0, writeUInt32BE(packet, protoLen, ++p), isBufProto ? packet.set(protocol, p += 4) : packet.utf8Write(protocol, p += 4, protoLen), writeUInt32BE(packet, cookieLen, p += protoLen), isBufCookie ? packet.set(cookie, p += 4) : packet.latin1Write(cookie, p += 4, cookieLen), writeUInt32BE(packet, cfg.screen || 0, p += cookieLen), this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, x11-req)`), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      subsystem(chan, name2, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let nameLen = Buffer.byteLength(name2), p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(23 + nameLen);
        packet[p] = MESSAGE.CHANNEL_REQUEST, writeUInt32BE(packet, chan, ++p), writeUInt32BE(packet, 9, p += 4), packet.utf8Write("subsystem", p += 4, 9), packet[p += 9] = wantReply === void 0 || wantReply === !0 ? 1 : 0, writeUInt32BE(packet, nameLen, ++p), packet.utf8Write(name2, p += 4, nameLen), this._debug && this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${chan}, subsystem: ${name2})`
        ), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_agentForward(chan, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(36);
        packet[p] = MESSAGE.CHANNEL_REQUEST, writeUInt32BE(packet, chan, ++p), writeUInt32BE(packet, 26, p += 4), packet.utf8Write("auth-agent-req@openssh.com", p += 4, 26), packet[p += 26] = wantReply === void 0 || wantReply === !0 ? 1 : 0, this._debug && this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${chan}, auth-agent-req@openssh.com)`
        ), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_hostKeysProve(keys) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let keysTotal = 0, publicKeys = [];
        for (let key of keys) {
          let publicKey = key.getPublicSSH();
          keysTotal += 4 + publicKey.length, publicKeys.push(publicKey);
        }
        let p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(35 + keysTotal);
        packet[p] = MESSAGE.GLOBAL_REQUEST, writeUInt32BE(packet, 29, ++p), packet.utf8Write("hostkeys-prove-00@openssh.com", p += 4, 29), packet[p += 29] = 1, ++p;
        for (let buf of publicKeys)
          writeUInt32BE(packet, buf.length, p), bufferCopy(buf, packet, 0, buf.length, p += 4), p += buf.length;
        this._debug && this._debug(
          "Outbound: Sending GLOBAL_REQUEST (hostkeys-prove-00@openssh.com)"
        ), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      // ===========================================================================
      // Server-specific ===========================================================
      // ===========================================================================
      // Global
      // ------
      serviceAccept(svcName) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        let svcNameLen = Buffer.byteLength(svcName), p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(5 + svcNameLen);
        if (packet[p] = MESSAGE.SERVICE_ACCEPT, writeUInt32BE(packet, svcNameLen, ++p), packet.utf8Write(svcName, p += 4, svcNameLen), this._debug && this._debug(`Outbound: Sending SERVICE_ACCEPT (${svcName})`), sendPacket(this, this._packetRW.write.finalize(packet)), this._server && this._banner && svcName === "ssh-userauth") {
          let banner = this._banner;
          this._banner = void 0;
          let bannerLen = Buffer.byteLength(banner);
          p = this._packetRW.write.allocStart;
          let packet2 = this._packetRW.write.alloc(5 + bannerLen + 4);
          packet2[p] = MESSAGE.USERAUTH_BANNER, writeUInt32BE(packet2, bannerLen, ++p), packet2.utf8Write(banner, p += 4, bannerLen), writeUInt32BE(packet2, 0, p += bannerLen), this._debug && this._debug("Outbound: Sending USERAUTH_BANNER"), sendPacket(this, this._packetRW.write.finalize(packet2));
        }
      }
      // 'ssh-connection' service-specific
      forwardedTcpip(chan, initWindow, maxPacket, cfg) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        let boundAddrLen = Buffer.byteLength(cfg.boundAddr), remoteAddrLen = Buffer.byteLength(cfg.remoteAddr), p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(
          36 + boundAddrLen + 4 + 4 + remoteAddrLen + 4
        );
        packet[p] = MESSAGE.CHANNEL_OPEN, writeUInt32BE(packet, 15, ++p), packet.utf8Write("forwarded-tcpip", p += 4, 15), writeUInt32BE(packet, chan, p += 15), writeUInt32BE(packet, initWindow, p += 4), writeUInt32BE(packet, maxPacket, p += 4), writeUInt32BE(packet, boundAddrLen, p += 4), packet.utf8Write(cfg.boundAddr, p += 4, boundAddrLen), writeUInt32BE(packet, cfg.boundPort, p += boundAddrLen), writeUInt32BE(packet, remoteAddrLen, p += 4), packet.utf8Write(cfg.remoteAddr, p += 4, remoteAddrLen), writeUInt32BE(packet, cfg.remotePort, p += remoteAddrLen), this._debug && this._debug(
          `Outbound: Sending CHANNEL_OPEN (r:${chan}, forwarded-tcpip)`
        ), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      x11(chan, initWindow, maxPacket, cfg) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        let addrLen = Buffer.byteLength(cfg.originAddr), p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(
          24 + addrLen + 4
        );
        packet[p] = MESSAGE.CHANNEL_OPEN, writeUInt32BE(packet, 3, ++p), packet.utf8Write("x11", p += 4, 3), writeUInt32BE(packet, chan, p += 3), writeUInt32BE(packet, initWindow, p += 4), writeUInt32BE(packet, maxPacket, p += 4), writeUInt32BE(packet, addrLen, p += 4), packet.utf8Write(cfg.originAddr, p += 4, addrLen), writeUInt32BE(packet, cfg.originPort, p += addrLen), this._debug && this._debug(
          `Outbound: Sending CHANNEL_OPEN (r:${chan}, x11)`
        ), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_authAgent(chan, initWindow, maxPacket) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        let p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(39);
        packet[p] = MESSAGE.CHANNEL_OPEN, writeUInt32BE(packet, 22, ++p), packet.utf8Write("auth-agent@openssh.com", p += 4, 22), writeUInt32BE(packet, chan, p += 22), writeUInt32BE(packet, initWindow, p += 4), writeUInt32BE(packet, maxPacket, p += 4), this._debug && this._debug(
          `Outbound: Sending CHANNEL_OPEN (r:${chan}, auth-agent@openssh.com)`
        ), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_forwardedStreamLocal(chan, initWindow, maxPacket, cfg) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        let pathLen = Buffer.byteLength(cfg.socketPath), p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(
          54 + pathLen + 4
        );
        packet[p] = MESSAGE.CHANNEL_OPEN, writeUInt32BE(packet, 33, ++p), packet.utf8Write("forwarded-streamlocal@openssh.com", p += 4, 33), writeUInt32BE(packet, chan, p += 33), writeUInt32BE(packet, initWindow, p += 4), writeUInt32BE(packet, maxPacket, p += 4), writeUInt32BE(packet, pathLen, p += 4), packet.utf8Write(cfg.socketPath, p += 4, pathLen), writeUInt32BE(packet, 0, p += pathLen), this._debug && this._debug(
          `Outbound: Sending CHANNEL_OPEN (r:${chan}, forwarded-streamlocal@openssh.com)`
        ), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      exitStatus(chan, status) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        let p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(25);
        packet[p] = MESSAGE.CHANNEL_REQUEST, writeUInt32BE(packet, chan, ++p), writeUInt32BE(packet, 11, p += 4), packet.utf8Write("exit-status", p += 4, 11), packet[p += 11] = 0, writeUInt32BE(packet, status, ++p), this._debug && this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${chan}, exit-status: ${status})`
        ), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      exitSignal(chan, name2, coreDumped, msg) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        let origSignal = name2;
        if (typeof origSignal != "string" || !origSignal)
          throw new Error(`Invalid signal: ${origSignal}`);
        let signal = name2.toUpperCase();
        if (signal.slice(0, 3) === "SIG" && (signal = signal.slice(3)), SIGNALS[signal] !== 1)
          throw new Error(`Invalid signal: ${origSignal}`);
        let nameLen = Buffer.byteLength(signal), msgLen = msg ? Buffer.byteLength(msg) : 0, p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(
          25 + nameLen + 1 + 4 + msgLen + 4
        );
        packet[p] = MESSAGE.CHANNEL_REQUEST, writeUInt32BE(packet, chan, ++p), writeUInt32BE(packet, 11, p += 4), packet.utf8Write("exit-signal", p += 4, 11), packet[p += 11] = 0, writeUInt32BE(packet, nameLen, ++p), packet.utf8Write(signal, p += 4, nameLen), packet[p += nameLen] = coreDumped ? 1 : 0, writeUInt32BE(packet, msgLen, ++p), p += 4, msgLen && (packet.utf8Write(msg, p, msgLen), p += msgLen), writeUInt32BE(packet, 0, p), this._debug && this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${chan}, exit-signal: ${name2})`
        ), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      // 'ssh-userauth' service-specific
      authFailure(authMethods, isPartial) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        if (this._authsQueue.length === 0)
          throw new Error("No auth in progress");
        let methods;
        if (typeof authMethods == "boolean" && (isPartial = authMethods, authMethods = void 0), authMethods) {
          methods = [];
          for (let i = 0; i < authMethods.length; ++i)
            authMethods[i].toLowerCase() !== "none" && methods.push(authMethods[i]);
          methods = methods.join(",");
        } else
          methods = "";
        let methodsLen = methods.length, p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(5 + methodsLen + 1);
        packet[p] = MESSAGE.USERAUTH_FAILURE, writeUInt32BE(packet, methodsLen, ++p), packet.utf8Write(methods, p += 4, methodsLen), packet[p += methodsLen] = isPartial === !0 ? 1 : 0, this._authsQueue.shift(), this._debug && this._debug("Outbound: Sending USERAUTH_FAILURE"), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      authSuccess() {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        if (this._authsQueue.length === 0)
          throw new Error("No auth in progress");
        let p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(1);
        packet[p] = MESSAGE.USERAUTH_SUCCESS, this._authsQueue.shift(), this._authenticated = !0, this._debug && this._debug("Outbound: Sending USERAUTH_SUCCESS"), sendPacket(this, this._packetRW.write.finalize(packet)), this._kex.negotiated.cs.compress === "zlib@openssh.com" && (this._packetRW.read = new ZlibPacketReader()), this._kex.negotiated.sc.compress === "zlib@openssh.com" && (this._packetRW.write = new ZlibPacketWriter(this));
      }
      authPKOK(keyAlgo, key) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        if (this._authsQueue.length === 0 || this._authsQueue[0] !== "publickey")
          throw new Error('"publickey" auth not in progress');
        let keyAlgoLen = Buffer.byteLength(keyAlgo), keyLen = key.length, p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(5 + keyAlgoLen + 4 + keyLen);
        packet[p] = MESSAGE.USERAUTH_PK_OK, writeUInt32BE(packet, keyAlgoLen, ++p), packet.utf8Write(keyAlgo, p += 4, keyAlgoLen), writeUInt32BE(packet, keyLen, p += keyAlgoLen), packet.set(key, p += 4), this._authsQueue.shift(), this._debug && this._debug("Outbound: Sending USERAUTH_PK_OK"), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      authPasswdChg(prompt) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        let promptLen = Buffer.byteLength(prompt), p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(5 + promptLen + 4);
        packet[p] = MESSAGE.USERAUTH_PASSWD_CHANGEREQ, writeUInt32BE(packet, promptLen, ++p), packet.utf8Write(prompt, p += 4, promptLen), writeUInt32BE(packet, 0, p += promptLen), this._debug && this._debug("Outbound: Sending USERAUTH_PASSWD_CHANGEREQ"), sendPacket(this, this._packetRW.write.finalize(packet));
      }
      authInfoReq(name2, instructions, prompts) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        let promptsLen = 0, nameLen = name2 ? Buffer.byteLength(name2) : 0, instrLen = instructions ? Buffer.byteLength(instructions) : 0;
        for (let i = 0; i < prompts.length; ++i)
          promptsLen += 4 + Buffer.byteLength(prompts[i].prompt) + 1;
        let p = this._packetRW.write.allocStart, packet = this._packetRW.write.alloc(
          5 + nameLen + 4 + instrLen + 4 + 4 + promptsLen
        );
        packet[p] = MESSAGE.USERAUTH_INFO_REQUEST, writeUInt32BE(packet, nameLen, ++p), p += 4, name2 && (packet.utf8Write(name2, p, nameLen), p += nameLen), writeUInt32BE(packet, instrLen, p), p += 4, instructions && (packet.utf8Write(instructions, p, instrLen), p += instrLen), writeUInt32BE(packet, 0, p), writeUInt32BE(packet, prompts.length, p += 4), p += 4;
        for (let i = 0; i < prompts.length; ++i) {
          let prompt = prompts[i], promptLen = Buffer.byteLength(prompt.prompt);
          writeUInt32BE(packet, promptLen, p), p += 4, promptLen && (packet.utf8Write(prompt.prompt, p, promptLen), p += promptLen), packet[p++] = prompt.echo ? 1 : 0;
        }
        this._debug && this._debug("Outbound: Sending USERAUTH_INFO_REQUEST"), sendPacket(this, this._packetRW.write.finalize(packet));
      }
    }, RE_IDENT = /^SSH-(2\.0|1\.99)-([^ ]+)(?: (.*))?$/;
    function parseHeader(chunk, p, len) {
      let data, chunkOffset;
      this._buffer ? (data = Buffer.allocUnsafe(this._buffer.length + (len - p)), data.set(this._buffer, 0), p === 0 ? data.set(chunk, this._buffer.length) : data.set(
        new Uint8Array(
          chunk.buffer,
          chunk.byteOffset + p,
          len - p
        ),
        this._buffer.length
      ), chunkOffset = this._buffer.length, p = 0) : (data = chunk, chunkOffset = 0);
      let op = p, start = p, end = p, needNL = !1, lineLen = 0, lines = 0;
      for (; p < data.length; ++p) {
        let ch = data[p];
        if (ch === 13) {
          needNL = !0;
          continue;
        }
        if (ch === 10) {
          if (end > start && end - start > 4 && data[start] === 83 && data[start + 1] === 83 && data[start + 2] === 72 && data[start + 3] === 45) {
            let full = data.latin1Slice(op, end + 1), identRaw = start === op ? full : full.slice(start - op), m = RE_IDENT.exec(identRaw);
            if (!m)
              throw new Error("Invalid identification string");
            let header = {
              greeting: start === op ? "" : full.slice(0, start - op),
              identRaw,
              versions: {
                protocol: m[1],
                software: m[2]
              },
              comments: m[3]
            };
            return this._remoteIdentRaw = Buffer.from(identRaw), this._debug && this._debug(`Remote ident: ${inspect(identRaw)}`), this._compatFlags = getCompatFlags(header), this._buffer = void 0, this._decipher = new NullDecipher(0, onKEXPayload.bind(this, { firstPacket: !0 })), this._parse = parsePacket, this._onHeader(header), this._destruct ? (kexinit(this), p + 1 - chunkOffset) : len;
          }
          if (this._server)
            throw new Error("Greetings from clients not permitted");
          if (++lines > MAX_LINES)
            throw new Error("Max greeting lines exceeded");
          needNL = !1, start = p + 1, lineLen = 0;
        } else {
          if (needNL)
            throw new Error("Invalid header: expected newline");
          if (++lineLen >= MAX_LINE_LEN)
            throw new Error("Header line too long");
        }
        end = p;
      }
      return this._buffer || (this._buffer = bufferSlice(data, op)), p - chunkOffset;
    }
    function parsePacket(chunk, p, len) {
      return this._decipher.decrypt(chunk, p, len);
    }
    function onPayload(payload) {
      if (this._onPacket(), payload.length === 0) {
        this._debug && this._debug("Inbound: Skipping empty packet payload");
        return;
      }
      payload = this._packetRW.read.read(payload);
      let type = payload[0];
      type === MESSAGE.USERAUTH_SUCCESS && !this._server && !this._authenticated && (this._authenticated = !0, this._kex.negotiated.cs.compress === "zlib@openssh.com" && (this._packetRW.write = new ZlibPacketWriter(this)), this._kex.negotiated.sc.compress === "zlib@openssh.com" && (this._packetRW.read = new ZlibPacketReader()));
      let handler = MESSAGE_HANDLERS[type];
      if (handler === void 0) {
        this._debug && this._debug(`Inbound: Unsupported message type: ${type}`);
        return;
      }
      return handler(this, payload);
    }
    function getCompatFlags(header) {
      let software = header.versions.software, flags = 0;
      for (let rule of COMPAT_CHECKS)
        typeof rule[0] == "string" ? software === rule[0] && (flags |= rule[1]) : rule[0].test(software) && (flags |= rule[1]);
      return flags;
    }
    function modesToBytes(modes) {
      let keys = Object.keys(modes), bytes = Buffer.allocUnsafe(5 * keys.length + 1), b = 0;
      for (let i = 0; i < keys.length; ++i) {
        let key = keys[i];
        if (key === "TTY_OP_END")
          continue;
        let opcode = TERMINAL_MODE[key];
        if (opcode === void 0)
          continue;
        let val = modes[key];
        typeof val == "number" && isFinite(val) && (bytes[b++] = opcode, bytes[b++] = val >>> 24, bytes[b++] = val >>> 16, bytes[b++] = val >>> 8, bytes[b++] = val);
      }
      return bytes[b++] = TERMINAL_MODE.TTY_OP_END, b < bytes.length ? bufferSlice(bytes, 0, b) : bytes;
    }
    function sendExtInfo(proto) {
      let serverSigAlgs = "ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521rsa-sha2-512,rsa-sha2-256,ssh-rsa,ssh-dss";
      eddsaSupported && (serverSigAlgs = `ssh-ed25519,${serverSigAlgs}`);
      let algsLen = Buffer.byteLength(serverSigAlgs), p = proto._packetRW.write.allocStart, packet = proto._packetRW.write.alloc(28 + algsLen);
      packet[p] = MESSAGE.EXT_INFO, writeUInt32BE(packet, 1, ++p), writeUInt32BE(packet, 15, p += 4), packet.utf8Write("server-sig-algs", p += 4, 15), writeUInt32BE(packet, algsLen, p += 15), packet.utf8Write(serverSigAlgs, p += 4, algsLen), proto._debug && proto._debug("Outbound: Sending EXT_INFO"), sendPacket(proto, proto._packetRW.write.finalize(packet));
    }
    module2.exports = Protocol;
  }
});

// node_modules/ssh2/lib/protocol/node-fs-compat.js
var require_node_fs_compat = __commonJS({
  "node_modules/ssh2/lib/protocol/node-fs-compat.js"(exports2) {
    "use strict";
    var assert3 = require("assert"), { inspect } = require("util");
    function addNumericalSeparator(val) {
      let res = "", i = val.length, start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3)
        res = `_${val.slice(i - 3, i)}${res}`;
      return `${val.slice(0, i)}${res}`;
    }
    function oneOf(expected, thing) {
      if (assert3(typeof thing == "string", "`thing` has to be of type string"), Array.isArray(expected)) {
        let len = expected.length;
        return assert3(len > 0, "At least one expected value needs to be specified"), expected = expected.map((i) => String(i)), len > 2 ? `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1] : len === 2 ? `one of ${thing} ${expected[0]} or ${expected[1]}` : `of ${thing} ${expected[0]}`;
      }
      return `of ${thing} ${String(expected)}`;
    }
    exports2.ERR_INTERNAL_ASSERTION = class ERR_INTERNAL_ASSERTION extends Error {
      constructor(message) {
        super(), Error.captureStackTrace(this, ERR_INTERNAL_ASSERTION);
        let suffix = `This is caused by either a bug in ssh2 or incorrect usage of ssh2 internals.
Please open an issue with this stack trace at https://github.com/mscdex/ssh2/issues
`;
        this.message = message === void 0 ? suffix : `${message}
${suffix}`;
      }
    };
    var MAX_32BIT_INT = 2 ** 32, MAX_32BIT_BIGINT = (() => {
      try {
        return new Function("return 2n ** 32n")();
      } catch {
      }
    })();
    exports2.ERR_OUT_OF_RANGE = class ERR_OUT_OF_RANGE extends RangeError {
      constructor(str, range, input, replaceDefaultBoolean) {
        super(), Error.captureStackTrace(this, ERR_OUT_OF_RANGE), assert3(range, 'Missing "range" argument');
        let msg = replaceDefaultBoolean ? str : `The value of "${str}" is out of range.`, received;
        Number.isInteger(input) && Math.abs(input) > MAX_32BIT_INT ? received = addNumericalSeparator(String(input)) : typeof input == "bigint" ? (received = String(input), (input > MAX_32BIT_BIGINT || input < -MAX_32BIT_BIGINT) && (received = addNumericalSeparator(received)), received += "n") : received = inspect(input), msg += ` It must be ${range}. Received ${received}`, this.message = msg;
      }
    };
    var ERR_INVALID_ARG_TYPE = class _ERR_INVALID_ARG_TYPE extends TypeError {
      constructor(name2, expected, actual) {
        super(), Error.captureStackTrace(this, _ERR_INVALID_ARG_TYPE), assert3(typeof name2 == "string", "'name' must be a string");
        let determiner;
        typeof expected == "string" && expected.startsWith("not ") ? (determiner = "must not be", expected = expected.replace(/^not /, "")) : determiner = "must be";
        let msg;
        if (name2.endsWith(" argument"))
          msg = `The ${name2} ${determiner} ${oneOf(expected, "type")}`;
        else {
          let type = name2.includes(".") ? "property" : "argument";
          msg = `The "${name2}" ${type} ${determiner} ${oneOf(expected, "type")}`;
        }
        msg += `. Received type ${typeof actual}`, this.message = msg;
      }
    };
    exports2.ERR_INVALID_ARG_TYPE = ERR_INVALID_ARG_TYPE;
    exports2.validateNumber = function(value, name2) {
      if (typeof value != "number")
        throw new ERR_INVALID_ARG_TYPE(name2, "number", value);
    };
  }
});

// node_modules/ssh2/lib/protocol/SFTP.js
var require_SFTP = __commonJS({
  "node_modules/ssh2/lib/protocol/SFTP.js"(exports2, module2) {
    "use strict";
    var EventEmitter2 = require("events"), fs11 = require("fs"), { constants: constants2 } = fs11, {
      Readable: ReadableStream,
      Writable: WritableStream
    } = require("stream"), { inherits, types: { isDate } } = require("util"), FastBuffer = Buffer[Symbol.species], {
      bufferCopy,
      bufferSlice,
      makeBufferParser,
      writeUInt32BE
    } = require_utils5(), ATTR = {
      SIZE: 1,
      UIDGID: 2,
      PERMISSIONS: 4,
      ACMODTIME: 8,
      EXTENDED: 2147483648
    }, ATTRS_BUF = Buffer.alloc(28), STATUS_CODE = {
      OK: 0,
      EOF: 1,
      NO_SUCH_FILE: 2,
      PERMISSION_DENIED: 3,
      FAILURE: 4,
      BAD_MESSAGE: 5,
      NO_CONNECTION: 6,
      CONNECTION_LOST: 7,
      OP_UNSUPPORTED: 8
    }, VALID_STATUS_CODES = new Map(
      Object.values(STATUS_CODE).map((n) => [n, 1])
    ), STATUS_CODE_STR = {
      [STATUS_CODE.OK]: "No error",
      [STATUS_CODE.EOF]: "End of file",
      [STATUS_CODE.NO_SUCH_FILE]: "No such file or directory",
      [STATUS_CODE.PERMISSION_DENIED]: "Permission denied",
      [STATUS_CODE.FAILURE]: "Failure",
      [STATUS_CODE.BAD_MESSAGE]: "Bad message",
      [STATUS_CODE.NO_CONNECTION]: "No connection",
      [STATUS_CODE.CONNECTION_LOST]: "Connection lost",
      [STATUS_CODE.OP_UNSUPPORTED]: "Operation unsupported"
    }, REQUEST = {
      INIT: 1,
      OPEN: 3,
      CLOSE: 4,
      READ: 5,
      WRITE: 6,
      LSTAT: 7,
      FSTAT: 8,
      SETSTAT: 9,
      FSETSTAT: 10,
      OPENDIR: 11,
      READDIR: 12,
      REMOVE: 13,
      MKDIR: 14,
      RMDIR: 15,
      REALPATH: 16,
      STAT: 17,
      RENAME: 18,
      READLINK: 19,
      SYMLINK: 20,
      EXTENDED: 200
    }, RESPONSE = {
      VERSION: 2,
      STATUS: 101,
      HANDLE: 102,
      DATA: 103,
      NAME: 104,
      ATTRS: 105,
      EXTENDED: 201
    }, OPEN_MODE = {
      READ: 1,
      WRITE: 2,
      APPEND: 4,
      CREAT: 8,
      TRUNC: 16,
      EXCL: 32
    }, PKT_RW_OVERHEAD = 2 * 1024, MAX_REQID = 2 ** 32 - 1, CLIENT_VERSION_BUFFER = Buffer.from([
      0,
      0,
      0,
      5,
      REQUEST.INIT,
      0,
      0,
      0,
      3
      /* version */
    ]), SERVER_VERSION_BUFFER = Buffer.from([
      0,
      0,
      0,
      5,
      RESPONSE.VERSION,
      0,
      0,
      0,
      3
      /* version */
    ]), RE_OPENSSH = /^SSH-2.0-(?:OpenSSH|dropbear)/, OPENSSH_MAX_PKT_LEN = 256 * 1024, bufferParser = makeBufferParser(), fakeStderr = {
      readable: !1,
      writable: !1,
      push: (data) => {
      },
      once: () => {
      },
      on: () => {
      },
      emit: () => {
      },
      end: () => {
      }
    };
    function noop2() {
    }
    var SFTP = class extends EventEmitter2 {
      constructor(client, chanInfo, cfg) {
        super(), (typeof cfg != "object" || !cfg) && (cfg = {});
        let remoteIdentRaw = client._protocol._remoteIdentRaw;
        this.server = !!cfg.server, this._debug = typeof cfg.debug == "function" ? cfg.debug : void 0, this._isOpenSSH = remoteIdentRaw && RE_OPENSSH.test(remoteIdentRaw), this._version = -1, this._extensions = {}, this._biOpt = cfg.biOpt, this._pktLenBytes = 0, this._pktLen = 0, this._pktPos = 0, this._pktType = 0, this._pktData = void 0, this._writeReqid = -1, this._requests = {}, this._maxInPktLen = OPENSSH_MAX_PKT_LEN, this._maxOutPktLen = 34e3, this._maxReadLen = (this._isOpenSSH ? OPENSSH_MAX_PKT_LEN : 34e3) - PKT_RW_OVERHEAD, this._maxWriteLen = (this._isOpenSSH ? OPENSSH_MAX_PKT_LEN : 34e3) - PKT_RW_OVERHEAD, this.maxOpenHandles = void 0, this._client = client, this._protocol = client._protocol, this._callbacks = [], this._hasX11 = !1, this._exit = {
          code: void 0,
          signal: void 0,
          dump: void 0,
          desc: void 0
        }, this._waitWindow = !1, this._chunkcb = void 0, this._buffer = [], this.type = chanInfo.type, this.subtype = void 0, this.incoming = chanInfo.incoming, this.outgoing = chanInfo.outgoing, this.stderr = fakeStderr, this.readable = !0;
      }
      // This handles incoming data to parse
      push(data) {
        if (data === null) {
          if (cleanupRequests(this), !this.readable)
            return;
          this.readable = !1, this.emit("end");
          return;
        }
        let p = 0;
        for (; p < data.length; ) {
          if (this._pktLenBytes < 4) {
            let nb = Math.min(4 - this._pktLenBytes, data.length - p);
            for (this._pktLenBytes += nb; nb--; )
              this._pktLen = (this._pktLen << 8) + data[p++];
            if (this._pktLenBytes < 4)
              return;
            if (this._pktLen === 0)
              return doFatalSFTPError(this, "Invalid packet length");
            if (this._pktLen > this._maxInPktLen) {
              let max = this._maxInPktLen;
              return doFatalSFTPError(
                this,
                `Packet length ${this._pktLen} exceeds max length of ${max}`
              );
            }
            if (p >= data.length)
              return;
          }
          if (this._pktPos < this._pktLen) {
            let nb = Math.min(this._pktLen - this._pktPos, data.length - p);
            if (p !== 0 || nb !== data.length ? nb === this._pktLen ? this._pkt = new FastBuffer(data.buffer, data.byteOffset + p, nb) : (this._pkt || (this._pkt = Buffer.allocUnsafe(this._pktLen)), this._pkt.set(
              new Uint8Array(data.buffer, data.byteOffset + p, nb),
              this._pktPos
            )) : nb === this._pktLen ? this._pkt = data : (this._pkt || (this._pkt = Buffer.allocUnsafe(this._pktLen)), this._pkt.set(data, this._pktPos)), p += nb, this._pktPos += nb, this._pktPos < this._pktLen)
              return;
          }
          let type = this._pkt[0], payload = this._pkt;
          this._pktLen = 0, this._pktLenBytes = 0, this._pkt = void 0, this._pktPos = 0;
          let handler = this.server ? SERVER_HANDLERS[type] : CLIENT_HANDLERS[type];
          if (!handler)
            return doFatalSFTPError(this, `Unknown packet type ${type}`);
          if (this._version === -1) {
            if (this.server) {
              if (type !== REQUEST.INIT)
                return doFatalSFTPError(this, `Expected INIT packet, got ${type}`);
            } else if (type !== RESPONSE.VERSION)
              return doFatalSFTPError(this, `Expected VERSION packet, got ${type}`);
          }
          if (handler(this, payload) === !1)
            return;
        }
      }
      end() {
        this.destroy();
      }
      destroy() {
        (this.outgoing.state === "open" || this.outgoing.state === "eof") && (this.outgoing.state = "closing", this._protocol.channelClose(this.outgoing.id));
      }
      _init() {
        this._init = noop2, this.server || sendOrBuffer(this, CLIENT_VERSION_BUFFER);
      }
      // ===========================================================================
      // Client-specific ===========================================================
      // ===========================================================================
      createReadStream(path8, options) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        return new ReadStream2(this, path8, options);
      }
      createWriteStream(path8, options) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        return new WriteStream2(this, path8, options);
      }
      open(path8, flags_, attrs, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        typeof attrs == "function" && (cb = attrs, attrs = void 0);
        let flags = typeof flags_ == "number" ? flags_ : stringToFlags(flags_);
        if (flags === null)
          throw new Error(`Unknown flags string: ${flags_}`);
        let attrsFlags = 0, attrsLen = 0;
        (typeof attrs == "string" || typeof attrs == "number") && (attrs = { mode: attrs }), typeof attrs == "object" && attrs !== null && (attrs = attrsToBytes(attrs), attrsFlags = attrs.flags, attrsLen = attrs.nb);
        let pathLen = Buffer.byteLength(path8), p = 9, buf = Buffer.allocUnsafe(13 + pathLen + 4 + 4 + attrsLen);
        writeUInt32BE(buf, buf.length - 4, 0), buf[4] = REQUEST.OPEN;
        let reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5), writeUInt32BE(buf, pathLen, p), buf.utf8Write(path8, p += 4, pathLen), writeUInt32BE(buf, flags, p += pathLen), writeUInt32BE(buf, attrsFlags, p += 4), attrsLen && (p += 4, attrsLen === ATTRS_BUF.length ? buf.set(ATTRS_BUF, p) : bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p), p += attrsLen), this._requests[reqid] = { cb };
        let isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} OPEN`
        );
      }
      close(handle, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (!Buffer.isBuffer(handle))
          throw new Error("handle is not a Buffer");
        let handleLen = handle.length, p = 9, buf = Buffer.allocUnsafe(13 + handleLen);
        writeUInt32BE(buf, buf.length - 4, 0), buf[4] = REQUEST.CLOSE;
        let reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5), writeUInt32BE(buf, handleLen, p), buf.set(handle, p += 4), this._requests[reqid] = { cb };
        let isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} CLOSE`
        );
      }
      read(handle, buf, off, len, position, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (!Buffer.isBuffer(handle))
          throw new Error("handle is not a Buffer");
        if (!Buffer.isBuffer(buf))
          throw new Error("buffer is not a Buffer");
        if (off >= buf.length)
          throw new Error("offset is out of bounds");
        if (off + len > buf.length)
          throw new Error("length extends beyond buffer");
        if (position === null)
          throw new Error("null position currently unsupported");
        read_(this, handle, buf, off, len, position, cb);
      }
      readData(handle, buf, off, len, position, cb) {
        this.read(handle, buf, off, len, position, cb);
      }
      write(handle, buf, off, len, position, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (!Buffer.isBuffer(handle))
          throw new Error("handle is not a Buffer");
        if (!Buffer.isBuffer(buf))
          throw new Error("buffer is not a Buffer");
        if (off > buf.length)
          throw new Error("offset is out of bounds");
        if (off + len > buf.length)
          throw new Error("length extends beyond buffer");
        if (position === null)
          throw new Error("null position currently unsupported");
        if (!len) {
          cb && process.nextTick(cb, void 0, 0);
          return;
        }
        let maxDataLen = this._maxWriteLen, overflow = Math.max(len - maxDataLen, 0), origPosition = position;
        overflow && (len = maxDataLen);
        let handleLen = handle.length, p = 9, out = Buffer.allocUnsafe(13 + handleLen + 8 + 4 + len);
        writeUInt32BE(out, out.length - 4, 0), out[4] = REQUEST.WRITE;
        let reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(out, reqid, 5), writeUInt32BE(out, handleLen, p), out.set(handle, p += 4), p += handleLen;
        for (let i = 7; i >= 0; --i)
          out[p + i] = position & 255, position /= 256;
        writeUInt32BE(out, len, p += 8), bufferCopy(buf, out, off, off + len, p += 4), this._requests[reqid] = {
          cb: (err) => {
            err ? typeof cb == "function" && cb(err) : overflow ? this.write(
              handle,
              buf,
              off + len,
              overflow,
              origPosition + len,
              cb
            ) : typeof cb == "function" && cb(void 0, off + len);
          }
        };
        let isSent = sendOrBuffer(this, out);
        if (this._debug) {
          let how = isSent ? "Sent" : "Buffered";
          this._debug(`SFTP: Outbound: ${how} WRITE (id:${reqid})`);
        }
      }
      writeData(handle, buf, off, len, position, cb) {
        this.write(handle, buf, off, len, position, cb);
      }
      fastGet(remotePath, localPath, opts, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        fastXfer(this, fs11, remotePath, localPath, opts, cb);
      }
      fastPut(localPath, remotePath, opts, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        fastXfer(fs11, this, localPath, remotePath, opts, cb);
      }
      readFile(path8, options, callback_) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        let callback;
        if (typeof callback_ == "function" ? callback = callback_ : typeof options == "function" && (callback = options, options = void 0), typeof options == "string")
          options = { encoding: options, flag: "r" };
        else if (!options)
          options = { encoding: null, flag: "r" };
        else if (typeof options != "object")
          throw new TypeError("Bad arguments");
        let encoding = options.encoding;
        if (encoding && !Buffer.isEncoding(encoding))
          throw new Error(`Unknown encoding: ${encoding}`);
        let size, buffer, buffers, pos2 = 0, handle, bytesRead = 0, flag = options.flag || "r", read = () => {
          size === 0 ? (buffer = Buffer.allocUnsafe(8192), this.read(handle, buffer, 0, 8192, bytesRead, afterRead)) : this.read(handle, buffer, pos2, size - pos2, bytesRead, afterRead);
        }, afterRead = (er, nbytes) => {
          let eof;
          if (er) {
            if (eof = er.code === STATUS_CODE.EOF, !eof)
              return this.close(handle, () => callback && callback(er));
          } else
            eof = !1;
          if (eof || size === 0 && nbytes === 0)
            return close();
          bytesRead += nbytes, pos2 += nbytes, size !== 0 ? pos2 === size ? close() : read() : (buffers.push(bufferSlice(buffer, 0, nbytes)), read());
        };
        afterRead._wantEOFError = !0;
        let close = () => {
          this.close(handle, (er) => (size === 0 ? buffer = Buffer.concat(buffers, pos2) : pos2 < size && (buffer = bufferSlice(buffer, 0, pos2)), encoding && (buffer = buffer.toString(encoding)), callback && callback(er, buffer)));
        };
        this.open(path8, flag, 438, (er, handle_) => {
          if (er)
            return callback && callback(er);
          handle = handle_;
          let tryStat = (er2, st) => {
            if (er2) {
              this.stat(path8, (er_, st_) => {
                if (er_)
                  return this.close(handle, () => {
                    callback && callback(er2);
                  });
                tryStat(null, st_);
              });
              return;
            }
            if (size = st.size || 0, size === 0)
              return buffers = [], read();
            buffer = Buffer.allocUnsafe(size), read();
          };
          this.fstat(handle, tryStat);
        });
      }
      writeFile(path8, data, options, callback_) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        let callback;
        if (typeof callback_ == "function" ? callback = callback_ : typeof options == "function" && (callback = options, options = void 0), typeof options == "string")
          options = { encoding: options, mode: 438, flag: "w" };
        else if (!options)
          options = { encoding: "utf8", mode: 438, flag: "w" };
        else if (typeof options != "object")
          throw new TypeError("Bad arguments");
        if (options.encoding && !Buffer.isEncoding(options.encoding))
          throw new Error(`Unknown encoding: ${options.encoding}`);
        let flag = options.flag || "w";
        this.open(path8, flag, options.mode, (openErr, handle) => {
          if (openErr)
            callback && callback(openErr);
          else {
            let buffer = Buffer.isBuffer(data) ? data : Buffer.from("" + data, options.encoding || "utf8"), position = /a/.test(flag) ? null : 0;
            if (position === null) {
              let tryStat = (er, st) => {
                if (er) {
                  this.stat(path8, (er_, st_) => {
                    if (er_)
                      return this.close(handle, () => {
                        callback && callback(er);
                      });
                    tryStat(null, st_);
                  });
                  return;
                }
                writeAll(this, handle, buffer, 0, buffer.length, st.size, callback);
              };
              this.fstat(handle, tryStat);
              return;
            }
            writeAll(this, handle, buffer, 0, buffer.length, position, callback);
          }
        });
      }
      appendFile(path8, data, options, callback_) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        let callback;
        if (typeof callback_ == "function" ? callback = callback_ : typeof options == "function" && (callback = options, options = void 0), typeof options == "string")
          options = { encoding: options, mode: 438, flag: "a" };
        else if (!options)
          options = { encoding: "utf8", mode: 438, flag: "a" };
        else if (typeof options != "object")
          throw new TypeError("Bad arguments");
        options.flag || (options = Object.assign({ flag: "a" }, options)), this.writeFile(path8, data, options, callback);
      }
      exists(path8, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        this.stat(path8, (err) => {
          cb && cb(!err);
        });
      }
      unlink(filename, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        let fnameLen = Buffer.byteLength(filename), p = 9, buf = Buffer.allocUnsafe(13 + fnameLen);
        writeUInt32BE(buf, buf.length - 4, 0), buf[4] = REQUEST.REMOVE;
        let reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5), writeUInt32BE(buf, fnameLen, p), buf.utf8Write(filename, p += 4, fnameLen), this._requests[reqid] = { cb };
        let isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} REMOVE`
        );
      }
      rename(oldPath, newPath, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        let oldLen = Buffer.byteLength(oldPath), newLen = Buffer.byteLength(newPath), p = 9, buf = Buffer.allocUnsafe(13 + oldLen + 4 + newLen);
        writeUInt32BE(buf, buf.length - 4, 0), buf[4] = REQUEST.RENAME;
        let reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5), writeUInt32BE(buf, oldLen, p), buf.utf8Write(oldPath, p += 4, oldLen), writeUInt32BE(buf, newLen, p += oldLen), buf.utf8Write(newPath, p += 4, newLen), this._requests[reqid] = { cb };
        let isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} RENAME`
        );
      }
      mkdir(path8, attrs, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        let flags = 0, attrsLen = 0;
        typeof attrs == "function" && (cb = attrs, attrs = void 0), typeof attrs == "object" && attrs !== null && (attrs = attrsToBytes(attrs), flags = attrs.flags, attrsLen = attrs.nb);
        let pathLen = Buffer.byteLength(path8), p = 9, buf = Buffer.allocUnsafe(13 + pathLen + 4 + attrsLen);
        writeUInt32BE(buf, buf.length - 4, 0), buf[4] = REQUEST.MKDIR;
        let reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5), writeUInt32BE(buf, pathLen, p), buf.utf8Write(path8, p += 4, pathLen), writeUInt32BE(buf, flags, p += pathLen), attrsLen && (p += 4, attrsLen === ATTRS_BUF.length ? buf.set(ATTRS_BUF, p) : bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p), p += attrsLen), this._requests[reqid] = { cb };
        let isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} MKDIR`
        );
      }
      rmdir(path8, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        let pathLen = Buffer.byteLength(path8), p = 9, buf = Buffer.allocUnsafe(13 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0), buf[4] = REQUEST.RMDIR;
        let reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5), writeUInt32BE(buf, pathLen, p), buf.utf8Write(path8, p += 4, pathLen), this._requests[reqid] = { cb };
        let isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} RMDIR`
        );
      }
      readdir(where, opts, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        typeof opts == "function" && (cb = opts, opts = {}), (typeof opts != "object" || opts === null) && (opts = {});
        let doFilter = !(opts && opts.full);
        if (!Buffer.isBuffer(where) && typeof where != "string")
          throw new Error("missing directory handle or path");
        if (typeof where == "string") {
          let entries = [], e = 0, reread = (err, handle) => {
            if (err)
              return cb(err);
            this.readdir(handle, opts, (err2, list2) => {
              let eof = err2 && err2.code === STATUS_CODE.EOF;
              if (err2 && !eof)
                return this.close(handle, () => cb(err2));
              if (eof)
                return this.close(handle, (err3) => {
                  if (err3)
                    return cb(err3);
                  cb(void 0, entries);
                });
              for (let i = 0; i < list2.length; ++i, ++e)
                entries[e] = list2[i];
              reread(void 0, handle);
            });
          };
          return this.opendir(where, reread);
        }
        let handleLen = where.length, p = 9, buf = Buffer.allocUnsafe(13 + handleLen);
        writeUInt32BE(buf, buf.length - 4, 0), buf[4] = REQUEST.READDIR;
        let reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5), writeUInt32BE(buf, handleLen, p), buf.set(where, p += 4), this._requests[reqid] = {
          cb: doFilter ? (err, list2) => {
            if (typeof cb == "function") {
              if (err)
                return cb(err);
              for (let i = list2.length - 1; i >= 0; --i)
                (list2[i].filename === "." || list2[i].filename === "..") && list2.splice(i, 1);
              cb(void 0, list2);
            }
          } : cb
        };
        let isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} READDIR`
        );
      }
      fstat(handle, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (!Buffer.isBuffer(handle))
          throw new Error("handle is not a Buffer");
        let handleLen = handle.length, p = 9, buf = Buffer.allocUnsafe(13 + handleLen);
        writeUInt32BE(buf, buf.length - 4, 0), buf[4] = REQUEST.FSTAT;
        let reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5), writeUInt32BE(buf, handleLen, p), buf.set(handle, p += 4), this._requests[reqid] = { cb };
        let isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} FSTAT`
        );
      }
      stat(path8, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        let pathLen = Buffer.byteLength(path8), p = 9, buf = Buffer.allocUnsafe(13 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0), buf[4] = REQUEST.STAT;
        let reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5), writeUInt32BE(buf, pathLen, p), buf.utf8Write(path8, p += 4, pathLen), this._requests[reqid] = { cb };
        let isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} STAT`
        );
      }
      lstat(path8, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        let pathLen = Buffer.byteLength(path8), p = 9, buf = Buffer.allocUnsafe(13 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0), buf[4] = REQUEST.LSTAT;
        let reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5), writeUInt32BE(buf, pathLen, p), buf.utf8Write(path8, p += 4, pathLen), this._requests[reqid] = { cb };
        let isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} LSTAT`
        );
      }
      opendir(path8, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        let pathLen = Buffer.byteLength(path8), p = 9, buf = Buffer.allocUnsafe(13 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0), buf[4] = REQUEST.OPENDIR;
        let reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5), writeUInt32BE(buf, pathLen, p), buf.utf8Write(path8, p += 4, pathLen), this._requests[reqid] = { cb };
        let isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} OPENDIR`
        );
      }
      setstat(path8, attrs, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        let flags = 0, attrsLen = 0;
        typeof attrs == "object" && attrs !== null ? (attrs = attrsToBytes(attrs), flags = attrs.flags, attrsLen = attrs.nb) : typeof attrs == "function" && (cb = attrs);
        let pathLen = Buffer.byteLength(path8), p = 9, buf = Buffer.allocUnsafe(13 + pathLen + 4 + attrsLen);
        writeUInt32BE(buf, buf.length - 4, 0), buf[4] = REQUEST.SETSTAT;
        let reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5), writeUInt32BE(buf, pathLen, p), buf.utf8Write(path8, p += 4, pathLen), writeUInt32BE(buf, flags, p += pathLen), attrsLen && (p += 4, attrsLen === ATTRS_BUF.length ? buf.set(ATTRS_BUF, p) : bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p), p += attrsLen), this._requests[reqid] = { cb };
        let isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} SETSTAT`
        );
      }
      fsetstat(handle, attrs, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (!Buffer.isBuffer(handle))
          throw new Error("handle is not a Buffer");
        let flags = 0, attrsLen = 0;
        typeof attrs == "object" && attrs !== null ? (attrs = attrsToBytes(attrs), flags = attrs.flags, attrsLen = attrs.nb) : typeof attrs == "function" && (cb = attrs);
        let handleLen = handle.length, p = 9, buf = Buffer.allocUnsafe(13 + handleLen + 4 + attrsLen);
        writeUInt32BE(buf, buf.length - 4, 0), buf[4] = REQUEST.FSETSTAT;
        let reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5), writeUInt32BE(buf, handleLen, p), buf.set(handle, p += 4), writeUInt32BE(buf, flags, p += handleLen), attrsLen && (p += 4, attrsLen === ATTRS_BUF.length ? buf.set(ATTRS_BUF, p) : bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p), p += attrsLen), this._requests[reqid] = { cb };
        let isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} FSETSTAT`
        );
      }
      futimes(handle, atime, mtime, cb) {
        return this.fsetstat(handle, {
          atime: toUnixTimestamp(atime),
          mtime: toUnixTimestamp(mtime)
        }, cb);
      }
      utimes(path8, atime, mtime, cb) {
        return this.setstat(path8, {
          atime: toUnixTimestamp(atime),
          mtime: toUnixTimestamp(mtime)
        }, cb);
      }
      fchown(handle, uid, gid, cb) {
        return this.fsetstat(handle, {
          uid,
          gid
        }, cb);
      }
      chown(path8, uid, gid, cb) {
        return this.setstat(path8, {
          uid,
          gid
        }, cb);
      }
      fchmod(handle, mode, cb) {
        return this.fsetstat(handle, {
          mode
        }, cb);
      }
      chmod(path8, mode, cb) {
        return this.setstat(path8, {
          mode
        }, cb);
      }
      readlink(path8, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        let pathLen = Buffer.byteLength(path8), p = 9, buf = Buffer.allocUnsafe(13 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0), buf[4] = REQUEST.READLINK;
        let reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5), writeUInt32BE(buf, pathLen, p), buf.utf8Write(path8, p += 4, pathLen), this._requests[reqid] = {
          cb: (err, names) => {
            if (typeof cb == "function") {
              if (err)
                return cb(err);
              if (!names || !names.length)
                return cb(new Error("Response missing link info"));
              cb(void 0, names[0].filename);
            }
          }
        };
        let isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} READLINK`
        );
      }
      symlink(targetPath, linkPath, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        let linkLen = Buffer.byteLength(linkPath), targetLen = Buffer.byteLength(targetPath), p = 9, buf = Buffer.allocUnsafe(13 + linkLen + 4 + targetLen);
        writeUInt32BE(buf, buf.length - 4, 0), buf[4] = REQUEST.SYMLINK;
        let reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5), this._isOpenSSH ? (writeUInt32BE(buf, targetLen, p), buf.utf8Write(targetPath, p += 4, targetLen), writeUInt32BE(buf, linkLen, p += targetLen), buf.utf8Write(linkPath, p += 4, linkLen)) : (writeUInt32BE(buf, linkLen, p), buf.utf8Write(linkPath, p += 4, linkLen), writeUInt32BE(buf, targetLen, p += linkLen), buf.utf8Write(targetPath, p += 4, targetLen)), this._requests[reqid] = { cb };
        let isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} SYMLINK`
        );
      }
      realpath(path8, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        let pathLen = Buffer.byteLength(path8), p = 9, buf = Buffer.allocUnsafe(13 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0), buf[4] = REQUEST.REALPATH;
        let reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5), writeUInt32BE(buf, pathLen, p), buf.utf8Write(path8, p += 4, pathLen), this._requests[reqid] = {
          cb: (err, names) => {
            if (typeof cb == "function") {
              if (err)
                return cb(err);
              if (!names || !names.length)
                return cb(new Error("Response missing path info"));
              cb(void 0, names[0].filename);
            }
          }
        };
        let isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} REALPATH`
        );
      }
      // extended requests
      ext_openssh_rename(oldPath, newPath, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        let ext = this._extensions["posix-rename@openssh.com"];
        if (!ext || ext !== "1")
          throw new Error("Server does not support this extended request");
        let oldLen = Buffer.byteLength(oldPath), newLen = Buffer.byteLength(newPath), p = 9, buf = Buffer.allocUnsafe(41 + oldLen + 4 + newLen);
        writeUInt32BE(buf, buf.length - 4, 0), buf[4] = REQUEST.EXTENDED;
        let reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5), writeUInt32BE(buf, 24, p), buf.utf8Write("posix-rename@openssh.com", p += 4, 24), writeUInt32BE(buf, oldLen, p += 24), buf.utf8Write(oldPath, p += 4, oldLen), writeUInt32BE(buf, newLen, p += oldLen), buf.utf8Write(newPath, p += 4, newLen), this._requests[reqid] = { cb };
        let isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          let which = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${which} posix-rename@openssh.com`);
        }
      }
      ext_openssh_statvfs(path8, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        let ext = this._extensions["statvfs@openssh.com"];
        if (!ext || ext !== "2")
          throw new Error("Server does not support this extended request");
        let pathLen = Buffer.byteLength(path8), p = 9, buf = Buffer.allocUnsafe(36 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0), buf[4] = REQUEST.EXTENDED;
        let reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5), writeUInt32BE(buf, 19, p), buf.utf8Write("statvfs@openssh.com", p += 4, 19), writeUInt32BE(buf, pathLen, p += 19), buf.utf8Write(path8, p += 4, pathLen), this._requests[reqid] = { extended: "statvfs@openssh.com", cb };
        let isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          let which = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${which} statvfs@openssh.com`);
        }
      }
      ext_openssh_fstatvfs(handle, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        let ext = this._extensions["fstatvfs@openssh.com"];
        if (!ext || ext !== "2")
          throw new Error("Server does not support this extended request");
        if (!Buffer.isBuffer(handle))
          throw new Error("handle is not a Buffer");
        let handleLen = handle.length, p = 9, buf = Buffer.allocUnsafe(37 + handleLen);
        writeUInt32BE(buf, buf.length - 4, 0), buf[4] = REQUEST.EXTENDED;
        let reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5), writeUInt32BE(buf, 20, p), buf.utf8Write("fstatvfs@openssh.com", p += 4, 20), writeUInt32BE(buf, handleLen, p += 20), buf.set(handle, p += 4), this._requests[reqid] = { extended: "fstatvfs@openssh.com", cb };
        let isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          let which = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${which} fstatvfs@openssh.com`);
        }
      }
      ext_openssh_hardlink(oldPath, newPath, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (this._extensions["hardlink@openssh.com"] !== "1")
          throw new Error("Server does not support this extended request");
        let oldLen = Buffer.byteLength(oldPath), newLen = Buffer.byteLength(newPath), p = 9, buf = Buffer.allocUnsafe(37 + oldLen + 4 + newLen);
        writeUInt32BE(buf, buf.length - 4, 0), buf[4] = REQUEST.EXTENDED;
        let reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5), writeUInt32BE(buf, 20, p), buf.utf8Write("hardlink@openssh.com", p += 4, 20), writeUInt32BE(buf, oldLen, p += 20), buf.utf8Write(oldPath, p += 4, oldLen), writeUInt32BE(buf, newLen, p += oldLen), buf.utf8Write(newPath, p += 4, newLen), this._requests[reqid] = { cb };
        let isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          let which = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${which} hardlink@openssh.com`);
        }
      }
      ext_openssh_fsync(handle, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (this._extensions["fsync@openssh.com"] !== "1")
          throw new Error("Server does not support this extended request");
        if (!Buffer.isBuffer(handle))
          throw new Error("handle is not a Buffer");
        let handleLen = handle.length, p = 9, buf = Buffer.allocUnsafe(34 + handleLen);
        writeUInt32BE(buf, buf.length - 4, 0), buf[4] = REQUEST.EXTENDED;
        let reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5), writeUInt32BE(buf, 17, p), buf.utf8Write("fsync@openssh.com", p += 4, 17), writeUInt32BE(buf, handleLen, p += 17), buf.set(handle, p += 4), this._requests[reqid] = { cb };
        let isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} fsync@openssh.com`
        );
      }
      ext_openssh_lsetstat(path8, attrs, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (this._extensions["lsetstat@openssh.com"] !== "1")
          throw new Error("Server does not support this extended request");
        let flags = 0, attrsLen = 0;
        typeof attrs == "object" && attrs !== null ? (attrs = attrsToBytes(attrs), flags = attrs.flags, attrsLen = attrs.nb) : typeof attrs == "function" && (cb = attrs);
        let pathLen = Buffer.byteLength(path8), p = 9, buf = Buffer.allocUnsafe(37 + pathLen + 4 + attrsLen);
        writeUInt32BE(buf, buf.length - 4, 0), buf[4] = REQUEST.EXTENDED;
        let reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5), writeUInt32BE(buf, 20, p), buf.utf8Write("lsetstat@openssh.com", p += 4, 20), writeUInt32BE(buf, pathLen, p += 20), buf.utf8Write(path8, p += 4, pathLen), writeUInt32BE(buf, flags, p += pathLen), attrsLen && (p += 4, attrsLen === ATTRS_BUF.length ? buf.set(ATTRS_BUF, p) : bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p), p += attrsLen), this._requests[reqid] = { cb };
        let isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          let status = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${status} lsetstat@openssh.com`);
        }
      }
      ext_openssh_expandPath(path8, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (this._extensions["expand-path@openssh.com"] !== "1")
          throw new Error("Server does not support this extended request");
        let pathLen = Buffer.byteLength(path8), p = 9, buf = Buffer.allocUnsafe(40 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0), buf[4] = REQUEST.EXTENDED;
        let reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5), writeUInt32BE(buf, 23, p), buf.utf8Write("expand-path@openssh.com", p += 4, 23), writeUInt32BE(buf, pathLen, p += 20), buf.utf8Write(path8, p += 4, pathLen), this._requests[reqid] = {
          cb: (err, names) => {
            if (typeof cb == "function") {
              if (err)
                return cb(err);
              if (!names || !names.length)
                return cb(new Error("Response missing expanded path"));
              cb(void 0, names[0].filename);
            }
          }
        };
        let isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          let status = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${status} expand-path@openssh.com`);
        }
      }
      ext_copy_data(srcHandle, srcOffset, len, dstHandle, dstOffset, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (this._extensions["copy-data"] !== "1")
          throw new Error("Server does not support this extended request");
        if (!Buffer.isBuffer(srcHandle))
          throw new Error("Source handle is not a Buffer");
        if (!Buffer.isBuffer(dstHandle))
          throw new Error("Destination handle is not a Buffer");
        let p = 0, buf = Buffer.allocUnsafe(
          26 + srcHandle.length + 8 + 8 + 4 + dstHandle.length + 8
        );
        writeUInt32BE(buf, buf.length - 4, p), p += 4, buf[p] = REQUEST.EXTENDED, ++p;
        let reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, p), p += 4, writeUInt32BE(buf, 9, p), p += 4, buf.utf8Write("copy-data", p, 9), p += 9, writeUInt32BE(buf, srcHandle.length, p), p += 4, buf.set(srcHandle, p), p += srcHandle.length;
        for (let i = 7; i >= 0; --i)
          buf[p + i] = srcOffset & 255, srcOffset /= 256;
        p += 8;
        for (let i = 7; i >= 0; --i)
          buf[p + i] = len & 255, len /= 256;
        p += 8, writeUInt32BE(buf, dstHandle.length, p), p += 4, buf.set(dstHandle, p), p += dstHandle.length;
        for (let i = 7; i >= 0; --i)
          buf[p + i] = dstOffset & 255, dstOffset /= 256;
        this._requests[reqid] = { cb };
        let isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          let status = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${status} copy-data`);
        }
      }
      ext_home_dir(username, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (this._extensions["home-directory"] !== "1")
          throw new Error("Server does not support this extended request");
        if (typeof username != "string")
          throw new TypeError("username is not a string");
        let p = 0, usernameLen = Buffer.byteLength(username), buf = Buffer.allocUnsafe(
          31 + usernameLen
        );
        writeUInt32BE(buf, buf.length - 4, p), p += 4, buf[p] = REQUEST.EXTENDED, ++p;
        let reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, p), p += 4, writeUInt32BE(buf, 14, p), p += 4, buf.utf8Write("home-directory", p, 14), p += 14, writeUInt32BE(buf, usernameLen, p), p += 4, buf.utf8Write(username, p, usernameLen), p += usernameLen, this._requests[reqid] = {
          cb: (err, names) => {
            if (typeof cb == "function") {
              if (err)
                return cb(err);
              if (!names || !names.length)
                return cb(new Error("Response missing home directory"));
              cb(void 0, names[0].filename);
            }
          }
        };
        let isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          let status = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${status} home-directory`);
        }
      }
      ext_users_groups(uids, gids, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (this._extensions["users-groups-by-id@openssh.com"] !== "1")
          throw new Error("Server does not support this extended request");
        if (!Array.isArray(uids))
          throw new TypeError("uids is not an array");
        for (let val of uids)
          if (!Number.isInteger(val) || val < 0 || val > 2 ** 32 - 1)
            throw new Error("uid values must all be 32-bit unsigned integers");
        if (!Array.isArray(gids))
          throw new TypeError("gids is not an array");
        for (let val of gids)
          if (!Number.isInteger(val) || val < 0 || val > 2 ** 32 - 1)
            throw new Error("gid values must all be 32-bit unsigned integers");
        let p = 0, buf = Buffer.allocUnsafe(
          47 + 4 * uids.length + 4 + 4 * gids.length
        );
        writeUInt32BE(buf, buf.length - 4, p), p += 4, buf[p] = REQUEST.EXTENDED, ++p;
        let reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, p), p += 4, writeUInt32BE(buf, 30, p), p += 4, buf.utf8Write("users-groups-by-id@openssh.com", p, 30), p += 30, writeUInt32BE(buf, 4 * uids.length, p), p += 4;
        for (let val of uids)
          writeUInt32BE(buf, val, p), p += 4;
        writeUInt32BE(buf, 4 * gids.length, p), p += 4;
        for (let val of gids)
          writeUInt32BE(buf, val, p), p += 4;
        this._requests[reqid] = { extended: "users-groups-by-id@openssh.com", cb };
        let isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          let status = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${status} users-groups-by-id@openssh.com`);
        }
      }
      // ===========================================================================
      // Server-specific ===========================================================
      // ===========================================================================
      handle(reqid, handle) {
        if (!this.server)
          throw new Error("Server-only method called in client mode");
        if (!Buffer.isBuffer(handle))
          throw new Error("handle is not a Buffer");
        let handleLen = handle.length;
        if (handleLen > 256)
          throw new Error("handle too large (> 256 bytes)");
        let p = 9, buf = Buffer.allocUnsafe(13 + handleLen);
        writeUInt32BE(buf, buf.length - 4, 0), buf[4] = RESPONSE.HANDLE, writeUInt32BE(buf, reqid, 5), writeUInt32BE(buf, handleLen, p), handleLen && buf.set(handle, p += 4);
        let isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} HANDLE`
        );
      }
      status(reqid, code2, message) {
        if (!this.server)
          throw new Error("Server-only method called in client mode");
        if (!VALID_STATUS_CODES.has(code2))
          throw new Error(`Bad status code: ${code2}`);
        message || (message = "");
        let msgLen = Buffer.byteLength(message), p = 9, buf = Buffer.allocUnsafe(17 + msgLen + 4);
        writeUInt32BE(buf, buf.length - 4, 0), buf[4] = RESPONSE.STATUS, writeUInt32BE(buf, reqid, 5), writeUInt32BE(buf, code2, p), writeUInt32BE(buf, msgLen, p += 4), p += 4, msgLen && (buf.utf8Write(message, p, msgLen), p += msgLen), writeUInt32BE(buf, 0, p);
        let isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} STATUS`
        );
      }
      data(reqid, data, encoding) {
        if (!this.server)
          throw new Error("Server-only method called in client mode");
        let isBuffer = Buffer.isBuffer(data);
        if (!isBuffer && typeof data != "string")
          throw new Error("data is not a Buffer or string");
        let isUTF8;
        !isBuffer && !encoding && (encoding = void 0, isUTF8 = !0);
        let dataLen = isBuffer ? data.length : Buffer.byteLength(data, encoding), p = 9, buf = Buffer.allocUnsafe(13 + dataLen);
        writeUInt32BE(buf, buf.length - 4, 0), buf[4] = RESPONSE.DATA, writeUInt32BE(buf, reqid, 5), writeUInt32BE(buf, dataLen, p), dataLen && (isBuffer ? buf.set(data, p += 4) : isUTF8 ? buf.utf8Write(data, p += 4, dataLen) : buf.write(data, p += 4, dataLen, encoding));
        let isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} DATA`
        );
      }
      name(reqid, names) {
        if (!this.server)
          throw new Error("Server-only method called in client mode");
        if (!Array.isArray(names)) {
          if (typeof names != "object" || names === null)
            throw new Error("names is not an object or array");
          names = [names];
        }
        let count = names.length, namesLen = 0, nameAttrs, attrs = [];
        for (let i = 0; i < count; ++i) {
          let name2 = names[i], filename = !name2 || !name2.filename || typeof name2.filename != "string" ? "" : name2.filename;
          namesLen += 4 + Buffer.byteLength(filename);
          let longname = !name2 || !name2.longname || typeof name2.longname != "string" ? "" : name2.longname;
          if (namesLen += 4 + Buffer.byteLength(longname), typeof name2.attrs == "object" && name2.attrs !== null) {
            if (nameAttrs = attrsToBytes(name2.attrs), namesLen += 4 + nameAttrs.nb, nameAttrs.nb) {
              let bytes;
              nameAttrs.nb === ATTRS_BUF.length ? bytes = new Uint8Array(ATTRS_BUF) : (bytes = new Uint8Array(nameAttrs.nb), bufferCopy(ATTRS_BUF, bytes, 0, nameAttrs.nb, 0)), nameAttrs.bytes = bytes;
            }
            attrs.push(nameAttrs);
          } else
            namesLen += 4, attrs.push(null);
        }
        let p = 9, buf = Buffer.allocUnsafe(13 + namesLen);
        writeUInt32BE(buf, buf.length - 4, 0), buf[4] = RESPONSE.NAME, writeUInt32BE(buf, reqid, 5), writeUInt32BE(buf, count, p), p += 4;
        for (let i = 0; i < count; ++i) {
          let name2 = names[i];
          {
            let filename = !name2 || !name2.filename || typeof name2.filename != "string" ? "" : name2.filename, len = Buffer.byteLength(filename);
            writeUInt32BE(buf, len, p), p += 4, len && (buf.utf8Write(filename, p, len), p += len);
          }
          {
            let longname = !name2 || !name2.longname || typeof name2.longname != "string" ? "" : name2.longname, len = Buffer.byteLength(longname);
            writeUInt32BE(buf, len, p), p += 4, len && (buf.utf8Write(longname, p, len), p += len);
          }
          let attr = attrs[i];
          attr ? (writeUInt32BE(buf, attr.flags, p), p += 4, attr.flags && attr.bytes && (buf.set(attr.bytes, p), p += attr.nb)) : (writeUInt32BE(buf, 0, p), p += 4);
        }
        let isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} NAME`
        );
      }
      attrs(reqid, attrs) {
        if (!this.server)
          throw new Error("Server-only method called in client mode");
        if (typeof attrs != "object" || attrs === null)
          throw new Error("attrs is not an object");
        attrs = attrsToBytes(attrs);
        let flags = attrs.flags, attrsLen = attrs.nb, p = 9, buf = Buffer.allocUnsafe(13 + attrsLen);
        writeUInt32BE(buf, buf.length - 4, 0), buf[4] = RESPONSE.ATTRS, writeUInt32BE(buf, reqid, 5), writeUInt32BE(buf, flags, p), attrsLen && (p += 4, attrsLen === ATTRS_BUF.length ? buf.set(ATTRS_BUF, p) : bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p), p += attrsLen);
        let isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} ATTRS`
        );
      }
    };
    function tryCreateBuffer(size) {
      try {
        return Buffer.allocUnsafe(size);
      } catch (ex) {
        return ex;
      }
    }
    function read_(self2, handle, buf, off, len, position, cb, req_) {
      let maxDataLen = self2._maxReadLen, overflow = Math.max(len - maxDataLen, 0);
      overflow && (len = maxDataLen);
      let handleLen = handle.length, p = 9, pos2 = position, out = Buffer.allocUnsafe(13 + handleLen + 8 + 4);
      writeUInt32BE(out, out.length - 4, 0), out[4] = REQUEST.READ;
      let reqid = self2._writeReqid = self2._writeReqid + 1 & MAX_REQID;
      writeUInt32BE(out, reqid, 5), writeUInt32BE(out, handleLen, p), out.set(handle, p += 4), p += handleLen;
      for (let i = 7; i >= 0; --i)
        out[p + i] = pos2 & 255, pos2 /= 256;
      writeUInt32BE(out, len, p += 8), typeof cb != "function" && (cb = noop2);
      let req = req_ || {
        nb: 0,
        position,
        off,
        origOff: off,
        len: void 0,
        overflow: void 0,
        cb: (err, data, nb) => {
          let len2 = req.len, overflow2 = req.overflow;
          if (err) {
            if (cb._wantEOFError || err.code !== STATUS_CODE.EOF)
              return cb(err);
          } else {
            if (nb > len2)
              return cb(new Error("Received more data than requested"));
            if (nb === len2 && overflow2) {
              req.nb += nb, req.position += nb, req.off += nb, read_(self2, handle, buf, req.off, overflow2, req.position, cb, req);
              return;
            }
          }
          nb = nb || 0, req.origOff === 0 && buf.length === req.nb ? data = buf : data = bufferSlice(buf, req.origOff, req.origOff + req.nb + nb), cb(void 0, req.nb + nb, data, req.position);
        },
        buffer: void 0
      };
      req.len = len, req.overflow = overflow, req.buffer = bufferSlice(buf, off, off + len), self2._requests[reqid] = req;
      let isBuffered = sendOrBuffer(self2, out);
      self2._debug && self2._debug(
        `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} READ`
      );
    }
    function fastXfer(src, dst, srcPath, dstPath, opts, cb) {
      let concurrency = 64, chunkSize = 32768, onstep, mode, fileSize;
      typeof opts == "function" ? cb = opts : typeof opts == "object" && opts !== null && (typeof opts.concurrency == "number" && opts.concurrency > 0 && !isNaN(opts.concurrency) && (concurrency = opts.concurrency), typeof opts.chunkSize == "number" && opts.chunkSize > 0 && !isNaN(opts.chunkSize) && (chunkSize = opts.chunkSize), typeof opts.fileSize == "number" && opts.fileSize > 0 && !isNaN(opts.fileSize) && (fileSize = opts.fileSize), typeof opts.step == "function" && (onstep = opts.step), (typeof opts.mode == "string" || typeof opts.mode == "number") && (mode = modeNum(opts.mode)));
      let fsize, pdst = 0, total = 0, hadError = !1, srcHandle, dstHandle, readbuf, bufsize = chunkSize * concurrency;
      function onerror(err) {
        if (hadError)
          return;
        hadError = !0;
        let left = 0, cbfinal;
        srcHandle || dstHandle ? (cbfinal = () => {
          --left === 0 && cb(err);
        }, srcHandle && (src === fs11 || src.outgoing.state === "open") && ++left, dstHandle && (dst === fs11 || dst.outgoing.state === "open") && ++left, srcHandle && (src === fs11 || src.outgoing.state === "open") && src.close(srcHandle, cbfinal), dstHandle && (dst === fs11 || dst.outgoing.state === "open") && dst.close(dstHandle, cbfinal)) : cb(err);
      }
      src.open(srcPath, "r", (err, sourceHandle) => {
        if (err)
          return onerror(err);
        srcHandle = sourceHandle, fileSize === void 0 ? src.fstat(srcHandle, tryStat) : tryStat(null, { size: fileSize });
        function tryStat(err2, attrs) {
          if (err2) {
            if (src !== fs11) {
              src.stat(srcPath, (err_, attrs_) => {
                if (err_)
                  return onerror(err2);
                tryStat(null, attrs_);
              });
              return;
            }
            return onerror(err2);
          }
          fsize = attrs.size, dst.open(dstPath, "w", (err3, destHandle) => {
            if (err3)
              return onerror(err3);
            if (dstHandle = destHandle, fsize <= 0)
              return onerror();
            for (; bufsize > fsize; ) {
              if (concurrency === 1) {
                bufsize = fsize;
                break;
              }
              bufsize -= chunkSize, --concurrency;
            }
            if (readbuf = tryCreateBuffer(bufsize), readbuf instanceof Error)
              return onerror(readbuf);
            mode !== void 0 ? dst.fchmod(dstHandle, mode, function tryAgain(err4) {
              if (err4) {
                dst.chmod(dstPath, mode, (err_) => tryAgain());
                return;
              }
              startReads();
            }) : startReads();
            function onread(err4, nb, data, dstpos, datapos, origChunkLen) {
              if (err4)
                return onerror(err4);
              datapos = datapos || 0, dst.write(dstHandle, readbuf, datapos, nb, dstpos, writeCb);
              function writeCb(err5) {
                if (err5)
                  return onerror(err5);
                if (total += nb, onstep && onstep(total, nb, fsize), nb < origChunkLen)
                  return singleRead(datapos, dstpos + nb, origChunkLen - nb);
                if (total === fsize) {
                  dst.close(dstHandle, (err6) => {
                    if (dstHandle = void 0, err6)
                      return onerror(err6);
                    src.close(srcHandle, (err7) => {
                      if (srcHandle = void 0, err7)
                        return onerror(err7);
                      cb();
                    });
                  });
                  return;
                }
                if (pdst >= fsize)
                  return;
                let chunk = pdst + chunkSize > fsize ? fsize - pdst : chunkSize;
                singleRead(datapos, pdst, chunk), pdst += chunk;
              }
            }
            function makeCb(psrc, pdst2, chunk) {
              return (err4, nb, data) => {
                onread(err4, nb, data, pdst2, psrc, chunk);
              };
            }
            function singleRead(psrc, pdst2, chunk) {
              src.read(
                srcHandle,
                readbuf,
                psrc,
                chunk,
                pdst2,
                makeCb(psrc, pdst2, chunk)
              );
            }
            function startReads() {
              let reads = 0, psrc = 0;
              for (; pdst < fsize && reads < concurrency; ) {
                let chunk = pdst + chunkSize > fsize ? fsize - pdst : chunkSize;
                singleRead(psrc, pdst, chunk), psrc += chunk, pdst += chunk, ++reads;
              }
            }
          });
        }
      });
    }
    function writeAll(sftp, handle, buffer, offset, length, position, callback_) {
      let callback = typeof callback_ == "function" ? callback_ : void 0;
      sftp.write(
        handle,
        buffer,
        offset,
        length,
        position,
        (writeErr, written) => {
          if (writeErr)
            return sftp.close(handle, () => {
              callback && callback(writeErr);
            });
          written === length ? sftp.close(handle, callback) : (offset += written, length -= written, position += written, writeAll(sftp, handle, buffer, offset, length, position, callback));
        }
      );
    }
    var Stats = class {
      constructor(initial) {
        this.mode = initial && initial.mode, this.uid = initial && initial.uid, this.gid = initial && initial.gid, this.size = initial && initial.size, this.atime = initial && initial.atime, this.mtime = initial && initial.mtime, this.extended = initial && initial.extended;
      }
      isDirectory() {
        return (this.mode & constants2.S_IFMT) === constants2.S_IFDIR;
      }
      isFile() {
        return (this.mode & constants2.S_IFMT) === constants2.S_IFREG;
      }
      isBlockDevice() {
        return (this.mode & constants2.S_IFMT) === constants2.S_IFBLK;
      }
      isCharacterDevice() {
        return (this.mode & constants2.S_IFMT) === constants2.S_IFCHR;
      }
      isSymbolicLink() {
        return (this.mode & constants2.S_IFMT) === constants2.S_IFLNK;
      }
      isFIFO() {
        return (this.mode & constants2.S_IFMT) === constants2.S_IFIFO;
      }
      isSocket() {
        return (this.mode & constants2.S_IFMT) === constants2.S_IFSOCK;
      }
    };
    function attrsToBytes(attrs) {
      let flags = 0, nb = 0;
      if (typeof attrs == "object" && attrs !== null) {
        if (typeof attrs.size == "number") {
          flags |= ATTR.SIZE;
          let val = attrs.size;
          ATTRS_BUF[nb++] = val / 72057594037927940, ATTRS_BUF[nb++] = val / 281474976710656, ATTRS_BUF[nb++] = val / 1099511627776, ATTRS_BUF[nb++] = val / 4294967296, ATTRS_BUF[nb++] = val / 16777216, ATTRS_BUF[nb++] = val / 65536, ATTRS_BUF[nb++] = val / 256, ATTRS_BUF[nb++] = val;
        }
        if (typeof attrs.uid == "number" && typeof attrs.gid == "number") {
          flags |= ATTR.UIDGID;
          let uid = attrs.uid, gid = attrs.gid;
          ATTRS_BUF[nb++] = uid >>> 24, ATTRS_BUF[nb++] = uid >>> 16, ATTRS_BUF[nb++] = uid >>> 8, ATTRS_BUF[nb++] = uid, ATTRS_BUF[nb++] = gid >>> 24, ATTRS_BUF[nb++] = gid >>> 16, ATTRS_BUF[nb++] = gid >>> 8, ATTRS_BUF[nb++] = gid;
        }
        if (typeof attrs.mode == "number" || typeof attrs.mode == "string") {
          let mode = modeNum(attrs.mode);
          flags |= ATTR.PERMISSIONS, ATTRS_BUF[nb++] = mode >>> 24, ATTRS_BUF[nb++] = mode >>> 16, ATTRS_BUF[nb++] = mode >>> 8, ATTRS_BUF[nb++] = mode;
        }
        if ((typeof attrs.atime == "number" || isDate(attrs.atime)) && (typeof attrs.mtime == "number" || isDate(attrs.mtime))) {
          let atime = toUnixTimestamp(attrs.atime), mtime = toUnixTimestamp(attrs.mtime);
          flags |= ATTR.ACMODTIME, ATTRS_BUF[nb++] = atime >>> 24, ATTRS_BUF[nb++] = atime >>> 16, ATTRS_BUF[nb++] = atime >>> 8, ATTRS_BUF[nb++] = atime, ATTRS_BUF[nb++] = mtime >>> 24, ATTRS_BUF[nb++] = mtime >>> 16, ATTRS_BUF[nb++] = mtime >>> 8, ATTRS_BUF[nb++] = mtime;
        }
      }
      return { flags, nb };
    }
    function toUnixTimestamp(time) {
      if (typeof time == "number" && time === time)
        return time;
      if (isDate(time))
        return parseInt(time.getTime() / 1e3, 10);
      throw new Error(`Cannot parse time: ${time}`);
    }
    function modeNum(mode) {
      if (typeof mode == "number" && mode === mode)
        return mode;
      if (typeof mode == "string")
        return modeNum(parseInt(mode, 8));
      throw new Error(`Cannot parse mode: ${mode}`);
    }
    var stringFlagMap = {
      r: OPEN_MODE.READ,
      "r+": OPEN_MODE.READ | OPEN_MODE.WRITE,
      w: OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE,
      wx: OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,
      xw: OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,
      "w+": OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE,
      "wx+": OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE | OPEN_MODE.EXCL,
      "xw+": OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE | OPEN_MODE.EXCL,
      a: OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE,
      ax: OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,
      xa: OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,
      "a+": OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE,
      "ax+": OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE | OPEN_MODE.EXCL,
      "xa+": OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE | OPEN_MODE.EXCL
    };
    function stringToFlags(str) {
      let flags = stringFlagMap[str];
      return flags !== void 0 ? flags : null;
    }
    var flagsToString = (() => {
      let stringFlagMapKeys = Object.keys(stringFlagMap);
      return (flags) => {
        for (let i = 0; i < stringFlagMapKeys.length; ++i) {
          let key = stringFlagMapKeys[i];
          if (stringFlagMap[key] === flags)
            return key;
        }
        return null;
      };
    })();
    function readAttrs(biOpt) {
      let flags = bufferParser.readUInt32BE();
      if (flags === void 0)
        return;
      let attrs = new Stats();
      if (flags & ATTR.SIZE) {
        let size = bufferParser.readUInt64BE(biOpt);
        if (size === void 0)
          return;
        attrs.size = size;
      }
      if (flags & ATTR.UIDGID) {
        let uid = bufferParser.readUInt32BE(), gid = bufferParser.readUInt32BE();
        if (gid === void 0)
          return;
        attrs.uid = uid, attrs.gid = gid;
      }
      if (flags & ATTR.PERMISSIONS) {
        let mode = bufferParser.readUInt32BE();
        if (mode === void 0)
          return;
        attrs.mode = mode;
      }
      if (flags & ATTR.ACMODTIME) {
        let atime = bufferParser.readUInt32BE(), mtime = bufferParser.readUInt32BE();
        if (mtime === void 0)
          return;
        attrs.atime = atime, attrs.mtime = mtime;
      }
      if (flags & ATTR.EXTENDED) {
        let count = bufferParser.readUInt32BE();
        if (count === void 0)
          return;
        let extended = {};
        for (let i = 0; i < count; ++i) {
          let type = bufferParser.readString(!0), data = bufferParser.readString();
          if (data === void 0)
            return;
          extended[type] = data;
        }
        attrs.extended = extended;
      }
      return attrs;
    }
    function sendOrBuffer(sftp, payload) {
      let ret = tryWritePayload(sftp, payload);
      return ret !== void 0 ? (sftp._buffer.push(ret), !1) : !0;
    }
    function tryWritePayload(sftp, payload) {
      let outgoing = sftp.outgoing;
      if (outgoing.state !== "open")
        return;
      if (outgoing.window === 0)
        return sftp._waitWindow = !0, sftp._chunkcb = drainBuffer, payload;
      let ret, len = payload.length, p = 0;
      for (; len - p > 0 && outgoing.window > 0; ) {
        let actualLen = Math.min(len - p, outgoing.window, outgoing.packetSize);
        outgoing.window -= actualLen, outgoing.window === 0 && (sftp._waitWindow = !0, sftp._chunkcb = drainBuffer), p === 0 && actualLen === len ? sftp._protocol.channelData(sftp.outgoing.id, payload) : sftp._protocol.channelData(
          sftp.outgoing.id,
          bufferSlice(payload, p, p + actualLen)
        ), p += actualLen;
      }
      return len - p > 0 && (p > 0 ? ret = bufferSlice(payload, p, len) : ret = payload), ret;
    }
    function drainBuffer() {
      this._chunkcb = void 0;
      let buffer = this._buffer, i = 0;
      for (; i < buffer.length; ) {
        let payload = buffer[i], ret = tryWritePayload(this, payload);
        if (ret !== void 0) {
          ret !== payload && (buffer[i] = ret), i > 0 && (this._buffer = buffer.slice(i));
          return;
        }
        ++i;
      }
      i > 0 && (this._buffer = []);
    }
    function doFatalSFTPError(sftp, msg, noDebug) {
      let err = new Error(msg);
      return err.level = "sftp-protocol", !noDebug && sftp._debug && sftp._debug(`SFTP: Inbound: ${msg}`), sftp.emit("error", err), sftp.destroy(), cleanupRequests(sftp), !1;
    }
    function cleanupRequests(sftp) {
      let keys = Object.keys(sftp._requests);
      if (keys.length === 0)
        return;
      let reqs = sftp._requests;
      sftp._requests = {};
      let err = new Error("No response from server");
      for (let i = 0; i < keys.length; ++i) {
        let req = reqs[keys[i]];
        typeof req.cb == "function" && req.cb(err);
      }
    }
    function requestLimits(sftp, cb) {
      let p = 9, buf = Buffer.allocUnsafe(31);
      writeUInt32BE(buf, buf.length - 4, 0), buf[4] = REQUEST.EXTENDED;
      let reqid = sftp._writeReqid = sftp._writeReqid + 1 & MAX_REQID;
      writeUInt32BE(buf, reqid, 5), writeUInt32BE(buf, 18, p), buf.utf8Write("limits@openssh.com", p += 4, 18), sftp._requests[reqid] = { extended: "limits@openssh.com", cb };
      let isBuffered = sendOrBuffer(sftp, buf);
      if (sftp._debug) {
        let which = isBuffered ? "Buffered" : "Sending";
        sftp._debug(`SFTP: Outbound: ${which} limits@openssh.com`);
      }
    }
    var CLIENT_HANDLERS = {
      [RESPONSE.VERSION]: (sftp, payload) => {
        if (sftp._version !== -1)
          return doFatalSFTPError(sftp, "Duplicate VERSION packet");
        let extensions = {};
        bufferParser.init(payload, 1);
        let version2 = bufferParser.readUInt32BE();
        for (; bufferParser.avail(); ) {
          let extName = bufferParser.readString(!0), extData = bufferParser.readString(!0);
          if (extData === void 0) {
            version2 = void 0;
            break;
          }
          extensions[extName] = extData;
        }
        if (bufferParser.clear(), version2 === void 0)
          return doFatalSFTPError(sftp, "Malformed VERSION packet");
        if (sftp._debug) {
          let names = Object.keys(extensions);
          names.length ? sftp._debug(
            `SFTP: Inbound: Received VERSION (v${version2}, exts:${names})`
          ) : sftp._debug(`SFTP: Inbound: Received VERSION (v${version2})`);
        }
        if (sftp._version = version2, sftp._extensions = extensions, extensions["limits@openssh.com"] === "1")
          return requestLimits(sftp, (err, limits) => {
            err || (limits.maxPktLen > 0 && (sftp._maxOutPktLen = limits.maxPktLen), limits.maxReadLen > 0 && (sftp._maxReadLen = limits.maxReadLen), limits.maxWriteLen > 0 && (sftp._maxWriteLen = limits.maxWriteLen), sftp.maxOpenHandles = limits.maxOpenHandles > 0 ? limits.maxOpenHandles : 1 / 0), sftp.emit("ready");
          });
        sftp.emit("ready");
      },
      [RESPONSE.STATUS]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        let reqID = bufferParser.readUInt32BE(), errorCode = bufferParser.readUInt32BE(), errorMsg = bufferParser.readString(!0);
        if (bufferParser.clear(), sftp._debug) {
          let jsonMsg = JSON.stringify(errorMsg);
          sftp._debug(
            `SFTP: Inbound: Received STATUS (id:${reqID}, ${errorCode}, ${jsonMsg})`
          );
        }
        let req = sftp._requests[reqID];
        if (delete sftp._requests[reqID], req && typeof req.cb == "function") {
          if (errorCode === STATUS_CODE.OK) {
            req.cb();
            return;
          }
          let err = new Error(errorMsg || STATUS_CODE_STR[errorCode] || "Unknown status");
          err.code = errorCode, req.cb(err);
        }
      },
      [RESPONSE.HANDLE]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        let reqID = bufferParser.readUInt32BE(), handle = bufferParser.readString();
        if (bufferParser.clear(), handle === void 0)
          return reqID !== void 0 && delete sftp._requests[reqID], doFatalSFTPError(sftp, "Malformed HANDLE packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received HANDLE (id:${reqID})`);
        let req = sftp._requests[reqID];
        delete sftp._requests[reqID], req && typeof req.cb == "function" && req.cb(void 0, handle);
      },
      [RESPONSE.DATA]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        let reqID = bufferParser.readUInt32BE(), req;
        if (reqID !== void 0 && (req = sftp._requests[reqID], delete sftp._requests[reqID]), req && typeof req.cb == "function")
          if (req.buffer) {
            let nb = bufferParser.readString(req.buffer);
            if (bufferParser.clear(), nb !== void 0) {
              sftp._debug && sftp._debug(
                `SFTP: Inbound: Received DATA (id:${reqID}, ${nb})`
              ), req.cb(void 0, req.buffer, nb);
              return;
            }
          } else {
            let data = bufferParser.readString();
            if (bufferParser.clear(), data !== void 0) {
              sftp._debug && sftp._debug(
                `SFTP: Inbound: Received DATA (id:${reqID}, ${data.length})`
              ), req.cb(void 0, data);
              return;
            }
          }
        else {
          let nb = bufferParser.skipString();
          if (bufferParser.clear(), nb !== void 0) {
            sftp._debug && sftp._debug(
              `SFTP: Inbound: Received DATA (id:${reqID}, ${nb})`
            );
            return;
          }
        }
        return doFatalSFTPError(sftp, "Malformed DATA packet");
      },
      [RESPONSE.NAME]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        let reqID = bufferParser.readUInt32BE(), req;
        reqID !== void 0 && (req = sftp._requests[reqID], delete sftp._requests[reqID]);
        let count = bufferParser.readUInt32BE();
        if (count !== void 0) {
          let names = [];
          for (let i = 0; i < count; ++i) {
            let filename = bufferParser.readString(!0), longname = bufferParser.readString(!0), attrs = readAttrs(sftp._biOpt);
            if (attrs === void 0) {
              names = void 0;
              break;
            }
            names.push({ filename, longname, attrs });
          }
          if (names !== void 0) {
            sftp._debug && sftp._debug(
              `SFTP: Inbound: Received NAME (id:${reqID}, ${names.length})`
            ), bufferParser.clear(), req && typeof req.cb == "function" && req.cb(void 0, names);
            return;
          }
        }
        return bufferParser.clear(), doFatalSFTPError(sftp, "Malformed NAME packet");
      },
      [RESPONSE.ATTRS]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        let reqID = bufferParser.readUInt32BE(), req;
        reqID !== void 0 && (req = sftp._requests[reqID], delete sftp._requests[reqID]);
        let attrs = readAttrs(sftp._biOpt);
        if (bufferParser.clear(), attrs !== void 0) {
          sftp._debug && sftp._debug(`SFTP: Inbound: Received ATTRS (id:${reqID})`), req && typeof req.cb == "function" && req.cb(void 0, attrs);
          return;
        }
        return doFatalSFTPError(sftp, "Malformed ATTRS packet");
      },
      [RESPONSE.EXTENDED]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        let reqID = bufferParser.readUInt32BE();
        if (reqID !== void 0) {
          let req = sftp._requests[reqID];
          if (req)
            switch (delete sftp._requests[reqID], req.extended) {
              case "statvfs@openssh.com":
              case "fstatvfs@openssh.com": {
                let biOpt = sftp._biOpt, stats = {
                  f_bsize: bufferParser.readUInt64BE(biOpt),
                  f_frsize: bufferParser.readUInt64BE(biOpt),
                  f_blocks: bufferParser.readUInt64BE(biOpt),
                  f_bfree: bufferParser.readUInt64BE(biOpt),
                  f_bavail: bufferParser.readUInt64BE(biOpt),
                  f_files: bufferParser.readUInt64BE(biOpt),
                  f_ffree: bufferParser.readUInt64BE(biOpt),
                  f_favail: bufferParser.readUInt64BE(biOpt),
                  f_sid: bufferParser.readUInt64BE(biOpt),
                  f_flag: bufferParser.readUInt64BE(biOpt),
                  f_namemax: bufferParser.readUInt64BE(biOpt)
                };
                if (stats.f_namemax === void 0)
                  break;
                sftp._debug && sftp._debug(
                  `SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ${req.extended})`
                ), bufferParser.clear(), typeof req.cb == "function" && req.cb(void 0, stats);
                return;
              }
              case "limits@openssh.com": {
                let limits = {
                  maxPktLen: bufferParser.readUInt64BE(),
                  maxReadLen: bufferParser.readUInt64BE(),
                  maxWriteLen: bufferParser.readUInt64BE(),
                  maxOpenHandles: bufferParser.readUInt64BE()
                };
                if (limits.maxOpenHandles === void 0)
                  break;
                sftp._debug && sftp._debug(
                  `SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ${req.extended})`
                ), bufferParser.clear(), typeof req.cb == "function" && req.cb(void 0, limits);
                return;
              }
              case "users-groups-by-id@openssh.com": {
                let usernameCount = bufferParser.readUInt32BE();
                if (usernameCount === void 0)
                  break;
                let usernames = new Array(usernameCount);
                for (let i = 0; i < usernames.length; ++i)
                  usernames[i] = bufferParser.readString(!0);
                let groupnameCount = bufferParser.readUInt32BE();
                if (groupnameCount === void 0)
                  break;
                let groupnames = new Array(groupnameCount);
                for (let i = 0; i < groupnames.length; ++i)
                  groupnames[i] = bufferParser.readString(!0);
                if (groupnames.length > 0 && groupnames[groupnames.length - 1] === void 0)
                  break;
                sftp._debug && sftp._debug(
                  `SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ${req.extended})`
                ), bufferParser.clear(), typeof req.cb == "function" && req.cb(void 0, usernames, groupnames);
                return;
              }
              default:
                sftp._debug && sftp._debug(
                  `SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ???)`
                ), bufferParser.clear(), typeof req.cb == "function" && req.cb();
                return;
            }
          else {
            sftp._debug && sftp._debug(
              `SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ???)`
            ), bufferParser.clear();
            return;
          }
        }
        return bufferParser.clear(), doFatalSFTPError(sftp, "Malformed EXTENDED_REPLY packet");
      }
    }, SERVER_HANDLERS = {
      [REQUEST.INIT]: (sftp, payload) => {
        if (sftp._version !== -1)
          return doFatalSFTPError(sftp, "Duplicate INIT packet");
        let extensions = {};
        bufferParser.init(payload, 1);
        let version2 = bufferParser.readUInt32BE();
        for (; bufferParser.avail(); ) {
          let extName = bufferParser.readString(!0), extData = bufferParser.readString(!0);
          if (extData === void 0) {
            version2 = void 0;
            break;
          }
          extensions[extName] = extData;
        }
        if (bufferParser.clear(), version2 === void 0)
          return doFatalSFTPError(sftp, "Malformed INIT packet");
        if (sftp._debug) {
          let names = Object.keys(extensions);
          names.length ? sftp._debug(
            `SFTP: Inbound: Received INIT (v${version2}, exts:${names})`
          ) : sftp._debug(`SFTP: Inbound: Received INIT (v${version2})`);
        }
        sendOrBuffer(sftp, SERVER_VERSION_BUFFER), sftp._version = version2, sftp._extensions = extensions, sftp.emit("ready");
      },
      [REQUEST.OPEN]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        let reqID = bufferParser.readUInt32BE(), filename = bufferParser.readString(!0), pflags = bufferParser.readUInt32BE(), attrs = readAttrs(sftp._biOpt);
        if (bufferParser.clear(), attrs === void 0)
          return doFatalSFTPError(sftp, "Malformed OPEN packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received OPEN (id:${reqID})`), sftp.emit("OPEN", reqID, filename, pflags, attrs) || sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
      },
      [REQUEST.CLOSE]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        let reqID = bufferParser.readUInt32BE(), handle = bufferParser.readString();
        if (bufferParser.clear(), handle === void 0 || handle.length > 256)
          return doFatalSFTPError(sftp, "Malformed CLOSE packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received CLOSE (id:${reqID})`), sftp.emit("CLOSE", reqID, handle) || sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
      },
      [REQUEST.READ]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        let reqID = bufferParser.readUInt32BE(), handle = bufferParser.readString(), offset = bufferParser.readUInt64BE(sftp._biOpt), len = bufferParser.readUInt32BE();
        if (bufferParser.clear(), len === void 0 || handle.length > 256)
          return doFatalSFTPError(sftp, "Malformed READ packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received READ (id:${reqID})`), sftp.emit("READ", reqID, handle, offset, len) || sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
      },
      [REQUEST.WRITE]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        let reqID = bufferParser.readUInt32BE(), handle = bufferParser.readString(), offset = bufferParser.readUInt64BE(sftp._biOpt), data = bufferParser.readString();
        if (bufferParser.clear(), data === void 0 || handle.length > 256)
          return doFatalSFTPError(sftp, "Malformed WRITE packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received WRITE (id:${reqID})`), sftp.emit("WRITE", reqID, handle, offset, data) || sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
      },
      [REQUEST.LSTAT]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        let reqID = bufferParser.readUInt32BE(), path8 = bufferParser.readString(!0);
        if (bufferParser.clear(), path8 === void 0)
          return doFatalSFTPError(sftp, "Malformed LSTAT packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received LSTAT (id:${reqID})`), sftp.emit("LSTAT", reqID, path8) || sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
      },
      [REQUEST.FSTAT]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        let reqID = bufferParser.readUInt32BE(), handle = bufferParser.readString();
        if (bufferParser.clear(), handle === void 0 || handle.length > 256)
          return doFatalSFTPError(sftp, "Malformed FSTAT packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received FSTAT (id:${reqID})`), sftp.emit("FSTAT", reqID, handle) || sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
      },
      [REQUEST.SETSTAT]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        let reqID = bufferParser.readUInt32BE(), path8 = bufferParser.readString(!0), attrs = readAttrs(sftp._biOpt);
        if (bufferParser.clear(), attrs === void 0)
          return doFatalSFTPError(sftp, "Malformed SETSTAT packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received SETSTAT (id:${reqID})`), sftp.emit("SETSTAT", reqID, path8, attrs) || sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
      },
      [REQUEST.FSETSTAT]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        let reqID = bufferParser.readUInt32BE(), handle = bufferParser.readString(), attrs = readAttrs(sftp._biOpt);
        if (bufferParser.clear(), attrs === void 0 || handle.length > 256)
          return doFatalSFTPError(sftp, "Malformed FSETSTAT packet");
        sftp._debug && sftp._debug(
          `SFTP: Inbound: Received FSETSTAT (id:${reqID})`
        ), sftp.emit("FSETSTAT", reqID, handle, attrs) || sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
      },
      [REQUEST.OPENDIR]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        let reqID = bufferParser.readUInt32BE(), path8 = bufferParser.readString(!0);
        if (bufferParser.clear(), path8 === void 0)
          return doFatalSFTPError(sftp, "Malformed OPENDIR packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received OPENDIR (id:${reqID})`), sftp.emit("OPENDIR", reqID, path8) || sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
      },
      [REQUEST.READDIR]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        let reqID = bufferParser.readUInt32BE(), handle = bufferParser.readString();
        if (bufferParser.clear(), handle === void 0 || handle.length > 256)
          return doFatalSFTPError(sftp, "Malformed READDIR packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received READDIR (id:${reqID})`), sftp.emit("READDIR", reqID, handle) || sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
      },
      [REQUEST.REMOVE]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        let reqID = bufferParser.readUInt32BE(), path8 = bufferParser.readString(!0);
        if (bufferParser.clear(), path8 === void 0)
          return doFatalSFTPError(sftp, "Malformed REMOVE packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received REMOVE (id:${reqID})`), sftp.emit("REMOVE", reqID, path8) || sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
      },
      [REQUEST.MKDIR]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        let reqID = bufferParser.readUInt32BE(), path8 = bufferParser.readString(!0), attrs = readAttrs(sftp._biOpt);
        if (bufferParser.clear(), attrs === void 0)
          return doFatalSFTPError(sftp, "Malformed MKDIR packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received MKDIR (id:${reqID})`), sftp.emit("MKDIR", reqID, path8, attrs) || sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
      },
      [REQUEST.RMDIR]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        let reqID = bufferParser.readUInt32BE(), path8 = bufferParser.readString(!0);
        if (bufferParser.clear(), path8 === void 0)
          return doFatalSFTPError(sftp, "Malformed RMDIR packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received RMDIR (id:${reqID})`), sftp.emit("RMDIR", reqID, path8) || sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
      },
      [REQUEST.REALPATH]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        let reqID = bufferParser.readUInt32BE(), path8 = bufferParser.readString(!0);
        if (bufferParser.clear(), path8 === void 0)
          return doFatalSFTPError(sftp, "Malformed REALPATH packet");
        sftp._debug && sftp._debug(
          `SFTP: Inbound: Received REALPATH (id:${reqID})`
        ), sftp.emit("REALPATH", reqID, path8) || sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
      },
      [REQUEST.STAT]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        let reqID = bufferParser.readUInt32BE(), path8 = bufferParser.readString(!0);
        if (bufferParser.clear(), path8 === void 0)
          return doFatalSFTPError(sftp, "Malformed STAT packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received STAT (id:${reqID})`), sftp.emit("STAT", reqID, path8) || sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
      },
      [REQUEST.RENAME]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        let reqID = bufferParser.readUInt32BE(), oldPath = bufferParser.readString(!0), newPath = bufferParser.readString(!0);
        if (bufferParser.clear(), newPath === void 0)
          return doFatalSFTPError(sftp, "Malformed RENAME packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received RENAME (id:${reqID})`), sftp.emit("RENAME", reqID, oldPath, newPath) || sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
      },
      [REQUEST.READLINK]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        let reqID = bufferParser.readUInt32BE(), path8 = bufferParser.readString(!0);
        if (bufferParser.clear(), path8 === void 0)
          return doFatalSFTPError(sftp, "Malformed READLINK packet");
        sftp._debug && sftp._debug(
          `SFTP: Inbound: Received READLINK (id:${reqID})`
        ), sftp.emit("READLINK", reqID, path8) || sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
      },
      [REQUEST.SYMLINK]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        let reqID = bufferParser.readUInt32BE(), linkPath = bufferParser.readString(!0), targetPath = bufferParser.readString(!0);
        if (bufferParser.clear(), targetPath === void 0)
          return doFatalSFTPError(sftp, "Malformed SYMLINK packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received SYMLINK (id:${reqID})`);
        let handled;
        sftp._isOpenSSH ? handled = sftp.emit("SYMLINK", reqID, targetPath, linkPath) : handled = sftp.emit("SYMLINK", reqID, linkPath, targetPath), handled || sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
      },
      [REQUEST.EXTENDED]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        let reqID = bufferParser.readUInt32BE(), extName = bufferParser.readString(!0);
        if (extName === void 0)
          return bufferParser.clear(), doFatalSFTPError(sftp, "Malformed EXTENDED packet");
        let extData;
        bufferParser.avail() && (extData = bufferParser.readRaw()), bufferParser.clear(), sftp._debug && sftp._debug(
          `SFTP: Inbound: Received EXTENDED (id:${reqID})`
        ), sftp.emit("EXTENDED", reqID, extName, extData) || sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
      }
    }, {
      ERR_INVALID_ARG_TYPE,
      ERR_OUT_OF_RANGE,
      validateNumber
    } = require_node_fs_compat(), kMinPoolSpace = 128, pool, poolFragments = [];
    function allocNewPool(poolSize) {
      poolFragments.length > 0 ? pool = poolFragments.pop() : pool = Buffer.allocUnsafe(poolSize), pool.used = 0;
    }
    function checkPosition(pos2, name2) {
      if (!Number.isSafeInteger(pos2))
        throw validateNumber(pos2, name2), Number.isInteger(pos2) ? new ERR_OUT_OF_RANGE(name2, ">= 0 and <= 2 ** 53 - 1", pos2) : new ERR_OUT_OF_RANGE(name2, "an integer", pos2);
      if (pos2 < 0)
        throw new ERR_OUT_OF_RANGE(name2, ">= 0 and <= 2 ** 53 - 1", pos2);
    }
    function roundUpToMultipleOf8(n) {
      return n + 7 & -8;
    }
    function ReadStream2(sftp, path8, options) {
      if (options === void 0)
        options = {};
      else if (typeof options == "string")
        options = { encoding: options };
      else {
        if (options === null || typeof options != "object")
          throw new TypeError('"options" argument must be a string or an object');
        options = Object.create(options);
      }
      if (options.highWaterMark === void 0 && (options.highWaterMark = 64 * 1024), options.emitClose = !1, options.autoDestroy = !1, ReadableStream.call(this, options), this.path = path8, this.flags = options.flags === void 0 ? "r" : options.flags, this.mode = options.mode === void 0 ? 438 : options.mode, this.start = options.start, this.end = options.end, this.autoClose = options.autoClose === void 0 ? !0 : options.autoClose, this.pos = 0, this.bytesRead = 0, this.isClosed = !1, this.handle = options.handle === void 0 ? null : options.handle, this.sftp = sftp, this._opening = !1, this.start !== void 0 && (checkPosition(this.start, "start"), this.pos = this.start), this.end === void 0)
        this.end = 1 / 0;
      else if (this.end !== 1 / 0 && (checkPosition(this.end, "end"), this.start !== void 0 && this.start > this.end))
        throw new ERR_OUT_OF_RANGE(
          "start",
          `<= "end" (here: ${this.end})`,
          this.start
        );
      this.on("end", function() {
        this.autoClose && this.destroy();
      }), Buffer.isBuffer(this.handle) || this.open();
    }
    inherits(ReadStream2, ReadableStream);
    ReadStream2.prototype.open = function() {
      this._opening || (this._opening = !0, this.sftp.open(this.path, this.flags, this.mode, (er, handle) => {
        if (this._opening = !1, er) {
          this.emit("error", er), this.autoClose && this.destroy();
          return;
        }
        this.handle = handle, this.emit("open", handle), this.emit("ready"), this.read();
      }));
    };
    ReadStream2.prototype._read = function(n) {
      if (!Buffer.isBuffer(this.handle))
        return this.once("open", () => this._read(n));
      if (this.destroyed)
        return;
      (!pool || pool.length - pool.used < kMinPoolSpace) && allocNewPool(this.readableHighWaterMark || this._readableState.highWaterMark);
      let thisPool = pool, toRead = Math.min(pool.length - pool.used, n), start = pool.used;
      if (this.end !== void 0 && (toRead = Math.min(this.end - this.pos + 1, toRead)), toRead <= 0)
        return this.push(null);
      this.sftp.read(
        this.handle,
        pool,
        pool.used,
        toRead,
        this.pos,
        (er, bytesRead) => {
          if (er) {
            this.emit("error", er), this.autoClose && this.destroy();
            return;
          }
          let b = null;
          if (start + toRead === thisPool.used && thisPool === pool)
            thisPool.used = roundUpToMultipleOf8(thisPool.used + bytesRead - toRead);
          else {
            let alignedEnd = start + toRead & -8, alignedStart = roundUpToMultipleOf8(start + bytesRead);
            alignedEnd - alignedStart >= kMinPoolSpace && poolFragments.push(thisPool.slice(alignedStart, alignedEnd));
          }
          bytesRead > 0 && (this.bytesRead += bytesRead, b = thisPool.slice(start, start + bytesRead)), this.pos += bytesRead, this.push(b);
        }
      ), pool.used = roundUpToMultipleOf8(pool.used + toRead);
    };
    ReadStream2.prototype._destroy = function(err, cb) {
      if (this._opening && !Buffer.isBuffer(this.handle)) {
        this.once("open", closeStream.bind(null, this, cb, err));
        return;
      }
      closeStream(this, cb, err), this.handle = null, this._opening = !1;
    };
    function closeStream(stream, cb, err) {
      if (!stream.handle)
        return onclose();
      stream.sftp.close(stream.handle, onclose);
      function onclose(er) {
        er = er || err, cb(er), stream.isClosed = !0, er || stream.emit("close");
      }
    }
    ReadStream2.prototype.close = function(cb) {
      this.destroy(null, cb);
    };
    Object.defineProperty(ReadStream2.prototype, "pending", {
      get() {
        return this.handle === null;
      },
      configurable: !0
    });
    function WriteStream2(sftp, path8, options) {
      if (options === void 0)
        options = {};
      else if (typeof options == "string")
        options = { encoding: options };
      else {
        if (options === null || typeof options != "object")
          throw new TypeError('"options" argument must be a string or an object');
        options = Object.create(options);
      }
      options.emitClose = !1, options.autoDestroy = !1, WritableStream.call(this, options), this.path = path8, this.flags = options.flags === void 0 ? "w" : options.flags, this.mode = options.mode === void 0 ? 438 : options.mode, this.start = options.start, this.autoClose = options.autoClose === void 0 ? !0 : options.autoClose, this.pos = 0, this.bytesWritten = 0, this.isClosed = !1, this.handle = options.handle === void 0 ? null : options.handle, this.sftp = sftp, this._opening = !1, this.start !== void 0 && (checkPosition(this.start, "start"), this.pos = this.start), options.encoding && this.setDefaultEncoding(options.encoding), this.on("finish", function() {
        this._writableState.finalCalled || this.autoClose && this.destroy();
      }), Buffer.isBuffer(this.handle) || this.open();
    }
    inherits(WriteStream2, WritableStream);
    WriteStream2.prototype._final = function(cb) {
      this.autoClose && this.destroy(), cb();
    };
    WriteStream2.prototype.open = function() {
      this._opening || (this._opening = !0, this.sftp.open(this.path, this.flags, this.mode, (er, handle) => {
        if (this._opening = !1, er) {
          this.emit("error", er), this.autoClose && this.destroy();
          return;
        }
        this.handle = handle;
        let tryAgain = (err) => {
          if (err) {
            this.sftp.chmod(this.path, this.mode, (err_) => tryAgain());
            return;
          }
          if (this.flags[0] === "a") {
            let tryStat = (err2, st) => {
              if (err2) {
                this.sftp.stat(this.path, (err_, st_) => {
                  if (err_) {
                    this.destroy(), this.emit("error", err2);
                    return;
                  }
                  tryStat(null, st_);
                });
                return;
              }
              this.pos = st.size, this.emit("open", handle), this.emit("ready");
            };
            this.sftp.fstat(handle, tryStat);
            return;
          }
          this.emit("open", handle), this.emit("ready");
        };
        this.sftp.fchmod(handle, this.mode, tryAgain);
      }));
    };
    WriteStream2.prototype._write = function(data, encoding, cb) {
      if (!Buffer.isBuffer(data)) {
        let err = new ERR_INVALID_ARG_TYPE("data", "Buffer", data);
        return this.emit("error", err);
      }
      if (!Buffer.isBuffer(this.handle))
        return this.once("open", function() {
          this._write(data, encoding, cb);
        });
      this.sftp.write(
        this.handle,
        data,
        0,
        data.length,
        this.pos,
        (er, bytes) => {
          if (er)
            return this.autoClose && this.destroy(), cb(er);
          this.bytesWritten += bytes, cb();
        }
      ), this.pos += data.length;
    };
    WriteStream2.prototype._writev = function(data, cb) {
      if (!Buffer.isBuffer(this.handle))
        return this.once("open", function() {
          this._writev(data, cb);
        });
      let sftp = this.sftp, handle = this.handle, writesLeft = data.length, onwrite = (er, bytes) => {
        if (er)
          return this.destroy(), cb(er);
        this.bytesWritten += bytes, --writesLeft === 0 && cb();
      };
      for (let i = 0; i < data.length; ++i) {
        let chunk = data[i].chunk;
        sftp.write(handle, chunk, 0, chunk.length, this.pos, onwrite), this.pos += chunk.length;
      }
    };
    typeof WritableStream.prototype.destroy != "function" && (WriteStream2.prototype.destroy = ReadStream2.prototype.destroy);
    WriteStream2.prototype._destroy = ReadStream2.prototype._destroy;
    WriteStream2.prototype.close = function(cb) {
      if (cb) {
        if (this.isClosed) {
          process.nextTick(cb);
          return;
        }
        this.on("close", cb);
      }
      this.autoClose || this.on("finish", this.destroy.bind(this)), this.end();
    };
    WriteStream2.prototype.destroySoon = WriteStream2.prototype.end;
    Object.defineProperty(WriteStream2.prototype, "pending", {
      get() {
        return this.handle === null;
      },
      configurable: !0
    });
    module2.exports = {
      flagsToString,
      OPEN_MODE,
      SFTP,
      Stats,
      STATUS_CODE,
      stringToFlags
    };
  }
});

// node_modules/ssh2/lib/Channel.js
var require_Channel = __commonJS({
  "node_modules/ssh2/lib/Channel.js"(exports2, module2) {
    "use strict";
    var {
      Duplex: DuplexStream,
      Readable: ReadableStream,
      Writable: WritableStream
    } = require("stream"), {
      CHANNEL_EXTENDED_DATATYPE: { STDERR }
    } = require_constants6(), { bufferSlice } = require_utils5(), PACKET_SIZE = 32 * 1024, MAX_WINDOW = 2 * 1024 * 1024, WINDOW_THRESHOLD = MAX_WINDOW / 2, ClientStderr = class extends ReadableStream {
      constructor(channel, streamOpts) {
        super(streamOpts), this._channel = channel;
      }
      _read(n) {
        this._channel._waitChanDrain && (this._channel._waitChanDrain = !1, this._channel.incoming.window <= WINDOW_THRESHOLD && windowAdjust(this._channel));
      }
    }, ServerStderr = class extends WritableStream {
      constructor(channel) {
        super({ highWaterMark: MAX_WINDOW }), this._channel = channel;
      }
      _write(data, encoding, cb) {
        let channel = this._channel, protocol = channel._client._protocol, outgoing = channel.outgoing, packetSize = outgoing.packetSize, id = outgoing.id, window2 = outgoing.window, len = data.length, p = 0;
        if (outgoing.state === "open") {
          for (; len - p > 0 && window2 > 0; ) {
            let sliceLen = len - p;
            sliceLen > window2 && (sliceLen = window2), sliceLen > packetSize && (sliceLen = packetSize), p === 0 && sliceLen === len ? protocol.channelExtData(id, data, STDERR) : protocol.channelExtData(id, bufferSlice(data, p, p + sliceLen), STDERR), p += sliceLen, window2 -= sliceLen;
          }
          if (outgoing.window = window2, len - p > 0) {
            window2 === 0 && (channel._waitWindow = !0), p > 0 ? channel._chunkErr = bufferSlice(data, p, len) : channel._chunkErr = data, channel._chunkcbErr = cb;
            return;
          }
          cb();
        }
      }
    }, Channel = class extends DuplexStream {
      constructor(client, info, opts) {
        let streamOpts = {
          highWaterMark: MAX_WINDOW,
          allowHalfOpen: !opts || opts && opts.allowHalfOpen !== !1,
          emitClose: !1
        };
        super(streamOpts), this.allowHalfOpen = streamOpts.allowHalfOpen;
        let server = !!(opts && opts.server);
        this.server = server, this.type = info.type, this.subtype = void 0, this.incoming = info.incoming, this.outgoing = info.outgoing, this._callbacks = [], this._client = client, this._hasX11 = !1, this._exit = {
          code: void 0,
          signal: void 0,
          dump: void 0,
          desc: void 0
        }, this.stdin = this.stdout = this, server ? this.stderr = new ServerStderr(this) : this.stderr = new ClientStderr(this, streamOpts), this._waitWindow = !1, this._waitChanDrain = !1, this._chunk = void 0, this._chunkcb = void 0, this._chunkErr = void 0, this._chunkcbErr = void 0, this.on("finish", onFinish).on("prefinish", onFinish), this.on("end", onEnd).on("close", onEnd);
      }
      _read(n) {
        this._waitChanDrain && (this._waitChanDrain = !1, this.incoming.window <= WINDOW_THRESHOLD && windowAdjust(this));
      }
      _write(data, encoding, cb) {
        let protocol = this._client._protocol, outgoing = this.outgoing, packetSize = outgoing.packetSize, id = outgoing.id, window2 = outgoing.window, len = data.length, p = 0;
        if (outgoing.state === "open") {
          for (; len - p > 0 && window2 > 0; ) {
            let sliceLen = len - p;
            sliceLen > window2 && (sliceLen = window2), sliceLen > packetSize && (sliceLen = packetSize), p === 0 && sliceLen === len ? protocol.channelData(id, data) : protocol.channelData(id, bufferSlice(data, p, p + sliceLen)), p += sliceLen, window2 -= sliceLen;
          }
          if (outgoing.window = window2, len - p > 0) {
            window2 === 0 && (this._waitWindow = !0), p > 0 ? this._chunk = bufferSlice(data, p, len) : this._chunk = data, this._chunkcb = cb;
            return;
          }
          cb();
        }
      }
      eof() {
        this.outgoing.state === "open" && (this.outgoing.state = "eof", this._client._protocol.channelEOF(this.outgoing.id));
      }
      close() {
        (this.outgoing.state === "open" || this.outgoing.state === "eof") && (this.outgoing.state = "closing", this._client._protocol.channelClose(this.outgoing.id));
      }
      destroy() {
        return this.end(), this.close(), this;
      }
      // Session type-specific methods =============================================
      setWindow(rows, cols, height, width) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        this.type === "session" && (this.subtype === "shell" || this.subtype === "exec") && this.writable && this.outgoing.state === "open" && this._client._protocol.windowChange(
          this.outgoing.id,
          rows,
          cols,
          height,
          width
        );
      }
      signal(signalName) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        this.type === "session" && this.writable && this.outgoing.state === "open" && this._client._protocol.signal(this.outgoing.id, signalName);
      }
      exit(statusOrSignal, coreDumped, msg) {
        if (!this.server)
          throw new Error("Server-only method called in client mode");
        this.type === "session" && this.writable && this.outgoing.state === "open" && (typeof statusOrSignal == "number" ? this._client._protocol.exitStatus(this.outgoing.id, statusOrSignal) : this._client._protocol.exitSignal(
          this.outgoing.id,
          statusOrSignal,
          coreDumped,
          msg
        ));
      }
    };
    function onFinish() {
      this.eof(), (this.server || !this.allowHalfOpen) && this.close(), this.writable = !1;
    }
    function onEnd() {
      this.readable = !1;
    }
    function windowAdjust(self2) {
      if (self2.outgoing.state === "closed")
        return;
      let amt = MAX_WINDOW - self2.incoming.window;
      amt <= 0 || (self2.incoming.window += amt, self2._client._protocol.channelWindowAdjust(self2.outgoing.id, amt));
    }
    module2.exports = {
      Channel,
      MAX_WINDOW,
      PACKET_SIZE,
      windowAdjust,
      WINDOW_THRESHOLD
    };
  }
});

// node_modules/ssh2/lib/utils.js
var require_utils6 = __commonJS({
  "node_modules/ssh2/lib/utils.js"(exports2, module2) {
    "use strict";
    var { SFTP } = require_SFTP(), MAX_CHANNEL = 2 ** 32 - 1;
    function onChannelOpenFailure(self2, recipient, info, cb) {
      if (self2._chanMgr.remove(recipient), typeof cb != "function")
        return;
      let err;
      info instanceof Error ? err = info : typeof info == "object" && info !== null ? (err = new Error(`(SSH) Channel open failure: ${info.description}`), err.reason = info.reason) : (err = new Error(
        "(SSH) Channel open failure: server closed channel unexpectedly"
      ), err.reason = ""), cb(err);
    }
    function onCHANNEL_CLOSE(self2, recipient, channel, err, dead) {
      if (typeof channel == "function") {
        onChannelOpenFailure(self2, recipient, err, channel);
        return;
      }
      if (typeof channel != "object" || channel === null || channel.incoming && channel.incoming.state === "closed" || (self2._chanMgr.remove(recipient), channel.server && channel.constructor.name === "Session"))
        return;
      channel.incoming.state = "closed", channel.readable && channel.push(null), channel.server ? channel.stderr.writable && channel.stderr.end() : channel.stderr.readable && channel.stderr.push(null), channel.constructor !== SFTP && (channel.outgoing.state === "open" || channel.outgoing.state === "eof") && !dead && channel.close(), channel.outgoing.state === "closing" && (channel.outgoing.state = "closed");
      let readState = channel._readableState, writeState = channel._writableState;
      writeState && !writeState.ending && !writeState.finished && !dead && channel.end();
      let chanCallbacks = channel._callbacks;
      channel._callbacks = [];
      for (let i = 0; i < chanCallbacks.length; ++i)
        chanCallbacks[i](!0);
      if (channel.server)
        !channel.readable || channel.destroyed || readState && readState.endEmitted ? channel.emit("close") : channel.once("end", () => channel.emit("close"));
      else {
        let doClose;
        switch (channel.type) {
          case "direct-streamlocal@openssh.com":
          case "direct-tcpip":
            doClose = () => channel.emit("close");
            break;
          default: {
            let exit2 = channel._exit;
            doClose = () => {
              exit2.code === null ? channel.emit("close", exit2.code, exit2.signal, exit2.dump, exit2.desc) : channel.emit("close", exit2.code);
            };
          }
        }
        !channel.readable || channel.destroyed || readState && readState.endEmitted ? doClose() : channel.once("end", doClose);
        let errReadState = channel.stderr._readableState;
        !channel.stderr.readable || channel.stderr.destroyed || errReadState && errReadState.endEmitted ? channel.stderr.emit("close") : channel.stderr.once("end", () => channel.stderr.emit("close"));
      }
    }
    var ChannelManager = class {
      constructor(client) {
        this._client = client, this._channels = {}, this._cur = -1, this._count = 0;
      }
      add(val) {
        let id;
        if (this._cur < MAX_CHANNEL)
          id = ++this._cur;
        else if (this._count === 0)
          this._cur = 0, id = 0;
        else {
          let channels = this._channels;
          for (let i = 0; i < MAX_CHANNEL; ++i)
            if (channels[i] === void 0) {
              id = i;
              break;
            }
        }
        return id === void 0 ? -1 : (this._channels[id] = val || !0, ++this._count, id);
      }
      update(id, val) {
        if (typeof id != "number" || id < 0 || id >= MAX_CHANNEL || !isFinite(id))
          throw new Error(`Invalid channel id: ${id}`);
        val && this._channels[id] && (this._channels[id] = val);
      }
      get(id) {
        if (typeof id != "number" || id < 0 || id >= MAX_CHANNEL || !isFinite(id))
          throw new Error(`Invalid channel id: ${id}`);
        return this._channels[id];
      }
      remove(id) {
        if (typeof id != "number" || id < 0 || id >= MAX_CHANNEL || !isFinite(id))
          throw new Error(`Invalid channel id: ${id}`);
        this._channels[id] && (delete this._channels[id], this._count && --this._count);
      }
      cleanup(err) {
        let channels = this._channels;
        this._channels = {}, this._cur = -1, this._count = 0;
        let chanIDs = Object.keys(channels), client = this._client;
        for (let i = 0; i < chanIDs.length; ++i) {
          let id = +chanIDs[i], channel = channels[id];
          onCHANNEL_CLOSE(client, id, channel._channel || channel, err, !0);
        }
      }
    }, isRegExp = /* @__PURE__ */ (() => {
      let toString = Object.prototype.toString;
      return (val) => toString.call(val) === "[object RegExp]";
    })();
    function generateAlgorithmList(algoList, defaultList, supportedList) {
      if (Array.isArray(algoList) && algoList.length > 0) {
        for (let i = 0; i < algoList.length; ++i)
          if (supportedList.indexOf(algoList[i]) === -1)
            throw new Error(`Unsupported algorithm: ${algoList[i]}`);
        return algoList;
      }
      if (typeof algoList == "object" && algoList !== null) {
        let keys = Object.keys(algoList), list2 = defaultList;
        for (let i = 0; i < keys.length; ++i) {
          let key = keys[i], val = algoList[key];
          switch (key) {
            case "append":
              if (Array.isArray(val) || (val = [val]), Array.isArray(val))
                for (let j = 0; j < val.length; ++j) {
                  let append = val[j];
                  if (typeof append == "string") {
                    if (!append || list2.indexOf(append) !== -1)
                      continue;
                    if (supportedList.indexOf(append) === -1)
                      throw new Error(`Unsupported algorithm: ${append}`);
                    list2 === defaultList && (list2 = list2.slice()), list2.push(append);
                  } else if (isRegExp(append))
                    for (let k = 0; k < supportedList.length; ++k) {
                      let algo = supportedList[k];
                      if (append.test(algo)) {
                        if (list2.indexOf(algo) !== -1)
                          continue;
                        list2 === defaultList && (list2 = list2.slice()), list2.push(algo);
                      }
                    }
                }
              break;
            case "prepend":
              if (Array.isArray(val) || (val = [val]), Array.isArray(val))
                for (let j = val.length; j >= 0; --j) {
                  let prepend = val[j];
                  if (typeof prepend == "string") {
                    if (!prepend || list2.indexOf(prepend) !== -1)
                      continue;
                    if (supportedList.indexOf(prepend) === -1)
                      throw new Error(`Unsupported algorithm: ${prepend}`);
                    list2 === defaultList && (list2 = list2.slice()), list2.unshift(prepend);
                  } else if (isRegExp(prepend))
                    for (let k = supportedList.length; k >= 0; --k) {
                      let algo = supportedList[k];
                      if (prepend.test(algo)) {
                        if (list2.indexOf(algo) !== -1)
                          continue;
                        list2 === defaultList && (list2 = list2.slice()), list2.unshift(algo);
                      }
                    }
                }
              break;
            case "remove":
              if (Array.isArray(val) || (val = [val]), Array.isArray(val))
                for (let j = 0; j < val.length; ++j) {
                  let search = val[j];
                  if (typeof search == "string") {
                    if (!search)
                      continue;
                    let idx = list2.indexOf(search);
                    if (idx === -1)
                      continue;
                    list2 === defaultList && (list2 = list2.slice()), list2.splice(idx, 1);
                  } else if (isRegExp(search))
                    for (let k = 0; k < list2.length; ++k)
                      search.test(list2[k]) && (list2 === defaultList && (list2 = list2.slice()), list2.splice(k, 1), --k);
                }
              break;
          }
        }
        return list2;
      }
      return defaultList;
    }
    module2.exports = {
      ChannelManager,
      generateAlgorithmList,
      onChannelOpenFailure,
      onCHANNEL_CLOSE,
      isWritable: (stream) => stream && stream.writable && stream._readableState && stream._readableState.ended === !1
    };
  }
});

// node_modules/ssh2/lib/client.js
var require_client2 = __commonJS({
  "node_modules/ssh2/lib/client.js"(exports2, module2) {
    "use strict";
    var {
      createHash,
      getHashes,
      randomFillSync
    } = require("crypto"), { Socket } = require("net"), { lookup: dnsLookup } = require("dns"), EventEmitter2 = require("events"), HASHES = getHashes(), {
      COMPAT,
      CHANNEL_EXTENDED_DATATYPE: { STDERR },
      CHANNEL_OPEN_FAILURE,
      DEFAULT_CIPHER,
      DEFAULT_COMPRESSION,
      DEFAULT_KEX,
      DEFAULT_MAC,
      DEFAULT_SERVER_HOST_KEY,
      DISCONNECT_REASON,
      DISCONNECT_REASON_BY_VALUE,
      SUPPORTED_CIPHER,
      SUPPORTED_COMPRESSION,
      SUPPORTED_KEX,
      SUPPORTED_MAC,
      SUPPORTED_SERVER_HOST_KEY
    } = require_constants6(), { init: cryptoInit } = require_crypto(), Protocol = require_Protocol(), { parseKey } = require_keyParser(), { SFTP } = require_SFTP(), {
      bufferCopy,
      makeBufferParser,
      makeError,
      readUInt32BE,
      sigSSHToASN1,
      writeUInt32BE
    } = require_utils5(), { AgentContext, createAgent, isAgent } = require_agent2(), {
      Channel,
      MAX_WINDOW,
      PACKET_SIZE,
      windowAdjust,
      WINDOW_THRESHOLD
    } = require_Channel(), {
      ChannelManager,
      generateAlgorithmList,
      isWritable: isWritable2,
      onChannelOpenFailure,
      onCHANNEL_CLOSE
    } = require_utils6(), bufferParser = makeBufferParser(), sigParser = makeBufferParser(), RE_OPENSSH = /^OpenSSH_(?:(?![0-4])\d)|(?:\d{2,})/, noop2 = (err) => {
    }, Client = class extends EventEmitter2 {
      constructor() {
        super(), this.config = {
          host: void 0,
          port: void 0,
          localAddress: void 0,
          localPort: void 0,
          forceIPv4: void 0,
          forceIPv6: void 0,
          keepaliveCountMax: void 0,
          keepaliveInterval: void 0,
          readyTimeout: void 0,
          ident: void 0,
          username: void 0,
          password: void 0,
          privateKey: void 0,
          tryKeyboard: void 0,
          agent: void 0,
          allowAgentFwd: void 0,
          authHandler: void 0,
          hostHashAlgo: void 0,
          hostHashCb: void 0,
          strictVendor: void 0,
          debug: void 0
        }, this._agent = void 0, this._readyTimeout = void 0, this._chanMgr = void 0, this._callbacks = void 0, this._forwarding = void 0, this._forwardingUnix = void 0, this._acceptX11 = void 0, this._agentFwdEnabled = void 0, this._remoteVer = void 0, this._protocol = void 0, this._sock = void 0, this._resetKA = void 0;
      }
      connect(cfg) {
        if (this._sock && isWritable2(this._sock))
          return this.once("close", () => {
            this.connect(cfg);
          }), this.end(), this;
        this.config.host = cfg.hostname || cfg.host || "localhost", this.config.port = cfg.port || 22, this.config.localAddress = typeof cfg.localAddress == "string" ? cfg.localAddress : void 0, this.config.localPort = typeof cfg.localPort == "string" || typeof cfg.localPort == "number" ? cfg.localPort : void 0, this.config.forceIPv4 = cfg.forceIPv4 || !1, this.config.forceIPv6 = cfg.forceIPv6 || !1, this.config.keepaliveCountMax = typeof cfg.keepaliveCountMax == "number" && cfg.keepaliveCountMax >= 0 ? cfg.keepaliveCountMax : 3, this.config.keepaliveInterval = typeof cfg.keepaliveInterval == "number" && cfg.keepaliveInterval > 0 ? cfg.keepaliveInterval : 0, this.config.readyTimeout = typeof cfg.readyTimeout == "number" && cfg.readyTimeout >= 0 ? cfg.readyTimeout : 2e4, this.config.ident = typeof cfg.ident == "string" || Buffer.isBuffer(cfg.ident) ? cfg.ident : void 0;
        let algorithms = {
          kex: void 0,
          serverHostKey: void 0,
          cs: {
            cipher: void 0,
            mac: void 0,
            compress: void 0,
            lang: []
          },
          sc: void 0
        }, allOfferDefaults = !0;
        if (typeof cfg.algorithms == "object" && cfg.algorithms !== null && (algorithms.kex = generateAlgorithmList(
          cfg.algorithms.kex,
          DEFAULT_KEX,
          SUPPORTED_KEX
        ), algorithms.kex !== DEFAULT_KEX && (allOfferDefaults = !1), algorithms.serverHostKey = generateAlgorithmList(
          cfg.algorithms.serverHostKey,
          DEFAULT_SERVER_HOST_KEY,
          SUPPORTED_SERVER_HOST_KEY
        ), algorithms.serverHostKey !== DEFAULT_SERVER_HOST_KEY && (allOfferDefaults = !1), algorithms.cs.cipher = generateAlgorithmList(
          cfg.algorithms.cipher,
          DEFAULT_CIPHER,
          SUPPORTED_CIPHER
        ), algorithms.cs.cipher !== DEFAULT_CIPHER && (allOfferDefaults = !1), algorithms.cs.mac = generateAlgorithmList(
          cfg.algorithms.hmac,
          DEFAULT_MAC,
          SUPPORTED_MAC
        ), algorithms.cs.mac !== DEFAULT_MAC && (allOfferDefaults = !1), algorithms.cs.compress = generateAlgorithmList(
          cfg.algorithms.compress,
          DEFAULT_COMPRESSION,
          SUPPORTED_COMPRESSION
        ), algorithms.cs.compress !== DEFAULT_COMPRESSION && (allOfferDefaults = !1), allOfferDefaults || (algorithms.sc = algorithms.cs)), typeof cfg.username == "string")
          this.config.username = cfg.username;
        else if (typeof cfg.user == "string")
          this.config.username = cfg.user;
        else
          throw new Error("Invalid username");
        this.config.password = typeof cfg.password == "string" ? cfg.password : void 0, this.config.privateKey = typeof cfg.privateKey == "string" || Buffer.isBuffer(cfg.privateKey) ? cfg.privateKey : void 0, this.config.localHostname = typeof cfg.localHostname == "string" ? cfg.localHostname : void 0, this.config.localUsername = typeof cfg.localUsername == "string" ? cfg.localUsername : void 0, this.config.tryKeyboard = cfg.tryKeyboard === !0, typeof cfg.agent == "string" && cfg.agent.length ? this.config.agent = createAgent(cfg.agent) : isAgent(cfg.agent) ? this.config.agent = cfg.agent : this.config.agent = void 0, this.config.allowAgentFwd = cfg.agentForward === !0 && this.config.agent !== void 0;
        let authHandler = this.config.authHandler = typeof cfg.authHandler == "function" || Array.isArray(cfg.authHandler) ? cfg.authHandler : void 0;
        this.config.strictVendor = typeof cfg.strictVendor == "boolean" ? cfg.strictVendor : !0;
        let debug = this.config.debug = typeof cfg.debug == "function" ? cfg.debug : void 0;
        if (cfg.agentForward === !0 && !this.config.allowAgentFwd)
          throw new Error(
            "You must set a valid agent path to allow agent forwarding"
          );
        let callbacks = this._callbacks = [];
        this._chanMgr = new ChannelManager(this), this._forwarding = {}, this._forwardingUnix = {}, this._acceptX11 = 0, this._agentFwdEnabled = !1, this._agent = this.config.agent ? this.config.agent : void 0, this._remoteVer = void 0;
        let privateKey;
        if (this.config.privateKey) {
          if (privateKey = parseKey(this.config.privateKey, cfg.passphrase), privateKey instanceof Error)
            throw new Error(`Cannot parse privateKey: ${privateKey.message}`);
          if (Array.isArray(privateKey) && (privateKey = privateKey[0]), privateKey.getPrivatePEM() === null)
            throw new Error(
              "privateKey value does not contain a (valid) private key"
            );
        }
        let hostVerifier;
        if (typeof cfg.hostVerifier == "function") {
          let hashCb = cfg.hostVerifier, hashAlgo;
          HASHES.indexOf(cfg.hostHash) !== -1 && (hashAlgo = cfg.hostHash), hostVerifier = (key, verify) => {
            hashAlgo && (key = createHash(hashAlgo).update(key).digest("hex"));
            let ret = hashCb(key, verify);
            ret !== void 0 && verify(ret);
          };
        }
        let sock = this._sock = cfg.sock || new Socket(), ready = !1, sawHeader = !1;
        this._protocol && this._protocol.cleanup();
        let DEBUG_HANDLER = debug ? (p, display, msg) => {
          debug(`Debug output from server: ${JSON.stringify(msg)}`);
        } : void 0, serverSigAlgs, proto = this._protocol = new Protocol({
          ident: this.config.ident,
          offer: allOfferDefaults ? void 0 : algorithms,
          onWrite: (data) => {
            isWritable2(sock) && sock.write(data);
          },
          onError: (err) => {
            err.level === "handshake" && clearTimeout(this._readyTimeout), proto._destruct || sock.removeAllListeners("data"), this.emit("error", err);
            try {
              sock.end();
            } catch {
            }
          },
          onHeader: (header) => {
            sawHeader = !0, this._remoteVer = header.versions.software, header.greeting && this.emit("greeting", header.greeting);
          },
          onHandshakeComplete: (negotiated) => {
            this.emit("handshake", negotiated), ready || (ready = !0, proto.service("ssh-userauth"));
          },
          debug,
          hostVerifier,
          messageHandlers: {
            DEBUG: DEBUG_HANDLER,
            DISCONNECT: (p, reason, desc) => {
              if (reason !== DISCONNECT_REASON.BY_APPLICATION) {
                desc || (desc = DISCONNECT_REASON_BY_VALUE[reason], desc === void 0 && (desc = `Unexpected disconnection reason: ${reason}`));
                let err = new Error(desc);
                err.code = reason, this.emit("error", err);
              }
              sock.end();
            },
            SERVICE_ACCEPT: (p, name2) => {
              name2 === "ssh-userauth" && tryNextAuth();
            },
            EXT_INFO: (p, exts) => {
              if (serverSigAlgs === void 0) {
                for (let ext of exts)
                  if (ext.name === "server-sig-algs") {
                    serverSigAlgs = ext.algs;
                    return;
                  }
                serverSigAlgs = null;
              }
            },
            USERAUTH_BANNER: (p, msg) => {
              this.emit("banner", msg);
            },
            USERAUTH_SUCCESS: (p) => {
              resetKA(), clearTimeout(this._readyTimeout), this.emit("ready");
            },
            USERAUTH_FAILURE: (p, authMethods, partialSuccess) => {
              if (curAuth.keyAlgos) {
                let oldKeyAlgo = curAuth.keyAlgos[0][0];
                if (debug && debug(`Client: ${curAuth.type} (${oldKeyAlgo}) auth failed`), curAuth.keyAlgos.shift(), curAuth.keyAlgos.length) {
                  let [keyAlgo, hashAlgo] = curAuth.keyAlgos[0];
                  switch (curAuth.type) {
                    case "agent":
                      proto.authPK(
                        curAuth.username,
                        curAuth.agentCtx.currentKey(),
                        keyAlgo
                      );
                      return;
                    case "publickey":
                      proto.authPK(curAuth.username, curAuth.key, keyAlgo);
                      return;
                    case "hostbased":
                      proto.authHostbased(
                        curAuth.username,
                        curAuth.key,
                        curAuth.localHostname,
                        curAuth.localUsername,
                        keyAlgo,
                        (buf, cb) => {
                          let signature = curAuth.key.sign(buf, hashAlgo);
                          if (signature instanceof Error)
                            return signature.message = `Error while signing with key: ${signature.message}`, signature.level = "client-authentication", this.emit("error", signature), tryNextAuth();
                          cb(signature);
                        }
                      );
                      return;
                  }
                } else
                  curAuth.keyAlgos = void 0;
              }
              if (curAuth.type === "agent") {
                let pos2 = curAuth.agentCtx.pos();
                return debug && debug(`Client: Agent key #${pos2 + 1} failed`), tryNextAgentKey();
              }
              debug && debug(`Client: ${curAuth.type} auth failed`), curPartial = partialSuccess, curAuthsLeft = authMethods, tryNextAuth();
            },
            USERAUTH_PASSWD_CHANGEREQ: (p, prompt) => {
              curAuth.type === "password" && this.emit("change password", prompt, (newPassword) => {
                proto.authPassword(
                  this.config.username,
                  this.config.password,
                  newPassword
                );
              });
            },
            USERAUTH_PK_OK: (p) => {
              let keyAlgo, hashAlgo;
              if (curAuth.keyAlgos && ([keyAlgo, hashAlgo] = curAuth.keyAlgos[0]), curAuth.type === "agent") {
                let key = curAuth.agentCtx.currentKey();
                proto.authPK(curAuth.username, key, keyAlgo, (buf, cb) => {
                  let opts = { hash: hashAlgo };
                  curAuth.agentCtx.sign(key, buf, opts, (err, signed) => {
                    if (err)
                      err.level = "agent", this.emit("error", err);
                    else
                      return cb(signed);
                    tryNextAgentKey();
                  });
                });
              } else curAuth.type === "publickey" && proto.authPK(curAuth.username, curAuth.key, keyAlgo, (buf, cb) => {
                let signature = curAuth.key.sign(buf, hashAlgo);
                if (signature instanceof Error)
                  return signature.message = `Error signing data with key: ${signature.message}`, signature.level = "client-authentication", this.emit("error", signature), tryNextAuth();
                cb(signature);
              });
            },
            USERAUTH_INFO_REQUEST: (p, name2, instructions, prompts) => {
              if (curAuth.type === "keyboard-interactive") {
                if ((Array.isArray(prompts) ? prompts.length : 0) === 0) {
                  debug && debug(
                    "Client: Sending automatic USERAUTH_INFO_RESPONSE"
                  ), proto.authInfoRes();
                  return;
                }
                curAuth.prompt(
                  name2,
                  instructions,
                  "",
                  prompts,
                  (answers) => {
                    proto.authInfoRes(answers);
                  }
                );
              }
            },
            REQUEST_SUCCESS: (p, data) => {
              callbacks.length && callbacks.shift()(!1, data);
            },
            REQUEST_FAILURE: (p) => {
              callbacks.length && callbacks.shift()(!0);
            },
            GLOBAL_REQUEST: (p, name2, wantReply, data) => {
              switch (name2) {
                case "hostkeys-00@openssh.com":
                  hostKeysProve(this, data, (err, keys) => {
                    err || this.emit("hostkeys", keys);
                  }), wantReply && proto.requestSuccess();
                  break;
                default:
                  wantReply && proto.requestFailure();
              }
            },
            CHANNEL_OPEN: (p, info) => {
              onCHANNEL_OPEN(this, info);
            },
            CHANNEL_OPEN_CONFIRMATION: (p, info) => {
              let channel = this._chanMgr.get(info.recipient);
              if (typeof channel != "function")
                return;
              let isSFTP = channel.type === "sftp", chanInfo = {
                type: isSFTP ? "session" : channel.type,
                incoming: {
                  id: info.recipient,
                  window: MAX_WINDOW,
                  packetSize: PACKET_SIZE,
                  state: "open"
                },
                outgoing: {
                  id: info.sender,
                  window: info.window,
                  packetSize: info.packetSize,
                  state: "open"
                }
              }, instance = isSFTP ? new SFTP(this, chanInfo, { debug }) : new Channel(this, chanInfo);
              this._chanMgr.update(info.recipient, instance), channel(void 0, instance);
            },
            CHANNEL_OPEN_FAILURE: (p, recipient, reason, description) => {
              let channel = this._chanMgr.get(recipient);
              if (typeof channel != "function")
                return;
              onChannelOpenFailure(this, recipient, { reason, description }, channel);
            },
            CHANNEL_DATA: (p, recipient, data) => {
              let channel = this._chanMgr.get(recipient);
              if (!(typeof channel != "object" || channel === null) && channel.incoming.window !== 0) {
                if (channel.incoming.window -= data.length, channel.push(data) === !1) {
                  channel._waitChanDrain = !0;
                  return;
                }
                channel.incoming.window <= WINDOW_THRESHOLD && windowAdjust(channel);
              }
            },
            CHANNEL_EXTENDED_DATA: (p, recipient, data, type) => {
              if (type !== STDERR)
                return;
              let channel = this._chanMgr.get(recipient);
              if (!(typeof channel != "object" || channel === null) && channel.incoming.window !== 0) {
                if (channel.incoming.window -= data.length, !channel.stderr.push(data)) {
                  channel._waitChanDrain = !0;
                  return;
                }
                channel.incoming.window <= WINDOW_THRESHOLD && windowAdjust(channel);
              }
            },
            CHANNEL_WINDOW_ADJUST: (p, recipient, amount) => {
              let channel = this._chanMgr.get(recipient);
              typeof channel != "object" || channel === null || (channel.outgoing.window += amount, channel._waitWindow && (channel._waitWindow = !1, channel._chunk ? channel._write(channel._chunk, null, channel._chunkcb) : channel._chunkcb ? channel._chunkcb() : channel._chunkErr ? channel.stderr._write(
                channel._chunkErr,
                null,
                channel._chunkcbErr
              ) : channel._chunkcbErr && channel._chunkcbErr()));
            },
            CHANNEL_SUCCESS: (p, recipient) => {
              let channel = this._chanMgr.get(recipient);
              typeof channel != "object" || channel === null || (this._resetKA(), channel._callbacks.length && channel._callbacks.shift()(!1));
            },
            CHANNEL_FAILURE: (p, recipient) => {
              let channel = this._chanMgr.get(recipient);
              typeof channel != "object" || channel === null || (this._resetKA(), channel._callbacks.length && channel._callbacks.shift()(!0));
            },
            CHANNEL_REQUEST: (p, recipient, type, wantReply, data) => {
              let channel = this._chanMgr.get(recipient);
              if (typeof channel != "object" || channel === null)
                return;
              let exit2 = channel._exit;
              if (exit2.code === void 0) {
                switch (type) {
                  case "exit-status":
                    channel.emit("exit", exit2.code = data);
                    return;
                  case "exit-signal":
                    channel.emit(
                      "exit",
                      exit2.code = null,
                      exit2.signal = `SIG${data.signal}`,
                      exit2.dump = data.coreDumped,
                      exit2.desc = data.errorMessage
                    );
                    return;
                }
                wantReply && p.channelFailure(channel.outgoing.id);
              }
            },
            CHANNEL_EOF: (p, recipient) => {
              let channel = this._chanMgr.get(recipient);
              typeof channel != "object" || channel === null || channel.incoming.state === "open" && (channel.incoming.state = "eof", channel.readable && channel.push(null), channel.stderr.readable && channel.stderr.push(null));
            },
            CHANNEL_CLOSE: (p, recipient) => {
              onCHANNEL_CLOSE(this, recipient, this._chanMgr.get(recipient));
            }
          }
        });
        sock.pause();
        let kainterval = this.config.keepaliveInterval, kacountmax = this.config.keepaliveCountMax, kacount = 0, katimer, sendKA = () => {
          if (++kacount > kacountmax) {
            if (clearInterval(katimer), sock.readable) {
              let err = new Error("Keepalive timeout");
              err.level = "client-timeout", this.emit("error", err), sock.destroy();
            }
            return;
          }
          isWritable2(sock) ? (callbacks.push(resetKA), proto.ping()) : clearInterval(katimer);
        };
        function resetKA() {
          kainterval > 0 && (kacount = 0, clearInterval(katimer), isWritable2(sock) && (katimer = setInterval(sendKA, kainterval)));
        }
        this._resetKA = resetKA;
        let onDone = /* @__PURE__ */ (() => {
          let called = !1;
          return () => {
            if (!called && (called = !0, wasConnected && !sawHeader)) {
              let err = makeError("Connection lost before handshake", "protocol", !0);
              this.emit("error", err);
            }
          };
        })(), onConnect = /* @__PURE__ */ (() => {
          let called = !1;
          return () => {
            called || (called = !0, wasConnected = !0, debug && debug("Socket connected"), this.emit("connect"), cryptoInit.then(() => {
              proto.start(), sock.on("data", (data) => {
                try {
                  proto.parse(data, 0, data.length);
                } catch (ex) {
                  this.emit("error", ex);
                  try {
                    isWritable2(sock) && sock.end();
                  } catch {
                  }
                }
              }), sock.stderr && typeof sock.stderr.resume == "function" && sock.stderr.resume(), sock.resume();
            }).catch((err) => {
              this.emit("error", err);
              try {
                isWritable2(sock) && sock.end();
              } catch {
              }
            }));
          };
        })(), wasConnected = !1;
        sock.on("connect", onConnect).on("timeout", () => {
          this.emit("timeout");
        }).on("error", (err) => {
          debug && debug(`Socket error: ${err.message}`), clearTimeout(this._readyTimeout), err.level = "client-socket", this.emit("error", err);
        }).on("end", () => {
          debug && debug("Socket ended"), onDone(), proto.cleanup(), clearTimeout(this._readyTimeout), clearInterval(katimer), this.emit("end");
        }).on("close", () => {
          debug && debug("Socket closed"), onDone(), proto.cleanup(), clearTimeout(this._readyTimeout), clearInterval(katimer), this.emit("close");
          let callbacks_ = callbacks;
          callbacks = this._callbacks = [];
          let err = new Error("No response from server");
          for (let i = 0; i < callbacks_.length; ++i)
            callbacks_[i](err);
          this._chanMgr.cleanup(err);
        });
        let curAuth, curPartial = null, curAuthsLeft = null, authsAllowed = ["none"];
        this.config.password !== void 0 && authsAllowed.push("password"), privateKey !== void 0 && authsAllowed.push("publickey"), this._agent !== void 0 && authsAllowed.push("agent"), this.config.tryKeyboard && authsAllowed.push("keyboard-interactive"), privateKey !== void 0 && this.config.localHostname !== void 0 && this.config.localUsername !== void 0 && authsAllowed.push("hostbased"), Array.isArray(authHandler) ? authHandler = makeSimpleAuthHandler(authHandler) : typeof authHandler != "function" && (authHandler = makeSimpleAuthHandler(authsAllowed));
        let hasSentAuth = !1, doNextAuth = (nextAuth) => {
          if (!hasSentAuth) {
            if (hasSentAuth = !0, nextAuth === !1) {
              let err = new Error("All configured authentication methods failed");
              err.level = "client-authentication", this.emit("error", err), this.end();
              return;
            }
            if (typeof nextAuth == "string") {
              let type = nextAuth;
              if (authsAllowed.indexOf(type) === -1)
                return skipAuth(`Authentication method not allowed: ${type}`);
              let username = this.config.username;
              switch (type) {
                case "password":
                  nextAuth = { type, username, password: this.config.password };
                  break;
                case "publickey":
                  nextAuth = { type, username, key: privateKey };
                  break;
                case "hostbased":
                  nextAuth = {
                    type,
                    username,
                    key: privateKey,
                    localHostname: this.config.localHostname,
                    localUsername: this.config.localUsername
                  };
                  break;
                case "agent":
                  nextAuth = {
                    type,
                    username,
                    agentCtx: new AgentContext(this._agent)
                  };
                  break;
                case "keyboard-interactive":
                  nextAuth = {
                    type,
                    username,
                    prompt: (...args) => this.emit("keyboard-interactive", ...args)
                  };
                  break;
                case "none":
                  nextAuth = { type, username };
                  break;
                default:
                  return skipAuth(
                    `Skipping unsupported authentication method: ${nextAuth}`
                  );
              }
            } else {
              if (typeof nextAuth != "object" || nextAuth === null)
                return skipAuth(
                  `Skipping invalid authentication attempt: ${nextAuth}`
                );
              {
                let username = nextAuth.username;
                if (typeof username != "string")
                  return skipAuth(
                    `Skipping invalid authentication attempt: ${nextAuth}`
                  );
                let type = nextAuth.type;
                switch (type) {
                  case "password": {
                    let { password } = nextAuth;
                    if (typeof password != "string" && !Buffer.isBuffer(password))
                      return skipAuth("Skipping invalid password auth attempt");
                    nextAuth = { type, username, password };
                    break;
                  }
                  case "publickey": {
                    let key = parseKey(nextAuth.key, nextAuth.passphrase);
                    if (key instanceof Error)
                      return skipAuth("Skipping invalid key auth attempt");
                    if (!key.isPrivateKey())
                      return skipAuth("Skipping non-private key");
                    nextAuth = { type, username, key };
                    break;
                  }
                  case "hostbased": {
                    let { localHostname, localUsername } = nextAuth, key = parseKey(nextAuth.key, nextAuth.passphrase);
                    if (key instanceof Error || typeof localHostname != "string" || typeof localUsername != "string")
                      return skipAuth("Skipping invalid hostbased auth attempt");
                    if (!key.isPrivateKey())
                      return skipAuth("Skipping non-private key");
                    nextAuth = { type, username, key, localHostname, localUsername };
                    break;
                  }
                  case "agent": {
                    let agent = nextAuth.agent;
                    if (typeof agent == "string" && agent.length)
                      agent = createAgent(agent);
                    else if (!isAgent(agent))
                      return skipAuth(
                        `Skipping invalid agent: ${nextAuth.agent}`
                      );
                    nextAuth = { type, username, agentCtx: new AgentContext(agent) };
                    break;
                  }
                  case "keyboard-interactive": {
                    let { prompt } = nextAuth;
                    if (typeof prompt != "function")
                      return skipAuth(
                        "Skipping invalid keyboard-interactive auth attempt"
                      );
                    nextAuth = { type, username, prompt };
                    break;
                  }
                  case "none":
                    nextAuth = { type, username };
                    break;
                  default:
                    return skipAuth(
                      `Skipping unsupported authentication method: ${nextAuth}`
                    );
                }
              }
            }
            curAuth = nextAuth;
            try {
              let username = curAuth.username;
              switch (curAuth.type) {
                case "password":
                  proto.authPassword(username, curAuth.password);
                  break;
                case "publickey": {
                  let keyAlgo;
                  if (curAuth.keyAlgos = getKeyAlgos(this, curAuth.key, serverSigAlgs), curAuth.keyAlgos)
                    if (curAuth.keyAlgos.length)
                      keyAlgo = curAuth.keyAlgos[0][0];
                    else
                      return skipAuth(
                        "Skipping key authentication (no mutual hash algorithm)"
                      );
                  proto.authPK(username, curAuth.key, keyAlgo);
                  break;
                }
                case "hostbased": {
                  let keyAlgo, hashAlgo;
                  if (curAuth.keyAlgos = getKeyAlgos(this, curAuth.key, serverSigAlgs), curAuth.keyAlgos)
                    if (curAuth.keyAlgos.length)
                      [keyAlgo, hashAlgo] = curAuth.keyAlgos[0];
                    else
                      return skipAuth(
                        "Skipping hostbased authentication (no mutual hash algorithm)"
                      );
                  proto.authHostbased(
                    username,
                    curAuth.key,
                    curAuth.localHostname,
                    curAuth.localUsername,
                    keyAlgo,
                    (buf, cb) => {
                      let signature = curAuth.key.sign(buf, hashAlgo);
                      if (signature instanceof Error)
                        return signature.message = `Error while signing with key: ${signature.message}`, signature.level = "client-authentication", this.emit("error", signature), tryNextAuth();
                      cb(signature);
                    }
                  );
                  break;
                }
                case "agent":
                  curAuth.agentCtx.init((err) => {
                    if (err)
                      return err.level = "agent", this.emit("error", err), tryNextAuth();
                    tryNextAgentKey();
                  });
                  break;
                case "keyboard-interactive":
                  proto.authKeyboard(username);
                  break;
                case "none":
                  proto.authNone(username);
                  break;
              }
            } finally {
              hasSentAuth = !1;
            }
          }
        };
        function skipAuth(msg) {
          debug && debug(msg), process.nextTick(tryNextAuth);
        }
        function tryNextAuth() {
          hasSentAuth = !1;
          let auth = authHandler(curAuthsLeft, curPartial, doNextAuth);
          hasSentAuth || auth === void 0 || doNextAuth(auth);
        }
        let tryNextAgentKey = () => {
          if (curAuth.type === "agent") {
            let key = curAuth.agentCtx.nextKey();
            if (key === !1)
              debug && debug("Agent: No more keys left to try"), debug && debug("Client: agent auth failed"), tryNextAuth();
            else {
              let pos2 = curAuth.agentCtx.pos(), keyAlgo;
              if (curAuth.keyAlgos = getKeyAlgos(this, key, serverSigAlgs), curAuth.keyAlgos)
                if (curAuth.keyAlgos.length)
                  keyAlgo = curAuth.keyAlgos[0][0];
                else {
                  debug && debug(
                    `Agent: Skipping key #${pos2 + 1} (no mutual hash algorithm)`
                  ), tryNextAgentKey();
                  return;
                }
              debug && debug(`Agent: Trying key #${pos2 + 1}`), proto.authPK(curAuth.username, key, keyAlgo);
            }
          }
        }, startTimeout = () => {
          this.config.readyTimeout > 0 && (this._readyTimeout = setTimeout(() => {
            let err = new Error("Timed out while waiting for handshake");
            err.level = "client-timeout", this.emit("error", err), sock.destroy();
          }, this.config.readyTimeout));
        };
        if (cfg.sock)
          startTimeout(), typeof sock.connecting == "boolean" && sock.connecting || onConnect();
        else {
          let host = this.config.host, forceIPv4 = this.config.forceIPv4, forceIPv6 = this.config.forceIPv6;
          debug && debug(`Client: Trying ${host} on port ${this.config.port} ...`);
          let doConnect = () => {
            startTimeout(), sock.connect({
              host,
              port: this.config.port,
              localAddress: this.config.localAddress,
              localPort: this.config.localPort
            }), sock.setMaxListeners(0), sock.setTimeout(typeof cfg.timeout == "number" ? cfg.timeout : 0);
          };
          !forceIPv4 && !forceIPv6 || forceIPv4 && forceIPv6 ? doConnect() : dnsLookup(host, forceIPv4 ? 4 : 6, (err, address, family) => {
            if (err) {
              let type = forceIPv4 ? "IPv4" : "IPv6", error = new Error(
                `Error while looking up ${type} address for '${host}': ${err}`
              );
              clearTimeout(this._readyTimeout), error.level = "client-dns", this.emit("error", error), this.emit("close");
              return;
            }
            host = address, doConnect();
          });
        }
        return this;
      }
      end() {
        return this._sock && isWritable2(this._sock) && (this._protocol.disconnect(DISCONNECT_REASON.BY_APPLICATION), this._sock.end()), this;
      }
      destroy() {
        return this._sock && isWritable2(this._sock) && this._sock.destroy(), this;
      }
      exec(cmd, opts, cb) {
        if (!this._sock || !isWritable2(this._sock))
          throw new Error("Not connected");
        typeof opts == "function" && (cb = opts, opts = {});
        let extraOpts = { allowHalfOpen: opts.allowHalfOpen !== !1 };
        return openChannel(this, "session", extraOpts, (err, chan) => {
          if (err) {
            cb(err);
            return;
          }
          let todo = [];
          function reqCb(err2) {
            if (err2) {
              chan.close(), cb(err2);
              return;
            }
            todo.length && todo.shift()();
          }
          (this.config.allowAgentFwd === !0 || opts && opts.agentForward === !0 && this._agent !== void 0) && todo.push(() => reqAgentFwd(chan, reqCb)), typeof opts == "object" && opts !== null && (typeof opts.env == "object" && opts.env !== null && reqEnv(chan, opts.env), (typeof opts.pty == "object" && opts.pty !== null || opts.pty === !0) && todo.push(() => reqPty(chan, opts.pty, reqCb)), (typeof opts.x11 == "object" && opts.x11 !== null || opts.x11 === "number" || opts.x11 === !0) && todo.push(() => reqX11(chan, opts.x11, reqCb))), todo.push(() => reqExec(chan, cmd, opts, cb)), todo.shift()();
        }), this;
      }
      shell(wndopts, opts, cb) {
        if (!this._sock || !isWritable2(this._sock))
          throw new Error("Not connected");
        return typeof wndopts == "function" ? (cb = wndopts, wndopts = opts = void 0) : typeof opts == "function" && (cb = opts, opts = void 0), wndopts && (wndopts.x11 !== void 0 || wndopts.env !== void 0) && (opts = wndopts, wndopts = void 0), openChannel(this, "session", (err, chan) => {
          if (err) {
            cb(err);
            return;
          }
          let todo = [];
          function reqCb(err2) {
            if (err2) {
              chan.close(), cb(err2);
              return;
            }
            todo.length && todo.shift()();
          }
          (this.config.allowAgentFwd === !0 || opts && opts.agentForward === !0 && this._agent !== void 0) && todo.push(() => reqAgentFwd(chan, reqCb)), wndopts !== !1 && todo.push(() => reqPty(chan, wndopts, reqCb)), typeof opts == "object" && opts !== null && (typeof opts.env == "object" && opts.env !== null && reqEnv(chan, opts.env), (typeof opts.x11 == "object" && opts.x11 !== null || opts.x11 === "number" || opts.x11 === !0) && todo.push(() => reqX11(chan, opts.x11, reqCb))), todo.push(() => reqShell(chan, cb)), todo.shift()();
        }), this;
      }
      subsys(name2, cb) {
        if (!this._sock || !isWritable2(this._sock))
          throw new Error("Not connected");
        return openChannel(this, "session", (err, chan) => {
          if (err) {
            cb(err);
            return;
          }
          reqSubsystem(chan, name2, (err2, stream) => {
            if (err2) {
              cb(err2);
              return;
            }
            cb(void 0, stream);
          });
        }), this;
      }
      forwardIn(bindAddr, bindPort, cb) {
        if (!this._sock || !isWritable2(this._sock))
          throw new Error("Not connected");
        let wantReply = typeof cb == "function";
        return wantReply && this._callbacks.push((had_err, data) => {
          if (had_err) {
            cb(had_err !== !0 ? had_err : new Error(`Unable to bind to ${bindAddr}:${bindPort}`));
            return;
          }
          let realPort = bindPort;
          bindPort === 0 && data && data.length >= 4 && (realPort = readUInt32BE(data, 0), this._protocol._compatFlags & COMPAT.DYN_RPORT_BUG || (bindPort = realPort)), this._forwarding[`${bindAddr}:${bindPort}`] = realPort, cb(void 0, realPort);
        }), this._protocol.tcpipForward(bindAddr, bindPort, wantReply), this;
      }
      unforwardIn(bindAddr, bindPort, cb) {
        if (!this._sock || !isWritable2(this._sock))
          throw new Error("Not connected");
        let wantReply = typeof cb == "function";
        return wantReply && this._callbacks.push((had_err) => {
          if (had_err) {
            cb(had_err !== !0 ? had_err : new Error(`Unable to unbind from ${bindAddr}:${bindPort}`));
            return;
          }
          delete this._forwarding[`${bindAddr}:${bindPort}`], cb();
        }), this._protocol.cancelTcpipForward(bindAddr, bindPort, wantReply), this;
      }
      forwardOut(srcIP, srcPort, dstIP, dstPort, cb) {
        if (!this._sock || !isWritable2(this._sock))
          throw new Error("Not connected");
        let cfg = {
          srcIP,
          srcPort,
          dstIP,
          dstPort
        };
        return typeof cb != "function" && (cb = noop2), openChannel(this, "direct-tcpip", cfg, cb), this;
      }
      openssh_noMoreSessions(cb) {
        if (!this._sock || !isWritable2(this._sock))
          throw new Error("Not connected");
        let wantReply = typeof cb == "function";
        return !this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer) ? (wantReply && this._callbacks.push((had_err) => {
          if (had_err) {
            cb(had_err !== !0 ? had_err : new Error("Unable to disable future sessions"));
            return;
          }
          cb();
        }), this._protocol.openssh_noMoreSessions(wantReply), this) : wantReply ? (process.nextTick(
          cb,
          new Error(
            "strictVendor enabled and server is not OpenSSH or compatible version"
          )
        ), this) : this;
      }
      openssh_forwardInStreamLocal(socketPath, cb) {
        if (!this._sock || !isWritable2(this._sock))
          throw new Error("Not connected");
        let wantReply = typeof cb == "function";
        return !this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer) ? (wantReply && this._callbacks.push((had_err) => {
          if (had_err) {
            cb(had_err !== !0 ? had_err : new Error(`Unable to bind to ${socketPath}`));
            return;
          }
          this._forwardingUnix[socketPath] = !0, cb();
        }), this._protocol.openssh_streamLocalForward(socketPath, wantReply), this) : wantReply ? (process.nextTick(
          cb,
          new Error(
            "strictVendor enabled and server is not OpenSSH or compatible version"
          )
        ), this) : this;
      }
      openssh_unforwardInStreamLocal(socketPath, cb) {
        if (!this._sock || !isWritable2(this._sock))
          throw new Error("Not connected");
        let wantReply = typeof cb == "function";
        return !this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer) ? (wantReply && this._callbacks.push((had_err) => {
          if (had_err) {
            cb(had_err !== !0 ? had_err : new Error(`Unable to unbind from ${socketPath}`));
            return;
          }
          delete this._forwardingUnix[socketPath], cb();
        }), this._protocol.openssh_cancelStreamLocalForward(socketPath, wantReply), this) : wantReply ? (process.nextTick(
          cb,
          new Error(
            "strictVendor enabled and server is not OpenSSH or compatible version"
          )
        ), this) : this;
      }
      openssh_forwardOutStreamLocal(socketPath, cb) {
        if (!this._sock || !isWritable2(this._sock))
          throw new Error("Not connected");
        return typeof cb != "function" && (cb = noop2), !this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer) ? (openChannel(this, "direct-streamlocal@openssh.com", { socketPath }, cb), this) : (process.nextTick(
          cb,
          new Error(
            "strictVendor enabled and server is not OpenSSH or compatible version"
          )
        ), this);
      }
      sftp(cb) {
        if (!this._sock || !isWritable2(this._sock))
          throw new Error("Not connected");
        return openChannel(this, "sftp", (err, sftp) => {
          if (err) {
            cb(err);
            return;
          }
          reqSubsystem(sftp, "sftp", (err2, sftp_) => {
            if (err2) {
              cb(err2);
              return;
            }
            function removeListeners() {
              sftp.removeListener("ready", onReady), sftp.removeListener("error", onError), sftp.removeListener("exit", onExit), sftp.removeListener("close", onExit);
            }
            function onReady() {
              removeListeners(), cb(void 0, sftp);
            }
            function onError(err3) {
              removeListeners(), cb(err3);
            }
            function onExit(code2, signal) {
              removeListeners();
              let msg;
              typeof code2 == "number" ? msg = `Received exit code ${code2} while establishing SFTP session` : signal !== void 0 ? msg = `Received signal ${signal} while establishing SFTP session` : msg = "Received unexpected SFTP session termination";
              let err3 = new Error(msg);
              err3.code = code2, err3.signal = signal, cb(err3);
            }
            sftp.on("ready", onReady).on("error", onError).on("exit", onExit).on("close", onExit), sftp._init();
          });
        }), this;
      }
      setNoDelay(noDelay) {
        return this._sock && typeof this._sock.setNoDelay == "function" && this._sock.setNoDelay(noDelay), this;
      }
    };
    function openChannel(self2, type, opts, cb) {
      let initWindow = MAX_WINDOW, maxPacket = PACKET_SIZE;
      typeof opts == "function" && (cb = opts, opts = {});
      let wrapper = (err, stream) => {
        cb(err, stream);
      };
      wrapper.type = type;
      let localChan = self2._chanMgr.add(wrapper);
      if (localChan === -1) {
        cb(new Error("No free channels available"));
        return;
      }
      switch (type) {
        case "session":
        case "sftp":
          self2._protocol.session(localChan, initWindow, maxPacket);
          break;
        case "direct-tcpip":
          self2._protocol.directTcpip(localChan, initWindow, maxPacket, opts);
          break;
        case "direct-streamlocal@openssh.com":
          self2._protocol.openssh_directStreamLocal(
            localChan,
            initWindow,
            maxPacket,
            opts
          );
          break;
        default:
          throw new Error(`Unsupported channel type: ${type}`);
      }
    }
    function reqX11(chan, screen, cb) {
      let cfg = {
        single: !1,
        protocol: "MIT-MAGIC-COOKIE-1",
        cookie: void 0,
        screen: 0
      };
      typeof screen == "function" ? cb = screen : typeof screen == "object" && screen !== null && (typeof screen.single == "boolean" && (cfg.single = screen.single), typeof screen.screen == "number" && (cfg.screen = screen.screen), typeof screen.protocol == "string" && (cfg.protocol = screen.protocol), typeof screen.cookie == "string" ? cfg.cookie = screen.cookie : Buffer.isBuffer(screen.cookie) && (cfg.cookie = screen.cookie.hexSlice(0, screen.cookie.length))), cfg.cookie === void 0 && (cfg.cookie = randomCookie());
      let wantReply = typeof cb == "function";
      if (chan.outgoing.state !== "open") {
        wantReply && cb(new Error("Channel is not open"));
        return;
      }
      wantReply && chan._callbacks.push((had_err) => {
        if (had_err) {
          cb(had_err !== !0 ? had_err : new Error("Unable to request X11"));
          return;
        }
        chan._hasX11 = !0, ++chan._client._acceptX11, chan.once("close", () => {
          chan._client._acceptX11 && --chan._client._acceptX11;
        }), cb();
      }), chan._client._protocol.x11Forward(chan.outgoing.id, cfg, wantReply);
    }
    function reqPty(chan, opts, cb) {
      let rows = 24, cols = 80, width = 640, height = 480, term = "vt100", modes = null;
      typeof opts == "function" ? cb = opts : typeof opts == "object" && opts !== null && (typeof opts.rows == "number" && (rows = opts.rows), typeof opts.cols == "number" && (cols = opts.cols), typeof opts.width == "number" && (width = opts.width), typeof opts.height == "number" && (height = opts.height), typeof opts.term == "string" && (term = opts.term), typeof opts.modes == "object" && (modes = opts.modes));
      let wantReply = typeof cb == "function";
      if (chan.outgoing.state !== "open") {
        wantReply && cb(new Error("Channel is not open"));
        return;
      }
      wantReply && chan._callbacks.push((had_err) => {
        if (had_err) {
          cb(had_err !== !0 ? had_err : new Error("Unable to request a pseudo-terminal"));
          return;
        }
        cb();
      }), chan._client._protocol.pty(
        chan.outgoing.id,
        rows,
        cols,
        height,
        width,
        term,
        modes,
        wantReply
      );
    }
    function reqAgentFwd(chan, cb) {
      let wantReply = typeof cb == "function";
      if (chan.outgoing.state !== "open") {
        wantReply && cb(new Error("Channel is not open"));
        return;
      }
      if (chan._client._agentFwdEnabled) {
        wantReply && cb(!1);
        return;
      }
      chan._client._agentFwdEnabled = !0, chan._callbacks.push((had_err) => {
        if (had_err) {
          chan._client._agentFwdEnabled = !1, wantReply && cb(had_err !== !0 ? had_err : new Error("Unable to request agent forwarding"));
          return;
        }
        wantReply && cb();
      }), chan._client._protocol.openssh_agentForward(chan.outgoing.id, !0);
    }
    function reqShell(chan, cb) {
      if (chan.outgoing.state !== "open") {
        cb(new Error("Channel is not open"));
        return;
      }
      chan._callbacks.push((had_err) => {
        if (had_err) {
          cb(had_err !== !0 ? had_err : new Error("Unable to open shell"));
          return;
        }
        chan.subtype = "shell", cb(void 0, chan);
      }), chan._client._protocol.shell(chan.outgoing.id, !0);
    }
    function reqExec(chan, cmd, opts, cb) {
      if (chan.outgoing.state !== "open") {
        cb(new Error("Channel is not open"));
        return;
      }
      chan._callbacks.push((had_err) => {
        if (had_err) {
          cb(had_err !== !0 ? had_err : new Error("Unable to exec"));
          return;
        }
        chan.subtype = "exec", chan.allowHalfOpen = opts.allowHalfOpen !== !1, cb(void 0, chan);
      }), chan._client._protocol.exec(chan.outgoing.id, cmd, !0);
    }
    function reqEnv(chan, env) {
      if (chan.outgoing.state !== "open")
        return;
      let keys = Object.keys(env || {});
      for (let i = 0; i < keys.length; ++i) {
        let key = keys[i], val = env[key];
        chan._client._protocol.env(chan.outgoing.id, key, val, !1);
      }
    }
    function reqSubsystem(chan, name2, cb) {
      if (chan.outgoing.state !== "open") {
        cb(new Error("Channel is not open"));
        return;
      }
      chan._callbacks.push((had_err) => {
        if (had_err) {
          cb(had_err !== !0 ? had_err : new Error(`Unable to start subsystem: ${name2}`));
          return;
        }
        chan.subtype = "subsystem", cb(void 0, chan);
      }), chan._client._protocol.subsystem(chan.outgoing.id, name2, !0);
    }
    function onCHANNEL_OPEN(self2, info) {
      let localChan = -1, reason, accept = () => {
        let chanInfo = {
          type: info.type,
          incoming: {
            id: localChan,
            window: MAX_WINDOW,
            packetSize: PACKET_SIZE,
            state: "open"
          },
          outgoing: {
            id: info.sender,
            window: info.window,
            packetSize: info.packetSize,
            state: "open"
          }
        }, stream = new Channel(self2, chanInfo);
        return self2._chanMgr.update(localChan, stream), self2._protocol.channelOpenConfirm(
          info.sender,
          localChan,
          MAX_WINDOW,
          PACKET_SIZE
        ), stream;
      }, reject = () => {
        reason === void 0 && (localChan === -1 ? reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE : reason = CHANNEL_OPEN_FAILURE.CONNECT_FAILED), localChan !== -1 && self2._chanMgr.remove(localChan), self2._protocol.channelOpenFail(info.sender, reason, "");
      }, reserveChannel = () => (localChan = self2._chanMgr.add(), localChan === -1 && (reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE, self2.config.debug && self2.config.debug(
        "Client: Automatic rejection of incoming channel open: no channels available"
      )), localChan !== -1), data = info.data;
      switch (info.type) {
        case "forwarded-tcpip": {
          let val = self2._forwarding[`${data.destIP}:${data.destPort}`];
          if (val !== void 0 && reserveChannel()) {
            data.destPort === 0 && (data.destPort = val), self2.emit("tcp connection", data, accept, reject);
            return;
          }
          break;
        }
        case "forwarded-streamlocal@openssh.com":
          if (self2._forwardingUnix[data.socketPath] !== void 0 && reserveChannel()) {
            self2.emit("unix connection", data, accept, reject);
            return;
          }
          break;
        case "auth-agent@openssh.com":
          if (self2._agentFwdEnabled && typeof self2._agent.getStream == "function" && reserveChannel()) {
            self2._agent.getStream((err, stream) => {
              if (err)
                return reject();
              let upstream = accept();
              upstream.pipe(stream).pipe(upstream);
            });
            return;
          }
          break;
        case "x11":
          if (self2._acceptX11 !== 0 && reserveChannel()) {
            self2.emit("x11", data, accept, reject);
            return;
          }
          break;
        default:
          reason = CHANNEL_OPEN_FAILURE.UNKNOWN_CHANNEL_TYPE, self2.config.debug && self2.config.debug(
            `Client: Automatic rejection of unsupported incoming channel open type: ${info.type}`
          );
      }
      reason === void 0 && (reason = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED, self2.config.debug && self2.config.debug(
        "Client: Automatic rejection of unexpected incoming channel open for: " + info.type
      )), reject();
    }
    var randomCookie = (() => {
      let buffer = Buffer.allocUnsafe(16);
      return () => (randomFillSync(buffer, 0, 16), buffer.hexSlice(0, 16));
    })();
    function makeSimpleAuthHandler(authList) {
      if (!Array.isArray(authList))
        throw new Error("authList must be an array");
      let a = 0;
      return (authsLeft, partialSuccess, cb) => a === authList.length ? !1 : authList[a++];
    }
    function hostKeysProve(client, keys_, cb) {
      if (!client._sock || !isWritable2(client._sock))
        return;
      if (typeof cb != "function" && (cb = noop2), !Array.isArray(keys_))
        throw new TypeError("Invalid keys argument type");
      let keys = [];
      for (let key of keys_) {
        let parsed = parseKey(key);
        if (parsed instanceof Error)
          throw parsed;
        keys.push(parsed);
      }
      if (!client.config.strictVendor || client.config.strictVendor && RE_OPENSSH.test(client._remoteVer)) {
        client._callbacks.push((had_err, data) => {
          if (had_err) {
            cb(had_err !== !0 ? had_err : new Error("Server failed to prove supplied keys"));
            return;
          }
          let ret = [], keyIdx = 0;
          for (bufferParser.init(data, 0); bufferParser.avail() && keyIdx !== keys.length; ) {
            let key = keys[keyIdx++], keyPublic = key.getPublicSSH(), sigEntry = bufferParser.readString();
            sigParser.init(sigEntry, 0);
            let type = sigParser.readString(!0), value = sigParser.readString(), algo;
            if (type !== key.type)
              if (key.type === "ssh-rsa")
                switch (type) {
                  case "rsa-sha2-256":
                    algo = "sha256";
                    break;
                  case "rsa-sha2-512":
                    algo = "sha512";
                    break;
                  default:
                    continue;
                }
              else
                continue;
            let sessionID = client._protocol._kex.sessionID, verifyData = Buffer.allocUnsafe(
              37 + sessionID.length + 4 + keyPublic.length
            ), p = 0;
            writeUInt32BE(verifyData, 29, p), verifyData.utf8Write("hostkeys-prove-00@openssh.com", p += 4, 29), writeUInt32BE(verifyData, sessionID.length, p += 29), bufferCopy(sessionID, verifyData, 0, sessionID.length, p += 4), writeUInt32BE(verifyData, keyPublic.length, p += sessionID.length), bufferCopy(keyPublic, verifyData, 0, keyPublic.length, p += 4), (value = sigSSHToASN1(value, type)) && key.verify(verifyData, value, algo) === !0 && ret.push(key);
          }
          sigParser.clear(), bufferParser.clear(), cb(null, ret);
        }), client._protocol.openssh_hostKeysProve(keys);
        return;
      }
      process.nextTick(
        cb,
        new Error(
          "strictVendor enabled and server is not OpenSSH or compatible version"
        )
      );
    }
    function getKeyAlgos(client, key, serverSigAlgs) {
      switch (key.type) {
        case "ssh-rsa":
          if (client._protocol._compatFlags & COMPAT.IMPLY_RSA_SHA2_SIGALGS && (Array.isArray(serverSigAlgs) ? serverSigAlgs = ["rsa-sha2-256", "rsa-sha2-512", ...serverSigAlgs] : serverSigAlgs = ["rsa-sha2-256", "rsa-sha2-512"]), Array.isArray(serverSigAlgs)) {
            if (serverSigAlgs.indexOf("rsa-sha2-256") !== -1)
              return [["rsa-sha2-256", "sha256"]];
            if (serverSigAlgs.indexOf("rsa-sha2-512") !== -1)
              return [["rsa-sha2-512", "sha512"]];
            if (serverSigAlgs.indexOf("ssh-rsa") === -1)
              return [];
          }
          return [["ssh-rsa", "sha1"]];
      }
    }
    module2.exports = Client;
  }
});

// node_modules/ssh2/lib/http-agents.js
var require_http_agents = __commonJS({
  "node_modules/ssh2/lib/http-agents.js"(exports2) {
    "use strict";
    var { Agent: HttpAgent } = require("http"), { Agent: HttpsAgent } = require("https"), { connect: tlsConnect } = require("tls"), Client;
    for (let ctor of [HttpAgent, HttpsAgent]) {
      class SSHAgent extends ctor {
        constructor(connectCfg, agentOptions) {
          super(agentOptions), this._connectCfg = connectCfg, this._defaultSrcIP = agentOptions && agentOptions.srcIP || "localhost";
        }
        createConnection(options, cb) {
          let srcIP = options && options.localAddress || this._defaultSrcIP, srcPort = options && options.localPort || 0, dstIP = options.host, dstPort = options.port;
          Client === void 0 && (Client = require_client2());
          let client = new Client(), triedForward = !1;
          client.on("ready", () => {
            client.forwardOut(srcIP, srcPort, dstIP, dstPort, (err, stream) => {
              if (triedForward = !0, err)
                return client.end(), cb(err);
              stream.once("close", () => client.end()), cb(null, decorateStream(stream, ctor, options));
            });
          }).on("error", cb).on("close", () => {
            triedForward || cb(new Error("Unexpected connection close"));
          }).connect(this._connectCfg);
        }
      }
      exports2[ctor === HttpAgent ? "SSHTTPAgent" : "SSHTTPSAgent"] = SSHAgent;
    }
    function noop2() {
    }
    function decorateStream(stream, ctor, options) {
      if (ctor === HttpAgent)
        return stream.setKeepAlive = noop2, stream.setNoDelay = noop2, stream.setTimeout = noop2, stream.ref = noop2, stream.unref = noop2, stream.destroySoon = stream.destroy, stream;
      options.socket = stream;
      let wrapped = tlsConnect(options), onClose = /* @__PURE__ */ (() => {
        let called = !1;
        return () => {
          called || (called = !0, stream.isPaused() && stream.resume());
        };
      })();
      return wrapped.on("end", onClose).on("close", onClose), wrapped;
    }
  }
});

// node_modules/ssh2/lib/server.js
var require_server = __commonJS({
  "node_modules/ssh2/lib/server.js"(exports2, module2) {
    "use strict";
    var { Server: netServer } = require("net"), EventEmitter2 = require("events"), { listenerCount } = EventEmitter2, {
      CHANNEL_OPEN_FAILURE,
      DEFAULT_CIPHER,
      DEFAULT_COMPRESSION,
      DEFAULT_KEX,
      DEFAULT_MAC,
      DEFAULT_SERVER_HOST_KEY,
      DISCONNECT_REASON,
      DISCONNECT_REASON_BY_VALUE,
      SUPPORTED_CIPHER,
      SUPPORTED_COMPRESSION,
      SUPPORTED_KEX,
      SUPPORTED_MAC,
      SUPPORTED_SERVER_HOST_KEY
    } = require_constants6(), { init: cryptoInit } = require_crypto(), { KexInit } = require_kex(), { parseKey } = require_keyParser(), Protocol = require_Protocol(), { SFTP } = require_SFTP(), { writeUInt32BE } = require_utils5(), {
      Channel,
      MAX_WINDOW,
      PACKET_SIZE,
      windowAdjust,
      WINDOW_THRESHOLD
    } = require_Channel(), {
      ChannelManager,
      generateAlgorithmList,
      isWritable: isWritable2,
      onChannelOpenFailure,
      onCHANNEL_CLOSE
    } = require_utils6(), MAX_PENDING_AUTHS = 10, AuthContext = class extends EventEmitter2 {
      constructor(protocol, username, service, method, cb) {
        super(), this.username = this.user = username, this.service = service, this.method = method, this._initialResponse = !1, this._finalResponse = !1, this._multistep = !1, this._cbfinal = (allowed, methodsLeft, isPartial) => {
          this._finalResponse || (this._finalResponse = !0, cb(this, allowed, methodsLeft, isPartial));
        }, this._protocol = protocol;
      }
      accept() {
        this._cleanup && this._cleanup(), this._initialResponse = !0, this._cbfinal(!0);
      }
      reject(methodsLeft, isPartial) {
        this._cleanup && this._cleanup(), this._initialResponse = !0, this._cbfinal(!1, methodsLeft, isPartial);
      }
    }, KeyboardAuthContext = class extends AuthContext {
      constructor(protocol, username, service, method, submethods, cb) {
        super(protocol, username, service, method, cb), this._multistep = !0, this._cb = void 0, this._onInfoResponse = (responses) => {
          let callback = this._cb;
          callback && (this._cb = void 0, callback(responses));
        }, this.submethods = submethods, this.on("abort", () => {
          this._cb && this._cb(new Error("Authentication request aborted"));
        });
      }
      prompt(prompts, title, instructions, cb) {
        Array.isArray(prompts) || (prompts = [prompts]), typeof title == "function" ? (cb = title, title = instructions = void 0) : typeof instructions == "function" ? (cb = instructions, instructions = void 0) : typeof cb != "function" && (cb = void 0);
        for (let i = 0; i < prompts.length; ++i)
          typeof prompts[i] == "string" && (prompts[i] = {
            prompt: prompts[i],
            echo: !0
          });
        this._cb = cb, this._initialResponse = !0, this._protocol.authInfoReq(title, instructions, prompts);
      }
    }, PKAuthContext = class extends AuthContext {
      constructor(protocol, username, service, method, pkInfo, cb) {
        super(protocol, username, service, method, cb), this.key = { algo: pkInfo.keyAlgo, data: pkInfo.key }, this.hashAlgo = pkInfo.hashAlgo, this.signature = pkInfo.signature, this.blob = pkInfo.blob;
      }
      accept() {
        this.signature ? AuthContext.prototype.accept.call(this) : (this._initialResponse = !0, this._protocol.authPKOK(this.key.algo, this.key.data));
      }
    }, HostbasedAuthContext = class extends AuthContext {
      constructor(protocol, username, service, method, pkInfo, cb) {
        super(protocol, username, service, method, cb), this.key = { algo: pkInfo.keyAlgo, data: pkInfo.key }, this.hashAlgo = pkInfo.hashAlgo, this.signature = pkInfo.signature, this.blob = pkInfo.blob, this.localHostname = pkInfo.localHostname, this.localUsername = pkInfo.localUsername;
      }
    }, PwdAuthContext = class extends AuthContext {
      constructor(protocol, username, service, method, password, cb) {
        super(protocol, username, service, method, cb), this.password = password, this._changeCb = void 0;
      }
      requestChange(prompt, cb) {
        if (this._changeCb)
          throw new Error("Change request already in progress");
        if (typeof prompt != "string")
          throw new Error("prompt argument must be a string");
        if (typeof cb != "function")
          throw new Error("Callback argument must be a function");
        this._changeCb = cb, this._protocol.authPasswdChg(prompt);
      }
    }, Session = class extends EventEmitter2 {
      constructor(client, info, localChan) {
        super(), this.type = "session", this.subtype = void 0, this.server = !0, this._ending = !1, this._channel = void 0, this._chanInfo = {
          type: "session",
          incoming: {
            id: localChan,
            window: MAX_WINDOW,
            packetSize: PACKET_SIZE,
            state: "open"
          },
          outgoing: {
            id: info.sender,
            window: info.window,
            packetSize: info.packetSize,
            state: "open"
          }
        };
      }
    }, Server = class extends EventEmitter2 {
      constructor(cfg, listener) {
        if (super(), typeof cfg != "object" || cfg === null)
          throw new Error("Missing configuration object");
        let hostKeys = /* @__PURE__ */ Object.create(null), hostKeyAlgoOrder = [], hostKeys_ = cfg.hostKeys;
        if (!Array.isArray(hostKeys_))
          throw new Error("hostKeys must be an array");
        let cfgAlgos = typeof cfg.algorithms == "object" && cfg.algorithms !== null ? cfg.algorithms : {}, hostKeyAlgos = generateAlgorithmList(
          cfgAlgos.serverHostKey,
          DEFAULT_SERVER_HOST_KEY,
          SUPPORTED_SERVER_HOST_KEY
        );
        for (let i = 0; i < hostKeys_.length; ++i) {
          let privateKey;
          if (Buffer.isBuffer(hostKeys_[i]) || typeof hostKeys_[i] == "string" ? privateKey = parseKey(hostKeys_[i]) : privateKey = parseKey(hostKeys_[i].key, hostKeys_[i].passphrase), privateKey instanceof Error)
            throw new Error(`Cannot parse privateKey: ${privateKey.message}`);
          if (Array.isArray(privateKey) && (privateKey = privateKey[0]), privateKey.getPrivatePEM() === null)
            throw new Error("privateKey value contains an invalid private key");
          if (!hostKeyAlgoOrder.includes(privateKey.type))
            if (privateKey.type === "ssh-rsa") {
              let sha1Pos = hostKeyAlgos.indexOf("ssh-rsa"), sha256Pos = hostKeyAlgos.indexOf("rsa-sha2-256"), sha512Pos = hostKeyAlgos.indexOf("rsa-sha2-512");
              sha1Pos === -1 && (sha1Pos = 1 / 0), [sha1Pos, sha256Pos, sha512Pos].sort(compareNumbers).forEach((pos2) => {
                if (pos2 === -1)
                  return;
                let type;
                switch (pos2) {
                  case sha1Pos:
                    type = "ssh-rsa";
                    break;
                  case sha256Pos:
                    type = "rsa-sha2-256";
                    break;
                  case sha512Pos:
                    type = "rsa-sha2-512";
                    break;
                  default:
                    return;
                }
                hostKeys[type] = privateKey, hostKeyAlgoOrder.push(type);
              });
            } else
              hostKeys[privateKey.type] = privateKey, hostKeyAlgoOrder.push(privateKey.type);
        }
        let algorithms = {
          kex: generateAlgorithmList(
            cfgAlgos.kex,
            DEFAULT_KEX,
            SUPPORTED_KEX
          ).concat(["kex-strict-s-v00@openssh.com"]),
          serverHostKey: hostKeyAlgoOrder,
          cs: {
            cipher: generateAlgorithmList(
              cfgAlgos.cipher,
              DEFAULT_CIPHER,
              SUPPORTED_CIPHER
            ),
            mac: generateAlgorithmList(cfgAlgos.hmac, DEFAULT_MAC, SUPPORTED_MAC),
            compress: generateAlgorithmList(
              cfgAlgos.compress,
              DEFAULT_COMPRESSION,
              SUPPORTED_COMPRESSION
            ),
            lang: []
          },
          sc: void 0
        };
        algorithms.sc = algorithms.cs, typeof listener == "function" && this.on("connection", listener);
        let origDebug = typeof cfg.debug == "function" ? cfg.debug : void 0, ident = cfg.ident ? Buffer.from(cfg.ident) : void 0, offer = new KexInit(algorithms);
        this._srv = new netServer((socket) => {
          if (this._connections >= this.maxConnections) {
            socket.destroy();
            return;
          }
          ++this._connections, socket.once("close", () => {
            --this._connections;
          });
          let debug;
          if (origDebug) {
            let debugPrefix = `[${process.hrtime().join(".")}] `;
            debug = (msg) => {
              origDebug(`${debugPrefix}${msg}`);
            };
          }
          new Client(socket, hostKeys, ident, offer, debug, this, cfg);
        }).on("error", (err) => {
          this.emit("error", err);
        }).on("listening", () => {
          this.emit("listening");
        }).on("close", () => {
          this.emit("close");
        }), this._connections = 0, this.maxConnections = 1 / 0;
      }
      injectSocket(socket) {
        this._srv.emit("connection", socket);
      }
      listen(...args) {
        return this._srv.listen(...args), this;
      }
      address() {
        return this._srv.address();
      }
      getConnections(cb) {
        return this._srv.getConnections(cb), this;
      }
      close(cb) {
        return this._srv.close(cb), this;
      }
      ref() {
        return this._srv.ref(), this;
      }
      unref() {
        return this._srv.unref(), this;
      }
    };
    Server.KEEPALIVE_CLIENT_INTERVAL = 15e3;
    Server.KEEPALIVE_CLIENT_COUNT_MAX = 3;
    var Client = class extends EventEmitter2 {
      constructor(socket, hostKeys, ident, offer, debug, server, srvCfg) {
        super();
        let exchanges = 0, acceptedAuthSvc = !1, pendingAuths = [], authCtx, kaTimer, onPacket, unsentGlobalRequestsReplies = [];
        this._sock = socket, this._chanMgr = new ChannelManager(this), this._debug = debug, this.noMoreSessions = !1, this.authenticated = !1;
        function onClientPreHeaderError(err) {
        }
        this.on("error", onClientPreHeaderError);
        let DEBUG_HANDLER = debug ? (p, display, msg) => {
          debug(`Debug output from client: ${JSON.stringify(msg)}`);
        } : void 0, kaIntvl = typeof srvCfg.keepaliveInterval == "number" && isFinite(srvCfg.keepaliveInterval) && srvCfg.keepaliveInterval > 0 ? srvCfg.keepaliveInterval : typeof Server.KEEPALIVE_CLIENT_INTERVAL == "number" && isFinite(Server.KEEPALIVE_CLIENT_INTERVAL) && Server.KEEPALIVE_CLIENT_INTERVAL > 0 ? Server.KEEPALIVE_CLIENT_INTERVAL : -1, kaCountMax = typeof srvCfg.keepaliveCountMax == "number" && isFinite(srvCfg.keepaliveCountMax) && srvCfg.keepaliveCountMax >= 0 ? srvCfg.keepaliveCountMax : typeof Server.KEEPALIVE_CLIENT_COUNT_MAX == "number" && isFinite(Server.KEEPALIVE_CLIENT_COUNT_MAX) && Server.KEEPALIVE_CLIENT_COUNT_MAX >= 0 ? Server.KEEPALIVE_CLIENT_COUNT_MAX : -1, kaCurCount = 0;
        kaIntvl !== -1 && kaCountMax !== -1 && (this.once("ready", () => {
          let onClose = () => {
            clearInterval(kaTimer);
          };
          this.on("close", onClose).on("end", onClose), kaTimer = setInterval(() => {
            if (++kaCurCount > kaCountMax) {
              clearInterval(kaTimer);
              let err = new Error("Keepalive timeout");
              err.level = "client-timeout", this.emit("error", err), this.end();
            } else
              proto.ping();
          }, kaIntvl);
        }), onPacket = () => {
          kaTimer && kaTimer.refresh(), kaCurCount = 0;
        });
        let proto = this._protocol = new Protocol({
          server: !0,
          hostKeys,
          ident,
          offer,
          onPacket,
          greeting: srvCfg.greeting,
          banner: srvCfg.banner,
          onWrite: (data) => {
            isWritable2(socket) && socket.write(data);
          },
          onError: (err) => {
            proto._destruct || socket.removeAllListeners("data"), this.emit("error", err);
            try {
              socket.end();
            } catch {
            }
          },
          onHeader: (header) => {
            this.removeListener("error", onClientPreHeaderError);
            let info = {
              ip: socket.remoteAddress,
              family: socket.remoteFamily,
              port: socket.remotePort,
              header
            };
            if (!server.emit("connection", this, info)) {
              proto.disconnect(DISCONNECT_REASON.BY_APPLICATION), socket.end();
              return;
            }
            header.greeting && this.emit("greeting", header.greeting);
          },
          onHandshakeComplete: (negotiated) => {
            ++exchanges > 1 && this.emit("rekey"), this.emit("handshake", negotiated);
          },
          debug,
          messageHandlers: {
            DEBUG: DEBUG_HANDLER,
            DISCONNECT: (p, reason, desc) => {
              if (reason !== DISCONNECT_REASON.BY_APPLICATION) {
                desc || (desc = DISCONNECT_REASON_BY_VALUE[reason], desc === void 0 && (desc = `Unexpected disconnection reason: ${reason}`));
                let err = new Error(desc);
                err.code = reason, this.emit("error", err);
              }
              socket.end();
            },
            CHANNEL_OPEN: (p, info) => {
              if (info.type === "session" && this.noMoreSessions || !this.authenticated) {
                let reasonCode = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;
                return proto.channelOpenFail(info.sender, reasonCode);
              }
              let localChan = -1, reason, replied = !1, accept, reject = () => {
                replied || (replied = !0, reason === void 0 && (localChan === -1 ? reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE : reason = CHANNEL_OPEN_FAILURE.CONNECT_FAILED), localChan !== -1 && this._chanMgr.remove(localChan), proto.channelOpenFail(info.sender, reason, ""));
              }, reserveChannel = () => (localChan = this._chanMgr.add(), localChan === -1 && (reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE, debug && debug("Automatic rejection of incoming channel open: no channels available")), localChan !== -1), data = info.data;
              switch (info.type) {
                case "session":
                  if (listenerCount(this, "session") && reserveChannel()) {
                    accept = () => {
                      if (replied)
                        return;
                      replied = !0;
                      let instance = new Session(this, info, localChan);
                      return this._chanMgr.update(localChan, instance), proto.channelOpenConfirm(
                        info.sender,
                        localChan,
                        MAX_WINDOW,
                        PACKET_SIZE
                      ), instance;
                    }, this.emit("session", accept, reject);
                    return;
                  }
                  break;
                case "direct-tcpip":
                  if (listenerCount(this, "tcpip") && reserveChannel()) {
                    accept = () => {
                      if (replied)
                        return;
                      replied = !0;
                      let chanInfo = {
                        type: void 0,
                        incoming: {
                          id: localChan,
                          window: MAX_WINDOW,
                          packetSize: PACKET_SIZE,
                          state: "open"
                        },
                        outgoing: {
                          id: info.sender,
                          window: info.window,
                          packetSize: info.packetSize,
                          state: "open"
                        }
                      }, stream = new Channel(this, chanInfo, { server: !0 });
                      return this._chanMgr.update(localChan, stream), proto.channelOpenConfirm(
                        info.sender,
                        localChan,
                        MAX_WINDOW,
                        PACKET_SIZE
                      ), stream;
                    }, this.emit("tcpip", accept, reject, data);
                    return;
                  }
                  break;
                case "direct-streamlocal@openssh.com":
                  if (listenerCount(this, "openssh.streamlocal") && reserveChannel()) {
                    accept = () => {
                      if (replied)
                        return;
                      replied = !0;
                      let chanInfo = {
                        type: void 0,
                        incoming: {
                          id: localChan,
                          window: MAX_WINDOW,
                          packetSize: PACKET_SIZE,
                          state: "open"
                        },
                        outgoing: {
                          id: info.sender,
                          window: info.window,
                          packetSize: info.packetSize,
                          state: "open"
                        }
                      }, stream = new Channel(this, chanInfo, { server: !0 });
                      return this._chanMgr.update(localChan, stream), proto.channelOpenConfirm(
                        info.sender,
                        localChan,
                        MAX_WINDOW,
                        PACKET_SIZE
                      ), stream;
                    }, this.emit("openssh.streamlocal", accept, reject, data);
                    return;
                  }
                  break;
                default:
                  reason = CHANNEL_OPEN_FAILURE.UNKNOWN_CHANNEL_TYPE, debug && debug(`Automatic rejection of unsupported incoming channel open type: ${info.type}`);
              }
              reason === void 0 && (reason = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED, debug && debug(`Automatic rejection of unexpected incoming channel open for: ${info.type}`)), reject();
            },
            CHANNEL_OPEN_CONFIRMATION: (p, info) => {
              let channel = this._chanMgr.get(info.recipient);
              if (typeof channel != "function")
                return;
              let chanInfo = {
                type: channel.type,
                incoming: {
                  id: info.recipient,
                  window: MAX_WINDOW,
                  packetSize: PACKET_SIZE,
                  state: "open"
                },
                outgoing: {
                  id: info.sender,
                  window: info.window,
                  packetSize: info.packetSize,
                  state: "open"
                }
              }, instance = new Channel(this, chanInfo, { server: !0 });
              this._chanMgr.update(info.recipient, instance), channel(void 0, instance);
            },
            CHANNEL_OPEN_FAILURE: (p, recipient, reason, description) => {
              let channel = this._chanMgr.get(recipient);
              if (typeof channel != "function")
                return;
              onChannelOpenFailure(this, recipient, { reason, description }, channel);
            },
            CHANNEL_DATA: (p, recipient, data) => {
              let channel = this._chanMgr.get(recipient);
              if (!(typeof channel != "object" || channel === null) && !(channel.constructor === Session && (channel = channel._channel, !channel)) && channel.incoming.window !== 0) {
                if (channel.incoming.window -= data.length, channel.push(data) === !1) {
                  channel._waitChanDrain = !0;
                  return;
                }
                channel.incoming.window <= WINDOW_THRESHOLD && windowAdjust(channel);
              }
            },
            CHANNEL_EXTENDED_DATA: (p, recipient, data, type) => {
            },
            CHANNEL_WINDOW_ADJUST: (p, recipient, amount) => {
              let channel = this._chanMgr.get(recipient);
              typeof channel != "object" || channel === null || channel.constructor === Session && (channel = channel._channel, !channel) || (channel.outgoing.window += amount, channel._waitWindow && (channel._waitWindow = !1, channel._chunk ? channel._write(channel._chunk, null, channel._chunkcb) : channel._chunkcb ? channel._chunkcb() : channel._chunkErr ? channel.stderr._write(
                channel._chunkErr,
                null,
                channel._chunkcbErr
              ) : channel._chunkcbErr && channel._chunkcbErr()));
            },
            CHANNEL_SUCCESS: (p, recipient) => {
              let channel = this._chanMgr.get(recipient);
              typeof channel != "object" || channel === null || channel.constructor === Session && (channel = channel._channel, !channel) || channel._callbacks.length && channel._callbacks.shift()(!1);
            },
            CHANNEL_FAILURE: (p, recipient) => {
              let channel = this._chanMgr.get(recipient);
              typeof channel != "object" || channel === null || channel.constructor === Session && (channel = channel._channel, !channel) || channel._callbacks.length && channel._callbacks.shift()(!0);
            },
            CHANNEL_REQUEST: (p, recipient, type, wantReply, data) => {
              let session = this._chanMgr.get(recipient);
              if (typeof session != "object" || session === null)
                return;
              let replied = !1, accept, reject;
              if (session.constructor !== Session) {
                wantReply && proto.channelFailure(session.outgoing.id);
                return;
              }
              if (wantReply && (type !== "shell" && type !== "exec" && type !== "subsystem" && (accept = () => {
                replied || session._ending || session._channel || (replied = !0, proto.channelSuccess(session._chanInfo.outgoing.id));
              }), reject = () => {
                replied || session._ending || session._channel || (replied = !0, proto.channelFailure(session._chanInfo.outgoing.id));
              }), session._ending) {
                reject && reject();
                return;
              }
              switch (type) {
                // "pre-real session start" requests
                case "env":
                  if (listenerCount(session, "env")) {
                    session.emit("env", accept, reject, {
                      key: data.name,
                      val: data.value
                    });
                    return;
                  }
                  break;
                case "pty-req":
                  if (listenerCount(session, "pty")) {
                    session.emit("pty", accept, reject, data);
                    return;
                  }
                  break;
                case "window-change":
                  listenerCount(session, "window-change") ? session.emit("window-change", accept, reject, data) : reject && reject();
                  break;
                case "x11-req":
                  if (listenerCount(session, "x11")) {
                    session.emit("x11", accept, reject, data);
                    return;
                  }
                  break;
                // "post-real session start" requests
                case "signal":
                  if (listenerCount(session, "signal")) {
                    session.emit("signal", accept, reject, {
                      name: data
                    });
                    return;
                  }
                  break;
                // XXX: is `auth-agent-req@openssh.com` really "post-real session
                // start"?
                case "auth-agent-req@openssh.com":
                  if (listenerCount(session, "auth-agent")) {
                    session.emit("auth-agent", accept, reject);
                    return;
                  }
                  break;
                // "real session start" requests
                case "shell":
                  if (listenerCount(session, "shell")) {
                    accept = () => {
                      if (replied || session._ending || session._channel)
                        return;
                      replied = !0, wantReply && proto.channelSuccess(session._chanInfo.outgoing.id);
                      let channel = new Channel(
                        this,
                        session._chanInfo,
                        { server: !0 }
                      );
                      return channel.subtype = session.subtype = type, session._channel = channel, channel;
                    }, session.emit("shell", accept, reject);
                    return;
                  }
                  break;
                case "exec":
                  if (listenerCount(session, "exec")) {
                    accept = () => {
                      if (replied || session._ending || session._channel)
                        return;
                      replied = !0, wantReply && proto.channelSuccess(session._chanInfo.outgoing.id);
                      let channel = new Channel(
                        this,
                        session._chanInfo,
                        { server: !0 }
                      );
                      return channel.subtype = session.subtype = type, session._channel = channel, channel;
                    }, session.emit("exec", accept, reject, {
                      command: data
                    });
                    return;
                  }
                  break;
                case "subsystem": {
                  let useSFTP = data === "sftp";
                  if (accept = () => {
                    if (replied || session._ending || session._channel)
                      return;
                    replied = !0, wantReply && proto.channelSuccess(session._chanInfo.outgoing.id);
                    let instance;
                    return useSFTP ? instance = new SFTP(this, session._chanInfo, {
                      server: !0,
                      debug
                    }) : (instance = new Channel(
                      this,
                      session._chanInfo,
                      { server: !0 }
                    ), instance.subtype = session.subtype = `${type}:${data}`), session._channel = instance, instance;
                  }, data === "sftp") {
                    if (listenerCount(session, "sftp")) {
                      session.emit("sftp", accept, reject);
                      return;
                    }
                    useSFTP = !1;
                  }
                  if (listenerCount(session, "subsystem")) {
                    session.emit("subsystem", accept, reject, {
                      name: data
                    });
                    return;
                  }
                  break;
                }
              }
              debug && debug(
                `Automatic rejection of incoming channel request: ${type}`
              ), reject && reject();
            },
            CHANNEL_EOF: (p, recipient) => {
              let channel = this._chanMgr.get(recipient);
              typeof channel != "object" || channel === null || channel.constructor === Session && (channel._ending || (channel._ending = !0, channel.emit("eof"), channel.emit("end")), channel = channel._channel, !channel) || channel.incoming.state === "open" && (channel.incoming.state = "eof", channel.readable && channel.push(null));
            },
            CHANNEL_CLOSE: (p, recipient) => {
              let channel = this._chanMgr.get(recipient);
              typeof channel != "object" || channel === null || channel.constructor === Session && (channel._ending = !0, channel.emit("close"), channel = channel._channel, !channel) || onCHANNEL_CLOSE(this, recipient, channel);
            },
            // Begin service/auth-related ==========================================
            SERVICE_REQUEST: (p, service) => {
              if (exchanges === 0 || acceptedAuthSvc || this.authenticated || service !== "ssh-userauth") {
                proto.disconnect(DISCONNECT_REASON.SERVICE_NOT_AVAILABLE), socket.end();
                return;
              }
              acceptedAuthSvc = !0, proto.serviceAccept(service);
            },
            USERAUTH_REQUEST: (p, username, service, method, methodData) => {
              if (exchanges === 0 || this.authenticated || authCtx && (authCtx.username !== username || authCtx.service !== service) || method !== "password" && method !== "publickey" && method !== "hostbased" && method !== "keyboard-interactive" && method !== "none" || pendingAuths.length === MAX_PENDING_AUTHS) {
                proto.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR), socket.end();
                return;
              } else if (service !== "ssh-connection") {
                proto.disconnect(DISCONNECT_REASON.SERVICE_NOT_AVAILABLE), socket.end();
                return;
              }
              let ctx;
              switch (method) {
                case "keyboard-interactive":
                  ctx = new KeyboardAuthContext(
                    proto,
                    username,
                    service,
                    method,
                    methodData,
                    onAuthDecide
                  );
                  break;
                case "publickey":
                  ctx = new PKAuthContext(
                    proto,
                    username,
                    service,
                    method,
                    methodData,
                    onAuthDecide
                  );
                  break;
                case "hostbased":
                  ctx = new HostbasedAuthContext(
                    proto,
                    username,
                    service,
                    method,
                    methodData,
                    onAuthDecide
                  );
                  break;
                case "password":
                  if (authCtx && authCtx instanceof PwdAuthContext && authCtx._changeCb) {
                    let cb = authCtx._changeCb;
                    authCtx._changeCb = void 0, cb(methodData.newPassword);
                    return;
                  }
                  ctx = new PwdAuthContext(
                    proto,
                    username,
                    service,
                    method,
                    methodData,
                    onAuthDecide
                  );
                  break;
                case "none":
                  ctx = new AuthContext(
                    proto,
                    username,
                    service,
                    method,
                    onAuthDecide
                  );
                  break;
              }
              if (authCtx)
                if (authCtx._initialResponse)
                  authCtx._multistep && !authCtx._finalResponse && (authCtx._cleanup && authCtx._cleanup(), authCtx.emit("abort"));
                else return pendingAuths.push(ctx);
              authCtx = ctx, listenerCount(this, "authentication") ? this.emit("authentication", authCtx) : authCtx.reject();
            },
            USERAUTH_INFO_RESPONSE: (p, responses) => {
              authCtx && authCtx instanceof KeyboardAuthContext && authCtx._onInfoResponse(responses);
            },
            // End service/auth-related ============================================
            GLOBAL_REQUEST: (p, name2, wantReply, data) => {
              let reply = {
                type: null,
                buf: null
              };
              function setReply(type, buf) {
                reply.type = type, reply.buf = buf, sendReplies();
              }
              if (wantReply && unsentGlobalRequestsReplies.push(reply), (name2 === "tcpip-forward" || name2 === "cancel-tcpip-forward" || name2 === "no-more-sessions@openssh.com" || name2 === "streamlocal-forward@openssh.com" || name2 === "cancel-streamlocal-forward@openssh.com") && listenerCount(this, "request") && this.authenticated) {
                let accept, reject;
                if (wantReply) {
                  let replied = !1;
                  accept = (chosenPort) => {
                    if (replied)
                      return;
                    replied = !0;
                    let bufPort;
                    name2 === "tcpip-forward" && data.bindPort === 0 && typeof chosenPort == "number" && (bufPort = Buffer.allocUnsafe(4), writeUInt32BE(bufPort, chosenPort, 0)), setReply("SUCCESS", bufPort);
                  }, reject = () => {
                    replied || (replied = !0, setReply("FAILURE"));
                  };
                }
                if (name2 === "no-more-sessions@openssh.com") {
                  this.noMoreSessions = !0, accept && accept();
                  return;
                }
                this.emit("request", accept, reject, name2, data);
              } else wantReply && setReply("FAILURE");
            }
          }
        });
        socket.pause(), cryptoInit.then(() => {
          proto.start(), socket.on("data", (data) => {
            try {
              proto.parse(data, 0, data.length);
            } catch (ex) {
              this.emit("error", ex);
              try {
                isWritable2(socket) && socket.end();
              } catch {
              }
            }
          }), socket.resume();
        }).catch((err) => {
          this.emit("error", err);
          try {
            isWritable2(socket) && socket.end();
          } catch {
          }
        }), socket.on("error", (err) => {
          err.level = "socket", this.emit("error", err);
        }).once("end", () => {
          debug && debug("Socket ended"), proto.cleanup(), this.emit("end");
        }).once("close", () => {
          debug && debug("Socket closed"), proto.cleanup(), this.emit("close");
          let err = new Error("No response from server");
          this._chanMgr.cleanup(err);
        });
        let onAuthDecide = (ctx, allowed, methodsLeft, isPartial) => {
          authCtx === ctx && !this.authenticated && (allowed ? (authCtx = void 0, this.authenticated = !0, proto.authSuccess(), pendingAuths = [], this.emit("ready")) : (proto.authFailure(methodsLeft, isPartial), pendingAuths.length && (authCtx = pendingAuths.pop(), listenerCount(this, "authentication") ? this.emit("authentication", authCtx) : authCtx.reject())));
        };
        function sendReplies() {
          for (; unsentGlobalRequestsReplies.length > 0 && unsentGlobalRequestsReplies[0].type; ) {
            let reply = unsentGlobalRequestsReplies.shift();
            reply.type === "SUCCESS" && proto.requestSuccess(reply.buf), reply.type === "FAILURE" && proto.requestFailure();
          }
        }
      }
      end() {
        return this._sock && isWritable2(this._sock) && (this._protocol.disconnect(DISCONNECT_REASON.BY_APPLICATION), this._sock.end()), this;
      }
      x11(originAddr, originPort, cb) {
        return openChannel(this, "x11", { originAddr, originPort }, cb), this;
      }
      forwardOut(boundAddr, boundPort, remoteAddr, remotePort, cb) {
        return openChannel(this, "forwarded-tcpip", { boundAddr, boundPort, remoteAddr, remotePort }, cb), this;
      }
      openssh_forwardOutStreamLocal(socketPath, cb) {
        return openChannel(this, "forwarded-streamlocal@openssh.com", { socketPath }, cb), this;
      }
      rekey(cb) {
        let error;
        try {
          this._protocol.rekey();
        } catch (ex) {
          error = ex;
        }
        typeof cb == "function" && (error ? process.nextTick(cb, error) : this.once("rekey", cb));
      }
      setNoDelay(noDelay) {
        return this._sock && typeof this._sock.setNoDelay == "function" && this._sock.setNoDelay(noDelay), this;
      }
    };
    function openChannel(self2, type, opts, cb) {
      let initWindow = MAX_WINDOW, maxPacket = PACKET_SIZE;
      typeof opts == "function" && (cb = opts, opts = {});
      let wrapper = (err, stream) => {
        cb(err, stream);
      };
      wrapper.type = type;
      let localChan = self2._chanMgr.add(wrapper);
      if (localChan === -1) {
        cb(new Error("No free channels available"));
        return;
      }
      switch (type) {
        case "forwarded-tcpip":
          self2._protocol.forwardedTcpip(localChan, initWindow, maxPacket, opts);
          break;
        case "x11":
          self2._protocol.x11(localChan, initWindow, maxPacket, opts);
          break;
        case "forwarded-streamlocal@openssh.com":
          self2._protocol.openssh_forwardedStreamLocal(
            localChan,
            initWindow,
            maxPacket,
            opts
          );
          break;
        default:
          throw new Error(`Unsupported channel type: ${type}`);
      }
    }
    function compareNumbers(a, b) {
      return a - b;
    }
    module2.exports = Server;
    module2.exports.IncomingClient = Client;
  }
});

// node_modules/ssh2/lib/keygen.js
var require_keygen = __commonJS({
  "node_modules/ssh2/lib/keygen.js"(exports2, module2) {
    "use strict";
    var {
      createCipheriv,
      generateKeyPair: generateKeyPair_,
      generateKeyPairSync: generateKeyPairSync_,
      getCurves,
      randomBytes: randomBytes2
    } = require("crypto"), { Ber } = require_lib4(), bcrypt_pbkdf = require_bcrypt_pbkdf().pbkdf, { CIPHER_INFO } = require_crypto(), SALT_LEN = 16, DEFAULT_ROUNDS = 16, curves = getCurves(), ciphers = new Map(Object.entries(CIPHER_INFO));
    function makeArgs(type, opts) {
      if (typeof type != "string")
        throw new TypeError("Key type must be a string");
      let publicKeyEncoding = { type: "spki", format: "der" }, privateKeyEncoding = { type: "pkcs8", format: "der" };
      switch (type.toLowerCase()) {
        case "rsa": {
          if (typeof opts != "object" || opts === null)
            throw new TypeError("Missing options object for RSA key");
          let modulusLength = opts.bits;
          if (!Number.isInteger(modulusLength))
            throw new TypeError("RSA bits must be an integer");
          if (modulusLength <= 0 || modulusLength > 16384)
            throw new RangeError("RSA bits must be non-zero and <= 16384");
          return ["rsa", { modulusLength, publicKeyEncoding, privateKeyEncoding }];
        }
        case "ecdsa": {
          if (typeof opts != "object" || opts === null)
            throw new TypeError("Missing options object for ECDSA key");
          if (!Number.isInteger(opts.bits))
            throw new TypeError("ECDSA bits must be an integer");
          let namedCurve;
          switch (opts.bits) {
            case 256:
              namedCurve = "prime256v1";
              break;
            case 384:
              namedCurve = "secp384r1";
              break;
            case 521:
              namedCurve = "secp521r1";
              break;
            default:
              throw new Error("ECDSA bits must be 256, 384, or 521");
          }
          if (!curves.includes(namedCurve))
            throw new Error("Unsupported ECDSA bits value");
          return ["ec", { namedCurve, publicKeyEncoding, privateKeyEncoding }];
        }
        case "ed25519":
          return ["ed25519", { publicKeyEncoding, privateKeyEncoding }];
        default:
          throw new Error(`Unsupported key type: ${type}`);
      }
    }
    function parseDERs(keyType, pub, priv) {
      switch (keyType) {
        case "rsa": {
          let reader = new Ber.Reader(priv);
          if (reader.readSequence(), reader.readInt() !== 0)
            throw new Error("Unsupported version in RSA private key");
          if (reader.readSequence(), reader.readOID() !== "1.2.840.113549.1.1.1")
            throw new Error("Bad RSA private OID");
          if (reader.readByte() !== Ber.Null)
            throw new Error("Malformed RSA private key (expected null)");
          if (reader.readByte() !== 0)
            throw new Error(
              "Malformed RSA private key (expected zero-length null)"
            );
          if (reader = new Ber.Reader(reader.readString(Ber.OctetString, !0)), reader.readSequence(), reader.readInt() !== 0)
            throw new Error("Unsupported version in RSA private key");
          let n = reader.readString(Ber.Integer, !0), e = reader.readString(Ber.Integer, !0), d = reader.readString(Ber.Integer, !0), p = reader.readString(Ber.Integer, !0), q = reader.readString(Ber.Integer, !0);
          reader.readString(Ber.Integer, !0), reader.readString(Ber.Integer, !0);
          let iqmp = reader.readString(Ber.Integer, !0), keyName = Buffer.from("ssh-rsa"), privBuf = Buffer.allocUnsafe(
            4 + keyName.length + 4 + n.length + 4 + e.length + 4 + d.length + 4 + iqmp.length + 4 + p.length + 4 + q.length
          ), pos2 = 0;
          privBuf.writeUInt32BE(keyName.length, pos2 += 0), privBuf.set(keyName, pos2 += 4), privBuf.writeUInt32BE(n.length, pos2 += keyName.length), privBuf.set(n, pos2 += 4), privBuf.writeUInt32BE(e.length, pos2 += n.length), privBuf.set(e, pos2 += 4), privBuf.writeUInt32BE(d.length, pos2 += e.length), privBuf.set(d, pos2 += 4), privBuf.writeUInt32BE(iqmp.length, pos2 += d.length), privBuf.set(iqmp, pos2 += 4), privBuf.writeUInt32BE(p.length, pos2 += iqmp.length), privBuf.set(p, pos2 += 4), privBuf.writeUInt32BE(q.length, pos2 += p.length), privBuf.set(q, pos2 += 4);
          let pubBuf = Buffer.allocUnsafe(
            4 + keyName.length + 4 + e.length + 4 + n.length
          );
          return pos2 = 0, pubBuf.writeUInt32BE(keyName.length, pos2 += 0), pubBuf.set(keyName, pos2 += 4), pubBuf.writeUInt32BE(e.length, pos2 += keyName.length), pubBuf.set(e, pos2 += 4), pubBuf.writeUInt32BE(n.length, pos2 += e.length), pubBuf.set(n, pos2 += 4), { sshName: keyName.toString(), priv: privBuf, pub: pubBuf };
        }
        case "ec": {
          let reader = new Ber.Reader(pub);
          if (reader.readSequence(), reader.readSequence(), reader.readOID() !== "1.2.840.10045.2.1")
            throw new Error("Bad ECDSA public OID");
          reader.readOID();
          let pubBin = reader.readString(Ber.BitString, !0);
          {
            let i = 0;
            for (; i < pubBin.length && pubBin[i] === 0; ++i) ;
            i > 0 && (pubBin = pubBin.slice(i));
          }
          if (reader = new Ber.Reader(priv), reader.readSequence(), reader.readInt() !== 0)
            throw new Error("Unsupported version in ECDSA private key");
          if (reader.readSequence(), reader.readOID() !== "1.2.840.10045.2.1")
            throw new Error("Bad ECDSA private OID");
          let curveOID = reader.readOID(), sshCurveName;
          switch (curveOID) {
            case "1.2.840.10045.3.1.7":
              sshCurveName = "nistp256";
              break;
            case "1.3.132.0.34":
              sshCurveName = "nistp384";
              break;
            case "1.3.132.0.35":
              sshCurveName = "nistp521";
              break;
            default:
              throw new Error("Unsupported curve in ECDSA private key");
          }
          if (reader = new Ber.Reader(reader.readString(Ber.OctetString, !0)), reader.readSequence(), reader.readInt() !== 1)
            throw new Error("Unsupported version in ECDSA private key");
          let privBin = Buffer.concat([
            Buffer.from([0]),
            reader.readString(Ber.OctetString, !0)
          ]), keyName = Buffer.from(`ecdsa-sha2-${sshCurveName}`);
          sshCurveName = Buffer.from(sshCurveName);
          let privBuf = Buffer.allocUnsafe(
            4 + keyName.length + 4 + sshCurveName.length + 4 + pubBin.length + 4 + privBin.length
          ), pos2 = 0;
          privBuf.writeUInt32BE(keyName.length, pos2 += 0), privBuf.set(keyName, pos2 += 4), privBuf.writeUInt32BE(sshCurveName.length, pos2 += keyName.length), privBuf.set(sshCurveName, pos2 += 4), privBuf.writeUInt32BE(pubBin.length, pos2 += sshCurveName.length), privBuf.set(pubBin, pos2 += 4), privBuf.writeUInt32BE(privBin.length, pos2 += pubBin.length), privBuf.set(privBin, pos2 += 4);
          let pubBuf = Buffer.allocUnsafe(
            4 + keyName.length + 4 + sshCurveName.length + 4 + pubBin.length
          );
          return pos2 = 0, pubBuf.writeUInt32BE(keyName.length, pos2 += 0), pubBuf.set(keyName, pos2 += 4), pubBuf.writeUInt32BE(sshCurveName.length, pos2 += keyName.length), pubBuf.set(sshCurveName, pos2 += 4), pubBuf.writeUInt32BE(pubBin.length, pos2 += sshCurveName.length), pubBuf.set(pubBin, pos2 += 4), { sshName: keyName.toString(), priv: privBuf, pub: pubBuf };
        }
        case "ed25519": {
          let reader = new Ber.Reader(pub);
          if (reader.readSequence(), reader.readSequence(), reader.readOID() !== "1.3.101.112")
            throw new Error("Bad ED25519 public OID");
          let pubBin = reader.readString(Ber.BitString, !0);
          {
            let i = 0;
            for (; i < pubBin.length && pubBin[i] === 0; ++i) ;
            i > 0 && (pubBin = pubBin.slice(i));
          }
          if (reader = new Ber.Reader(priv), reader.readSequence(), reader.readInt() !== 0)
            throw new Error("Unsupported version in ED25519 private key");
          if (reader.readSequence(), reader.readOID() !== "1.3.101.112")
            throw new Error("Bad ED25519 private OID");
          reader = new Ber.Reader(reader.readString(Ber.OctetString, !0));
          let privBin = reader.readString(Ber.OctetString, !0), keyName = Buffer.from("ssh-ed25519"), privBuf = Buffer.allocUnsafe(
            4 + keyName.length + 4 + pubBin.length + 4 + (privBin.length + pubBin.length)
          ), pos2 = 0;
          privBuf.writeUInt32BE(keyName.length, pos2 += 0), privBuf.set(keyName, pos2 += 4), privBuf.writeUInt32BE(pubBin.length, pos2 += keyName.length), privBuf.set(pubBin, pos2 += 4), privBuf.writeUInt32BE(
            privBin.length + pubBin.length,
            pos2 += pubBin.length
          ), privBuf.set(privBin, pos2 += 4), privBuf.set(pubBin, pos2 += privBin.length);
          let pubBuf = Buffer.allocUnsafe(
            4 + keyName.length + 4 + pubBin.length
          );
          return pos2 = 0, pubBuf.writeUInt32BE(keyName.length, pos2 += 0), pubBuf.set(keyName, pos2 += 4), pubBuf.writeUInt32BE(pubBin.length, pos2 += keyName.length), pubBuf.set(pubBin, pos2 += 4), { sshName: keyName.toString(), priv: privBuf, pub: pubBuf };
        }
      }
    }
    function convertKeys(keyType, pub, priv, opts) {
      let format = "new", encrypted, comment = "";
      if (typeof opts == "object" && opts !== null && (typeof opts.comment == "string" && opts.comment && (comment = opts.comment), typeof opts.format == "string" && opts.format && (format = opts.format), opts.passphrase)) {
        let passphrase;
        if (typeof opts.passphrase == "string")
          passphrase = Buffer.from(opts.passphrase);
        else if (Buffer.isBuffer(opts.passphrase))
          passphrase = opts.passphrase;
        else
          throw new Error("Invalid passphrase");
        if (opts.cipher === void 0)
          throw new Error("Missing cipher name");
        let cipher = ciphers.get(opts.cipher);
        if (cipher === void 0)
          throw new Error("Invalid cipher name");
        if (format === "new") {
          let rounds = DEFAULT_ROUNDS;
          if (opts.rounds !== void 0) {
            if (!Number.isInteger(opts.rounds))
              throw new TypeError("rounds must be an integer");
            opts.rounds > 0 && (rounds = opts.rounds);
          }
          let gen = Buffer.allocUnsafe(cipher.keyLen + cipher.ivLen), salt = randomBytes2(SALT_LEN);
          if (bcrypt_pbkdf(
            passphrase,
            passphrase.length,
            salt,
            salt.length,
            gen,
            gen.length,
            rounds
          ) !== 0)
            return new Error("Failed to generate information to encrypt key");
          let kdfOptions = Buffer.allocUnsafe(4 + salt.length + 4);
          {
            let pos2 = 0;
            kdfOptions.writeUInt32BE(salt.length, pos2 += 0), kdfOptions.set(salt, pos2 += 4), kdfOptions.writeUInt32BE(rounds, pos2 += salt.length);
          }
          encrypted = {
            cipher,
            cipherName: opts.cipher,
            kdfName: "bcrypt",
            kdfOptions,
            key: gen.slice(0, cipher.keyLen),
            iv: gen.slice(cipher.keyLen)
          };
        }
      }
      switch (format) {
        case "new": {
          let privateB64 = `-----BEGIN OPENSSH PRIVATE KEY-----
`, publicB64, cipherName = Buffer.from(encrypted ? encrypted.cipherName : "none"), kdfName = Buffer.from(encrypted ? encrypted.kdfName : "none"), kdfOptions = encrypted ? encrypted.kdfOptions : Buffer.alloc(0), blockLen = encrypted ? encrypted.cipher.blockLen : 8, parsed = parseDERs(keyType, pub, priv), checkInt = randomBytes2(4), commentBin = Buffer.from(comment), privBlobLen = 8 + parsed.priv.length + 4 + commentBin.length, padding = [];
          for (let i = 1; (privBlobLen + padding.length) % blockLen; ++i)
            padding.push(i & 255);
          padding = Buffer.from(padding);
          let privBlob = Buffer.allocUnsafe(privBlobLen + padding.length), extra;
          {
            let pos2 = 0;
            privBlob.set(checkInt, pos2 += 0), privBlob.set(checkInt, pos2 += 4), privBlob.set(parsed.priv, pos2 += 4), privBlob.writeUInt32BE(commentBin.length, pos2 += parsed.priv.length), privBlob.set(commentBin, pos2 += 4), privBlob.set(padding, pos2 += commentBin.length);
          }
          if (encrypted) {
            let options = { authTagLength: encrypted.cipher.authLen }, cipher = createCipheriv(
              encrypted.cipher.sslName,
              encrypted.key,
              encrypted.iv,
              options
            );
            cipher.setAutoPadding(!1), privBlob = Buffer.concat([cipher.update(privBlob), cipher.final()]), encrypted.cipher.authLen > 0 ? extra = cipher.getAuthTag() : extra = Buffer.alloc(0), encrypted.key.fill(0), encrypted.iv.fill(0);
          } else
            extra = Buffer.alloc(0);
          let magicBytes = Buffer.from("openssh-key-v1\0"), privBin = Buffer.allocUnsafe(
            magicBytes.length + 4 + cipherName.length + 4 + kdfName.length + 4 + kdfOptions.length + 4 + 4 + parsed.pub.length + 4 + privBlob.length + extra.length
          );
          {
            let pos2 = 0;
            privBin.set(magicBytes, pos2 += 0), privBin.writeUInt32BE(cipherName.length, pos2 += magicBytes.length), privBin.set(cipherName, pos2 += 4), privBin.writeUInt32BE(kdfName.length, pos2 += cipherName.length), privBin.set(kdfName, pos2 += 4), privBin.writeUInt32BE(kdfOptions.length, pos2 += kdfName.length), privBin.set(kdfOptions, pos2 += 4), privBin.writeUInt32BE(1, pos2 += kdfOptions.length), privBin.writeUInt32BE(parsed.pub.length, pos2 += 4), privBin.set(parsed.pub, pos2 += 4), privBin.writeUInt32BE(privBlob.length, pos2 += parsed.pub.length), privBin.set(privBlob, pos2 += 4), privBin.set(extra, pos2 += privBlob.length);
          }
          {
            let b64 = privBin.base64Slice(0, privBin.length), formatted = b64.replace(/.{64}/g, `$&
`);
            b64.length & 63 && (formatted += `
`), privateB64 += formatted;
          }
          {
            let b64 = parsed.pub.base64Slice(0, parsed.pub.length);
            publicB64 = `${parsed.sshName} ${b64}${comment ? ` ${comment}` : ""}`;
          }
          return privateB64 += `-----END OPENSSH PRIVATE KEY-----
`, {
            private: privateB64,
            public: publicB64
          };
        }
        default:
          throw new Error("Invalid output key format");
      }
    }
    function noop2() {
    }
    module2.exports = {
      generateKeyPair: (keyType, opts, cb) => {
        typeof opts == "function" && (cb = opts, opts = void 0), typeof cb != "function" && (cb = noop2);
        let args = makeArgs(keyType, opts);
        generateKeyPair_(...args, (err, pub, priv) => {
          if (err)
            return cb(err);
          let ret;
          try {
            ret = convertKeys(args[0], pub, priv, opts);
          } catch (ex) {
            return cb(ex);
          }
          cb(null, ret);
        });
      },
      generateKeyPairSync: (keyType, opts) => {
        let args = makeArgs(keyType, opts), { publicKey: pub, privateKey: priv } = generateKeyPairSync_(...args);
        return convertKeys(args[0], pub, priv, opts);
      }
    };
  }
});

// node_modules/ssh2/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/ssh2/lib/index.js"(exports2, module2) {
    "use strict";
    var {
      AgentProtocol,
      BaseAgent,
      createAgent,
      CygwinAgent,
      OpenSSHAgent,
      PageantAgent
    } = require_agent2(), {
      SSHTTPAgent: HTTPAgent,
      SSHTTPSAgent: HTTPSAgent
    } = require_http_agents(), { parseKey } = require_keyParser(), {
      flagsToString,
      OPEN_MODE,
      STATUS_CODE,
      stringToFlags
    } = require_SFTP();
    module2.exports = {
      AgentProtocol,
      BaseAgent,
      createAgent,
      Client: require_client2(),
      CygwinAgent,
      HTTPAgent,
      HTTPSAgent,
      OpenSSHAgent,
      PageantAgent,
      Server: require_server(),
      utils: {
        parseKey,
        ...require_keygen(),
        sftp: {
          flagsToString,
          OPEN_MODE,
          STATUS_CODE,
          stringToFlags
        }
      }
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      return key = _toPropertyKey(key), key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Object.defineProperty(Constructor, "prototype", { writable: !1 }), Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key == "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input != "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res != "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require("buffer"), Buffer3 = _require.Buffer, _require2 = require("util"), inspect = _require2.inspect, custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer3.prototype.copy.call(src, target, offset);
    }
    module2.exports = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList), this.head = null, this.tail = null, this.length = 0;
      }
      return _createClass(BufferList, [{
        key: "push",
        value: function(v) {
          var entry = {
            data: v,
            next: null
          };
          this.length > 0 ? this.tail.next = entry : this.head = entry, this.tail = entry, ++this.length;
        }
      }, {
        key: "unshift",
        value: function(v) {
          var entry = {
            data: v,
            next: this.head
          };
          this.length === 0 && (this.tail = entry), this.head = entry, ++this.length;
        }
      }, {
        key: "shift",
        value: function() {
          if (this.length !== 0) {
            var ret = this.head.data;
            return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, ret;
          }
        }
      }, {
        key: "clear",
        value: function() {
          this.head = this.tail = null, this.length = 0;
        }
      }, {
        key: "join",
        value: function(s) {
          if (this.length === 0) return "";
          for (var p = this.head, ret = "" + p.data; p = p.next; ) ret += s + p.data;
          return ret;
        }
      }, {
        key: "concat",
        value: function(n) {
          if (this.length === 0) return Buffer3.alloc(0);
          for (var ret = Buffer3.allocUnsafe(n >>> 0), p = this.head, i = 0; p; )
            copyBuffer(p.data, ret, i), i += p.data.length, p = p.next;
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function(n, hasStrings) {
          var ret;
          return n < this.head.data.length ? (ret = this.head.data.slice(0, n), this.head.data = this.head.data.slice(n)) : n === this.head.data.length ? ret = this.shift() : ret = hasStrings ? this._getString(n) : this._getBuffer(n), ret;
        }
      }, {
        key: "first",
        value: function() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function(n) {
          var p = this.head, c = 1, ret = p.data;
          for (n -= ret.length; p = p.next; ) {
            var str = p.data, nb = n > str.length ? str.length : n;
            if (nb === str.length ? ret += str : ret += str.slice(0, n), n -= nb, n === 0) {
              nb === str.length ? (++c, p.next ? this.head = p.next : this.head = this.tail = null) : (this.head = p, p.data = str.slice(nb));
              break;
            }
            ++c;
          }
          return this.length -= c, ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function(n) {
          var ret = Buffer3.allocUnsafe(n), p = this.head, c = 1;
          for (p.data.copy(ret), n -= p.data.length; p = p.next; ) {
            var buf = p.data, nb = n > buf.length ? buf.length : n;
            if (buf.copy(ret, ret.length - n, 0, nb), n -= nb, n === 0) {
              nb === buf.length ? (++c, p.next ? this.head = p.next : this.head = this.tail = null) : (this.head = p, p.data = buf.slice(nb));
              break;
            }
            ++c;
          }
          return this.length -= c, ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function(_, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: !1
          }));
        }
      }]), BufferList;
    }();
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    function destroy(err, cb) {
      var _this = this, readableDestroyed = this._readableState && this._readableState.destroyed, writableDestroyed = this._writableState && this._writableState.destroyed;
      return readableDestroyed || writableDestroyed ? (cb ? cb(err) : err && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process.nextTick(emitErrorNT, this, err)) : process.nextTick(emitErrorNT, this, err)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(err || null, function(err2) {
        !cb && err2 ? _this._writableState ? _this._writableState.errorEmitted ? process.nextTick(emitCloseNT, _this) : (_this._writableState.errorEmitted = !0, process.nextTick(emitErrorAndCloseNT, _this, err2)) : process.nextTick(emitErrorAndCloseNT, _this, err2) : cb ? (process.nextTick(emitCloseNT, _this), cb(err2)) : process.nextTick(emitCloseNT, _this);
      }), this);
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err), emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      self2._writableState && !self2._writableState.emitClose || self2._readableState && !self2._readableState.emitClose || self2.emit("close");
    }
    function undestroy() {
      this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState, wState = stream._writableState;
      rState && rState.autoDestroy || wState && wState.autoDestroy ? stream.destroy(err) : stream.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/readable-stream/errors.js
var require_errors3 = __commonJS({
  "node_modules/readable-stream/errors.js"(exports2, module2) {
    "use strict";
    var codes = {};
    function createErrorType(code2, message, Base) {
      Base || (Base = Error);
      function getMessage(arg1, arg2, arg3) {
        return typeof message == "string" ? message : message(arg1, arg2, arg3);
      }
      class NodeError extends Base {
        constructor(arg1, arg2, arg3) {
          super(getMessage(arg1, arg2, arg3));
        }
      }
      NodeError.prototype.name = Base.name, NodeError.prototype.code = code2, codes[code2] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        let len = expected.length;
        return expected = expected.map((i) => String(i)), len > 2 ? `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1] : len === 2 ? `one of ${thing} ${expected[0]} or ${expected[1]}` : `of ${thing} ${expected[0]}`;
      } else
        return `of ${thing} ${String(expected)}`;
    }
    function startsWith(str, search, pos2) {
      return str.substr(!pos2 || pos2 < 0 ? 0 : +pos2, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      return (this_len === void 0 || this_len > str.length) && (this_len = str.length), str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      return typeof start != "number" && (start = 0), start + search.length > str.length ? !1 : str.indexOf(search, start) !== -1;
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name2, value) {
      return 'The value "' + value + '" is invalid for option "' + name2 + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name2, expected, actual) {
      let determiner;
      typeof expected == "string" && startsWith(expected, "not ") ? (determiner = "must not be", expected = expected.replace(/^not /, "")) : determiner = "must be";
      let msg;
      if (endsWith(name2, " argument"))
        msg = `The ${name2} ${determiner} ${oneOf(expected, "type")}`;
      else {
        let type = includes(name2, ".") ? "property" : "argument";
        msg = `The "${name2}" ${type} ${determiner} ${oneOf(expected, "type")}`;
      }
      return msg += `. Received type ${typeof actual}`, msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name2) {
      return "The " + name2 + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name2) {
      return "Cannot call " + name2 + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors3().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name2 = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name2, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    typeof Object.create == "function" ? module2.exports = function(ctor, superCtor) {
      superCtor && (ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      }));
    } : module2.exports = function(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor(), ctor.prototype.constructor = ctor;
      }
    };
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports2, module2) {
    try {
      if (util = require("util"), typeof util.inherits != "function") throw "";
      module2.exports = util.inherits;
    } catch {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/util-deprecate/node.js
var require_node = __commonJS({
  "node_modules/util-deprecate/node.js"(exports2, module2) {
    module2.exports = require("util").deprecate;
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null, this.entry = null, this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_node()
    }, Stream2 = require_stream(), Buffer3 = require("buffer").Buffer, OurUint8Array = (typeof global < "u" ? global : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer3.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy(), _require = require_state(), getHighWaterMark = _require.getHighWaterMark, _require$codes = require_errors3().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING, errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits()(Writable, Stream2);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex(), options = options || {}, typeof isDuplex != "boolean" && (isDuplex = stream instanceof Duplex), this.objectMode = !!options.objectMode, isDuplex && (this.objectMode = this.objectMode || !!options.writableObjectMode), this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
      var noDecode = options.decodeStrings === !1;
      this.decodeStrings = !noDecode, this.defaultEncoding = options.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(er) {
        onwrite(stream, er);
      }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = options.emitClose !== !1, this.autoDestroy = !!options.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function() {
      for (var current = this.bufferedRequest, out = []; current; )
        out.push(current), current = current.next;
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch {
      }
    })();
    var realHasInstance;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (realHasInstance = Function.prototype[Symbol.hasInstance], Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function(object) {
        return realHasInstance.call(this, object) ? !0 : this !== Writable ? !1 : object && object._writableState instanceof WritableState;
      }
    })) : realHasInstance = function(object) {
      return object instanceof this;
    };
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex), this.writable = !0, options && (typeof options.write == "function" && (this._write = options.write), typeof options.writev == "function" && (this._writev = options.writev), typeof options.destroy == "function" && (this._destroy = options.destroy), typeof options.final == "function" && (this._final = options.final)), Stream2.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er), process.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      return chunk === null ? er = new ERR_STREAM_NULL_VALUES() : typeof chunk != "string" && !state.objectMode && (er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk)), er ? (errorOrDestroy(stream, er), process.nextTick(cb, er), !1) : !0;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState, ret = !1, isBuf = !state.objectMode && _isUint8Array(chunk);
      return isBuf && !Buffer3.isBuffer(chunk) && (chunk = _uint8ArrayToBuffer(chunk)), typeof encoding == "function" && (cb = encoding, encoding = null), isBuf ? encoding = "buffer" : encoding || (encoding = state.defaultEncoding), typeof cb != "function" && (cb = nop), state.ending ? writeAfterEnd(this, cb) : (isBuf || validChunk(this, state, chunk, cb)) && (state.pendingcb++, ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb)), ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      state.corked && (state.corked--, !state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest && clearBuffer(this, state));
    };
    Writable.prototype.setDefaultEncoding = function(encoding) {
      if (typeof encoding == "string" && (encoding = encoding.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
      return this._writableState.defaultEncoding = encoding, this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: !1,
      get: function() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      return !state.objectMode && state.decodeStrings !== !1 && typeof chunk == "string" && (chunk = Buffer3.from(chunk, encoding)), chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: !1,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        chunk !== newChunk && (isBuf = !0, encoding = "buffer", chunk = newChunk);
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (ret || (state.needDrain = !0), state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        }, last ? last.next = state.lastBufferedRequest : state.bufferedRequest = state.lastBufferedRequest, state.bufferedRequestCount += 1;
      } else
        doWrite(stream, state, !1, len, chunk, encoding, cb);
      return ret;
    }
    function doWrite(stream, state, writev2, len, chunk, encoding, cb) {
      state.writelen = len, state.writecb = cb, state.writing = !0, state.sync = !0, state.destroyed ? state.onwrite(new ERR_STREAM_DESTROYED("write")) : writev2 ? stream._writev(chunk, state.onwrite) : stream._write(chunk, encoding, state.onwrite), state.sync = !1;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb, sync ? (process.nextTick(cb, er), process.nextTick(finishMaybe, stream, state), stream._writableState.errorEmitted = !0, errorOrDestroy(stream, er)) : (cb(er), stream._writableState.errorEmitted = !0, errorOrDestroy(stream, er), finishMaybe(stream, state));
    }
    function onwriteStateUpdate(state) {
      state.writing = !1, state.writecb = null, state.length -= state.writelen, state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState, sync = state.sync, cb = state.writecb;
      if (typeof cb != "function") throw new ERR_MULTIPLE_CALLBACK();
      if (onwriteStateUpdate(state), er) onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        !finished && !state.corked && !state.bufferProcessing && state.bufferedRequest && clearBuffer(stream, state), sync ? process.nextTick(afterWrite, stream, state, finished, cb) : afterWrite(stream, state, finished, cb);
      }
    }
    function afterWrite(stream, state, finished, cb) {
      finished || onwriteDrain(stream, state), state.pendingcb--, cb(), finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      state.length === 0 && state.needDrain && (state.needDrain = !1, stream.emit("drain"));
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = !0;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount, buffer = new Array(l), holder = state.corkedRequestsFree;
        holder.entry = entry;
        for (var count = 0, allBuffers = !0; entry; )
          buffer[count] = entry, entry.isBuf || (allBuffers = !1), entry = entry.next, count += 1;
        buffer.allBuffers = allBuffers, doWrite(stream, state, !0, state.length, buffer, "", holder.finish), state.pendingcb++, state.lastBufferedRequest = null, holder.next ? (state.corkedRequestsFree = holder.next, holder.next = null) : state.corkedRequestsFree = new CorkedRequest(state), state.bufferedRequestCount = 0;
      } else {
        for (; entry; ) {
          var chunk = entry.chunk, encoding = entry.encoding, cb = entry.callback, len = state.objectMode ? 1 : chunk.length;
          if (doWrite(stream, state, !1, len, chunk, encoding, cb), entry = entry.next, state.bufferedRequestCount--, state.writing)
            break;
        }
        entry === null && (state.lastBufferedRequest = null);
      }
      state.bufferedRequest = entry, state.bufferProcessing = !1;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      return typeof chunk == "function" ? (cb = chunk, chunk = null, encoding = null) : typeof encoding == "function" && (cb = encoding, encoding = null), chunk != null && this.write(chunk, encoding), state.corked && (state.corked = 1, this.uncork()), state.ending || endWritable(this, state, cb), this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: !1,
      get: function() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--, err && errorOrDestroy(stream, err), state.prefinished = !0, stream.emit("prefinish"), finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      !state.prefinished && !state.finalCalled && (typeof stream._final == "function" && !state.destroyed ? (state.pendingcb++, state.finalCalled = !0, process.nextTick(callFinal, stream, state)) : (state.prefinished = !0, stream.emit("prefinish")));
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need && (prefinish(stream, state), state.pendingcb === 0 && (state.finished = !0, stream.emit("finish"), state.autoDestroy))) {
        var rState = stream._readableState;
        (!rState || rState.autoDestroy && rState.endEmitted) && stream.destroy();
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = !0, finishMaybe(stream, state), cb && (state.finished ? process.nextTick(cb) : stream.once("finish", cb)), state.ended = !0, stream.writable = !1;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      for (corkReq.entry = null; entry; ) {
        var cb = entry.callback;
        state.pendingcb--, cb(err), entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: !1,
      get: function() {
        return this._writableState === void 0 ? !1 : this._writableState.destroyed;
      },
      set: function(value) {
        this._writableState && (this._writableState.destroyed = value);
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) keys2.push(key);
      return keys2;
    };
    module2.exports = Duplex;
    var Readable = require_stream_readable(), Writable = require_stream_writable();
    require_inherits()(Duplex, Readable);
    for (keys = objectKeys(Writable.prototype), v = 0; v < keys.length; v++)
      method = keys[v], Duplex.prototype[method] || (Duplex.prototype[method] = Writable.prototype[method]);
    var keys, method, v;
    function Duplex(options) {
      if (!(this instanceof Duplex)) return new Duplex(options);
      Readable.call(this, options), Writable.call(this, options), this.allowHalfOpen = !0, options && (options.readable === !1 && (this.readable = !1), options.writable === !1 && (this.writable = !1), options.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", onend)));
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: !1,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: !1,
      get: function() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: !1,
      get: function() {
        return this._writableState.length;
      }
    });
    function onend() {
      this._writableState.ended || process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: !1,
      get: function() {
        return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value) {
        this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = value, this._writableState.destroyed = value);
      }
    });
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer"), Buffer3 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src)
        dst[key] = src[key];
    }
    Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow ? module2.exports = buffer : (copyProps(buffer, exports2), exports2.Buffer = SafeBuffer);
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer3(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer3.prototype);
    copyProps(Buffer3, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg == "number")
        throw new TypeError("Argument must not be a number");
      return Buffer3(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size != "number")
        throw new TypeError("Argument must be a number");
      var buf = Buffer3(size);
      return fill !== void 0 ? typeof encoding == "string" ? buf.fill(fill, encoding) : buf.fill(fill) : buf.fill(0), buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size != "number")
        throw new TypeError("Argument must be a number");
      return Buffer3(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size != "number")
        throw new TypeError("Argument must be a number");
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer3 = require_safe_buffer().Buffer, isEncoding = Buffer3.isEncoding || function(encoding) {
      switch (encoding = "" + encoding, encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return !0;
        default:
          return !1;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc) return "utf8";
      for (var retried; ; )
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried) return;
            enc = ("" + enc).toLowerCase(), retried = !0;
        }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc != "string" && (Buffer3.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder2;
    function StringDecoder2(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text, this.end = utf16End, nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast, nb = 4;
          break;
        case "base64":
          this.text = base64Text, this.end = base64End, nb = 3;
          break;
        default:
          this.write = simpleWrite, this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Buffer3.allocUnsafe(nb);
    }
    StringDecoder2.prototype.write = function(buf) {
      if (buf.length === 0) return "";
      var r, i;
      if (this.lastNeed) {
        if (r = this.fillLast(buf), r === void 0) return "";
        i = this.lastNeed, this.lastNeed = 0;
      } else
        i = 0;
      return i < buf.length ? r ? r + this.text(buf, i) : this.text(buf, i) : r || "";
    };
    StringDecoder2.prototype.end = utf8End;
    StringDecoder2.prototype.text = utf8Text;
    StringDecoder2.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length)
        return buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length), this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      return byte <= 127 ? 0 : byte >> 5 === 6 ? 2 : byte >> 4 === 14 ? 3 : byte >> 3 === 30 ? 4 : byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i) return 0;
      var nb = utf8CheckByte(buf[j]);
      return nb >= 0 ? (nb > 0 && (self2.lastNeed = nb - 1), nb) : --j < i || nb === -2 ? 0 : (nb = utf8CheckByte(buf[j]), nb >= 0 ? (nb > 0 && (self2.lastNeed = nb - 2), nb) : --j < i || nb === -2 ? 0 : (nb = utf8CheckByte(buf[j]), nb >= 0 ? (nb > 0 && (nb === 2 ? nb = 0 : self2.lastNeed = nb - 3), nb) : 0));
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128)
        return self2.lastNeed = 0, "\uFFFD";
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128)
          return self2.lastNeed = 1, "\uFFFD";
        if (self2.lastNeed > 2 && buf.length > 2 && (buf[2] & 192) !== 128)
          return self2.lastNeed = 2, "\uFFFD";
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed, r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0) return r;
      if (this.lastNeed <= buf.length)
        return buf.copy(this.lastChar, p, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      buf.copy(this.lastChar, p, 0, buf.length), this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed) return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      return buf.copy(this.lastChar, 0, end), buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      return this.lastNeed ? r + "\uFFFD" : r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319)
            return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = buf[buf.length - 2], this.lastChar[1] = buf[buf.length - 1], r.slice(0, -1);
        }
        return r;
      }
      return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = buf[buf.length - 1], buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      return n === 0 ? buf.toString("base64", i) : (this.lastNeed = 3 - n, this.lastTotal = 3, n === 1 ? this.lastChar[0] = buf[buf.length - 1] : (this.lastChar[0] = buf[buf.length - 2], this.lastChar[1] = buf[buf.length - 1]), buf.toString("base64", i, buf.length - n));
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      return this.lastNeed ? r + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors3().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = !1;
      return function() {
        if (!called) {
          called = !0;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
            args[_key] = arguments[_key];
          callback.apply(this, args);
        }
      };
    }
    function noop2() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort == "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts == "function") return eos(stream, null, opts);
      opts || (opts = {}), callback = once(callback || noop2);
      var readable = opts.readable || opts.readable !== !1 && stream.readable, writable = opts.writable || opts.writable !== !1 && stream.writable, onlegacyfinish = function() {
        stream.writable || onfinish();
      }, writableEnded = stream._writableState && stream._writableState.finished, onfinish = function() {
        writable = !1, writableEnded = !0, readable || callback.call(stream);
      }, readableEnded = stream._readableState && stream._readableState.endEmitted, onend = function() {
        readable = !1, readableEnded = !0, writable || callback.call(stream);
      }, onerror = function(err) {
        callback.call(stream, err);
      }, onclose = function() {
        var err;
        if (readable && !readableEnded)
          return (!stream._readableState || !stream._readableState.ended) && (err = new ERR_STREAM_PREMATURE_CLOSE()), callback.call(stream, err);
        if (writable && !writableEnded)
          return (!stream._writableState || !stream._writableState.ended) && (err = new ERR_STREAM_PREMATURE_CLOSE()), callback.call(stream, err);
      }, onrequest = function() {
        stream.req.on("finish", onfinish);
      };
      return isRequest(stream) ? (stream.on("complete", onfinish), stream.on("abort", onclose), stream.req ? onrequest() : stream.on("request", onrequest)) : writable && !stream._writableState && (stream.on("end", onlegacyfinish), stream.on("close", onlegacyfinish)), stream.on("end", onend), stream.on("finish", onfinish), opts.error !== !1 && stream.on("error", onerror), stream.on("close", onclose), function() {
        stream.removeListener("complete", onfinish), stream.removeListener("abort", onclose), stream.removeListener("request", onrequest), stream.req && stream.req.removeListener("finish", onfinish), stream.removeListener("end", onlegacyfinish), stream.removeListener("close", onlegacyfinish), stream.removeListener("finish", onfinish), stream.removeListener("end", onend), stream.removeListener("error", onerror), stream.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports2, module2) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      return key = _toPropertyKey(key), key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key == "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input != "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res != "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream(), kLastResolve = Symbol("lastResolve"), kLastReject = Symbol("lastReject"), kError = Symbol("error"), kEnded = Symbol("ended"), kLastPromise = Symbol("lastPromise"), kHandlePromise = Symbol("handlePromise"), kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve2 = iter[kLastResolve];
      if (resolve2 !== null) {
        var data = iter[kStream].read();
        data !== null && (iter[kLastPromise] = null, iter[kLastResolve] = null, iter[kLastReject] = null, resolve2(createIterResult(data, !1)));
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve2, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve2(createIterResult(void 0, !0));
            return;
          }
          iter[kHandlePromise](resolve2, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    }), ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function() {
        var _this = this, error = this[kError];
        if (error !== null)
          return Promise.reject(error);
        if (this[kEnded])
          return Promise.resolve(createIterResult(void 0, !0));
        if (this[kStream].destroyed)
          return new Promise(function(resolve2, reject) {
            process.nextTick(function() {
              _this[kError] ? reject(_this[kError]) : resolve2(createIterResult(void 0, !0));
            });
          });
        var lastPromise = this[kLastPromise], promise;
        if (lastPromise)
          promise = new Promise(wrapForNext(lastPromise, this));
        else {
          var data = this[kStream].read();
          if (data !== null)
            return Promise.resolve(createIterResult(data, !1));
          promise = new Promise(this[kHandlePromise]);
        }
        return this[kLastPromise] = promise, promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function() {
      var _this2 = this;
      return new Promise(function(resolve2, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve2(createIterResult(void 0, !0));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype), createReadableStreamAsyncIterator = function(stream) {
      var _Object$create, iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: !0
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: !0
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: !0
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: !0
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: !0
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function(resolve2, reject) {
          var data = iterator[kStream].read();
          data ? (iterator[kLastPromise] = null, iterator[kLastResolve] = null, iterator[kLastReject] = null, resolve2(createIterResult(data, !1))) : (iterator[kLastResolve] = resolve2, iterator[kLastReject] = reject);
        },
        writable: !0
      }), _Object$create));
      return iterator[kLastPromise] = null, finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          reject !== null && (iterator[kLastPromise] = null, iterator[kLastResolve] = null, iterator[kLastReject] = null, reject(err)), iterator[kError] = err;
          return;
        }
        var resolve2 = iterator[kLastResolve];
        resolve2 !== null && (iterator[kLastPromise] = null, iterator[kLastResolve] = null, iterator[kLastReject] = null, resolve2(createIterResult(void 0, !0))), iterator[kEnded] = !0;
      }), stream.on("readable", onReadable.bind(null, iterator)), iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/from.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve2, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg), value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      info.done ? resolve2(value) : Promise.resolve(value).then(_next, _throw);
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve2, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      return key = _toPropertyKey(key), key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key == "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input != "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res != "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var ERR_INVALID_ARG_TYPE = require_errors3().codes.ERR_INVALID_ARG_TYPE;
    function from(Readable, iterable, opts) {
      var iterator;
      if (iterable && typeof iterable.next == "function")
        iterator = iterable;
      else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator]();
      else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator]();
      else throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      var readable = new Readable(_objectSpread({
        objectMode: !0
      }, opts)), reading = !1;
      readable._read = function() {
        reading || (reading = !0, next());
      };
      function next() {
        return _next2.apply(this, arguments);
      }
      function _next2() {
        return _next2 = _asyncToGenerator(function* () {
          try {
            var _yield$iterator$next = yield iterator.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;
            done ? readable.push(null) : readable.push(yield value) ? next() : reading = !1;
          } catch (err) {
            readable.destroy(err);
          }
        }), _next2.apply(this, arguments);
      }
      return readable;
    }
    module2.exports = from;
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    module2.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE3 = require("events").EventEmitter, EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    }, Stream2 = require_stream(), Buffer3 = require("buffer").Buffer, OurUint8Array = (typeof global < "u" ? global : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer3.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require("util"), debug;
    debugUtil && debugUtil.debuglog ? debug = debugUtil.debuglog("stream") : debug = function() {
    };
    var BufferList = require_buffer_list(), destroyImpl = require_destroy(), _require = require_state(), getHighWaterMark = _require.getHighWaterMark, _require$codes = require_errors3().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, StringDecoder2, createReadableStreamAsyncIterator, from;
    require_inherits()(Readable, Stream2);
    var errorOrDestroy = destroyImpl.errorOrDestroy, kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener == "function") return emitter.prependListener(event, fn);
      !emitter._events || !emitter._events[event] ? emitter.on(event, fn) : Array.isArray(emitter._events[event]) ? emitter._events[event].unshift(fn) : emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex(), options = options || {}, typeof isDuplex != "boolean" && (isDuplex = stream instanceof Duplex), this.objectMode = !!options.objectMode, isDuplex && (this.objectMode = this.objectMode || !!options.readableObjectMode), this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex), this.buffer = new BufferList(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = options.emitClose !== !1, this.autoDestroy = !!options.autoDestroy, this.destroyed = !1, this.defaultEncoding = options.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, options.encoding && (StringDecoder2 || (StringDecoder2 = require_string_decoder().StringDecoder), this.decoder = new StringDecoder2(options.encoding), this.encoding = options.encoding);
    }
    function Readable(options) {
      if (Duplex = Duplex || require_stream_duplex(), !(this instanceof Readable)) return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex), this.readable = !0, options && (typeof options.read == "function" && (this._read = options.read), typeof options.destroy == "function" && (this._destroy = options.destroy)), Stream2.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: !1,
      get: function() {
        return this._readableState === void 0 ? !1 : this._readableState.destroyed;
      },
      set: function(value) {
        this._readableState && (this._readableState.destroyed = value);
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState, skipChunkCheck;
      return state.objectMode ? skipChunkCheck = !0 : typeof chunk == "string" && (encoding = encoding || state.defaultEncoding, encoding !== state.encoding && (chunk = Buffer3.from(chunk, encoding), encoding = ""), skipChunkCheck = !0), readableAddChunk(this, chunk, encoding, !1, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, !0, !1);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null)
        state.reading = !1, onEofChunk(stream, state);
      else {
        var er;
        if (skipChunkCheck || (er = chunkInvalid(state, chunk)), er)
          errorOrDestroy(stream, er);
        else if (state.objectMode || chunk && chunk.length > 0)
          if (typeof chunk != "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer3.prototype && (chunk = _uint8ArrayToBuffer(chunk)), addToFront)
            state.endEmitted ? errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT()) : addChunk(stream, state, chunk, !0);
          else if (state.ended)
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          else {
            if (state.destroyed)
              return !1;
            state.reading = !1, state.decoder && !encoding ? (chunk = state.decoder.write(chunk), state.objectMode || chunk.length !== 0 ? addChunk(stream, state, chunk, !1) : maybeReadMore(stream, state)) : addChunk(stream, state, chunk, !1);
          }
        else addToFront || (state.reading = !1, maybeReadMore(stream, state));
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      state.flowing && state.length === 0 && !state.sync ? (state.awaitDrain = 0, stream.emit("data", chunk)) : (state.length += state.objectMode ? 1 : chunk.length, addToFront ? state.buffer.unshift(chunk) : state.buffer.push(chunk), state.needReadable && emitReadable(stream)), maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      return !_isUint8Array(chunk) && typeof chunk != "string" && chunk !== void 0 && !state.objectMode && (er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk)), er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === !1;
    };
    Readable.prototype.setEncoding = function(enc) {
      StringDecoder2 || (StringDecoder2 = require_string_decoder().StringDecoder);
      var decoder = new StringDecoder2(enc);
      this._readableState.decoder = decoder, this._readableState.encoding = this._readableState.decoder.encoding;
      for (var p = this._readableState.buffer.head, content = ""; p !== null; )
        content += decoder.write(p.data), p = p.next;
      return this._readableState.buffer.clear(), content !== "" && this._readableState.buffer.push(content), this._readableState.length = content.length, this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      return n >= MAX_HWM ? n = MAX_HWM : (n--, n |= n >>> 1, n |= n >>> 2, n |= n >>> 4, n |= n >>> 8, n |= n >>> 16, n++), n;
    }
    function howMuchToRead(n, state) {
      return n <= 0 || state.length === 0 && state.ended ? 0 : state.objectMode ? 1 : n !== n ? state.flowing && state.length ? state.buffer.head.data.length : state.length : (n > state.highWaterMark && (state.highWaterMark = computeNewHighWaterMark(n)), n <= state.length ? n : state.ended ? state.length : (state.needReadable = !0, 0));
    }
    Readable.prototype.read = function(n) {
      debug("read", n), n = parseInt(n, 10);
      var state = this._readableState, nOrig = n;
      if (n !== 0 && (state.emittedReadable = !1), n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended))
        return debug("read: emitReadable", state.length, state.ended), state.length === 0 && state.ended ? endReadable(this) : emitReadable(this), null;
      if (n = howMuchToRead(n, state), n === 0 && state.ended)
        return state.length === 0 && endReadable(this), null;
      var doRead = state.needReadable;
      debug("need readable", doRead), (state.length === 0 || state.length - n < state.highWaterMark) && (doRead = !0, debug("length less than watermark", doRead)), state.ended || state.reading ? (doRead = !1, debug("reading or ended", doRead)) : doRead && (debug("do read"), state.reading = !0, state.sync = !0, state.length === 0 && (state.needReadable = !0), this._read(state.highWaterMark), state.sync = !1, state.reading || (n = howMuchToRead(nOrig, state)));
      var ret;
      return n > 0 ? ret = fromList(n, state) : ret = null, ret === null ? (state.needReadable = state.length <= state.highWaterMark, n = 0) : (state.length -= n, state.awaitDrain = 0), state.length === 0 && (state.ended || (state.needReadable = !0), nOrig !== n && state.ended && endReadable(this)), ret !== null && this.emit("data", ret), ret;
    };
    function onEofChunk(stream, state) {
      if (debug("onEofChunk"), !state.ended) {
        if (state.decoder) {
          var chunk = state.decoder.end();
          chunk && chunk.length && (state.buffer.push(chunk), state.length += state.objectMode ? 1 : chunk.length);
        }
        state.ended = !0, state.sync ? emitReadable(stream) : (state.needReadable = !1, state.emittedReadable || (state.emittedReadable = !0, emitReadable_(stream)));
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable), state.needReadable = !1, state.emittedReadable || (debug("emitReadable", state.flowing), state.emittedReadable = !0, process.nextTick(emitReadable_, stream));
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended), !state.destroyed && (state.length || state.ended) && (stream.emit("readable"), state.emittedReadable = !1), state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark, flow(stream);
    }
    function maybeReadMore(stream, state) {
      state.readingMore || (state.readingMore = !0, process.nextTick(maybeReadMore_, stream, state));
    }
    function maybeReadMore_(stream, state) {
      for (; !state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0); ) {
        var len = state.length;
        if (debug("maybeReadMore read 0"), stream.read(0), len === state.length)
          break;
      }
      state.readingMore = !1;
    }
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this, state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1, debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== !1) && dest !== process.stdout && dest !== process.stderr, endFn = doEnd ? onend : unpipe;
      state.endEmitted ? process.nextTick(endFn) : src.once("end", endFn), dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe"), readable === src && unpipeInfo && unpipeInfo.hasUnpiped === !1 && (unpipeInfo.hasUnpiped = !0, cleanup());
      }
      function onend() {
        debug("onend"), dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = !1;
      function cleanup() {
        debug("cleanup"), dest.removeListener("close", onclose), dest.removeListener("finish", onfinish), dest.removeListener("drain", ondrain), dest.removeListener("error", onerror), dest.removeListener("unpipe", onunpipe), src.removeListener("end", onend), src.removeListener("end", unpipe), src.removeListener("data", ondata), cleanedUp = !0, state.awaitDrain && (!dest._writableState || dest._writableState.needDrain) && ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret), ret === !1 && ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp && (debug("false write response, pause", state.awaitDrain), state.awaitDrain++), src.pause());
      }
      function onerror(er) {
        debug("onerror", er), unpipe(), dest.removeListener("error", onerror), EElistenerCount(dest, "error") === 0 && errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish), unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish"), dest.removeListener("close", onclose), unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe"), src.unpipe(dest);
      }
      return dest.emit("pipe", src), state.flowing || (debug("pipe resume"), src.resume()), dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain), state.awaitDrain && state.awaitDrain--, state.awaitDrain === 0 && EElistenerCount(src, "data") && (state.flowing = !0, flow(src));
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState, unpipeInfo = {
        hasUnpiped: !1
      };
      if (state.pipesCount === 0) return this;
      if (state.pipesCount === 1)
        return dest && dest !== state.pipes ? this : (dest || (dest = state.pipes), state.pipes = null, state.pipesCount = 0, state.flowing = !1, dest && dest.emit("unpipe", this, unpipeInfo), this);
      if (!dest) {
        var dests = state.pipes, len = state.pipesCount;
        state.pipes = null, state.pipesCount = 0, state.flowing = !1;
        for (var i = 0; i < len; i++) dests[i].emit("unpipe", this, {
          hasUnpiped: !1
        });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      return index === -1 ? this : (state.pipes.splice(index, 1), state.pipesCount -= 1, state.pipesCount === 1 && (state.pipes = state.pipes[0]), dest.emit("unpipe", this, unpipeInfo), this);
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream2.prototype.on.call(this, ev, fn), state = this._readableState;
      return ev === "data" ? (state.readableListening = this.listenerCount("readable") > 0, state.flowing !== !1 && this.resume()) : ev === "readable" && !state.endEmitted && !state.readableListening && (state.readableListening = state.needReadable = !0, state.flowing = !1, state.emittedReadable = !1, debug("on readable", state.length, state.reading), state.length ? emitReadable(this) : state.reading || process.nextTick(nReadingNextTick, this)), res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream2.prototype.removeListener.call(this, ev, fn);
      return ev === "readable" && process.nextTick(updateReadableListening, this), res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
      return (ev === "readable" || ev === void 0) && process.nextTick(updateReadableListening, this), res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0, state.resumeScheduled && !state.paused ? state.flowing = !0 : self2.listenerCount("data") > 0 && self2.resume();
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0"), self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      return state.flowing || (debug("resume"), state.flowing = !state.readableListening, resume(this, state)), state.paused = !1, this;
    };
    function resume(stream, state) {
      state.resumeScheduled || (state.resumeScheduled = !0, process.nextTick(resume_, stream, state));
    }
    function resume_(stream, state) {
      debug("resume", state.reading), state.reading || stream.read(0), state.resumeScheduled = !1, stream.emit("resume"), flow(stream), state.flowing && !state.reading && stream.read(0);
    }
    Readable.prototype.pause = function() {
      return debug("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (debug("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
    };
    function flow(stream) {
      var state = stream._readableState;
      for (debug("flow", state.flowing); state.flowing && stream.read() !== null; ) ;
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this, state = this._readableState, paused = !1;
      stream.on("end", function() {
        if (debug("wrapped end"), state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          chunk && chunk.length && _this.push(chunk);
        }
        _this.push(null);
      }), stream.on("data", function(chunk) {
        if (debug("wrapped data"), state.decoder && (chunk = state.decoder.write(chunk)), !(state.objectMode && chunk == null) && !(!state.objectMode && (!chunk || !chunk.length))) {
          var ret = _this.push(chunk);
          ret || (paused = !0, stream.pause());
        }
      });
      for (var i in stream)
        this[i] === void 0 && typeof stream[i] == "function" && (this[i] = /* @__PURE__ */ function(method) {
          return function() {
            return stream[method].apply(stream, arguments);
          };
        }(i));
      for (var n = 0; n < kProxyEvents.length; n++)
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      return this._read = function(n2) {
        debug("wrapped _read", n2), paused && (paused = !1, stream.resume());
      }, this;
    };
    typeof Symbol == "function" && (Readable.prototype[Symbol.asyncIterator] = function() {
      return createReadableStreamAsyncIterator === void 0 && (createReadableStreamAsyncIterator = require_async_iterator()), createReadableStreamAsyncIterator(this);
    });
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: !1,
      get: function() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: !1,
      get: function() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: !1,
      get: function() {
        return this._readableState.flowing;
      },
      set: function(state) {
        this._readableState && (this._readableState.flowing = state);
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: !1,
      get: function() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0) return null;
      var ret;
      return state.objectMode ? ret = state.buffer.shift() : !n || n >= state.length ? (state.decoder ? ret = state.buffer.join("") : state.buffer.length === 1 ? ret = state.buffer.first() : ret = state.buffer.concat(state.length), state.buffer.clear()) : ret = state.buffer.consume(n, state.decoder), ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted), state.endEmitted || (state.ended = !0, process.nextTick(endReadableNT, state, stream));
    }
    function endReadableNT(state, stream) {
      if (debug("endReadableNT", state.endEmitted, state.length), !state.endEmitted && state.length === 0 && (state.endEmitted = !0, stream.readable = !1, stream.emit("end"), state.autoDestroy)) {
        var wState = stream._writableState;
        (!wState || wState.autoDestroy && wState.finished) && stream.destroy();
      }
    }
    typeof Symbol == "function" && (Readable.from = function(iterable, opts) {
      return from === void 0 && (from = require_from()), from(Readable, iterable, opts);
    });
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++)
        if (xs[i] === x) return i;
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var _require$codes = require_errors3().codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0, Duplex = require_stream_duplex();
    require_inherits()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = !1;
      var cb = ts.writecb;
      if (cb === null)
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      ts.writechunk = null, ts.writecb = null, data != null && this.push(data), cb(er);
      var rs = this._readableState;
      rs.reading = !1, (rs.needReadable || rs.length < rs.highWaterMark) && this._read(rs.highWaterMark);
    }
    function Transform(options) {
      if (!(this instanceof Transform)) return new Transform(options);
      Duplex.call(this, options), this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: !1,
        transforming: !1,
        writecb: null,
        writechunk: null,
        writeencoding: null
      }, this._readableState.needReadable = !0, this._readableState.sync = !1, options && (typeof options.transform == "function" && (this._transform = options.transform), typeof options.flush == "function" && (this._flush = options.flush)), this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(er, data) {
        done(_this, er, data);
      }) : done(this, null, null);
    }
    Transform.prototype.push = function(chunk, encoding) {
      return this._transformState.needTransform = !1, Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      if (ts.writecb = cb, ts.writechunk = chunk, ts.writeencoding = encoding, !ts.transforming) {
        var rs = this._readableState;
        (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) && this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      ts.writechunk !== null && !ts.transforming ? (ts.transforming = !0, this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform)) : ts.needTransform = !0;
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er) return stream.emit("error", er);
      if (data != null && stream.push(data), stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    require_inherits()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough)) return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports2, module2) {
    "use strict";
    var eos;
    function once(callback) {
      var called = !1;
      return function() {
        called || (called = !0, callback.apply(void 0, arguments));
      };
    }
    var _require$codes = require_errors3().codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop2(err) {
      if (err) throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort == "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = !1;
      stream.on("close", function() {
        closed = !0;
      }), eos === void 0 && (eos = require_end_of_stream()), eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err) return callback(err);
        closed = !0, callback();
      });
      var destroyed = !1;
      return function(err) {
        if (!closed && !destroyed) {
          if (destroyed = !0, isRequest(stream)) return stream.abort();
          if (typeof stream.destroy == "function") return stream.destroy();
          callback(err || new ERR_STREAM_DESTROYED("pipe"));
        }
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      return !streams.length || typeof streams[streams.length - 1] != "function" ? noop2 : streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++)
        streams[_key] = arguments[_key];
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]) && (streams = streams[0]), streams.length < 2)
        throw new ERR_MISSING_ARGS("streams");
      var error, destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1, writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          error || (error = err), err && destroys.forEach(call), !reading && (destroys.forEach(call), callback(error));
        });
      });
      return streams.reduce(pipe);
    }
    module2.exports = pipeline;
  }
});

// node_modules/readable-stream/readable.js
var require_readable2 = __commonJS({
  "node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream2 = require("stream");
    process.env.READABLE_STREAM === "disable" && Stream2 ? (module2.exports = Stream2.Readable, Object.assign(module2.exports, Stream2), module2.exports.Stream = Stream2) : (exports2 = module2.exports = require_stream_readable(), exports2.Stream = Stream2 || exports2, exports2.Readable = exports2, exports2.Writable = require_stream_writable(), exports2.Duplex = require_stream_duplex(), exports2.Transform = require_stream_transform(), exports2.PassThrough = require_stream_passthrough(), exports2.finished = require_end_of_stream(), exports2.pipeline = require_pipeline());
  }
});

// node_modules/buffer-from/index.js
var require_buffer_from = __commonJS({
  "node_modules/buffer-from/index.js"(exports2, module2) {
    var toString = Object.prototype.toString, isModern = typeof Buffer < "u" && typeof Buffer.alloc == "function" && typeof Buffer.allocUnsafe == "function" && typeof Buffer.from == "function";
    function isArrayBuffer(input) {
      return toString.call(input).slice(8, -1) === "ArrayBuffer";
    }
    function fromArrayBuffer(obj, byteOffset, length) {
      byteOffset >>>= 0;
      var maxLength = obj.byteLength - byteOffset;
      if (maxLength < 0)
        throw new RangeError("'offset' is out of bounds");
      if (length === void 0)
        length = maxLength;
      else if (length >>>= 0, length > maxLength)
        throw new RangeError("'length' is out of bounds");
      return isModern ? Buffer.from(obj.slice(byteOffset, byteOffset + length)) : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)));
    }
    function fromString(string, encoding) {
      if ((typeof encoding != "string" || encoding === "") && (encoding = "utf8"), !Buffer.isEncoding(encoding))
        throw new TypeError('"encoding" must be a valid string encoding');
      return isModern ? Buffer.from(string, encoding) : new Buffer(string, encoding);
    }
    function bufferFrom(value, encodingOrOffset, length) {
      if (typeof value == "number")
        throw new TypeError('"value" argument must not be a number');
      return isArrayBuffer(value) ? fromArrayBuffer(value, encodingOrOffset, length) : typeof value == "string" ? fromString(value, encodingOrOffset) : isModern ? Buffer.from(value) : new Buffer(value);
    }
    module2.exports = bufferFrom;
  }
});

// node_modules/typedarray/index.js
var require_typedarray = __commonJS({
  "node_modules/typedarray/index.js"(exports2) {
    var undefined2 = void 0, MAX_ARRAY_LENGTH = 1e5, ECMAScript = /* @__PURE__ */ function() {
      var opts = Object.prototype.toString, ophop = Object.prototype.hasOwnProperty;
      return {
        // Class returns internal [[Class]] property, used to avoid cross-frame instanceof issues:
        Class: function(v) {
          return opts.call(v).replace(/^\[object *|\]$/g, "");
        },
        HasProperty: function(o, p) {
          return p in o;
        },
        HasOwnProperty: function(o, p) {
          return ophop.call(o, p);
        },
        IsCallable: function(o) {
          return typeof o == "function";
        },
        ToInt32: function(v) {
          return v >> 0;
        },
        ToUint32: function(v) {
          return v >>> 0;
        }
      };
    }(), LN2 = Math.LN2, abs = Math.abs, floor = Math.floor, log = Math.log, min = Math.min, pow = Math.pow, round = Math.round;
    function configureProperties(obj) {
      if (getOwnPropNames && defineProp) {
        var props = getOwnPropNames(obj), i;
        for (i = 0; i < props.length; i += 1)
          defineProp(obj, props[i], {
            value: obj[props[i]],
            writable: !1,
            enumerable: !1,
            configurable: !1
          });
      }
    }
    var defineProp;
    Object.defineProperty && function() {
      try {
        return Object.defineProperty({}, "x", {}), !0;
      } catch {
        return !1;
      }
    }() ? defineProp = Object.defineProperty : defineProp = function(o, p, desc) {
      if (!o === Object(o)) throw new TypeError("Object.defineProperty called on non-object");
      return ECMAScript.HasProperty(desc, "get") && Object.prototype.__defineGetter__ && Object.prototype.__defineGetter__.call(o, p, desc.get), ECMAScript.HasProperty(desc, "set") && Object.prototype.__defineSetter__ && Object.prototype.__defineSetter__.call(o, p, desc.set), ECMAScript.HasProperty(desc, "value") && (o[p] = desc.value), o;
    };
    var getOwnPropNames = Object.getOwnPropertyNames || function(o) {
      if (o !== Object(o)) throw new TypeError("Object.getOwnPropertyNames called on non-object");
      var props = [], p;
      for (p in o)
        ECMAScript.HasOwnProperty(o, p) && props.push(p);
      return props;
    };
    function makeArrayAccessors(obj) {
      if (!defineProp)
        return;
      if (obj.length > MAX_ARRAY_LENGTH) throw new RangeError("Array too large for polyfill");
      function makeArrayAccessor(index) {
        defineProp(obj, index, {
          get: function() {
            return obj._getter(index);
          },
          set: function(v) {
            obj._setter(index, v);
          },
          enumerable: !0,
          configurable: !1
        });
      }
      var i;
      for (i = 0; i < obj.length; i += 1)
        makeArrayAccessor(i);
    }
    function as_signed(value, bits) {
      var s = 32 - bits;
      return value << s >> s;
    }
    function as_unsigned(value, bits) {
      var s = 32 - bits;
      return value << s >>> s;
    }
    function packI8(n) {
      return [n & 255];
    }
    function unpackI8(bytes) {
      return as_signed(bytes[0], 8);
    }
    function packU8(n) {
      return [n & 255];
    }
    function unpackU8(bytes) {
      return as_unsigned(bytes[0], 8);
    }
    function packU8Clamped(n) {
      return n = round(Number(n)), [n < 0 ? 0 : n > 255 ? 255 : n & 255];
    }
    function packI16(n) {
      return [n >> 8 & 255, n & 255];
    }
    function unpackI16(bytes) {
      return as_signed(bytes[0] << 8 | bytes[1], 16);
    }
    function packU16(n) {
      return [n >> 8 & 255, n & 255];
    }
    function unpackU16(bytes) {
      return as_unsigned(bytes[0] << 8 | bytes[1], 16);
    }
    function packI32(n) {
      return [n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, n & 255];
    }
    function unpackI32(bytes) {
      return as_signed(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32);
    }
    function packU32(n) {
      return [n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, n & 255];
    }
    function unpackU32(bytes) {
      return as_unsigned(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32);
    }
    function packIEEE754(v, ebits, fbits) {
      var bias = (1 << ebits - 1) - 1, s, e, f, ln, i, bits, str, bytes;
      function roundToEven(n) {
        var w = floor(n), f2 = n - w;
        return f2 < 0.5 ? w : f2 > 0.5 || w % 2 ? w + 1 : w;
      }
      for (v !== v ? (e = (1 << ebits) - 1, f = pow(2, fbits - 1), s = 0) : v === 1 / 0 || v === -1 / 0 ? (e = (1 << ebits) - 1, f = 0, s = v < 0 ? 1 : 0) : v === 0 ? (e = 0, f = 0, s = 1 / v === -1 / 0 ? 1 : 0) : (s = v < 0, v = abs(v), v >= pow(2, 1 - bias) ? (e = min(floor(log(v) / LN2), 1023), f = roundToEven(v / pow(2, e) * pow(2, fbits)), f / pow(2, fbits) >= 2 && (e = e + 1, f = 1), e > bias ? (e = (1 << ebits) - 1, f = 0) : (e = e + bias, f = f - pow(2, fbits))) : (e = 0, f = roundToEven(v / pow(2, 1 - bias - fbits)))), bits = [], i = fbits; i; i -= 1)
        bits.push(f % 2 ? 1 : 0), f = floor(f / 2);
      for (i = ebits; i; i -= 1)
        bits.push(e % 2 ? 1 : 0), e = floor(e / 2);
      for (bits.push(s ? 1 : 0), bits.reverse(), str = bits.join(""), bytes = []; str.length; )
        bytes.push(parseInt(str.substring(0, 8), 2)), str = str.substring(8);
      return bytes;
    }
    function unpackIEEE754(bytes, ebits, fbits) {
      var bits = [], i, j, b, str, bias, s, e, f;
      for (i = bytes.length; i; i -= 1)
        for (b = bytes[i - 1], j = 8; j; j -= 1)
          bits.push(b % 2 ? 1 : 0), b = b >> 1;
      return bits.reverse(), str = bits.join(""), bias = (1 << ebits - 1) - 1, s = parseInt(str.substring(0, 1), 2) ? -1 : 1, e = parseInt(str.substring(1, 1 + ebits), 2), f = parseInt(str.substring(1 + ebits), 2), e === (1 << ebits) - 1 ? f !== 0 ? NaN : s * (1 / 0) : e > 0 ? s * pow(2, e - bias) * (1 + f / pow(2, fbits)) : f !== 0 ? s * pow(2, -(bias - 1)) * (f / pow(2, fbits)) : s < 0 ? -0 : 0;
    }
    function unpackF64(b) {
      return unpackIEEE754(b, 11, 52);
    }
    function packF64(v) {
      return packIEEE754(v, 11, 52);
    }
    function unpackF32(b) {
      return unpackIEEE754(b, 8, 23);
    }
    function packF32(v) {
      return packIEEE754(v, 8, 23);
    }
    (function() {
      var ArrayBuffer2 = function(length) {
        if (length = ECMAScript.ToInt32(length), length < 0) throw new RangeError("ArrayBuffer size is not a small enough positive integer");
        this.byteLength = length, this._bytes = [], this._bytes.length = length;
        var i;
        for (i = 0; i < this.byteLength; i += 1)
          this._bytes[i] = 0;
        configureProperties(this);
      };
      exports2.ArrayBuffer = exports2.ArrayBuffer || ArrayBuffer2;
      var ArrayBufferView = function() {
      };
      function makeConstructor(bytesPerElement, pack, unpack) {
        var ctor;
        return ctor = function(buffer, byteOffset, length) {
          var array, sequence, i, s;
          if (!arguments.length || typeof arguments[0] == "number") {
            if (this.length = ECMAScript.ToInt32(arguments[0]), length < 0) throw new RangeError("ArrayBufferView size is not a small enough positive integer");
            this.byteLength = this.length * this.BYTES_PER_ELEMENT, this.buffer = new ArrayBuffer2(this.byteLength), this.byteOffset = 0;
          } else if (typeof arguments[0] == "object" && arguments[0].constructor === ctor)
            for (array = arguments[0], this.length = array.length, this.byteLength = this.length * this.BYTES_PER_ELEMENT, this.buffer = new ArrayBuffer2(this.byteLength), this.byteOffset = 0, i = 0; i < this.length; i += 1)
              this._setter(i, array._getter(i));
          else if (typeof arguments[0] == "object" && !(arguments[0] instanceof ArrayBuffer2 || ECMAScript.Class(arguments[0]) === "ArrayBuffer"))
            for (sequence = arguments[0], this.length = ECMAScript.ToUint32(sequence.length), this.byteLength = this.length * this.BYTES_PER_ELEMENT, this.buffer = new ArrayBuffer2(this.byteLength), this.byteOffset = 0, i = 0; i < this.length; i += 1)
              s = sequence[i], this._setter(i, Number(s));
          else if (typeof arguments[0] == "object" && (arguments[0] instanceof ArrayBuffer2 || ECMAScript.Class(arguments[0]) === "ArrayBuffer")) {
            if (this.buffer = buffer, this.byteOffset = ECMAScript.ToUint32(byteOffset), this.byteOffset > this.buffer.byteLength)
              throw new RangeError("byteOffset out of range");
            if (this.byteOffset % this.BYTES_PER_ELEMENT)
              throw new RangeError("ArrayBuffer length minus the byteOffset is not a multiple of the element size.");
            if (arguments.length < 3) {
              if (this.byteLength = this.buffer.byteLength - this.byteOffset, this.byteLength % this.BYTES_PER_ELEMENT)
                throw new RangeError("length of buffer minus byteOffset not a multiple of the element size");
              this.length = this.byteLength / this.BYTES_PER_ELEMENT;
            } else
              this.length = ECMAScript.ToUint32(length), this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            if (this.byteOffset + this.byteLength > this.buffer.byteLength)
              throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
          } else
            throw new TypeError("Unexpected argument type(s)");
          this.constructor = ctor, configureProperties(this), makeArrayAccessors(this);
        }, ctor.prototype = new ArrayBufferView(), ctor.prototype.BYTES_PER_ELEMENT = bytesPerElement, ctor.prototype._pack = pack, ctor.prototype._unpack = unpack, ctor.BYTES_PER_ELEMENT = bytesPerElement, ctor.prototype._getter = function(index) {
          if (arguments.length < 1) throw new SyntaxError("Not enough arguments");
          if (index = ECMAScript.ToUint32(index), index >= this.length)
            return undefined2;
          var bytes = [], i, o;
          for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT; i < this.BYTES_PER_ELEMENT; i += 1, o += 1)
            bytes.push(this.buffer._bytes[o]);
          return this._unpack(bytes);
        }, ctor.prototype.get = ctor.prototype._getter, ctor.prototype._setter = function(index, value) {
          if (arguments.length < 2) throw new SyntaxError("Not enough arguments");
          if (index = ECMAScript.ToUint32(index), index >= this.length)
            return undefined2;
          var bytes = this._pack(value), i, o;
          for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT; i < this.BYTES_PER_ELEMENT; i += 1, o += 1)
            this.buffer._bytes[o] = bytes[i];
        }, ctor.prototype.set = function(index, value) {
          if (arguments.length < 1) throw new SyntaxError("Not enough arguments");
          var array, sequence, offset, len, i, s, d, byteOffset, byteLength, tmp;
          if (typeof arguments[0] == "object" && arguments[0].constructor === this.constructor) {
            if (array = arguments[0], offset = ECMAScript.ToUint32(arguments[1]), offset + array.length > this.length)
              throw new RangeError("Offset plus length of array is out of range");
            if (byteOffset = this.byteOffset + offset * this.BYTES_PER_ELEMENT, byteLength = array.length * this.BYTES_PER_ELEMENT, array.buffer === this.buffer) {
              for (tmp = [], i = 0, s = array.byteOffset; i < byteLength; i += 1, s += 1)
                tmp[i] = array.buffer._bytes[s];
              for (i = 0, d = byteOffset; i < byteLength; i += 1, d += 1)
                this.buffer._bytes[d] = tmp[i];
            } else
              for (i = 0, s = array.byteOffset, d = byteOffset; i < byteLength; i += 1, s += 1, d += 1)
                this.buffer._bytes[d] = array.buffer._bytes[s];
          } else if (typeof arguments[0] == "object" && typeof arguments[0].length < "u") {
            if (sequence = arguments[0], len = ECMAScript.ToUint32(sequence.length), offset = ECMAScript.ToUint32(arguments[1]), offset + len > this.length)
              throw new RangeError("Offset plus length of array is out of range");
            for (i = 0; i < len; i += 1)
              s = sequence[i], this._setter(offset + i, Number(s));
          } else
            throw new TypeError("Unexpected argument type(s)");
        }, ctor.prototype.subarray = function(start, end) {
          function clamp(v, min2, max) {
            return v < min2 ? min2 : v > max ? max : v;
          }
          start = ECMAScript.ToInt32(start), end = ECMAScript.ToInt32(end), arguments.length < 1 && (start = 0), arguments.length < 2 && (end = this.length), start < 0 && (start = this.length + start), end < 0 && (end = this.length + end), start = clamp(start, 0, this.length), end = clamp(end, 0, this.length);
          var len = end - start;
          return len < 0 && (len = 0), new this.constructor(
            this.buffer,
            this.byteOffset + start * this.BYTES_PER_ELEMENT,
            len
          );
        }, ctor;
      }
      var Int8Array2 = makeConstructor(1, packI8, unpackI8), Uint8Array2 = makeConstructor(1, packU8, unpackU8), Uint8ClampedArray = makeConstructor(1, packU8Clamped, unpackU8), Int16Array2 = makeConstructor(2, packI16, unpackI16), Uint16Array2 = makeConstructor(2, packU16, unpackU16), Int32Array2 = makeConstructor(4, packI32, unpackI32), Uint32Array2 = makeConstructor(4, packU32, unpackU32), Float32Array2 = makeConstructor(4, packF32, unpackF32), Float64Array2 = makeConstructor(8, packF64, unpackF64);
      exports2.Int8Array = exports2.Int8Array || Int8Array2, exports2.Uint8Array = exports2.Uint8Array || Uint8Array2, exports2.Uint8ClampedArray = exports2.Uint8ClampedArray || Uint8ClampedArray, exports2.Int16Array = exports2.Int16Array || Int16Array2, exports2.Uint16Array = exports2.Uint16Array || Uint16Array2, exports2.Int32Array = exports2.Int32Array || Int32Array2, exports2.Uint32Array = exports2.Uint32Array || Uint32Array2, exports2.Float32Array = exports2.Float32Array || Float32Array2, exports2.Float64Array = exports2.Float64Array || Float64Array2;
    })();
    (function() {
      function r(array, index) {
        return ECMAScript.IsCallable(array.get) ? array.get(index) : array[index];
      }
      var IS_BIG_ENDIAN = function() {
        var u16array = new exports2.Uint16Array([4660]), u8array = new exports2.Uint8Array(u16array.buffer);
        return r(u8array, 0) === 18;
      }(), DataView = function(buffer, byteOffset, byteLength) {
        if (arguments.length === 0)
          buffer = new exports2.ArrayBuffer(0);
        else if (!(buffer instanceof exports2.ArrayBuffer || ECMAScript.Class(buffer) === "ArrayBuffer"))
          throw new TypeError("TypeError");
        if (this.buffer = buffer || new exports2.ArrayBuffer(0), this.byteOffset = ECMAScript.ToUint32(byteOffset), this.byteOffset > this.buffer.byteLength)
          throw new RangeError("byteOffset out of range");
        if (arguments.length < 3 ? this.byteLength = this.buffer.byteLength - this.byteOffset : this.byteLength = ECMAScript.ToUint32(byteLength), this.byteOffset + this.byteLength > this.buffer.byteLength)
          throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
        configureProperties(this);
      };
      function makeGetter(arrayType) {
        return function(byteOffset, littleEndian) {
          if (byteOffset = ECMAScript.ToUint32(byteOffset), byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength)
            throw new RangeError("Array index out of range");
          byteOffset += this.byteOffset;
          var uint8Array = new exports2.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT), bytes = [], i;
          for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1)
            bytes.push(r(uint8Array, i));
          return !!littleEndian == !!IS_BIG_ENDIAN && bytes.reverse(), r(new arrayType(new exports2.Uint8Array(bytes).buffer), 0);
        };
      }
      DataView.prototype.getUint8 = makeGetter(exports2.Uint8Array), DataView.prototype.getInt8 = makeGetter(exports2.Int8Array), DataView.prototype.getUint16 = makeGetter(exports2.Uint16Array), DataView.prototype.getInt16 = makeGetter(exports2.Int16Array), DataView.prototype.getUint32 = makeGetter(exports2.Uint32Array), DataView.prototype.getInt32 = makeGetter(exports2.Int32Array), DataView.prototype.getFloat32 = makeGetter(exports2.Float32Array), DataView.prototype.getFloat64 = makeGetter(exports2.Float64Array);
      function makeSetter(arrayType) {
        return function(byteOffset, value, littleEndian) {
          if (byteOffset = ECMAScript.ToUint32(byteOffset), byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength)
            throw new RangeError("Array index out of range");
          var typeArray = new arrayType([value]), byteArray = new exports2.Uint8Array(typeArray.buffer), bytes = [], i, byteView;
          for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1)
            bytes.push(r(byteArray, i));
          !!littleEndian == !!IS_BIG_ENDIAN && bytes.reverse(), byteView = new exports2.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT), byteView.set(bytes);
        };
      }
      DataView.prototype.setUint8 = makeSetter(exports2.Uint8Array), DataView.prototype.setInt8 = makeSetter(exports2.Int8Array), DataView.prototype.setUint16 = makeSetter(exports2.Uint16Array), DataView.prototype.setInt16 = makeSetter(exports2.Int16Array), DataView.prototype.setUint32 = makeSetter(exports2.Uint32Array), DataView.prototype.setInt32 = makeSetter(exports2.Int32Array), DataView.prototype.setFloat32 = makeSetter(exports2.Float32Array), DataView.prototype.setFloat64 = makeSetter(exports2.Float64Array), exports2.DataView = exports2.DataView || DataView;
    })();
  }
});

// node_modules/concat-stream/index.js
var require_concat_stream = __commonJS({
  "node_modules/concat-stream/index.js"(exports2, module2) {
    var Writable = require_readable2().Writable, inherits = require_inherits(), bufferFrom = require_buffer_from();
    typeof Uint8Array > "u" ? U8 = require_typedarray().Uint8Array : U8 = Uint8Array;
    var U8;
    function ConcatStream(opts, cb) {
      if (!(this instanceof ConcatStream)) return new ConcatStream(opts, cb);
      typeof opts == "function" && (cb = opts, opts = {}), opts || (opts = {});
      var encoding = opts.encoding, shouldInferEncoding = !1;
      encoding ? (encoding = String(encoding).toLowerCase(), (encoding === "u8" || encoding === "uint8") && (encoding = "uint8array")) : shouldInferEncoding = !0, Writable.call(this, { objectMode: !0 }), this.encoding = encoding, this.shouldInferEncoding = shouldInferEncoding, cb && this.on("finish", function() {
        cb(this.getBody());
      }), this.body = [];
    }
    module2.exports = ConcatStream;
    inherits(ConcatStream, Writable);
    ConcatStream.prototype._write = function(chunk, enc, next) {
      this.body.push(chunk), next();
    };
    ConcatStream.prototype.inferEncoding = function(buff) {
      var firstBuffer = buff === void 0 ? this.body[0] : buff;
      return Buffer.isBuffer(firstBuffer) ? "buffer" : typeof Uint8Array < "u" && firstBuffer instanceof Uint8Array ? "uint8array" : Array.isArray(firstBuffer) ? "array" : typeof firstBuffer == "string" ? "string" : Object.prototype.toString.call(firstBuffer) === "[object Object]" ? "object" : "buffer";
    };
    ConcatStream.prototype.getBody = function() {
      return !this.encoding && this.body.length === 0 ? [] : (this.shouldInferEncoding && (this.encoding = this.inferEncoding()), this.encoding === "array" ? arrayConcat(this.body) : this.encoding === "string" ? stringConcat(this.body) : this.encoding === "buffer" ? bufferConcat(this.body) : this.encoding === "uint8array" ? u8Concat(this.body) : this.body);
    };
    var isArray = Array.isArray || function(arr) {
      return Object.prototype.toString.call(arr) == "[object Array]";
    };
    function isArrayish(arr) {
      return /Array\]$/.test(Object.prototype.toString.call(arr));
    }
    function isBufferish(p) {
      return typeof p == "string" || isArrayish(p) || p && typeof p.subarray == "function";
    }
    function stringConcat(parts) {
      for (var strings = [], needsToString = !1, i = 0; i < parts.length; i++) {
        var p = parts[i];
        typeof p == "string" || Buffer.isBuffer(p) ? strings.push(p) : isBufferish(p) ? strings.push(bufferFrom(p)) : strings.push(bufferFrom(String(p)));
      }
      return Buffer.isBuffer(parts[0]) ? (strings = Buffer.concat(strings), strings = strings.toString("utf8")) : strings = strings.join(""), strings;
    }
    function bufferConcat(parts) {
      for (var bufs = [], i = 0; i < parts.length; i++) {
        var p = parts[i];
        Buffer.isBuffer(p) ? bufs.push(p) : isBufferish(p) ? bufs.push(bufferFrom(p)) : bufs.push(bufferFrom(String(p)));
      }
      return Buffer.concat(bufs);
    }
    function arrayConcat(parts) {
      for (var res = [], i = 0; i < parts.length; i++)
        res.push.apply(res, parts[i]);
      return res;
    }
    function u8Concat(parts) {
      for (var len = 0, i = 0; i < parts.length; i++)
        typeof parts[i] == "string" && (parts[i] = bufferFrom(parts[i])), len += parts[i].length;
      for (var u8 = new U8(len), i = 0, offset = 0; i < parts.length; i++)
        for (var part = parts[i], j = 0; j < part.length; j++)
          u8[offset++] = part[j];
      return u8;
    }
  }
});

// node_modules/err-code/index.js
var require_err_code = __commonJS({
  "node_modules/err-code/index.js"(exports2, module2) {
    "use strict";
    function assign(obj, props) {
      for (let key in props)
        Object.defineProperty(obj, key, {
          value: props[key],
          enumerable: !0,
          configurable: !0
        });
      return obj;
    }
    function createError(err, code2, props) {
      if (!err || typeof err == "string")
        throw new TypeError("Please pass an Error to err-code");
      props || (props = {}), typeof code2 == "object" && (props = code2, code2 = void 0), code2 != null && (props.code = code2);
      try {
        return assign(err, props);
      } catch {
        props.message = err.message, props.stack = err.stack;
        let ErrClass = function() {
        };
        return ErrClass.prototype = Object.create(Object.getPrototypeOf(err)), assign(new ErrClass(), props);
      }
    }
    module2.exports = createError;
  }
});

// node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "node_modules/retry/lib/retry_operation.js"(exports2, module2) {
    function RetryOperation(timeouts, options) {
      typeof options == "boolean" && (options = { forever: options }), this._originalTimeouts = JSON.parse(JSON.stringify(timeouts)), this._timeouts = timeouts, this._options = options || {}, this._maxRetryTime = options && options.maxRetryTime || 1 / 0, this._fn = null, this._errors = [], this._attempts = 1, this._operationTimeout = null, this._operationTimeoutCb = null, this._timeout = null, this._operationStart = null, this._options.forever && (this._cachedTimeouts = this._timeouts.slice(0));
    }
    module2.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1, this._timeouts = this._originalTimeouts;
    };
    RetryOperation.prototype.stop = function() {
      this._timeout && clearTimeout(this._timeout), this._timeouts = [], this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout && clearTimeout(this._timeout), !err)
        return !1;
      var currentTime = (/* @__PURE__ */ new Date()).getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime)
        return this._errors.unshift(new Error("RetryOperation timeout occurred")), !1;
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0)
        if (this._cachedTimeouts)
          this._errors.splice(this._errors.length - 1, this._errors.length), this._timeouts = this._cachedTimeouts.slice(0), timeout = this._timeouts.shift();
        else
          return !1;
      var self2 = this, timer = setTimeout(function() {
        self2._attempts++, self2._operationTimeoutCb && (self2._timeout = setTimeout(function() {
          self2._operationTimeoutCb(self2._attempts);
        }, self2._operationTimeout), self2._options.unref && self2._timeout.unref()), self2._fn(self2._attempts);
      }, timeout);
      return this._options.unref && timer.unref(), !0;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn, timeoutOps && (timeoutOps.timeout && (this._operationTimeout = timeoutOps.timeout), timeoutOps.cb && (this._operationTimeoutCb = timeoutOps.cb));
      var self2 = this;
      this._operationTimeoutCb && (this._timeout = setTimeout(function() {
        self2._operationTimeoutCb();
      }, self2._operationTimeout)), this._operationStart = (/* @__PURE__ */ new Date()).getTime(), this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated"), this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated"), this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0)
        return null;
      for (var counts = {}, mainError = null, mainErrorCount = 0, i = 0; i < this._errors.length; i++) {
        var error = this._errors[i], message = error.message, count = (counts[message] || 0) + 1;
        counts[message] = count, count >= mainErrorCount && (mainError = error, mainErrorCount = count);
      }
      return mainError;
    };
  }
});

// node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "node_modules/retry/lib/retry.js"(exports2) {
    var RetryOperation = require_retry_operation();
    exports2.operation = function(options) {
      var timeouts = exports2.timeouts(options);
      return new RetryOperation(timeouts, {
        forever: options && options.forever,
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
      });
    };
    exports2.timeouts = function(options) {
      if (options instanceof Array)
        return [].concat(options);
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: 1 / 0,
        randomize: !1
      };
      for (var key in options)
        opts[key] = options[key];
      if (opts.minTimeout > opts.maxTimeout)
        throw new Error("minTimeout is greater than maxTimeout");
      for (var timeouts = [], i = 0; i < opts.retries; i++)
        timeouts.push(this.createTimeout(i, opts));
      return options && options.forever && !timeouts.length && timeouts.push(this.createTimeout(i, opts)), timeouts.sort(function(a, b) {
        return a - b;
      }), timeouts;
    };
    exports2.createTimeout = function(attempt, opts) {
      var random = opts.randomize ? Math.random() + 1 : 1, timeout = Math.round(random * opts.minTimeout * Math.pow(opts.factor, attempt));
      return timeout = Math.min(timeout, opts.maxTimeout), timeout;
    };
    exports2.wrap = function(obj, options, methods) {
      if (options instanceof Array && (methods = options, options = null), !methods) {
        methods = [];
        for (var key in obj)
          typeof obj[key] == "function" && methods.push(key);
      }
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i], original = obj[method];
        obj[method] = function(original2) {
          var op = exports2.operation(options), args = Array.prototype.slice.call(arguments, 1), callback = args.pop();
          args.push(function(err) {
            op.retry(err) || (err && (arguments[0] = op.mainError()), callback.apply(this, arguments));
          }), op.attempt(function() {
            original2.apply(obj, args);
          });
        }.bind(obj, original), obj[method].options = options;
      }
    };
  }
});

// node_modules/retry/index.js
var require_retry2 = __commonJS({
  "node_modules/retry/index.js"(exports2, module2) {
    module2.exports = require_retry();
  }
});

// node_modules/promise-retry/index.js
var require_promise_retry = __commonJS({
  "node_modules/promise-retry/index.js"(exports2, module2) {
    "use strict";
    var errcode = require_err_code(), retry = require_retry2(), hasOwn = Object.prototype.hasOwnProperty;
    function isRetryError(err) {
      return err && err.code === "EPROMISERETRY" && hasOwn.call(err, "retried");
    }
    function promiseRetry(fn, options) {
      var temp, operation;
      return typeof fn == "object" && typeof options == "function" && (temp = options, options = fn, fn = temp), operation = retry.operation(options), new Promise(function(resolve2, reject) {
        operation.attempt(function(number) {
          Promise.resolve().then(function() {
            return fn(function(err) {
              throw isRetryError(err) && (err = err.retried), errcode(new Error("Retrying"), "EPROMISERETRY", { retried: err });
            }, number);
          }).then(resolve2, function(err) {
            isRetryError(err) && (err = err.retried, operation.retry(err || new Error())) || reject(err);
          });
        });
      });
    }
    module2.exports = promiseRetry;
  }
});

// node_modules/ssh2-sftp-client/src/constants.js
var require_constants7 = __commonJS({
  "node_modules/ssh2-sftp-client/src/constants.js"(exports2, module2) {
    var errorCode = {
      generic: "ERR_GENERIC_CLIENT",
      connect: "ERR_NOT_CONNECTED",
      badPath: "ERR_BAD_PATH",
      permission: "EACCES",
      notexist: "ENOENT",
      notdir: "ENOTDIR",
      badAuth: "ERR_BAD_AUTH"
    }, targetType = {
      writeFile: 1,
      readFile: 2,
      writeDir: 3,
      readDir: 4,
      readObj: 5,
      writeObj: 6
    };
    module2.exports = {
      errorCode,
      targetType
    };
  }
});

// node_modules/ssh2-sftp-client/src/utils.js
var require_utils7 = __commonJS({
  "node_modules/ssh2-sftp-client/src/utils.js"(exports2, module2) {
    var { statSync: statSync2, constants: constants2, accessSync } = require("node:fs"), { dirname: dirname5 } = require("node:path"), { errorCode } = require_constants7();
    function eventHandled(client) {
      return !!(client.errorHandled || client.endHandled || client.closeHandled);
    }
    function globalListener(client, evt, eventCallbacks) {
      return evt === "error" ? (err) => {
        if (client.errorHandled) {
          client.debugMsg(`Global error event: Ignoring handled error ${err.message}`);
          return;
        }
        client.debugMsg(`Global error event: ${err.message}`), client.errorHandled = !0, eventCallbacks?.error && eventCallbacks.error(err);
      } : evt === "end" ? () => {
        if (client.endCalled || client.endHandled) {
          client.debugMsg("Global end event: Ignoring handled end event");
          return;
        }
        client.debugMsg("Global end event: Handling end event"), client.endHandled = !0, eventCallbacks?.end && eventCallbacks.end();
      } : () => {
        client.endCalled || client.closeHandled ? client.debugMsg("Global close event: Ignoring handled close event") : (client.debugMsg("Global close event: Handling close event"), client.closeHandled = !0, client.sftp = void 0, eventCallbacks?.close && eventCallbacks.close());
      };
    }
    function errorListener(client, name2, reject) {
      return function(err) {
        if (eventHandled(client)) {
          client.debugMsg(`${name2} errorListener - ignoring handled error ${err.message}`);
          return;
        }
        client.debugMsg(`${name2} errorListener - handling error ${err.message}`), client.errorHandled = !0;
        let newError = new Error(`${name2}: ${err.message}`);
        if (newError.code = err.code, reject)
          reject(newError);
        else
          throw newError;
      };
    }
    function endListener(client, name2, reject) {
      return function() {
        if (client.sftp = void 0, client.endCalled || eventHandled(client)) {
          client.debugMsg(`${name2} endListener - ignoring handled end event`);
          return;
        }
        client.endHandled = !0, client.debugMsg(`${name2} endListener - handling unexpected end event`);
        let newError = new Error(`${name2}: Unexpected end event`);
        if (newError.code = errorCode.ERR_GENERIC_CLIENT, reject)
          reject(newError);
        else
          throw newError;
      };
    }
    function closeListener(client, name2, reject) {
      return function() {
        if (client.sftp = void 0, client.endCalled || eventHandled(client)) {
          client.debugMsg(`${name2} closeListener - ignoring handled close event`);
          return;
        }
        client.closeHandled = !0, client.debugMsg(`${name2} closeListener - handling unexpected close event`);
        let newError = new Error(`${name2}: Unexpected close event`);
        if (newError.code = errorCode.ERR_GENERIC_CLIENT, reject)
          reject(newError);
        else
          throw newError;
      };
    }
    function addTempListeners(client, name2, reject) {
      let listeners = {
        end: endListener(client, name2, reject),
        close: closeListener(client, name2, reject),
        error: errorListener(client, name2, reject)
      };
      return client.on("end", listeners.end), client.on("close", listeners.close), client.on("error", listeners.error), client._resetEventFlags(), listeners;
    }
    function removeTempListeners(client, listeners, name2) {
      try {
        client.removeListener("end", listeners.end), client.removeListener("close", listeners.close), client.removeListener("error", listeners.error);
      } catch (err) {
        throw new Error(`${name2}: Error removing temp listeners: ${err.message}`);
      }
    }
    function localExists(filePath) {
      let stats = statSync2(filePath, { throwIfNoEntry: !1 });
      if (stats) {
        if (stats.isDirectory())
          return "d";
        if (stats.isFile())
          return "-";
        {
          let err = new Error(`Bad path: ${filePath}: target must be a file or directory`);
          throw err.code = errorCode.badPath, err;
        }
      } else return !1;
    }
    function haveLocalAccess(filePath, mode = "r") {
      let accessMode = constants2.F_OK | mode === "w" ? constants2.W_OK : constants2.R_OK;
      try {
        return accessSync(filePath, accessMode), {
          status: !0,
          type: localExists(filePath),
          details: "access OK",
          code: 0
        };
      } catch (err) {
        switch (err.errno) {
          case -2:
            return {
              status: !1,
              type: null,
              details: "not exist",
              code: -2
            };
          case -13:
            return {
              status: !1,
              type: localExists(filePath),
              details: "permission denied",
              code: -13
            };
          case -20:
            return {
              status: !1,
              type: null,
              details: "parent not a directory"
            };
          default:
            return {
              status: !1,
              type: null,
              details: err.message
            };
        }
      }
    }
    function haveLocalCreate(filePath) {
      let { status, details, type } = haveLocalAccess(filePath, "w");
      if (!status) {
        if (details === "permission denied")
          return {
            status,
            details,
            type
          };
        let dirPath = dirname5(filePath), localCheck = haveLocalAccess(dirPath, "w");
        return localCheck.status ? localCheck.type !== "d" ? {
          status: !1,
          details: `${dirPath}: not a directory`,
          type: null
        } : {
          status: !0,
          details: "access OK",
          type: null,
          code: 0
        } : {
          status: localCheck.status,
          details: `${dirPath}: ${localCheck.details}`,
          type: null
        };
      }
      return { status, details, type };
    }
    async function normalizeRemotePath(client, aPath) {
      try {
        return aPath.startsWith("..") ? `${await client.realPath("..")}/${aPath.slice(3)}` : aPath.startsWith(".") ? `${await client.realPath(".")}/${aPath.slice(2)}` : aPath;
      } catch (err) {
        throw new Error(`normalizeRemotePath: ${err.message}`);
      }
    }
    function haveConnection(client, name2, reject) {
      if (!client.sftp) {
        let newError = new Error(`${name2}: No SFTP connection available`);
        if (newError.code = errorCode.connect, reject)
          return reject(newError), !1;
        throw newError;
      }
      return !0;
    }
    function sleep(ms) {
      return new Promise((resolve2, reject) => {
        try {
          Number.isNaN(Number.parseInt(ms)) || ms < 0 ? reject("Argument must be a number >= 0") : setTimeout(() => {
            resolve2(!0);
          }, ms);
        } catch (err) {
          reject(err);
        }
      });
    }
    function partition(input, size) {
      let output = [];
      if (size < 1)
        throw new Error("Partition size must be greater than zero");
      for (let i = 0; i < input.length; i += size)
        output[output.length] = input.slice(i, i + size);
      return output;
    }
    module2.exports = {
      globalListener,
      errorListener,
      endListener,
      closeListener,
      addTempListeners,
      removeTempListeners,
      haveLocalAccess,
      haveLocalCreate,
      normalizeRemotePath,
      localExists,
      haveConnection,
      sleep,
      partition
    };
  }
});

// node_modules/ssh2-sftp-client/src/index.js
var require_src = __commonJS({
  "node_modules/ssh2-sftp-client/src/index.js"(exports2, module2) {
    "use strict";
    var { Client } = require_lib6(), fs11 = require("node:fs"), concat = require_concat_stream(), promiseRetry = require_promise_retry(), { join: join2, parse: parse5 } = require("node:path"), {
      globalListener,
      addTempListeners,
      removeTempListeners,
      haveConnection,
      normalizeRemotePath,
      localExists,
      haveLocalAccess,
      haveLocalCreate,
      partition
    } = require_utils7(), { errorCode } = require_constants7(), SftpClient = class {
      constructor(clientName = "sftp", callbacks = {
        error: (err) => console.error(`Global error listener: ${err.message}`),
        end: () => console.log("Global end listener: end event raised"),
        close: () => console.log("Global close listener: close event raised")
      }) {
        this.version = "11.0.0", this.client = new Client(), this.sftp = void 0, this.clientName = clientName, this.endCalled = !1, this.errorHandled = !1, this.closeHandled = !1, this.endHandled = !1, this.remotePlatform = "unix", this.debug = void 0, this.promiseLimit = 10, this.eventCallbacks = callbacks, this.client.on("close", globalListener(this, "close", this.eventCallbacks)), this.client.on("end", globalListener(this, "end", this.eventCallbacks)), this.client.on("error", globalListener(this, "error", this.eventCallbacks));
      }
      debugMsg(msg, obj) {
        this.debug && (obj ? this.debug(
          `CLIENT[${this.clientName}]: ${msg} ${JSON.stringify(obj, null, " ")}`
        ) : this.debug(`CLIENT[${this.clientName}]: ${msg}`));
      }
      fmtError(err, name2 = "sftp", eCode, retryCount) {
        let msg = "", code2 = "", retry = retryCount ? ` after ${retryCount} ${retryCount > 1 ? "attempts" : "attempt"}` : "";
        if (err === void 0)
          msg = `${name2}: Undefined error - probably a bug!`, code2 = errorCode.generic;
        else if (typeof err == "string")
          msg = `${name2}: ${err}${retry}`, code2 = eCode || errorCode.generic;
        else if (err.custom)
          msg = `${name2}->${err.message}${retry}`, code2 = err.code;
        else {
          switch (err.code) {
            case "ENOTFOUND": {
              msg = `${name2}: Address lookup failed for host${retry}`;
              break;
            }
            case "ECONNREFUSED": {
              msg = `${name2}: Remote host refused connection${retry}`;
              break;
            }
            case "ECONNRESET": {
              msg = `${name2}: Remote host has reset the connection: ${err.message}${retry}`;
              break;
            }
            default:
              msg = `${name2}: ${err.message}${retry}`;
          }
          code2 = err.code || errorCode.generic;
        }
        let newError = new Error(msg);
        return newError.code = code2, newError.custom = !0, this.debugMsg(`${newError.message} (${newError.code})`), newError;
      }
      /**
       * Add a listner to the client object. This is rarely necessary and can be
       * the source of errors. It is the client's responsibility to remove the
       * listeners when no longer required. Failure to do so can result in memory
       * leaks.
       *
       * @param {string} eventType - one of the supported event types
       * @param {function} callback - function called when event triggers
       */
      on(eventType, callback) {
        this.client.prependListener(eventType, callback);
      }
      removeListener(eventType, callback) {
        this.client.removeListener(eventType, callback);
      }
      _resetEventFlags() {
        this.closeHandled = !1, this.endHandled = !1, this.errorHandled = !1;
      }
      /**
       * @async
       *
       * Create a new SFTP connection to a remote SFTP server
       *
       * @param {Object} config - an SFTP configuration object
       *
       * @return {Promise<Object>} which will resolve to an sftp client object
       */
      getConnection(config) {
        let doReady, listeners;
        return new Promise((resolve2, reject) => {
          listeners = addTempListeners(this, "getConnection", reject), doReady = () => {
            resolve2(!0);
          }, this.on("ready", doReady);
          try {
            this.client.connect(config);
          } catch (err) {
            reject(err);
          }
        }).finally(() => {
          this.removeListener("ready", doReady), removeTempListeners(this, listeners, "getConnection");
        });
      }
      getSftpChannel() {
        return new Promise((resolve2, reject) => {
          this.client.sftp((err, sftp) => {
            err ? reject(this.fmtError(err, "getSftpChannel", err.code)) : (this.sftp = sftp, resolve2(sftp));
          });
        });
      }
      /**
       * @async
       *
       * Create a new SFTP connection to a remote SFTP server.
       * The connection options are the same as those offered
       * by the underlying SSH2 module.
       *
       * @param {Object} config - an SFTP configuration object
       *
       * @return {Promise<Object>} which will resolve to an sftp client object
       */
      async connect(config) {
        let listeners;
        try {
          if (listeners = addTempListeners(this, "connect"), config.debug && (this.debug = config.debug, this.debugMsg("connect: Debugging turned on"), this.debugMsg(`ssh2-sftp-client Version: ${this.version} `, process.versions)), this.promiseLimit = config.promiseLimit ?? 10, this.sftp)
            throw this.fmtError(
              "An existing SFTP connection is already defined",
              "connect",
              errorCode.connect
            );
          let retryOpts = {
            retries: config.retries ?? 1,
            factor: config.retry_factor ?? 2,
            minTimeout: config.retry_minTimeout ?? 25e3
          };
          await promiseRetry(retryOpts, async (retry, attempt) => {
            try {
              this.debugMsg(`connect: Connect attempt ${attempt}`), await this.getConnection(config);
            } catch (err) {
              switch (err.code) {
                case "ENOTFOUND":
                case "ECONNREFUSED":
                case "ERR_SOCKET_BAD_PORT":
                  throw err;
                case void 0: {
                  if (err.message.endsWith("All configured authentication methods failed") || err.message.startsWith("Cannot parse privateKey"))
                    throw err;
                  retry(err);
                  break;
                }
                default:
                  retry(err);
              }
            }
          });
          let sftp = await this.getSftpChannel();
          return this.endCalled = !1, sftp;
        } catch (err) {
          throw this.end(), err.custom ? err : this.fmtError(err, "connect");
        } finally {
          removeTempListeners(this, listeners, "connect");
        }
      }
      /**
       * @async
       *
       * Returns the real absolute path on the remote server. Is able to handle
       * both '.' and '..' in path names, but not '~'. If the path is relative
       * then the current working directory is prepended to create an absolute path.
       * Returns undefined if the path does not exists.
       *
       * @param {String} remotePath - remote path, may be relative
       * @param {Boolean} addListeners - (Optional) add event listeners. Default = true
       * @returns {Promise<String>} - remote absolute path or ''
       */
      realPath(remotePath, addListeners = !0) {
        let listeners;
        return new Promise((resolve2, reject) => {
          addListeners && (listeners = addTempListeners(this, "realPath", reject)), this.sftp.realpath(remotePath, (err, absPath) => {
            err && (err.code === 2 ? resolve2("") : reject(this.fmtError(`${err.message} ${remotePath}`, "realPath", err.code))), resolve2(absPath);
          });
        }).finally(() => {
          addListeners && removeTempListeners(this, listeners, "realPath");
        });
      }
      /**
       * @async
       *
       * Return the current workding directory path
       *
       * @returns {Promise<String>} - current remote working directory
       */
      cwd() {
        return this.realPath(".");
      }
      /**
       * Retrieves attributes for path using cmd, which is either
       * this.sftp.stat or this.sftp.lstat
       *
       * @param {Function} cmd - either this.sftp.stat or this.sftp.lstat
       * @param {String} remotePath - a string containing the path to a file
       * @param {Boolean} addListeners - (Optional) if true add event listeners. Default true.
       * @return {Promise<Object>} stats - attributes info
       */
      _xstat(cmd, aPath, addListeners = !0) {
        let listeners;
        return new Promise((resolve2, reject) => {
          let cb = (err, stats) => {
            if (err)
              err.code === 2 || err.code === 4 ? reject(this.fmtError(`No such file: ${aPath}`, "_xstat", errorCode.notexist)) : reject(this.fmtError(`${err.message} ${aPath}`, "_xstat", err.code));
            else {
              let result = {
                mode: stats.mode,
                uid: stats.uid,
                gid: stats.gid,
                size: stats.size,
                accessTime: stats.atime * 1e3,
                modifyTime: stats.mtime * 1e3,
                isDirectory: stats.isDirectory(),
                isFile: stats.isFile(),
                isBlockDevice: stats.isBlockDevice(),
                isCharacterDevice: stats.isCharacterDevice(),
                isSymbolicLink: stats.isSymbolicLink(),
                isFIFO: stats.isFIFO(),
                isSocket: stats.isSocket()
              };
              resolve2(result);
            }
          };
          addListeners && (listeners = addTempListeners(this, "_xstat", reject)), cmd === "stat" ? this.sftp.stat(aPath, cb) : this.sftp.lstat(aPath, cb);
        }).finally(() => {
          addListeners && removeTempListeners(this, listeners, "_xstat");
        });
      }
      /*
       * Use the stat command to obtain attributes associated with a remote path.
       * THe difference between stat and lstat is that stat, in the case of symbolic
       * links, will return the attributes associated with the target of the link. With
       * lstat, attributes associated with the symbolic link rather than the target are
       * returned.
       *
       * @param {String} remotePath - path to an object on the remote server
       * @return {Promise<Object>} stats - attributes info
       */
      async stat(remotePath) {
        try {
          return haveConnection(this, "stat"), await this._xstat("stat", remotePath);
        } catch (err) {
          throw err.custom ? err : this.fmtError(err, "stat", err.code);
        }
      }
      /*
       * Use the lstat command to obtain attributes associated with a remote path.
       * THe difference between stat and lstat is that stat, in the case of symbolic
       * links, will return the attributes associated with the target of the link. With
       * lstat, attributes associated with the symbolic link rather than the target are
       * returned.
       *
       * @param {String} remotePath - path to an object on the remote server
       * @return {Promise<Object>} stats - attributes info
       */
      async lstat(remotePath) {
        try {
          return haveConnection(this, "lstat"), await this._xstat("lstat", remotePath);
        } catch (err) {
          throw err.custom ? err : this.fmtError(err, "lstat", err.code);
        }
      }
      /**
       * @async
       *
       * Tests to see if an object exists. If it does, return the type of that object
       * (in the format returned by list). If it does not exist, return false.
       *
       * @param {string} remotePath - path to the object on the sftp server.
       *
       * @return {Promise<Boolean|String>} returns false if object does not exist. Returns type of
       *                   object if it does
       */
      async exists(remotePath) {
        try {
          if (remotePath === ".")
            return "d";
          let info = await this.lstat(remotePath);
          return info.isDirectory ? "d" : info.isSymbolicLink ? "l" : info.isFile ? "-" : !1;
        } catch (err) {
          if (err.code === errorCode.notexist)
            return !1;
          throw err.custom ? err : this.fmtError(err.message, "exists", err.code);
        }
      }
      /**
       * @async
       *
       * List contents of a remote directory. If a pattern is provided,
       * filter the results to only include files with names that match
       * the supplied pattern. Return value is an array of file entry
       * objects that include properties for type, name, size, modifyTime,
       * accessTime, rights {user, group other}, owner and group.
       *
       * @param {String} remotePath - path to remote directory
       * @param {function} filter - a filter function used to select return entries
       * @param {Boolean} addListeners - (Optional) if true, add listeners. Default true
       * @returns {Promise<Array>} array of file description objects
       */
      list(remotePath, filter, addListeners = !0) {
        let listeners;
        return new Promise((resolve2, reject) => {
          addListeners && (listeners = addTempListeners(this, "list", reject)), haveConnection(this, "list", reject) && this.sftp.readdir(remotePath, (err, fileList) => {
            if (err)
              reject(this.fmtError(`${err.message} ${remotePath}`, "list", err.code));
            else {
              let reg = /-/gi, newList = fileList.map((item) => ({
                type: item.longname.slice(0, 1),
                name: item.filename,
                size: item.attrs.size,
                modifyTime: item.attrs.mtime * 1e3,
                accessTime: item.attrs.atime * 1e3,
                rights: {
                  user: item.longname.slice(1, 4).replaceAll(reg, ""),
                  group: item.longname.slice(4, 7).replaceAll(reg, ""),
                  other: item.longname.slice(7, 10).replaceAll(reg, "")
                },
                owner: item.attrs.uid,
                group: item.attrs.gid,
                longname: item.longname
              }));
              resolve2(filter ? newList.filter((item) => filter(item)) : newList);
            }
          });
        }).finally(() => {
          addListeners && removeTempListeners(this, listeners, "list");
        });
      }
      /**
       * get file
       *
       * If a dst argument is provided, it must be either a string, representing the
       * local path to where the data will be put, a stream, in which case data is
       * piped into the stream or undefined, in which case the data is returned as
       * a Buffer object.
       *
       * @param {String} remotePath - remote file path
       * @param {string|stream|undefined} dst - data destination
       * @param {Object} options - options object with supported properties of readStreamOptions,
       *                          writeStreamOptions and pipeOptions.
       * @param {Boolean} addListeners - (Optional) if true, add listeners. Default true
       *
       * *Important Note*: The ability to set ''autoClose' on read/write streams and 'end' on pipe() calls
       * is no longer supported. New methods 'createReadStream()' and 'createWriteStream()' have been
       * added to support low-level access to stream objects.
       *
       * @return {Promise<String|Stream|Buffer>}
       */
      get(remotePath, dst, options, addListeners = !0) {
        let listeners, rdr, wtr;
        return new Promise((resolve2, reject) => {
          if (addListeners && (listeners = addTempListeners(this, "get", reject)), haveConnection(this, "get", reject)) {
            if (options = {
              readStreamOptions: { ...options?.readStreamOptions, autoClose: !0 },
              writeStreamOptions: {
                ...options?.writeStreamOptions,
                autoClose: !0
              },
              pipeOptions: { ...options?.pipeOptions, end: !0 }
            }, rdr = this.sftp.createReadStream(remotePath, options.readStreamOptions), rdr.once("error", (err) => {
              dst && typeof dst == "string" && wtr && !wtr.destroyed && wtr.destroy(), reject(this.fmtError(`${err.message} ${remotePath}`, "get", err.code));
            }), dst === void 0)
              this.debugMsg("get resolving with buffer of data"), wtr = concat((buff) => {
                resolve2(buff);
              });
            else if (typeof dst == "string") {
              this.debugMsg(`get called with file path destination ${dst}`);
              let localCheck = haveLocalCreate(dst);
              localCheck.status ? wtr = fs11.createWriteStream(dst, options.writeStreamOptions) : reject(
                this.fmtError(
                  `Bad path: ${dst}: ${localCheck.details}`,
                  "get",
                  localCheck.code
                )
              );
            } else
              this.debugMsg("get called with stream destination"), wtr = dst;
            wtr.once("error", (err) => {
              reject(
                this.fmtError(
                  `${err.message} ${typeof dst == "string" ? dst : "<stream>"}`,
                  "get",
                  err.code
                )
              );
            }), rdr.once("end", () => {
              typeof dst == "string" ? resolve2(dst) : dst !== void 0 && resolve2(wtr);
            }), rdr.pipe(wtr, options.pipeOptions);
          }
        }).finally(() => {
          rdr && !rdr.destroyed && rdr.destroy(), addListeners && removeTempListeners(this, listeners, "get");
        });
      }
      /**
       * Use SSH2 fastGet for downloading the file.
       * Downloads a file at remotePath to localPath using parallel reads
       * for faster throughput.
       *
       * WARNING: The functionality of fastGet is heavily dependent on the capabilities
       * of the remote SFTP server. Not all sftp server support or fully support this
       * functionality. See the Platform Quirks & Warnings section of the README.
       *
       * @param {String} remotePath
       * @param {String} localPath
       * @param {Object} options
       * @return {Promise<String>} the result of downloading the file
       */
      _fastGet(rPath, lPath, opts, addListeners = !0) {
        let listeners;
        return new Promise((resolve2, reject) => {
          addListeners && (listeners = addTempListeners(this, "_fastGet", reject)), haveConnection(this, "_fastGet", reject) && this.sftp.fastGet(rPath, lPath, opts, (err) => {
            err && reject(this.fmtError(`${err.message} Remote: ${rPath} Local: ${lPath}`)), resolve2(`${rPath} was successfully download to ${lPath}!`);
          });
        }).finally(() => {
          addListeners && removeTempListeners(this, listeners, "_fastGet");
        });
      }
      async fastGet(remotePath, localPath, options) {
        try {
          let ftype = await this.exists(remotePath);
          if (ftype !== "-") {
            let msg = `${ftype ? "Not a regular file" : "No such file "} ${remotePath}`;
            throw this.fmtError(msg, "fastGet", errorCode.badPath);
          }
          let localCheck = haveLocalCreate(localPath);
          if (!localCheck.status)
            throw this.fmtError(
              `Bad path: ${localPath}: ${localCheck.details}`,
              "fastGet",
              errorCode.badPath
            );
          return await this._fastGet(remotePath, localPath, options);
        } catch (err) {
          throw this.fmtError(err, "fastGet");
        }
      }
      /**
       * Use SSH2 fastPut for uploading the file.
       * Uploads a file from localPath to remotePath using parallel reads
       * for faster throughput.
       *
       * See 'fastPut' at
       * https://github.com/mscdex/ssh2-streams/blob/master/SFTPStream.md
       *
       * WARNING: The fastPut functionality is heavily dependent on the capabilities of
       * the remote sftp server. Many sftp servers do not support or do not fully support this
       * functionality. See the Platform Quirks & Warnings section of the README for more details.
       *
       * @param {String} localPath - path to local file to put
       * @param {String} remotePath - destination path for put file
       * @param {Object} options - additonal fastPut options
       * @param {Boolean} addListeners - (Optional) if true, add listeners. Default true.
       * @return {Promise<String>} the result of downloading the file
       */
      _fastPut(lPath, rPath, opts, addListeners = !0) {
        let listeners;
        return new Promise((resolve2, reject) => {
          addListeners && (listeners = addTempListeners(this, "_fastPut", reject)), haveConnection(this, "_fastPut", reject) && this.sftp.fastPut(lPath, rPath, opts, (err) => {
            err && reject(
              this.fmtError(
                `${err.message} Local: ${lPath} Remote: ${rPath}`,
                "fastPut",
                err.code
              )
            ), resolve2(`${lPath} was successfully uploaded to ${rPath}!`);
          });
        }).finally(() => {
          addListeners && removeTempListeners(this, listeners, "_fastPut");
        });
      }
      async fastPut(localPath, remotePath, options) {
        try {
          let localCheck = haveLocalAccess(localPath);
          if (localCheck.status) {
            if (localCheck.status && localExists(localPath) === "d")
              throw this.fmtError(
                `Bad path: ${localPath} not a regular file`,
                "fastgPut",
                errorCode.badPath
              );
          } else throw this.fmtError(
            `Bad path: ${localPath}: ${localCheck.details}`,
            "fastPut",
            localCheck.code
          );
          return await this._fastPut(localPath, remotePath, options);
        } catch (e) {
          throw e.custom ? e : this.fmtError(e.message, "fastPut", e.code);
        }
      }
      /**
       * Create a file on the remote server. The 'src' argument
       * can be a buffer, string or read stream. If 'src' is a string, it
       * should be the path to a local file.
       *
       * @param  {String|Buffer|stream} localSrc - source data to use
       * @param  {String} remotePath - path to remote file
       * @param  {Object} options - options used for read, write stream and pipe configuration
       *                            value supported by node. Allowed properties are readStreamOptions,
       *                            writeStreamOptions and pipeOptions.
       *
       * *Important Note*: The ability to set ''autoClose' on read/write streams and 'end' on pipe() calls
       * is no longer supported. New methods 'createReadStream()' and 'createWriteStream()' have been
       * added to support low-level access to stream objects.
       *
       * @return {Promise<String>}
       */
      _put(lPath, rPath, opts, addListeners = !0) {
        let listeners, wtr, rdr;
        return new Promise((resolve2, reject) => {
          addListeners && (listeners = addTempListeners(this, "_put", reject)), opts = {
            readStreamOptions: { ...opts?.readStreamOptions, autoClose: !0 },
            writeStreamOptions: { ...opts?.writeStreamOptions, autoClose: !0 },
            pipeOptions: { ...opts?.pipeOptions, end: !0 }
          }, haveConnection(this, "_put", reject) && (wtr = this.sftp.createWriteStream(rPath, opts.writeStreamOptions), wtr.once("error", (err) => {
            typeof lPath == "string" && rdr && !rdr.destroyed && rdr.destroy(), reject(
              this.fmtError(
                `Write stream error: ${err.message} ${rPath}`,
                "_put",
                err.code
              )
            );
          }), wtr.once("close", () => {
            resolve2(`Uploaded data stream to ${rPath}`);
          }), lPath instanceof Buffer ? (this.debugMsg("put source is a buffer"), wtr.end(lPath)) : (typeof lPath == "string" ? (this.debugMsg("put source is string path"), rdr = fs11.createReadStream(lPath, opts.readStreamOptions)) : (this.debugMsg("put source is a stream"), rdr = lPath), rdr.once("error", (err) => {
            reject(
              this.fmtError(
                `Read stream error: ${err.message} ${typeof lPath == "string" ? lPath : "<stream>"}`,
                "_put",
                err.code
              )
            );
          }), rdr.pipe(wtr, opts.pipeOptions)));
        }).finally(() => {
          wtr && !wtr.destroyed && wtr.destroy(), addListeners && removeTempListeners(this, listeners, "_put");
        });
      }
      async put(localSrc, remotePath, options) {
        try {
          if (typeof localSrc == "string") {
            let localCheck = haveLocalAccess(localSrc);
            if (!localCheck.status)
              throw this.fmtError(
                `Bad path: ${localSrc} ${localCheck.details}`,
                "put",
                localCheck.code
              );
          }
          return await this._put(localSrc, remotePath, options);
        } catch (e) {
          throw e.custom ? e : this.fmtError(`Re-thrown: ${e.message}`, "put", e.code);
        }
      }
      /**
       * Append to an existing remote file
       *
       * @param  {Buffer|stream} input
       * @param  {String} remotePath
       * @param  {Object} options
       * @return {Promise<String>}
       */
      _append(input, rPath, opts, addListeners = !0) {
        let listeners;
        return new Promise((resolve2, reject) => {
          if (addListeners && (listeners = addTempListeners(this, "_append", reject)), haveConnection(this, "_append", reject)) {
            opts.flags = "a";
            let stream = this.sftp.createWriteStream(rPath, opts);
            stream.on("error", (err) => {
              reject(this.fmtError(`${err.message} ${rPath}`, "append", err.code));
            }), stream.on("close", () => {
              resolve2(`Appended data to ${rPath}`);
            }), input instanceof Buffer ? (stream.write(input), stream.end()) : input.pipe(stream);
          }
        }).finally(() => {
          addListeners && removeTempListeners(this, listeners, "_append");
        });
      }
      async append(input, remotePath, options = {}) {
        try {
          if (typeof input == "string")
            throw this.fmtError(
              "Cannot append one file to another",
              "append",
              errorCode.badPath
            );
          let fileType = await this.exists(remotePath);
          if (fileType && fileType === "d")
            throw this.fmtError(
              `Bad path: ${remotePath}: cannot append to a directory`,
              "append",
              errorCode.badPath
            );
          return await this._append(input, remotePath, options);
        } catch (e) {
          throw e.custom ? e : this.fmtError(e.message, "append", e.code);
        }
      }
      /**
       * @async
       *
       * Make a directory on remote server
       *
       * @param {string} remotePath - remote directory path.
       * @param {boolean} recursive - if true, recursively create directories
       * @return {Promise<String>}
       */
      _doMkdir(p, addListeners = !0) {
        let listeners;
        return new Promise((resolve2, reject) => {
          addListeners && (listeners = addTempListeners(this, "_doMkdir", reject)), this.sftp.mkdir(p, (err) => {
            err ? err.code === 4 ? reject(
              this.fmtError(
                `Bad path: ${p} permission denied`,
                "_doMkdir",
                errorCode.badPath
              )
            ) : err.code === 2 ? reject(
              this.fmtError(
                `Bad path: ${p} parent not a directory or not exist`,
                "_doMkdir",
                errorCode.badPath
              )
            ) : reject(this.fmtError(`${err.message} ${p}`, "_doMkdir", err.code)) : resolve2(`${p} directory created`);
          });
        }).finally(() => {
          addListeners && removeTempListeners(this, listeners, "_doMkdir");
        });
      }
      async _mkdir(remotePath, recursive) {
        try {
          let rPath = await normalizeRemotePath(this, remotePath), targetExists = await this.exists(rPath);
          if (targetExists && targetExists !== "d")
            throw this.fmtError(
              `Bad path: ${rPath} already exists as a file`,
              "_mkdir",
              errorCode.badPath
            );
          if (targetExists)
            return `${rPath} already exists`;
          if (!recursive)
            return await this._doMkdir(rPath);
          let dir = parse5(rPath).dir;
          if (dir) {
            let dirExists = await this.exists(dir);
            if (!dirExists)
              await this._mkdir(dir, !0);
            else if (dirExists !== "d")
              throw this.fmtError(
                `Bad path: ${dir} not a directory`,
                "_mkdir",
                errorCode.badPath
              );
          }
          return await this._doMkdir(rPath);
        } catch (err) {
          throw err.custom ? err : this.fmtError(`${err.message} ${remotePath}`, "_mkdir", err.code);
        }
      }
      async mkdir(remotePath, recursive = !1) {
        try {
          return haveConnection(this, "mkdir"), await this._mkdir(remotePath, recursive);
        } catch (err) {
          throw this.fmtError(`${err.message}`, "mkdir", err.code);
        }
      }
      /**
       * @async
       *
       * Remove directory on remote server
       *
       * @param {string} remotePath - path to directory to be removed
       * @param {boolean} recursive - if true, remove directories/files in target
       *                             directory
       * @return {Promise<String>}
       */
      async rmdir(remoteDir, recursive = !1) {
        let _rmdir = (dir) => {
          let listeners;
          return new Promise((resolve2, reject) => {
            listeners = addTempListeners(this, "_rmdir", reject), this.sftp.rmdir(dir, (err) => {
              err && reject(this.fmtError(`${err.message} ${dir}`, "rmdir", err.code)), resolve2("Successfully removed directory");
            });
          }).finally(() => {
            removeTempListeners(this, listeners, "_rmdir");
          });
        }, _delFiles = (path8, fileList) => {
          let listeners;
          return new Promise((resolve2, reject) => {
            listeners = addTempListeners(this, "_delFiles", reject);
            let pList = [];
            for (let f of fileList)
              pList.push(this.delete(`${path8}/${f.name}`, !0, !1));
            resolve2(pList);
          }).then((p) => Promise.all(p)).finally(() => {
            removeTempListeners(this, listeners, "_delFiles");
          });
        };
        try {
          let absPath = await normalizeRemotePath(this, remoteDir), existStatus = await this.exists(absPath);
          if (!existStatus)
            throw this.fmtError(
              `Bad Path: ${remoteDir}: No such directory`,
              "rmdir",
              errorCode.badPath
            );
          if (existStatus !== "d")
            throw this.fmtError(
              `Bad Path: ${remoteDir}: Not a directory`,
              "rmdir",
              errorCode.badPath
            );
          if (!recursive)
            return await _rmdir(absPath);
          let listing = await this.list(absPath);
          if (!listing.length)
            return await _rmdir(absPath);
          let fileList = listing.filter((i) => i.type !== "d"), dirList = listing.filter((i) => i.type === "d");
          await _delFiles(absPath, fileList);
          for (let d of dirList)
            await this.rmdir(`${absPath}/${d.name}`, !0);
          return await _rmdir(absPath), "Successfully removed directory";
        } catch (err) {
          throw err.custom ? err : this.fmtError(`${err.message} ${remoteDir}`, "rmdir", err.code);
        }
      }
      /**
       * @async
       *
       * Delete a file on the remote SFTP server
       *
       * @param {string} remotePath - path to the file to delete
       * @param {boolean} notFoundOK - if true, ignore errors for missing target.
       *                               Default is false.
       * @return {Promise<String>} with string 'Successfully deleted file' once resolved
       */
      delete(remotePath, notFoundOK = !1, addListeners = !0) {
        let listeners;
        return new Promise((resolve2, reject) => {
          addListeners && (listeners = addTempListeners(this, "delete", reject)), this.sftp.unlink(remotePath, (err) => {
            err && (notFoundOK && err.code === 2 ? resolve2(`Successfully deleted ${remotePath}`) : reject(this.fmtError(`${err.message} ${remotePath}`, "delete", err.code))), resolve2(`Successfully deleted ${remotePath}`);
          });
        }).finally(() => {
          addListeners && removeTempListeners(this, listeners, "delete");
        });
      }
      /**
       * @async
       *
       * Rename a file on the remote SFTP repository
       *
       * @param {string} fromPath - path to the file to be renamed.
       * @param {string} toPath - path to the new name.
       * @param {Boolean} addListeners - (Optional) if true, add listeners. Default true
       *
       * @return {Promise<String>}
       */
      rename(fPath, tPath, addListeners = !0) {
        let listeners;
        return new Promise((resolve2, reject) => {
          addListeners && (listeners = addTempListeners(this, "rename", reject)), haveConnection(this, "rename", reject) && this.sftp.rename(fPath, tPath, (err) => {
            err && reject(
              this.fmtError(
                `${err.message} From: ${fPath} To: ${tPath}`,
                "_rename",
                err.code
              )
            ), resolve2(`Successfully renamed ${fPath} to ${tPath}`);
          });
        }).finally(() => {
          addListeners && removeTempListeners(this, listeners, "rename");
        });
      }
      /**
       * @async
       *
       * Rename a file on the remote SFTP repository using the SSH extension
       * posix-rename@openssh.com using POSIX atomic rename. (Introduced in SSH 4.8)
       *
       * @param {string} fromPath - path to the file to be renamed.
       * @param {string} toPath - path  the new name.
       * @param {Boolean} addListeners - (Optional) if true, add listeners. Default true
       *
       * @return {Promise<String>}
       */
      posixRename(fPath, tPath, addListeners = !0) {
        let listeners;
        return new Promise((resolve2, reject) => {
          addListeners && (listeners = addTempListeners(this, "posixRename", reject)), haveConnection(this, "posixRename", reject) && this.sftp.ext_openssh_rename(fPath, tPath, (err) => {
            err && reject(
              this.fmtError(
                `${err.message} From: ${fPath} To: ${tPath}`,
                "_posixRename",
                err.code
              )
            ), resolve2(`Successful POSIX rename ${fPath} to ${tPath}`);
          });
        }).finally(() => {
          removeTempListeners(this, listeners, "posixRename");
        });
      }
      /**
       * @async
       *
       * Change the mode of a remote file on the SFTP repository
       *
       * @param {string} remotePath - path to the remote target object.
       * @param {number | string} mode - the new octal mode to set
       * @param {boolean} addListeners - (Optional) if true, add listeners. Default true.
       *
       * @return {Promise<String>}
       */
      chmod(rPath, mode, addListeners = !0) {
        let listeners;
        return new Promise((resolve2, reject) => {
          addListeners && (listeners = addTempListeners(this, "chmod", reject)), haveConnection(this, "chmod", reject) && this.sftp.chmod(rPath, mode, (err) => {
            err && reject(this.fmtError(`${err.message} ${rPath}`, "_chmod", err.code)), resolve2("Successfully change file mode");
          });
        }).finally(() => {
          addListeners && removeTempListeners(this, listeners, "chmod");
        });
      }
      /**
       * @async
       *
       * Upload the specified source directory to the specified destination
       * directory. All regular files and sub-directories are uploaded to the remote
       * server.
       * @param {String} srcDir - local source directory
       * @param {String} dstDir - remote destination directory
       * @param {Object} options - (Optional) An object with 2 supported properties,
       * 'filter' and 'useFastput'. Filter is a function of two arguments.
       * The first argument is the full path of a directory entry from the directory
       * to be uploaded and the second argument is a boolean, which will be true if
       * the target path is for a directory. If the function returns true, this item
       * will be uploaded and excluded when it returns false. The 'useFastput' property is a
       * boolean value. When true, the 'fastPut()' method will be used to upload files. Default
       * is to use the slower, but more supported 'put()' method.
       *
       * @returns {Promise<Array>}
       */
      async uploadDir(srcDir, dstDir, options) {
        let getRemoteStatus = async (dstDir2) => {
          let absDstDir = await normalizeRemotePath(this, dstDir2), status = await this.exists(absDstDir);
          if (status && status !== "d")
            throw this.fmtError(
              `Bad path ${absDstDir} Not a directory`,
              "getRemoteStatus",
              errorCode.badPath
            );
          return { remoteDir: absDstDir, remoteStatus: status };
        }, checkLocalStatus = (srcDir2) => {
          let srcType = localExists(srcDir2);
          if (!srcType)
            throw this.fmtError(
              `Bad path: ${srcDir2} not exist`,
              "getLocalStatus",
              errorCode.badPath
            );
          if (srcType !== "d")
            throw this.fmtError(
              `Bad path: ${srcDir2}: not a directory`,
              "getLocalStatus",
              errorCode.badPath
            );
          return srcType;
        }, uploadFiles = async (srcDir2, dstDir2, fileList, useFastput) => {
          let listeners = addTempListeners(this, "uploadFiles");
          try {
            let uploadList = [];
            for (let f of fileList) {
              let src = join2(srcDir2, f.name), dst = `${dstDir2}/${f.name}`;
              uploadList.push([src, dst]);
            }
            let uploadGroups = partition(uploadList, this.promiseLimit), func = useFastput ? this._fastPut.bind(this) : this._put.bind(this), uploadResults = [];
            for (let group of uploadGroups) {
              let pList = [];
              for (let [src, dst] of group)
                pList.push(func(src, dst, null, !1)), this.client.emit("upload", { source: src, destination: dst });
              let groupResults = await Promise.all(pList);
              for (let r of groupResults)
                uploadResults.push(r);
            }
            return uploadResults;
          } catch (e) {
            throw this.fmtError(`${e.message} ${srcDir2} to ${dstDir2}`, "uploadFiles", e.code);
          } finally {
            removeTempListeners(this, listeners, uploadFiles);
          }
        };
        try {
          haveConnection(this, "uploadDir");
          let { remoteDir, remoteStatus } = await getRemoteStatus(dstDir);
          checkLocalStatus(srcDir), remoteStatus || await this._mkdir(remoteDir, !0);
          let dirEntries = fs11.readdirSync(srcDir, {
            encoding: "utf8",
            withFileTypes: !0
          });
          options?.filter && (dirEntries = dirEntries.filter(
            (item) => options.filter(join2(srcDir, item.name), item.isDirectory())
          ));
          let dirUploads = dirEntries.filter((item) => item.isDirectory()), fileUploads = dirEntries.filter((item) => !item.isDirectory());
          await uploadFiles(srcDir, remoteDir, fileUploads, options?.useFastput);
          for (let d of dirUploads) {
            let src = join2(srcDir, d.name), dst = `${remoteDir}/${d.name}`;
            await this.uploadDir(src, dst, options);
          }
          return `${srcDir} uploaded to ${dstDir}`;
        } catch (err) {
          throw err.custom ? err : this.fmtError(`${err.message} ${srcDir}`, "uploadDir", err.code);
        }
      }
      /**
       * @async
       *
       * Download the specified source directory to the specified destination
       * directory. All regular files and sub-directories are downloaded to the local
       * file system.
       * @param {String} srcDir - remote source directory
       * @param {String} dstDir - local destination directory
       * @param {Object} options - (Optional) Object with 2 supported properties,
       * 'filter' and 'useFastget'. The filter property is a function of two
       * arguments. The first argument is the full path of the item to be downloaded
       * and the second argument is a boolean, which will be true if the target path
       * is for a directory. If the function returns true, the item will be
       * downloaded and excluded if teh function returns false.
       *
       * @returns {Promise<Array>}
       */
      async downloadDir(srcDir, dstDir, options = { filter: null, useFastget: !1 }) {
        let getDownloadList = async (srcDir2, filter) => {
          try {
            let listing = await this.list(srcDir2);
            return filter ? listing.filter(
              (item) => filter(`${srcDir2}/${item.name}`, item.type === "d")
            ) : listing;
          } catch (err) {
            throw err.custom ? err : this.fmtError(err.message, "_getDownloadList", err.code);
          }
        }, prepareDestination = (dst) => {
          try {
            let localCheck = haveLocalCreate(dst);
            if (!localCheck.status && localCheck.details === "permission denied")
              throw this.fmtError(
                `Bad path: ${dst}: ${localCheck.details}`,
                "prepareDestination",
                localCheck.code
              );
            if (localCheck.status && !localCheck.type)
              fs11.mkdirSync(dst, { recursive: !0 });
            else if (localCheck.status && localCheck.type !== "d")
              throw this.fmtError(
                `Bad path: ${dstDir}: not a directory`,
                "_prepareDestination",
                errorCode.badPath
              );
          } catch (err) {
            throw err.custom ? err : this.fmtError(err.message, "_prepareDestination", err.code);
          }
        }, downloadFiles = async (remotePath, localPath, fileList, useFastget) => {
          let listeners = addTempListeners(this, "downloadFIles");
          try {
            let downloadList = [];
            for (let f of fileList) {
              let src = `${remotePath}/${f.name}`, dst = join2(localPath, f.name);
              downloadList.push([src, dst]);
            }
            let downloadGroups = partition(downloadList, this.promiseLimit), func = useFastget ? this._fastGet.bind(this) : this.get.bind(this), downloadResults = [];
            for (let group of downloadGroups) {
              let pList = [];
              for (let [src, dst] of group)
                pList.push(func(src, dst, null, !1)), this.client.emit("download", { source: src, destination: dst });
              let groupResults = await Promise.all(pList);
              for (let r of groupResults)
                downloadResults.push(r);
            }
            return downloadResults;
          } catch (e) {
            throw this.fmtError(
              `${e.message} ${srcDir} to ${dstDir}`,
              "downloadFiles",
              e.code
            );
          } finally {
            removeTempListeners(this, listeners, "downloadFiles");
          }
        };
        try {
          haveConnection(this, "downloadDir");
          let downloadList = await getDownloadList(srcDir, options.filter);
          prepareDestination(dstDir);
          let fileDownloads = downloadList.filter((i) => i.type !== "d");
          fileDownloads.length && await downloadFiles(srcDir, dstDir, fileDownloads, options.useFastget);
          let dirDownloads = downloadList.filter((i) => i.type === "d");
          for (let d of dirDownloads) {
            let src = `${srcDir}/${d.name}`, dst = join2(dstDir, d.name);
            await this.downloadDir(src, dst, options);
          }
          return `${srcDir} downloaded to ${dstDir}`;
        } catch (err) {
          throw err.custom ? err : this.fmtError(`${err.message}: ${srcDir}`, "downloadDir", err.code);
        }
      }
      /**
       * Returns a read stream object. This is a low level method which will return a read stream
       * connected to the remote file object specified as an argument. Client code is fully responsible
       * for managing this stream object i.e. adding any necessary listeners and disposing of the object etc.
       * See the SSH2 sftp documentation for details on possible options which can be used.
       *
       * @param {String} remotePath - path to remote file to attach stream to
       * @param {Object} options - options to pass to the create stream process
       *
       * @returns {Object} a read stream object
       */
      createReadStream(remotePath, options) {
        let listeners;
        try {
          return listeners = addTempListeners(this, "createReadStream"), haveConnection(this, "createReadStream"), this.sftp.createReadStream(remotePath, options);
        } catch (err) {
          throw err.custom ? err : this.fmtError(err.message, "createReadStream", err.code);
        } finally {
          removeTempListeners(this, listeners, "createReadStreame");
        }
      }
      /**
       * Create a write stream object connected to a file on the remote sftp server.
       * This is a low level method which will return a write stream for the remote file specified
       * in the 'remotePath' argument. Client code to responsible for managing this object once created.
       * This includes disposing of file handles, setting up any necessary event listeners etc.
       *
       * @param {String} remotePath - path to the remote file on the sftp server
       * @param (Object} options - options to pass to the create write stream process)
       *
       * @returns {Object} a stream object
       */
      createWriteStream(remotePath, options) {
        let listeners;
        try {
          return listeners = addTempListeners(this, "createWriteStream"), haveConnection(this, "createWriteStream"), this.sftp.createWriteStream(remotePath, options);
        } catch (err) {
          throw err.custom ? err : this.fmtError(err.message, "createWriteStream", err.code);
        } finally {
          removeTempListeners(this, listeners, "createWriteStream");
        }
      }
      /**
       * @async
       *
       * Make a remote copy of a remote file. Create a copy of a remote file on the remote
       * server. It is assumed the directory where the copy will be placed already exists.
       * The destination file must not already exist.
       *
       * @param {String} srcPath - path to the remote file to be copied
       * @param {String} dstPath - destination path for the copy.
       *
       * @returns {String}.
       */
      _rcopy(srcPath, dstPath) {
        return new Promise((resolve2, reject) => {
          let ws = this.sftp.createWriteStream(dstPath), rs = this.sftp.createReadStream(srcPath);
          ws.on("error", (err) => {
            reject(this.fmtError(`${err.message} ${dstPath}`, "_rcopy"));
          }), rs.on("error", (err) => {
            reject(this.fmtError(`${err.message} ${srcPath}`, "_rcopy"));
          }), ws.on("close", () => {
            resolve2(`${srcPath} copied to ${dstPath}`);
          }), rs.pipe(ws);
        });
      }
      async rcopy(src, dst) {
        let listeners;
        try {
          listeners = addTempListeners(this, "rcopy"), haveConnection(this, "rcopy");
          let srcPath = await normalizeRemotePath(this, src), srcExists = await this.exists(srcPath);
          if (!srcExists)
            throw this.fmtError(
              `Source does not exist ${srcPath}`,
              "rcopy",
              errorCode.badPath
            );
          if (srcExists !== "-")
            throw this.fmtError(`Source not a file ${srcPath}`, "rcopy", errorCode.badPath);
          let dstPath = await normalizeRemotePath(this, dst);
          if (await this.exists(dstPath))
            throw this.fmtError(
              `Destination already exists ${dstPath}`,
              "rcopy",
              errorCode.badPath
            );
          return this._rcopy(srcPath, dstPath);
        } catch (err) {
          throw err.custom ? err : this.fmtError(err, "rcopy");
        } finally {
          removeTempListeners(this, listeners, "rcopy");
        }
      }
      /**
       * @async
       *
       * End the SFTP connection
       *
       * @returns {Promise<Boolean>}
       */
      end() {
        let endCloseHandler, listeners;
        return new Promise((resolve2, reject) => {
          listeners = addTempListeners(this, "end", reject), this.endCalled = !0, endCloseHandler = () => {
            this.sftp = void 0, this.debugMsg("end: Connection closed"), resolve2(!0);
          }, this.on("close", endCloseHandler), this.sftp ? (this.debugMsg("end: Ending SFTP connection"), this.client.end()) : (this.debugMsg("end: Called when no connection active"), resolve2(!0));
        }).finally(() => {
          removeTempListeners(this, listeners, "end"), this.removeListener("close", endCloseHandler);
        });
      }
    };
    module2.exports = SftpClient;
  }
});

// node_modules/n-readlines/readlines.js
var require_readlines = __commonJS({
  "node_modules/n-readlines/readlines.js"(exports2, module2) {
    "use strict";
    var fs11 = require("fs"), LineByLine = class {
      constructor(file, options) {
        options = options || {}, options.readChunk || (options.readChunk = 1024), options.newLineCharacter ? options.newLineCharacter = options.newLineCharacter.charCodeAt(0) : options.newLineCharacter = 10, typeof file == "number" ? this.fd = file : this.fd = fs11.openSync(file, "r"), this.options = options, this.newLineCharacter = options.newLineCharacter, this.reset();
      }
      _searchInBuffer(buffer, hexNeedle) {
        let found = -1;
        for (let i = 0; i <= buffer.length; i++)
          if (buffer[i] === hexNeedle) {
            found = i;
            break;
          }
        return found;
      }
      reset() {
        this.eofReached = !1, this.linesCache = [], this.fdPosition = 0;
      }
      close() {
        fs11.closeSync(this.fd), this.fd = null;
      }
      _extractLines(buffer) {
        let line, lines = [], bufferPosition = 0, lastNewLineBufferPosition = 0;
        for (; ; ) {
          let bufferPositionValue = buffer[bufferPosition++];
          if (bufferPositionValue === this.newLineCharacter)
            line = buffer.slice(lastNewLineBufferPosition, bufferPosition), lines.push(line), lastNewLineBufferPosition = bufferPosition;
          else if (bufferPositionValue === void 0)
            break;
        }
        let leftovers = buffer.slice(lastNewLineBufferPosition, bufferPosition);
        return leftovers.length && lines.push(leftovers), lines;
      }
      _readChunk(lineLeftovers) {
        let totalBytesRead = 0, bytesRead, buffers = [];
        do {
          let readBuffer = new Buffer(this.options.readChunk);
          bytesRead = fs11.readSync(this.fd, readBuffer, 0, this.options.readChunk, this.fdPosition), totalBytesRead = totalBytesRead + bytesRead, this.fdPosition = this.fdPosition + bytesRead, buffers.push(readBuffer);
        } while (bytesRead && this._searchInBuffer(buffers[buffers.length - 1], this.options.newLineCharacter) === -1);
        let bufferData = Buffer.concat(buffers);
        return bytesRead < this.options.readChunk && (this.eofReached = !0, bufferData = bufferData.slice(0, totalBytesRead)), totalBytesRead && (this.linesCache = this._extractLines(bufferData), lineLeftovers && (this.linesCache[0] = Buffer.concat([lineLeftovers, this.linesCache[0]]))), totalBytesRead;
      }
      next() {
        if (!this.fd) return !1;
        let line = !1;
        if (this.eofReached && this.linesCache.length === 0)
          return line;
        let bytesRead;
        return this.linesCache.length || (bytesRead = this._readChunk()), this.linesCache.length && (line = this.linesCache.shift(), line[line.length - 1] !== this.newLineCharacter && (bytesRead = this._readChunk(line), bytesRead && (line = this.linesCache.shift()))), this.eofReached && this.linesCache.length === 0 && this.close(), line && line[line.length - 1] === this.newLineCharacter && (line = line.slice(0, line.length - 1)), line;
      }
    };
    module2.exports = LineByLine;
  }
});

// src/index.ts
var index_exports = {};
__export(index_exports, {
  logError: () => logError,
  logInfo: () => logInfo
});
module.exports = __toCommonJS(index_exports);
var ActionsCore = __toESM(require_core()), import_async = __toESM(require_async()), import_fs_extra = __toESM(require_lib2()), import_node_fs10 = __toESM(require("node:fs")), import_node_os4 = __toESM(require("node:os")), import_node_path14 = __toESM(require("node:path")), import_xml_js = __toESM(require_lib3());

// src/cache/SpigotArtifactCache.ts
var import_node_fs8 = __toESM(require("node:fs")), import_node_path12 = __toESM(require("node:path"));

// src/cache/SFTPCache.ts
var import_node_child_process = __toESM(require("node:child_process")), import_node_fs = __toESM(require("node:fs")), import_node_os = __toESM(require("node:os")), import_node_path = __toESM(require("node:path")), import_ssh2_sftp_client = __toESM(require_src()), SFTPCache = class _SFTPCache {
  static CACHE_DIR = "SpraxDev_Action-SpigotMC-Cache";
  host;
  port;
  username;
  privateKey;
  expectedHostKey;
  sftpClient = new import_ssh2_sftp_client.default();
  initPromise;
  constructor(host, port, username, privateKey, expectedHostKey) {
    this.host = host, this.port = port, this.username = username, this.privateKey = privateKey, this.expectedHostKey = expectedHostKey;
  }
  async shutdown() {
    this.initPromise != null && await this.initPromise, await this.sftpClient.end();
  }
  async getSizeOfCacheForVersion(version2) {
    await this.ensureInit();
    let remotePath = _SFTPCache.constructRemoteCacheFilePath(version2);
    return await this.sftpClient.exists(remotePath) !== "-" ? null : (await this.sftpClient.stat(remotePath)).size;
  }
  async fetchCacheForVersion(version2, destFilePath) {
    await this.ensureInit();
    let remotePath = _SFTPCache.constructRemoteCacheFilePath(version2);
    return await this.sftpClient.exists(remotePath) === "-" ? (await this.downloadSftpFile(remotePath, destFilePath), !0) : !1;
  }
  async uploadCacheForVersion(version2, filePath) {
    await this.ensureInit();
    let remotePath = _SFTPCache.constructRemoteCacheFilePath(version2);
    await this.sftpClient.mkdir(import_node_path.default.dirname(remotePath), !0), await this.sftpClient.put(filePath, remotePath);
  }
  async init() {
    try {
      await this.sftpClient.connect({
        host: this.host,
        port: this.port,
        username: this.username,
        privateKey: this.privateKey,
        retries: 0,
        hostVerifier: (key) => {
          let expectedHostKeyHash = this.expectedHostKey?.split(" ")[1];
          return expectedHostKeyHash == null || key.toString("base64") === expectedHostKeyHash;
        }
      });
    } catch (err) {
      let detail = err.toString();
      throw detail.endsWith("Host denied (verification failed)") && (detail = "Host key verification failed"), new Error(`Failed to connect to SFTP-Server: ${detail}`);
    }
  }
  async ensureInit() {
    this.initPromise == null && (this.initPromise = this.init()), await this.initPromise;
  }
  async downloadSftpFile(remotePath, destFilePath) {
    if (!await this.doesSftpBinaryExist()) {
      await this.sftpClient.get(remotePath, destFilePath);
      return;
    }
    let privateKeyTmpPath = await import_node_fs.default.promises.mkdtemp(import_node_path.default.join(import_node_os.default.tmpdir(), "/"));
    try {
      let privateKeyFilePath = import_node_path.default.join(privateKeyTmpPath, "id");
      await import_node_fs.default.promises.writeFile(privateKeyFilePath, this.privateKey + `
`, { mode: 256 });
      let knownHostsFilePath = import_node_path.default.join(privateKeyTmpPath, "known_hosts");
      this.expectedHostKey != null && await import_node_fs.default.promises.writeFile(knownHostsFilePath, `[${this.host}]:${this.port} ${this.expectedHostKey}
`), await new Promise((resolve2, reject) => {
        let sftpCommandArgs = [
          "-i",
          privateKeyFilePath,
          "-o",
          "BatchMode=yes",
          "-o",
          `StrictHostKeyChecking=${this.expectedHostKey == null ? "no" : "yes"}`,
          "-o",
          `UserKnownHostsFile=${knownHostsFilePath}`,
          this.constructSftpRemoteUrl(remotePath),
          import_node_path.default.resolve(destFilePath)
        ], process2 = import_node_child_process.default.spawn("sftp", sftpCommandArgs, { stdio: ["ignore", "inherit", "inherit"] });
        process2.on("error", reject), process2.on("exit", (code2) => code2 === 0 ? resolve2() : reject(new Error(`Exit code: ${code2}`)));
      });
    } finally {
      await import_node_fs.default.promises.rm(privateKeyTmpPath, { recursive: !0, force: !0 });
    }
  }
  async doesSftpBinaryExist() {
    return new Promise((resolve2) => {
      let process2 = import_node_child_process.default.spawn("sftp", [], { timeout: 5e3, stdio: "ignore" });
      process2.on("error", () => resolve2(!1)), process2.on("exit", (code2) => resolve2(code2 === 1));
    });
  }
  constructSftpRemoteUrl(remotePath) {
    let url = new URL("sftp://");
    return url.hostname = this.host, url.port = this.port.toString(), url.pathname = remotePath, url.username = this.username, url.toString();
  }
  static constructRemoteCacheFilePath(version2) {
    return import_node_path.default.join(_SFTPCache.CACHE_DIR, `${version2}.tar.gz`);
  }
};

// src/cache/SpigotArtifactArchiver.ts
var import_node_fs7 = __toESM(require("node:fs")), import_node_os2 = __toESM(require("node:os")), import_node_path11 = __toESM(require("node:path"));

// node_modules/@isaacs/fs-minipass/dist/esm/index.js
var import_events = __toESM(require("events"), 1), import_fs = __toESM(require("fs"), 1);

// node_modules/minipass/dist/esm/index.js
var import_node_events = require("node:events"), import_node_stream = __toESM(require("node:stream"), 1), import_node_string_decoder = require("node:string_decoder"), proc = typeof process == "object" && process ? process : {
  stdout: null,
  stderr: null
}, isStream = (s) => !!s && typeof s == "object" && (s instanceof Minipass || s instanceof import_node_stream.default || isReadable(s) || isWritable(s)), isReadable = (s) => !!s && typeof s == "object" && s instanceof import_node_events.EventEmitter && typeof s.pipe == "function" && // node core Writable streams have a pipe() method, but it throws
s.pipe !== import_node_stream.default.Writable.prototype.pipe, isWritable = (s) => !!s && typeof s == "object" && s instanceof import_node_events.EventEmitter && typeof s.write == "function" && typeof s.end == "function", EOF = Symbol("EOF"), MAYBE_EMIT_END = Symbol("maybeEmitEnd"), EMITTED_END = Symbol("emittedEnd"), EMITTING_END = Symbol("emittingEnd"), EMITTED_ERROR = Symbol("emittedError"), CLOSED = Symbol("closed"), READ = Symbol("read"), FLUSH = Symbol("flush"), FLUSHCHUNK = Symbol("flushChunk"), ENCODING = Symbol("encoding"), DECODER = Symbol("decoder"), FLOWING = Symbol("flowing"), PAUSED = Symbol("paused"), RESUME = Symbol("resume"), BUFFER = Symbol("buffer"), PIPES = Symbol("pipes"), BUFFERLENGTH = Symbol("bufferLength"), BUFFERPUSH = Symbol("bufferPush"), BUFFERSHIFT = Symbol("bufferShift"), OBJECTMODE = Symbol("objectMode"), DESTROYED = Symbol("destroyed"), ERROR = Symbol("error"), EMITDATA = Symbol("emitData"), EMITEND = Symbol("emitEnd"), EMITEND2 = Symbol("emitEnd2"), ASYNC = Symbol("async"), ABORT = Symbol("abort"), ABORTED = Symbol("aborted"), SIGNAL = Symbol("signal"), DATALISTENERS = Symbol("dataListeners"), DISCARDED = Symbol("discarded"), defer = (fn) => Promise.resolve().then(fn), nodefer = (fn) => fn(), isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish", isArrayBufferLike = (b) => b instanceof ArrayBuffer || !!b && typeof b == "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0, isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b), Pipe = class {
  src;
  dest;
  opts;
  ondrain;
  constructor(src, dest, opts) {
    this.src = src, this.dest = dest, this.opts = opts, this.ondrain = () => src[RESUME](), this.dest.on("drain", this.ondrain);
  }
  unpipe() {
    this.dest.removeListener("drain", this.ondrain);
  }
  // only here for the prototype
  /* c8 ignore start */
  proxyErrors(_er) {
  }
  /* c8 ignore stop */
  end() {
    this.unpipe(), this.opts.end && this.dest.end();
  }
}, PipeProxyErrors = class extends Pipe {
  unpipe() {
    this.src.removeListener("error", this.proxyErrors), super.unpipe();
  }
  constructor(src, dest, opts) {
    super(src, dest, opts), this.proxyErrors = (er) => dest.emit("error", er), src.on("error", this.proxyErrors);
  }
}, isObjectModeOptions = (o) => !!o.objectMode, isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== "buffer", Minipass = class extends import_node_events.EventEmitter {
  [FLOWING] = !1;
  [PAUSED] = !1;
  [PIPES] = [];
  [BUFFER] = [];
  [OBJECTMODE];
  [ENCODING];
  [ASYNC];
  [DECODER];
  [EOF] = !1;
  [EMITTED_END] = !1;
  [EMITTING_END] = !1;
  [CLOSED] = !1;
  [EMITTED_ERROR] = null;
  [BUFFERLENGTH] = 0;
  [DESTROYED] = !1;
  [SIGNAL];
  [ABORTED] = !1;
  [DATALISTENERS] = 0;
  [DISCARDED] = !1;
  /**
   * true if the stream can be written
   */
  writable = !0;
  /**
   * true if the stream can be read
   */
  readable = !0;
  /**
   * If `RType` is Buffer, then options do not need to be provided.
   * Otherwise, an options object must be provided to specify either
   * {@link Minipass.SharedOptions.objectMode} or
   * {@link Minipass.SharedOptions.encoding}, as appropriate.
   */
  constructor(...args) {
    let options = args[0] || {};
    if (super(), options.objectMode && typeof options.encoding == "string")
      throw new TypeError("Encoding and objectMode may not be used together");
    isObjectModeOptions(options) ? (this[OBJECTMODE] = !0, this[ENCODING] = null) : isEncodingOptions(options) ? (this[ENCODING] = options.encoding, this[OBJECTMODE] = !1) : (this[OBJECTMODE] = !1, this[ENCODING] = null), this[ASYNC] = !!options.async, this[DECODER] = this[ENCODING] ? new import_node_string_decoder.StringDecoder(this[ENCODING]) : null, options && options.debugExposeBuffer === !0 && Object.defineProperty(this, "buffer", { get: () => this[BUFFER] }), options && options.debugExposePipes === !0 && Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
    let { signal } = options;
    signal && (this[SIGNAL] = signal, signal.aborted ? this[ABORT]() : signal.addEventListener("abort", () => this[ABORT]()));
  }
  /**
   * The amount of data stored in the buffer waiting to be read.
   *
   * For Buffer strings, this will be the total byte length.
   * For string encoding streams, this will be the string character length,
   * according to JavaScript's `string.length` logic.
   * For objectMode streams, this is a count of the items waiting to be
   * emitted.
   */
  get bufferLength() {
    return this[BUFFERLENGTH];
  }
  /**
   * The `BufferEncoding` currently in use, or `null`
   */
  get encoding() {
    return this[ENCODING];
  }
  /**
   * @deprecated - This is a read only property
   */
  set encoding(_enc) {
    throw new Error("Encoding must be set at instantiation time");
  }
  /**
   * @deprecated - Encoding may only be set at instantiation time
   */
  setEncoding(_enc) {
    throw new Error("Encoding must be set at instantiation time");
  }
  /**
   * True if this is an objectMode stream
   */
  get objectMode() {
    return this[OBJECTMODE];
  }
  /**
   * @deprecated - This is a read-only property
   */
  set objectMode(_om) {
    throw new Error("objectMode must be set at instantiation time");
  }
  /**
   * true if this is an async stream
   */
  get async() {
    return this[ASYNC];
  }
  /**
   * Set to true to make this stream async.
   *
   * Once set, it cannot be unset, as this would potentially cause incorrect
   * behavior.  Ie, a sync stream can be made async, but an async stream
   * cannot be safely made sync.
   */
  set async(a) {
    this[ASYNC] = this[ASYNC] || !!a;
  }
  // drop everything and get out of the flow completely
  [ABORT]() {
    this[ABORTED] = !0, this.emit("abort", this[SIGNAL]?.reason), this.destroy(this[SIGNAL]?.reason);
  }
  /**
   * True if the stream has been aborted.
   */
  get aborted() {
    return this[ABORTED];
  }
  /**
   * No-op setter. Stream aborted status is set via the AbortSignal provided
   * in the constructor options.
   */
  set aborted(_) {
  }
  write(chunk, encoding, cb) {
    if (this[ABORTED])
      return !1;
    if (this[EOF])
      throw new Error("write after end");
    if (this[DESTROYED])
      return this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" })), !0;
    typeof encoding == "function" && (cb = encoding, encoding = "utf8"), encoding || (encoding = "utf8");
    let fn = this[ASYNC] ? defer : nodefer;
    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
      if (isArrayBufferView(chunk))
        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
      else if (isArrayBufferLike(chunk))
        chunk = Buffer.from(chunk);
      else if (typeof chunk != "string")
        throw new Error("Non-contiguous data written to non-objectMode stream");
    }
    return this[OBJECTMODE] ? (this[FLOWING] && this[BUFFERLENGTH] !== 0 && this[FLUSH](!0), this[FLOWING] ? this.emit("data", chunk) : this[BUFFERPUSH](chunk), this[BUFFERLENGTH] !== 0 && this.emit("readable"), cb && fn(cb), this[FLOWING]) : chunk.length ? (typeof chunk == "string" && // unless it is a string already ready for us to use
    !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed) && (chunk = Buffer.from(chunk, encoding)), Buffer.isBuffer(chunk) && this[ENCODING] && (chunk = this[DECODER].write(chunk)), this[FLOWING] && this[BUFFERLENGTH] !== 0 && this[FLUSH](!0), this[FLOWING] ? this.emit("data", chunk) : this[BUFFERPUSH](chunk), this[BUFFERLENGTH] !== 0 && this.emit("readable"), cb && fn(cb), this[FLOWING]) : (this[BUFFERLENGTH] !== 0 && this.emit("readable"), cb && fn(cb), this[FLOWING]);
  }
  /**
   * Low-level explicit read method.
   *
   * In objectMode, the argument is ignored, and one item is returned if
   * available.
   *
   * `n` is the number of bytes (or in the case of encoding streams,
   * characters) to consume. If `n` is not provided, then the entire buffer
   * is returned, or `null` is returned if no data is available.
   *
   * If `n` is greater that the amount of data in the internal buffer,
   * then `null` is returned.
   */
  read(n) {
    if (this[DESTROYED])
      return null;
    if (this[DISCARDED] = !1, this[BUFFERLENGTH] === 0 || n === 0 || n && n > this[BUFFERLENGTH])
      return this[MAYBE_EMIT_END](), null;
    this[OBJECTMODE] && (n = null), this[BUFFER].length > 1 && !this[OBJECTMODE] && (this[BUFFER] = [
      this[ENCODING] ? this[BUFFER].join("") : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])
    ]);
    let ret = this[READ](n || null, this[BUFFER][0]);
    return this[MAYBE_EMIT_END](), ret;
  }
  [READ](n, chunk) {
    if (this[OBJECTMODE])
      this[BUFFERSHIFT]();
    else {
      let c = chunk;
      n === c.length || n === null ? this[BUFFERSHIFT]() : typeof c == "string" ? (this[BUFFER][0] = c.slice(n), chunk = c.slice(0, n), this[BUFFERLENGTH] -= n) : (this[BUFFER][0] = c.subarray(n), chunk = c.subarray(0, n), this[BUFFERLENGTH] -= n);
    }
    return this.emit("data", chunk), !this[BUFFER].length && !this[EOF] && this.emit("drain"), chunk;
  }
  end(chunk, encoding, cb) {
    return typeof chunk == "function" && (cb = chunk, chunk = void 0), typeof encoding == "function" && (cb = encoding, encoding = "utf8"), chunk !== void 0 && this.write(chunk, encoding), cb && this.once("end", cb), this[EOF] = !0, this.writable = !1, (this[FLOWING] || !this[PAUSED]) && this[MAYBE_EMIT_END](), this;
  }
  // don't let the internal resume be overwritten
  [RESUME]() {
    this[DESTROYED] || (!this[DATALISTENERS] && !this[PIPES].length && (this[DISCARDED] = !0), this[PAUSED] = !1, this[FLOWING] = !0, this.emit("resume"), this[BUFFER].length ? this[FLUSH]() : this[EOF] ? this[MAYBE_EMIT_END]() : this.emit("drain"));
  }
  /**
   * Resume the stream if it is currently in a paused state
   *
   * If called when there are no pipe destinations or `data` event listeners,
   * this will place the stream in a "discarded" state, where all data will
   * be thrown away. The discarded state is removed if a pipe destination or
   * data handler is added, if pause() is called, or if any synchronous or
   * asynchronous iteration is started.
   */
  resume() {
    return this[RESUME]();
  }
  /**
   * Pause the stream
   */
  pause() {
    this[FLOWING] = !1, this[PAUSED] = !0, this[DISCARDED] = !1;
  }
  /**
   * true if the stream has been forcibly destroyed
   */
  get destroyed() {
    return this[DESTROYED];
  }
  /**
   * true if the stream is currently in a flowing state, meaning that
   * any writes will be immediately emitted.
   */
  get flowing() {
    return this[FLOWING];
  }
  /**
   * true if the stream is currently in a paused state
   */
  get paused() {
    return this[PAUSED];
  }
  [BUFFERPUSH](chunk) {
    this[OBJECTMODE] ? this[BUFFERLENGTH] += 1 : this[BUFFERLENGTH] += chunk.length, this[BUFFER].push(chunk);
  }
  [BUFFERSHIFT]() {
    return this[OBJECTMODE] ? this[BUFFERLENGTH] -= 1 : this[BUFFERLENGTH] -= this[BUFFER][0].length, this[BUFFER].shift();
  }
  [FLUSH](noDrain = !1) {
    do
      ;
    while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
    !noDrain && !this[BUFFER].length && !this[EOF] && this.emit("drain");
  }
  [FLUSHCHUNK](chunk) {
    return this.emit("data", chunk), this[FLOWING];
  }
  /**
   * Pipe all data emitted by this stream into the destination provided.
   *
   * Triggers the flow of data.
   */
  pipe(dest, opts) {
    if (this[DESTROYED])
      return dest;
    this[DISCARDED] = !1;
    let ended = this[EMITTED_END];
    return opts = opts || {}, dest === proc.stdout || dest === proc.stderr ? opts.end = !1 : opts.end = opts.end !== !1, opts.proxyErrors = !!opts.proxyErrors, ended ? opts.end && dest.end() : (this[PIPES].push(opts.proxyErrors ? new PipeProxyErrors(this, dest, opts) : new Pipe(this, dest, opts)), this[ASYNC] ? defer(() => this[RESUME]()) : this[RESUME]()), dest;
  }
  /**
   * Fully unhook a piped destination stream.
   *
   * If the destination stream was the only consumer of this stream (ie,
   * there are no other piped destinations or `'data'` event listeners)
   * then the flow of data will stop until there is another consumer or
   * {@link Minipass#resume} is explicitly called.
   */
  unpipe(dest) {
    let p = this[PIPES].find((p2) => p2.dest === dest);
    p && (this[PIPES].length === 1 ? (this[FLOWING] && this[DATALISTENERS] === 0 && (this[FLOWING] = !1), this[PIPES] = []) : this[PIPES].splice(this[PIPES].indexOf(p), 1), p.unpipe());
  }
  /**
   * Alias for {@link Minipass#on}
   */
  addListener(ev, handler) {
    return this.on(ev, handler);
  }
  /**
   * Mostly identical to `EventEmitter.on`, with the following
   * behavior differences to prevent data loss and unnecessary hangs:
   *
   * - Adding a 'data' event handler will trigger the flow of data
   *
   * - Adding a 'readable' event handler when there is data waiting to be read
   *   will cause 'readable' to be emitted immediately.
   *
   * - Adding an 'endish' event handler ('end', 'finish', etc.) which has
   *   already passed will cause the event to be emitted immediately and all
   *   handlers removed.
   *
   * - Adding an 'error' event handler after an error has been emitted will
   *   cause the event to be re-emitted immediately with the error previously
   *   raised.
   */
  on(ev, handler) {
    let ret = super.on(ev, handler);
    if (ev === "data")
      this[DISCARDED] = !1, this[DATALISTENERS]++, !this[PIPES].length && !this[FLOWING] && this[RESUME]();
    else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
      super.emit("readable");
    else if (isEndish(ev) && this[EMITTED_END])
      super.emit(ev), this.removeAllListeners(ev);
    else if (ev === "error" && this[EMITTED_ERROR]) {
      let h = handler;
      this[ASYNC] ? defer(() => h.call(this, this[EMITTED_ERROR])) : h.call(this, this[EMITTED_ERROR]);
    }
    return ret;
  }
  /**
   * Alias for {@link Minipass#off}
   */
  removeListener(ev, handler) {
    return this.off(ev, handler);
  }
  /**
   * Mostly identical to `EventEmitter.off`
   *
   * If a 'data' event handler is removed, and it was the last consumer
   * (ie, there are no pipe destinations or other 'data' event listeners),
   * then the flow of data will stop until there is another consumer or
   * {@link Minipass#resume} is explicitly called.
   */
  off(ev, handler) {
    let ret = super.off(ev, handler);
    return ev === "data" && (this[DATALISTENERS] = this.listeners("data").length, this[DATALISTENERS] === 0 && !this[DISCARDED] && !this[PIPES].length && (this[FLOWING] = !1)), ret;
  }
  /**
   * Mostly identical to `EventEmitter.removeAllListeners`
   *
   * If all 'data' event handlers are removed, and they were the last consumer
   * (ie, there are no pipe destinations), then the flow of data will stop
   * until there is another consumer or {@link Minipass#resume} is explicitly
   * called.
   */
  removeAllListeners(ev) {
    let ret = super.removeAllListeners(ev);
    return (ev === "data" || ev === void 0) && (this[DATALISTENERS] = 0, !this[DISCARDED] && !this[PIPES].length && (this[FLOWING] = !1)), ret;
  }
  /**
   * true if the 'end' event has been emitted
   */
  get emittedEnd() {
    return this[EMITTED_END];
  }
  [MAYBE_EMIT_END]() {
    !this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF] && (this[EMITTING_END] = !0, this.emit("end"), this.emit("prefinish"), this.emit("finish"), this[CLOSED] && this.emit("close"), this[EMITTING_END] = !1);
  }
  /**
   * Mostly identical to `EventEmitter.emit`, with the following
   * behavior differences to prevent data loss and unnecessary hangs:
   *
   * If the stream has been destroyed, and the event is something other
   * than 'close' or 'error', then `false` is returned and no handlers
   * are called.
   *
   * If the event is 'end', and has already been emitted, then the event
   * is ignored. If the stream is in a paused or non-flowing state, then
   * the event will be deferred until data flow resumes. If the stream is
   * async, then handlers will be called on the next tick rather than
   * immediately.
   *
   * If the event is 'close', and 'end' has not yet been emitted, then
   * the event will be deferred until after 'end' is emitted.
   *
   * If the event is 'error', and an AbortSignal was provided for the stream,
   * and there are no listeners, then the event is ignored, matching the
   * behavior of node core streams in the presense of an AbortSignal.
   *
   * If the event is 'finish' or 'prefinish', then all listeners will be
   * removed after emitting the event, to prevent double-firing.
   */
  emit(ev, ...args) {
    let data = args[0];
    if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
      return !1;
    if (ev === "data")
      return !this[OBJECTMODE] && !data ? !1 : this[ASYNC] ? (defer(() => this[EMITDATA](data)), !0) : this[EMITDATA](data);
    if (ev === "end")
      return this[EMITEND]();
    if (ev === "close") {
      if (this[CLOSED] = !0, !this[EMITTED_END] && !this[DESTROYED])
        return !1;
      let ret2 = super.emit("close");
      return this.removeAllListeners("close"), ret2;
    } else if (ev === "error") {
      this[EMITTED_ERROR] = data, super.emit(ERROR, data);
      let ret2 = !this[SIGNAL] || this.listeners("error").length ? super.emit("error", data) : !1;
      return this[MAYBE_EMIT_END](), ret2;
    } else if (ev === "resume") {
      let ret2 = super.emit("resume");
      return this[MAYBE_EMIT_END](), ret2;
    } else if (ev === "finish" || ev === "prefinish") {
      let ret2 = super.emit(ev);
      return this.removeAllListeners(ev), ret2;
    }
    let ret = super.emit(ev, ...args);
    return this[MAYBE_EMIT_END](), ret;
  }
  [EMITDATA](data) {
    for (let p of this[PIPES])
      p.dest.write(data) === !1 && this.pause();
    let ret = this[DISCARDED] ? !1 : super.emit("data", data);
    return this[MAYBE_EMIT_END](), ret;
  }
  [EMITEND]() {
    return this[EMITTED_END] ? !1 : (this[EMITTED_END] = !0, this.readable = !1, this[ASYNC] ? (defer(() => this[EMITEND2]()), !0) : this[EMITEND2]());
  }
  [EMITEND2]() {
    if (this[DECODER]) {
      let data = this[DECODER].end();
      if (data) {
        for (let p of this[PIPES])
          p.dest.write(data);
        this[DISCARDED] || super.emit("data", data);
      }
    }
    for (let p of this[PIPES])
      p.end();
    let ret = super.emit("end");
    return this.removeAllListeners("end"), ret;
  }
  /**
   * Return a Promise that resolves to an array of all emitted data once
   * the stream ends.
   */
  async collect() {
    let buf = Object.assign([], {
      dataLength: 0
    });
    this[OBJECTMODE] || (buf.dataLength = 0);
    let p = this.promise();
    return this.on("data", (c) => {
      buf.push(c), this[OBJECTMODE] || (buf.dataLength += c.length);
    }), await p, buf;
  }
  /**
   * Return a Promise that resolves to the concatenation of all emitted data
   * once the stream ends.
   *
   * Not allowed on objectMode streams.
   */
  async concat() {
    if (this[OBJECTMODE])
      throw new Error("cannot concat in objectMode");
    let buf = await this.collect();
    return this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength);
  }
  /**
   * Return a void Promise that resolves once the stream ends.
   */
  async promise() {
    return new Promise((resolve2, reject) => {
      this.on(DESTROYED, () => reject(new Error("stream destroyed"))), this.on("error", (er) => reject(er)), this.on("end", () => resolve2());
    });
  }
  /**
   * Asynchronous `for await of` iteration.
   *
   * This will continue emitting all chunks until the stream terminates.
   */
  [Symbol.asyncIterator]() {
    this[DISCARDED] = !1;
    let stopped = !1, stop = async () => (this.pause(), stopped = !0, { value: void 0, done: !0 });
    return {
      next: () => {
        if (stopped)
          return stop();
        let res = this.read();
        if (res !== null)
          return Promise.resolve({ done: !1, value: res });
        if (this[EOF])
          return stop();
        let resolve2, reject, onerr = (er) => {
          this.off("data", ondata), this.off("end", onend), this.off(DESTROYED, ondestroy), stop(), reject(er);
        }, ondata = (value) => {
          this.off("error", onerr), this.off("end", onend), this.off(DESTROYED, ondestroy), this.pause(), resolve2({ value, done: !!this[EOF] });
        }, onend = () => {
          this.off("error", onerr), this.off("data", ondata), this.off(DESTROYED, ondestroy), stop(), resolve2({ done: !0, value: void 0 });
        }, ondestroy = () => onerr(new Error("stream destroyed"));
        return new Promise((res2, rej) => {
          reject = rej, resolve2 = res2, this.once(DESTROYED, ondestroy), this.once("error", onerr), this.once("end", onend), this.once("data", ondata);
        });
      },
      throw: stop,
      return: stop,
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
  /**
   * Synchronous `for of` iteration.
   *
   * The iteration will terminate when the internal buffer runs out, even
   * if the stream has not yet terminated.
   */
  [Symbol.iterator]() {
    this[DISCARDED] = !1;
    let stopped = !1, stop = () => (this.pause(), this.off(ERROR, stop), this.off(DESTROYED, stop), this.off("end", stop), stopped = !0, { done: !0, value: void 0 }), next = () => {
      if (stopped)
        return stop();
      let value = this.read();
      return value === null ? stop() : { done: !1, value };
    };
    return this.once("end", stop), this.once(ERROR, stop), this.once(DESTROYED, stop), {
      next,
      throw: stop,
      return: stop,
      [Symbol.iterator]() {
        return this;
      }
    };
  }
  /**
   * Destroy a stream, preventing it from being used for any further purpose.
   *
   * If the stream has a `close()` method, then it will be called on
   * destruction.
   *
   * After destruction, any attempt to write data, read data, or emit most
   * events will be ignored.
   *
   * If an error argument is provided, then it will be emitted in an
   * 'error' event.
   */
  destroy(er) {
    if (this[DESTROYED])
      return er ? this.emit("error", er) : this.emit(DESTROYED), this;
    this[DESTROYED] = !0, this[DISCARDED] = !0, this[BUFFER].length = 0, this[BUFFERLENGTH] = 0;
    let wc = this;
    return typeof wc.close == "function" && !this[CLOSED] && wc.close(), er ? this.emit("error", er) : this.emit(DESTROYED), this;
  }
  /**
   * Alias for {@link isStream}
   *
   * Former export location, maintained for backwards compatibility.
   *
   * @deprecated
   */
  static get isStream() {
    return isStream;
  }
};

// node_modules/@isaacs/fs-minipass/dist/esm/index.js
var writev = import_fs.default.writev, _autoClose = Symbol("_autoClose"), _close = Symbol("_close"), _ended = Symbol("_ended"), _fd = Symbol("_fd"), _finished = Symbol("_finished"), _flags = Symbol("_flags"), _flush = Symbol("_flush"), _handleChunk = Symbol("_handleChunk"), _makeBuf = Symbol("_makeBuf"), _mode = Symbol("_mode"), _needDrain = Symbol("_needDrain"), _onerror = Symbol("_onerror"), _onopen = Symbol("_onopen"), _onread = Symbol("_onread"), _onwrite = Symbol("_onwrite"), _open = Symbol("_open"), _path = Symbol("_path"), _pos = Symbol("_pos"), _queue = Symbol("_queue"), _read = Symbol("_read"), _readSize = Symbol("_readSize"), _reading = Symbol("_reading"), _remain = Symbol("_remain"), _size = Symbol("_size"), _write = Symbol("_write"), _writing = Symbol("_writing"), _defaultFlag = Symbol("_defaultFlag"), _errored = Symbol("_errored"), ReadStream = class extends Minipass {
  [_errored] = !1;
  [_fd];
  [_path];
  [_readSize];
  [_reading] = !1;
  [_size];
  [_remain];
  [_autoClose];
  constructor(path8, opt) {
    if (opt = opt || {}, super(opt), this.readable = !0, this.writable = !1, typeof path8 != "string")
      throw new TypeError("path must be a string");
    this[_errored] = !1, this[_fd] = typeof opt.fd == "number" ? opt.fd : void 0, this[_path] = path8, this[_readSize] = opt.readSize || 16 * 1024 * 1024, this[_reading] = !1, this[_size] = typeof opt.size == "number" ? opt.size : 1 / 0, this[_remain] = this[_size], this[_autoClose] = typeof opt.autoClose == "boolean" ? opt.autoClose : !0, typeof this[_fd] == "number" ? this[_read]() : this[_open]();
  }
  get fd() {
    return this[_fd];
  }
  get path() {
    return this[_path];
  }
  //@ts-ignore
  write() {
    throw new TypeError("this is a readable stream");
  }
  //@ts-ignore
  end() {
    throw new TypeError("this is a readable stream");
  }
  [_open]() {
    import_fs.default.open(this[_path], "r", (er, fd) => this[_onopen](er, fd));
  }
  [_onopen](er, fd) {
    er ? this[_onerror](er) : (this[_fd] = fd, this.emit("open", fd), this[_read]());
  }
  [_makeBuf]() {
    return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));
  }
  [_read]() {
    if (!this[_reading]) {
      this[_reading] = !0;
      let buf = this[_makeBuf]();
      if (buf.length === 0)
        return process.nextTick(() => this[_onread](null, 0, buf));
      import_fs.default.read(this[_fd], buf, 0, buf.length, null, (er, br, b) => this[_onread](er, br, b));
    }
  }
  [_onread](er, br, buf) {
    this[_reading] = !1, er ? this[_onerror](er) : this[_handleChunk](br, buf) && this[_read]();
  }
  [_close]() {
    if (this[_autoClose] && typeof this[_fd] == "number") {
      let fd = this[_fd];
      this[_fd] = void 0, import_fs.default.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
    }
  }
  [_onerror](er) {
    this[_reading] = !0, this[_close](), this.emit("error", er);
  }
  [_handleChunk](br, buf) {
    let ret = !1;
    return this[_remain] -= br, br > 0 && (ret = super.write(br < buf.length ? buf.subarray(0, br) : buf)), (br === 0 || this[_remain] <= 0) && (ret = !1, this[_close](), super.end()), ret;
  }
  emit(ev, ...args) {
    switch (ev) {
      case "prefinish":
      case "finish":
        return !1;
      case "drain":
        return typeof this[_fd] == "number" && this[_read](), !1;
      case "error":
        return this[_errored] ? !1 : (this[_errored] = !0, super.emit(ev, ...args));
      default:
        return super.emit(ev, ...args);
    }
  }
}, ReadStreamSync = class extends ReadStream {
  [_open]() {
    let threw = !0;
    try {
      this[_onopen](null, import_fs.default.openSync(this[_path], "r")), threw = !1;
    } finally {
      threw && this[_close]();
    }
  }
  [_read]() {
    let threw = !0;
    try {
      if (!this[_reading]) {
        this[_reading] = !0;
        do {
          let buf = this[_makeBuf](), br = buf.length === 0 ? 0 : import_fs.default.readSync(this[_fd], buf, 0, buf.length, null);
          if (!this[_handleChunk](br, buf))
            break;
        } while (!0);
        this[_reading] = !1;
      }
      threw = !1;
    } finally {
      threw && this[_close]();
    }
  }
  [_close]() {
    if (this[_autoClose] && typeof this[_fd] == "number") {
      let fd = this[_fd];
      this[_fd] = void 0, import_fs.default.closeSync(fd), this.emit("close");
    }
  }
}, WriteStream = class extends import_events.default {
  readable = !1;
  writable = !0;
  [_errored] = !1;
  [_writing] = !1;
  [_ended] = !1;
  [_queue] = [];
  [_needDrain] = !1;
  [_path];
  [_mode];
  [_autoClose];
  [_fd];
  [_defaultFlag];
  [_flags];
  [_finished] = !1;
  [_pos];
  constructor(path8, opt) {
    opt = opt || {}, super(opt), this[_path] = path8, this[_fd] = typeof opt.fd == "number" ? opt.fd : void 0, this[_mode] = opt.mode === void 0 ? 438 : opt.mode, this[_pos] = typeof opt.start == "number" ? opt.start : void 0, this[_autoClose] = typeof opt.autoClose == "boolean" ? opt.autoClose : !0;
    let defaultFlag = this[_pos] !== void 0 ? "r+" : "w";
    this[_defaultFlag] = opt.flags === void 0, this[_flags] = opt.flags === void 0 ? defaultFlag : opt.flags, this[_fd] === void 0 && this[_open]();
  }
  emit(ev, ...args) {
    if (ev === "error") {
      if (this[_errored])
        return !1;
      this[_errored] = !0;
    }
    return super.emit(ev, ...args);
  }
  get fd() {
    return this[_fd];
  }
  get path() {
    return this[_path];
  }
  [_onerror](er) {
    this[_close](), this[_writing] = !0, this.emit("error", er);
  }
  [_open]() {
    import_fs.default.open(this[_path], this[_flags], this[_mode], (er, fd) => this[_onopen](er, fd));
  }
  [_onopen](er, fd) {
    this[_defaultFlag] && this[_flags] === "r+" && er && er.code === "ENOENT" ? (this[_flags] = "w", this[_open]()) : er ? this[_onerror](er) : (this[_fd] = fd, this.emit("open", fd), this[_writing] || this[_flush]());
  }
  end(buf, enc) {
    return buf && this.write(buf, enc), this[_ended] = !0, !this[_writing] && !this[_queue].length && typeof this[_fd] == "number" && this[_onwrite](null, 0), this;
  }
  write(buf, enc) {
    return typeof buf == "string" && (buf = Buffer.from(buf, enc)), this[_ended] ? (this.emit("error", new Error("write() after end()")), !1) : this[_fd] === void 0 || this[_writing] || this[_queue].length ? (this[_queue].push(buf), this[_needDrain] = !0, !1) : (this[_writing] = !0, this[_write](buf), !0);
  }
  [_write](buf) {
    import_fs.default.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) => this[_onwrite](er, bw));
  }
  [_onwrite](er, bw) {
    er ? this[_onerror](er) : (this[_pos] !== void 0 && typeof bw == "number" && (this[_pos] += bw), this[_queue].length ? this[_flush]() : (this[_writing] = !1, this[_ended] && !this[_finished] ? (this[_finished] = !0, this[_close](), this.emit("finish")) : this[_needDrain] && (this[_needDrain] = !1, this.emit("drain"))));
  }
  [_flush]() {
    if (this[_queue].length === 0)
      this[_ended] && this[_onwrite](null, 0);
    else if (this[_queue].length === 1)
      this[_write](this[_queue].pop());
    else {
      let iovec = this[_queue];
      this[_queue] = [], writev(this[_fd], iovec, this[_pos], (er, bw) => this[_onwrite](er, bw));
    }
  }
  [_close]() {
    if (this[_autoClose] && typeof this[_fd] == "number") {
      let fd = this[_fd];
      this[_fd] = void 0, import_fs.default.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
    }
  }
}, WriteStreamSync = class extends WriteStream {
  [_open]() {
    let fd;
    if (this[_defaultFlag] && this[_flags] === "r+")
      try {
        fd = import_fs.default.openSync(this[_path], this[_flags], this[_mode]);
      } catch (er) {
        if (er?.code === "ENOENT")
          return this[_flags] = "w", this[_open]();
        throw er;
      }
    else
      fd = import_fs.default.openSync(this[_path], this[_flags], this[_mode]);
    this[_onopen](null, fd);
  }
  [_close]() {
    if (this[_autoClose] && typeof this[_fd] == "number") {
      let fd = this[_fd];
      this[_fd] = void 0, import_fs.default.closeSync(fd), this.emit("close");
    }
  }
  [_write](buf) {
    let threw = !0;
    try {
      this[_onwrite](null, import_fs.default.writeSync(this[_fd], buf, 0, buf.length, this[_pos])), threw = !1;
    } finally {
      if (threw)
        try {
          this[_close]();
        } catch {
        }
    }
  }
};

// node_modules/tar/dist/esm/create.js
var import_node_path5 = __toESM(require("node:path"), 1);

// node_modules/tar/dist/esm/list.js
var import_node_fs2 = __toESM(require("node:fs"), 1), import_path = require("path");

// node_modules/tar/dist/esm/options.js
var argmap = /* @__PURE__ */ new Map([
  ["C", "cwd"],
  ["f", "file"],
  ["z", "gzip"],
  ["P", "preservePaths"],
  ["U", "unlink"],
  ["strip-components", "strip"],
  ["stripComponents", "strip"],
  ["keep-newer", "newer"],
  ["keepNewer", "newer"],
  ["keep-newer-files", "newer"],
  ["keepNewerFiles", "newer"],
  ["k", "keep"],
  ["keep-existing", "keep"],
  ["keepExisting", "keep"],
  ["m", "noMtime"],
  ["no-mtime", "noMtime"],
  ["p", "preserveOwner"],
  ["L", "follow"],
  ["h", "follow"],
  ["onentry", "onReadEntry"]
]), isSyncFile = (o) => !!o.sync && !!o.file, isAsyncFile = (o) => !o.sync && !!o.file, isSyncNoFile = (o) => !!o.sync && !o.file, isAsyncNoFile = (o) => !o.sync && !o.file;
var isFile = (o) => !!o.file;
var dealiasKey = (k) => {
  let d = argmap.get(k);
  return d || k;
}, dealias = (opt = {}) => {
  if (!opt)
    return {};
  let result = {};
  for (let [key, v] of Object.entries(opt)) {
    let k = dealiasKey(key);
    result[k] = v;
  }
  return result.chmod === void 0 && result.noChmod === !1 && (result.chmod = !0), delete result.noChmod, result;
};

// node_modules/tar/dist/esm/make-command.js
var makeCommand = (syncFile, asyncFile, syncNoFile, asyncNoFile, validate) => Object.assign((opt_ = [], entries, cb) => {
  Array.isArray(opt_) && (entries = opt_, opt_ = {}), typeof entries == "function" && (cb = entries, entries = void 0), entries ? entries = Array.from(entries) : entries = [];
  let opt = dealias(opt_);
  if (validate?.(opt, entries), isSyncFile(opt)) {
    if (typeof cb == "function")
      throw new TypeError("callback not supported for sync tar functions");
    return syncFile(opt, entries);
  } else if (isAsyncFile(opt)) {
    let p = asyncFile(opt, entries), c = cb || void 0;
    return c ? p.then(() => c(), c) : p;
  } else if (isSyncNoFile(opt)) {
    if (typeof cb == "function")
      throw new TypeError("callback not supported for sync tar functions");
    return syncNoFile(opt, entries);
  } else if (isAsyncNoFile(opt)) {
    if (typeof cb == "function")
      throw new TypeError("callback only supported with file option");
    return asyncNoFile(opt, entries);
  } else
    throw new Error("impossible options??");
}, {
  syncFile,
  asyncFile,
  syncNoFile,
  asyncNoFile,
  validate
});

// node_modules/tar/dist/esm/parse.js
var import_events2 = require("events");

// node_modules/minizlib/dist/esm/index.js
var import_assert = __toESM(require("assert"), 1), import_buffer = require("buffer");
var import_zlib2 = __toESM(require("zlib"), 1);

// node_modules/minizlib/dist/esm/constants.js
var import_zlib = __toESM(require("zlib"), 1), realZlibConstants = import_zlib.default.constants || { ZLIB_VERNUM: 4736 }, constants = Object.freeze(Object.assign(/* @__PURE__ */ Object.create(null), {
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  Z_VERSION_ERROR: -6,
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  DEFLATE: 1,
  INFLATE: 2,
  GZIP: 3,
  GUNZIP: 4,
  DEFLATERAW: 5,
  INFLATERAW: 6,
  UNZIP: 7,
  BROTLI_DECODE: 8,
  BROTLI_ENCODE: 9,
  Z_MIN_WINDOWBITS: 8,
  Z_MAX_WINDOWBITS: 15,
  Z_DEFAULT_WINDOWBITS: 15,
  Z_MIN_CHUNK: 64,
  Z_MAX_CHUNK: 1 / 0,
  Z_DEFAULT_CHUNK: 16384,
  Z_MIN_MEMLEVEL: 1,
  Z_MAX_MEMLEVEL: 9,
  Z_DEFAULT_MEMLEVEL: 8,
  Z_MIN_LEVEL: -1,
  Z_MAX_LEVEL: 9,
  Z_DEFAULT_LEVEL: -1,
  BROTLI_OPERATION_PROCESS: 0,
  BROTLI_OPERATION_FLUSH: 1,
  BROTLI_OPERATION_FINISH: 2,
  BROTLI_OPERATION_EMIT_METADATA: 3,
  BROTLI_MODE_GENERIC: 0,
  BROTLI_MODE_TEXT: 1,
  BROTLI_MODE_FONT: 2,
  BROTLI_DEFAULT_MODE: 0,
  BROTLI_MIN_QUALITY: 0,
  BROTLI_MAX_QUALITY: 11,
  BROTLI_DEFAULT_QUALITY: 11,
  BROTLI_MIN_WINDOW_BITS: 10,
  BROTLI_MAX_WINDOW_BITS: 24,
  BROTLI_LARGE_MAX_WINDOW_BITS: 30,
  BROTLI_DEFAULT_WINDOW: 22,
  BROTLI_MIN_INPUT_BLOCK_BITS: 16,
  BROTLI_MAX_INPUT_BLOCK_BITS: 24,
  BROTLI_PARAM_MODE: 0,
  BROTLI_PARAM_QUALITY: 1,
  BROTLI_PARAM_LGWIN: 2,
  BROTLI_PARAM_LGBLOCK: 3,
  BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
  BROTLI_PARAM_SIZE_HINT: 5,
  BROTLI_PARAM_LARGE_WINDOW: 6,
  BROTLI_PARAM_NPOSTFIX: 7,
  BROTLI_PARAM_NDIRECT: 8,
  BROTLI_DECODER_RESULT_ERROR: 0,
  BROTLI_DECODER_RESULT_SUCCESS: 1,
  BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
  BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
  BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
  BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
  BROTLI_DECODER_NO_ERROR: 0,
  BROTLI_DECODER_SUCCESS: 1,
  BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
  BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
  BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
  BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
  BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
  BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
  BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
  BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
  BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
  BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
  BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
  BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
  BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
  BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
  BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
  BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
  BROTLI_DECODER_ERROR_UNREACHABLE: -31
}, realZlibConstants));

// node_modules/minizlib/dist/esm/index.js
var OriginalBufferConcat = import_buffer.Buffer.concat, _superWrite = Symbol("_superWrite"), ZlibError = class extends Error {
  code;
  errno;
  constructor(err) {
    super("zlib: " + err.message), this.code = err.code, this.errno = err.errno, this.code || (this.code = "ZLIB_ERROR"), this.message = "zlib: " + err.message, Error.captureStackTrace(this, this.constructor);
  }
  get name() {
    return "ZlibError";
  }
}, _flushFlag = Symbol("flushFlag"), ZlibBase = class extends Minipass {
  #sawError = !1;
  #ended = !1;
  #flushFlag;
  #finishFlushFlag;
  #fullFlushFlag;
  #handle;
  #onError;
  get sawError() {
    return this.#sawError;
  }
  get handle() {
    return this.#handle;
  }
  /* c8 ignore start */
  get flushFlag() {
    return this.#flushFlag;
  }
  /* c8 ignore stop */
  constructor(opts, mode) {
    if (!opts || typeof opts != "object")
      throw new TypeError("invalid options for ZlibBase constructor");
    super(opts), this.#flushFlag = opts.flush ?? 0, this.#finishFlushFlag = opts.finishFlush ?? 0, this.#fullFlushFlag = opts.fullFlushFlag ?? 0;
    try {
      this.#handle = new import_zlib2.default[mode](opts);
    } catch (er) {
      throw new ZlibError(er);
    }
    this.#onError = (err) => {
      this.#sawError || (this.#sawError = !0, this.close(), this.emit("error", err));
    }, this.#handle?.on("error", (er) => this.#onError(new ZlibError(er))), this.once("end", () => this.close);
  }
  close() {
    this.#handle && (this.#handle.close(), this.#handle = void 0, this.emit("close"));
  }
  reset() {
    if (!this.#sawError)
      return (0, import_assert.default)(this.#handle, "zlib binding closed"), this.#handle.reset?.();
  }
  flush(flushFlag) {
    this.ended || (typeof flushFlag != "number" && (flushFlag = this.#fullFlushFlag), this.write(Object.assign(import_buffer.Buffer.alloc(0), { [_flushFlag]: flushFlag })));
  }
  end(chunk, encoding, cb) {
    return typeof chunk == "function" && (cb = chunk, encoding = void 0, chunk = void 0), typeof encoding == "function" && (cb = encoding, encoding = void 0), chunk && (encoding ? this.write(chunk, encoding) : this.write(chunk)), this.flush(this.#finishFlushFlag), this.#ended = !0, super.end(cb);
  }
  get ended() {
    return this.#ended;
  }
  // overridden in the gzip classes to do portable writes
  [_superWrite](data) {
    return super.write(data);
  }
  write(chunk, encoding, cb) {
    if (typeof encoding == "function" && (cb = encoding, encoding = "utf8"), typeof chunk == "string" && (chunk = import_buffer.Buffer.from(chunk, encoding)), this.#sawError)
      return;
    (0, import_assert.default)(this.#handle, "zlib binding closed");
    let nativeHandle = this.#handle._handle, originalNativeClose = nativeHandle.close;
    nativeHandle.close = () => {
    };
    let originalClose = this.#handle.close;
    this.#handle.close = () => {
    }, import_buffer.Buffer.concat = (args) => args;
    let result;
    try {
      let flushFlag = typeof chunk[_flushFlag] == "number" ? chunk[_flushFlag] : this.#flushFlag;
      result = this.#handle._processChunk(chunk, flushFlag), import_buffer.Buffer.concat = OriginalBufferConcat;
    } catch (err) {
      import_buffer.Buffer.concat = OriginalBufferConcat, this.#onError(new ZlibError(err));
    } finally {
      this.#handle && (this.#handle._handle = nativeHandle, nativeHandle.close = originalNativeClose, this.#handle.close = originalClose, this.#handle.removeAllListeners("error"));
    }
    this.#handle && this.#handle.on("error", (er) => this.#onError(new ZlibError(er)));
    let writeReturn;
    if (result)
      if (Array.isArray(result) && result.length > 0) {
        let r = result[0];
        writeReturn = this[_superWrite](import_buffer.Buffer.from(r));
        for (let i = 1; i < result.length; i++)
          writeReturn = this[_superWrite](result[i]);
      } else
        writeReturn = this[_superWrite](import_buffer.Buffer.from(result));
    return cb && cb(), writeReturn;
  }
}, Zlib = class extends ZlibBase {
  #level;
  #strategy;
  constructor(opts, mode) {
    opts = opts || {}, opts.flush = opts.flush || constants.Z_NO_FLUSH, opts.finishFlush = opts.finishFlush || constants.Z_FINISH, opts.fullFlushFlag = constants.Z_FULL_FLUSH, super(opts, mode), this.#level = opts.level, this.#strategy = opts.strategy;
  }
  params(level, strategy) {
    if (!this.sawError) {
      if (!this.handle)
        throw new Error("cannot switch params when binding is closed");
      if (!this.handle.params)
        throw new Error("not supported in this implementation");
      if (this.#level !== level || this.#strategy !== strategy) {
        this.flush(constants.Z_SYNC_FLUSH), (0, import_assert.default)(this.handle, "zlib binding closed");
        let origFlush = this.handle.flush;
        this.handle.flush = (flushFlag, cb) => {
          typeof flushFlag == "function" && (cb = flushFlag, flushFlag = this.flushFlag), this.flush(flushFlag), cb?.();
        };
        try {
          this.handle.params(level, strategy);
        } finally {
          this.handle.flush = origFlush;
        }
        this.handle && (this.#level = level, this.#strategy = strategy);
      }
    }
  }
};
var Gzip = class extends Zlib {
  #portable;
  constructor(opts) {
    super(opts, "Gzip"), this.#portable = opts && !!opts.portable;
  }
  [_superWrite](data) {
    return this.#portable ? (this.#portable = !1, data[9] = 255, super[_superWrite](data)) : super[_superWrite](data);
  }
};
var Unzip = class extends Zlib {
  constructor(opts) {
    super(opts, "Unzip");
  }
}, Brotli = class extends ZlibBase {
  constructor(opts, mode) {
    opts = opts || {}, opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS, opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH, opts.fullFlushFlag = constants.BROTLI_OPERATION_FLUSH, super(opts, mode);
  }
}, BrotliCompress = class extends Brotli {
  constructor(opts) {
    super(opts, "BrotliCompress");
  }
}, BrotliDecompress = class extends Brotli {
  constructor(opts) {
    super(opts, "BrotliDecompress");
  }
};

// node_modules/yallist/dist/esm/index.js
var Yallist = class _Yallist {
  tail;
  head;
  length = 0;
  static create(list2 = []) {
    return new _Yallist(list2);
  }
  constructor(list2 = []) {
    for (let item of list2)
      this.push(item);
  }
  *[Symbol.iterator]() {
    for (let walker = this.head; walker; walker = walker.next)
      yield walker.value;
  }
  removeNode(node) {
    if (node.list !== this)
      throw new Error("removing node which does not belong to this list");
    let next = node.next, prev = node.prev;
    return next && (next.prev = prev), prev && (prev.next = next), node === this.head && (this.head = next), node === this.tail && (this.tail = prev), this.length--, node.next = void 0, node.prev = void 0, node.list = void 0, next;
  }
  unshiftNode(node) {
    if (node === this.head)
      return;
    node.list && node.list.removeNode(node);
    let head = this.head;
    node.list = this, node.next = head, head && (head.prev = node), this.head = node, this.tail || (this.tail = node), this.length++;
  }
  pushNode(node) {
    if (node === this.tail)
      return;
    node.list && node.list.removeNode(node);
    let tail = this.tail;
    node.list = this, node.prev = tail, tail && (tail.next = node), this.tail = node, this.head || (this.head = node), this.length++;
  }
  push(...args) {
    for (let i = 0, l = args.length; i < l; i++)
      push(this, args[i]);
    return this.length;
  }
  unshift(...args) {
    for (var i = 0, l = args.length; i < l; i++)
      unshift(this, args[i]);
    return this.length;
  }
  pop() {
    if (!this.tail)
      return;
    let res = this.tail.value, t = this.tail;
    return this.tail = this.tail.prev, this.tail ? this.tail.next = void 0 : this.head = void 0, t.list = void 0, this.length--, res;
  }
  shift() {
    if (!this.head)
      return;
    let res = this.head.value, h = this.head;
    return this.head = this.head.next, this.head ? this.head.prev = void 0 : this.tail = void 0, h.list = void 0, this.length--, res;
  }
  forEach(fn, thisp) {
    thisp = thisp || this;
    for (let walker = this.head, i = 0; walker; i++)
      fn.call(thisp, walker.value, i, this), walker = walker.next;
  }
  forEachReverse(fn, thisp) {
    thisp = thisp || this;
    for (let walker = this.tail, i = this.length - 1; walker; i--)
      fn.call(thisp, walker.value, i, this), walker = walker.prev;
  }
  get(n) {
    let i = 0, walker = this.head;
    for (; walker && i < n; i++)
      walker = walker.next;
    if (i === n && walker)
      return walker.value;
  }
  getReverse(n) {
    let i = 0, walker = this.tail;
    for (; walker && i < n; i++)
      walker = walker.prev;
    if (i === n && walker)
      return walker.value;
  }
  map(fn, thisp) {
    thisp = thisp || this;
    let res = new _Yallist();
    for (let walker = this.head; walker; )
      res.push(fn.call(thisp, walker.value, this)), walker = walker.next;
    return res;
  }
  mapReverse(fn, thisp) {
    thisp = thisp || this;
    var res = new _Yallist();
    for (let walker = this.tail; walker; )
      res.push(fn.call(thisp, walker.value, this)), walker = walker.prev;
    return res;
  }
  reduce(fn, initial) {
    let acc, walker = this.head;
    if (arguments.length > 1)
      acc = initial;
    else if (this.head)
      walker = this.head.next, acc = this.head.value;
    else
      throw new TypeError("Reduce of empty list with no initial value");
    for (var i = 0; walker; i++)
      acc = fn(acc, walker.value, i), walker = walker.next;
    return acc;
  }
  reduceReverse(fn, initial) {
    let acc, walker = this.tail;
    if (arguments.length > 1)
      acc = initial;
    else if (this.tail)
      walker = this.tail.prev, acc = this.tail.value;
    else
      throw new TypeError("Reduce of empty list with no initial value");
    for (let i = this.length - 1; walker; i--)
      acc = fn(acc, walker.value, i), walker = walker.prev;
    return acc;
  }
  toArray() {
    let arr = new Array(this.length);
    for (let i = 0, walker = this.head; walker; i++)
      arr[i] = walker.value, walker = walker.next;
    return arr;
  }
  toArrayReverse() {
    let arr = new Array(this.length);
    for (let i = 0, walker = this.tail; walker; i++)
      arr[i] = walker.value, walker = walker.prev;
    return arr;
  }
  slice(from = 0, to = this.length) {
    to < 0 && (to += this.length), from < 0 && (from += this.length);
    let ret = new _Yallist();
    if (to < from || to < 0)
      return ret;
    from < 0 && (from = 0), to > this.length && (to = this.length);
    let walker = this.head, i = 0;
    for (i = 0; walker && i < from; i++)
      walker = walker.next;
    for (; walker && i < to; i++, walker = walker.next)
      ret.push(walker.value);
    return ret;
  }
  sliceReverse(from = 0, to = this.length) {
    to < 0 && (to += this.length), from < 0 && (from += this.length);
    let ret = new _Yallist();
    if (to < from || to < 0)
      return ret;
    from < 0 && (from = 0), to > this.length && (to = this.length);
    let i = this.length, walker = this.tail;
    for (; walker && i > to; i--)
      walker = walker.prev;
    for (; walker && i > from; i--, walker = walker.prev)
      ret.push(walker.value);
    return ret;
  }
  splice(start, deleteCount = 0, ...nodes) {
    start > this.length && (start = this.length - 1), start < 0 && (start = this.length + start);
    let walker = this.head;
    for (let i = 0; walker && i < start; i++)
      walker = walker.next;
    let ret = [];
    for (let i = 0; walker && i < deleteCount; i++)
      ret.push(walker.value), walker = this.removeNode(walker);
    walker ? walker !== this.tail && (walker = walker.prev) : walker = this.tail;
    for (let v of nodes)
      walker = insertAfter(this, walker, v);
    return ret;
  }
  reverse() {
    let head = this.head, tail = this.tail;
    for (let walker = head; walker; walker = walker.prev) {
      let p = walker.prev;
      walker.prev = walker.next, walker.next = p;
    }
    return this.head = tail, this.tail = head, this;
  }
};
function insertAfter(self2, node, value) {
  let prev = node, next = node ? node.next : self2.head, inserted = new Node(value, prev, next, self2);
  return inserted.next === void 0 && (self2.tail = inserted), inserted.prev === void 0 && (self2.head = inserted), self2.length++, inserted;
}
function push(self2, item) {
  self2.tail = new Node(item, self2.tail, void 0, self2), self2.head || (self2.head = self2.tail), self2.length++;
}
function unshift(self2, item) {
  self2.head = new Node(item, void 0, self2.head, self2), self2.tail || (self2.tail = self2.head), self2.length++;
}
var Node = class {
  list;
  next;
  prev;
  value;
  constructor(value, prev, next, list2) {
    this.list = list2, this.value = value, prev ? (prev.next = this, this.prev = prev) : this.prev = void 0, next ? (next.prev = this, this.next = next) : this.next = void 0;
  }
};

// node_modules/tar/dist/esm/header.js
var import_node_path2 = require("node:path");

// node_modules/tar/dist/esm/large-numbers.js
var encode = (num, buf) => {
  if (Number.isSafeInteger(num))
    num < 0 ? encodeNegative(num, buf) : encodePositive(num, buf);
  else throw Error("cannot encode number outside of javascript safe integer range");
  return buf;
}, encodePositive = (num, buf) => {
  buf[0] = 128;
  for (var i = buf.length; i > 1; i--)
    buf[i - 1] = num & 255, num = Math.floor(num / 256);
}, encodeNegative = (num, buf) => {
  buf[0] = 255;
  var flipped = !1;
  num = num * -1;
  for (var i = buf.length; i > 1; i--) {
    var byte = num & 255;
    num = Math.floor(num / 256), flipped ? buf[i - 1] = onesComp(byte) : byte === 0 ? buf[i - 1] = 0 : (flipped = !0, buf[i - 1] = twosComp(byte));
  }
}, parse = (buf) => {
  let pre = buf[0], value = pre === 128 ? pos(buf.subarray(1, buf.length)) : pre === 255 ? twos(buf) : null;
  if (value === null)
    throw Error("invalid base256 encoding");
  if (!Number.isSafeInteger(value))
    throw Error("parsed number outside of javascript safe integer range");
  return value;
}, twos = (buf) => {
  for (var len = buf.length, sum = 0, flipped = !1, i = len - 1; i > -1; i--) {
    var byte = Number(buf[i]), f;
    flipped ? f = onesComp(byte) : byte === 0 ? f = byte : (flipped = !0, f = twosComp(byte)), f !== 0 && (sum -= f * Math.pow(256, len - i - 1));
  }
  return sum;
}, pos = (buf) => {
  for (var len = buf.length, sum = 0, i = len - 1; i > -1; i--) {
    var byte = Number(buf[i]);
    byte !== 0 && (sum += byte * Math.pow(256, len - i - 1));
  }
  return sum;
}, onesComp = (byte) => (255 ^ byte) & 255, twosComp = (byte) => (255 ^ byte) + 1 & 255;

// node_modules/tar/dist/esm/types.js
var isCode = (c) => name.has(c);
var name = /* @__PURE__ */ new Map([
  ["0", "File"],
  // same as File
  ["", "OldFile"],
  ["1", "Link"],
  ["2", "SymbolicLink"],
  // Devices and FIFOs aren't fully supported
  // they are parsed, but skipped when unpacking
  ["3", "CharacterDevice"],
  ["4", "BlockDevice"],
  ["5", "Directory"],
  ["6", "FIFO"],
  // same as File
  ["7", "ContiguousFile"],
  // pax headers
  ["g", "GlobalExtendedHeader"],
  ["x", "ExtendedHeader"],
  // vendor-specific stuff
  // skip
  ["A", "SolarisACL"],
  // like 5, but with data, which should be skipped
  ["D", "GNUDumpDir"],
  // metadata only, skip
  ["I", "Inode"],
  // data = link path of next file
  ["K", "NextFileHasLongLinkpath"],
  // data = path of next file
  ["L", "NextFileHasLongPath"],
  // skip
  ["M", "ContinuationFile"],
  // like L
  ["N", "OldGnuLongPath"],
  // skip
  ["S", "SparseFile"],
  // skip
  ["V", "TapeVolumeHeader"],
  // like x
  ["X", "OldExtendedHeader"]
]), code = new Map(Array.from(name).map((kv) => [kv[1], kv[0]]));

// node_modules/tar/dist/esm/header.js
var Header = class {
  cksumValid = !1;
  needPax = !1;
  nullBlock = !1;
  block;
  path;
  mode;
  uid;
  gid;
  size;
  cksum;
  #type = "Unsupported";
  linkpath;
  uname;
  gname;
  devmaj = 0;
  devmin = 0;
  atime;
  ctime;
  mtime;
  charset;
  comment;
  constructor(data, off = 0, ex, gex) {
    Buffer.isBuffer(data) ? this.decode(data, off || 0, ex, gex) : data && this.#slurp(data);
  }
  decode(buf, off, ex, gex) {
    if (off || (off = 0), !buf || !(buf.length >= off + 512))
      throw new Error("need 512 bytes for header");
    this.path = decString(buf, off, 100), this.mode = decNumber(buf, off + 100, 8), this.uid = decNumber(buf, off + 108, 8), this.gid = decNumber(buf, off + 116, 8), this.size = decNumber(buf, off + 124, 12), this.mtime = decDate(buf, off + 136, 12), this.cksum = decNumber(buf, off + 148, 12), gex && this.#slurp(gex, !0), ex && this.#slurp(ex);
    let t = decString(buf, off + 156, 1);
    if (isCode(t) && (this.#type = t || "0"), this.#type === "0" && this.path.slice(-1) === "/" && (this.#type = "5"), this.#type === "5" && (this.size = 0), this.linkpath = decString(buf, off + 157, 100), buf.subarray(off + 257, off + 265).toString() === "ustar\x0000")
      if (this.uname = decString(buf, off + 265, 32), this.gname = decString(buf, off + 297, 32), this.devmaj = decNumber(buf, off + 329, 8) ?? 0, this.devmin = decNumber(buf, off + 337, 8) ?? 0, buf[off + 475] !== 0) {
        let prefix = decString(buf, off + 345, 155);
        this.path = prefix + "/" + this.path;
      } else {
        let prefix = decString(buf, off + 345, 130);
        prefix && (this.path = prefix + "/" + this.path), this.atime = decDate(buf, off + 476, 12), this.ctime = decDate(buf, off + 488, 12);
      }
    let sum = 8 * 32;
    for (let i = off; i < off + 148; i++)
      sum += buf[i];
    for (let i = off + 156; i < off + 512; i++)
      sum += buf[i];
    this.cksumValid = sum === this.cksum, this.cksum === void 0 && sum === 8 * 32 && (this.nullBlock = !0);
  }
  #slurp(ex, gex = !1) {
    Object.assign(this, Object.fromEntries(Object.entries(ex).filter(([k, v]) => !(v == null || k === "path" && gex || k === "linkpath" && gex || k === "global"))));
  }
  encode(buf, off = 0) {
    if (buf || (buf = this.block = Buffer.alloc(512)), this.#type === "Unsupported" && (this.#type = "0"), !(buf.length >= off + 512))
      throw new Error("need 512 bytes for header");
    let prefixSize = this.ctime || this.atime ? 130 : 155, split = splitPrefix(this.path || "", prefixSize), path8 = split[0], prefix = split[1];
    this.needPax = !!split[2], this.needPax = encString(buf, off, 100, path8) || this.needPax, this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax, this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax, this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax, this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax, this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax, buf[off + 156] = this.#type.charCodeAt(0), this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax, buf.write("ustar\x0000", off + 257, 8), this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax, this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax, this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax, this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax, this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax, buf[off + 475] !== 0 ? this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax : (this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax, this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax, this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax);
    let sum = 8 * 32;
    for (let i = off; i < off + 148; i++)
      sum += buf[i];
    for (let i = off + 156; i < off + 512; i++)
      sum += buf[i];
    return this.cksum = sum, encNumber(buf, off + 148, 8, this.cksum), this.cksumValid = !0, this.needPax;
  }
  get type() {
    return this.#type === "Unsupported" ? this.#type : name.get(this.#type);
  }
  get typeKey() {
    return this.#type;
  }
  set type(type) {
    let c = String(code.get(type));
    if (isCode(c) || c === "Unsupported")
      this.#type = c;
    else if (isCode(type))
      this.#type = type;
    else
      throw new TypeError("invalid entry type: " + type);
  }
}, splitPrefix = (p, prefixSize) => {
  let pp = p, prefix = "", ret, root = import_node_path2.posix.parse(p).root || ".";
  if (Buffer.byteLength(pp) < 100)
    ret = [pp, prefix, !1];
  else {
    prefix = import_node_path2.posix.dirname(pp), pp = import_node_path2.posix.basename(pp);
    do
      Buffer.byteLength(pp) <= 100 && Buffer.byteLength(prefix) <= prefixSize ? ret = [pp, prefix, !1] : Buffer.byteLength(pp) > 100 && Buffer.byteLength(prefix) <= prefixSize ? ret = [pp.slice(0, 99), prefix, !0] : (pp = import_node_path2.posix.join(import_node_path2.posix.basename(prefix), pp), prefix = import_node_path2.posix.dirname(prefix));
    while (prefix !== root && ret === void 0);
    ret || (ret = [p.slice(0, 99), "", !0]);
  }
  return ret;
}, decString = (buf, off, size) => buf.subarray(off, off + size).toString("utf8").replace(/\0.*/, ""), decDate = (buf, off, size) => numToDate(decNumber(buf, off, size)), numToDate = (num) => num === void 0 ? void 0 : new Date(num * 1e3), decNumber = (buf, off, size) => Number(buf[off]) & 128 ? parse(buf.subarray(off, off + size)) : decSmallNumber(buf, off, size), nanUndef = (value) => isNaN(value) ? void 0 : value, decSmallNumber = (buf, off, size) => nanUndef(parseInt(buf.subarray(off, off + size).toString("utf8").replace(/\0.*$/, "").trim(), 8)), MAXNUM = {
  12: 8589934591,
  8: 2097151
}, encNumber = (buf, off, size, num) => num === void 0 ? !1 : num > MAXNUM[size] || num < 0 ? (encode(num, buf.subarray(off, off + size)), !0) : (encSmallNumber(buf, off, size, num), !1), encSmallNumber = (buf, off, size, num) => buf.write(octalString(num, size), off, size, "ascii"), octalString = (num, size) => padOctal(Math.floor(num).toString(8), size), padOctal = (str, size) => (str.length === size - 1 ? str : new Array(size - str.length - 1).join("0") + str + " ") + "\0", encDate = (buf, off, size, date) => date === void 0 ? !1 : encNumber(buf, off, size, date.getTime() / 1e3), NULLS = new Array(156).join("\0"), encString = (buf, off, size, str) => str === void 0 ? !1 : (buf.write(str + NULLS, off, size, "utf8"), str.length !== Buffer.byteLength(str) || str.length > size);

// node_modules/tar/dist/esm/pax.js
var import_node_path3 = require("node:path");
var Pax = class _Pax {
  atime;
  mtime;
  ctime;
  charset;
  comment;
  gid;
  uid;
  gname;
  uname;
  linkpath;
  dev;
  ino;
  nlink;
  path;
  size;
  mode;
  global;
  constructor(obj, global2 = !1) {
    this.atime = obj.atime, this.charset = obj.charset, this.comment = obj.comment, this.ctime = obj.ctime, this.dev = obj.dev, this.gid = obj.gid, this.global = global2, this.gname = obj.gname, this.ino = obj.ino, this.linkpath = obj.linkpath, this.mtime = obj.mtime, this.nlink = obj.nlink, this.path = obj.path, this.size = obj.size, this.uid = obj.uid, this.uname = obj.uname;
  }
  encode() {
    let body = this.encodeBody();
    if (body === "")
      return Buffer.allocUnsafe(0);
    let bodyLen = Buffer.byteLength(body), bufLen = 512 * Math.ceil(1 + bodyLen / 512), buf = Buffer.allocUnsafe(bufLen);
    for (let i = 0; i < 512; i++)
      buf[i] = 0;
    new Header({
      // XXX split the path
      // then the path should be PaxHeader + basename, but less than 99,
      // prepend with the dirname
      /* c8 ignore start */
      path: ("PaxHeader/" + (0, import_node_path3.basename)(this.path ?? "")).slice(0, 99),
      /* c8 ignore stop */
      mode: this.mode || 420,
      uid: this.uid,
      gid: this.gid,
      size: bodyLen,
      mtime: this.mtime,
      type: this.global ? "GlobalExtendedHeader" : "ExtendedHeader",
      linkpath: "",
      uname: this.uname || "",
      gname: this.gname || "",
      devmaj: 0,
      devmin: 0,
      atime: this.atime,
      ctime: this.ctime
    }).encode(buf), buf.write(body, 512, bodyLen, "utf8");
    for (let i = bodyLen + 512; i < buf.length; i++)
      buf[i] = 0;
    return buf;
  }
  encodeBody() {
    return this.encodeField("path") + this.encodeField("ctime") + this.encodeField("atime") + this.encodeField("dev") + this.encodeField("ino") + this.encodeField("nlink") + this.encodeField("charset") + this.encodeField("comment") + this.encodeField("gid") + this.encodeField("gname") + this.encodeField("linkpath") + this.encodeField("mtime") + this.encodeField("size") + this.encodeField("uid") + this.encodeField("uname");
  }
  encodeField(field) {
    if (this[field] === void 0)
      return "";
    let r = this[field], v = r instanceof Date ? r.getTime() / 1e3 : r, s = " " + (field === "dev" || field === "ino" || field === "nlink" ? "SCHILY." : "") + field + "=" + v + `
`, byteLen = Buffer.byteLength(s), digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1;
    return byteLen + digits >= Math.pow(10, digits) && (digits += 1), digits + byteLen + s;
  }
  static parse(str, ex, g = !1) {
    return new _Pax(merge(parseKV(str), ex), g);
  }
}, merge = (a, b) => b ? Object.assign({}, b, a) : a, parseKV = (str) => str.replace(/\n$/, "").split(`
`).reduce(parseKVLine, /* @__PURE__ */ Object.create(null)), parseKVLine = (set, line) => {
  let n = parseInt(line, 10);
  if (n !== Buffer.byteLength(line) + 1)
    return set;
  line = line.slice((n + " ").length);
  let kv = line.split("="), r = kv.shift();
  if (!r)
    return set;
  let k = r.replace(/^SCHILY\.(dev|ino|nlink)/, "$1"), v = kv.join("=");
  return set[k] = /^([A-Z]+\.)?([mac]|birth|creation)time$/.test(k) ? new Date(Number(v) * 1e3) : /^[0-9]+$/.test(v) ? +v : v, set;
};

// node_modules/tar/dist/esm/normalize-windows-path.js
var platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform, normalizeWindowsPath = platform !== "win32" ? (p) => p : (p) => p && p.replace(/\\/g, "/");

// node_modules/tar/dist/esm/read-entry.js
var ReadEntry = class extends Minipass {
  extended;
  globalExtended;
  header;
  startBlockSize;
  blockRemain;
  remain;
  type;
  meta = !1;
  ignore = !1;
  path;
  mode;
  uid;
  gid;
  uname;
  gname;
  size = 0;
  mtime;
  atime;
  ctime;
  linkpath;
  dev;
  ino;
  nlink;
  invalid = !1;
  absolute;
  unsupported = !1;
  constructor(header, ex, gex) {
    switch (super({}), this.pause(), this.extended = ex, this.globalExtended = gex, this.header = header, this.remain = header.size ?? 0, this.startBlockSize = 512 * Math.ceil(this.remain / 512), this.blockRemain = this.startBlockSize, this.type = header.type, this.type) {
      case "File":
      case "OldFile":
      case "Link":
      case "SymbolicLink":
      case "CharacterDevice":
      case "BlockDevice":
      case "Directory":
      case "FIFO":
      case "ContiguousFile":
      case "GNUDumpDir":
        break;
      case "NextFileHasLongLinkpath":
      case "NextFileHasLongPath":
      case "OldGnuLongPath":
      case "GlobalExtendedHeader":
      case "ExtendedHeader":
      case "OldExtendedHeader":
        this.meta = !0;
        break;
      // NOTE: gnutar and bsdtar treat unrecognized types as 'File'
      // it may be worth doing the same, but with a warning.
      default:
        this.ignore = !0;
    }
    if (!header.path)
      throw new Error("no path provided for tar.ReadEntry");
    this.path = normalizeWindowsPath(header.path), this.mode = header.mode, this.mode && (this.mode = this.mode & 4095), this.uid = header.uid, this.gid = header.gid, this.uname = header.uname, this.gname = header.gname, this.size = this.remain, this.mtime = header.mtime, this.atime = header.atime, this.ctime = header.ctime, this.linkpath = header.linkpath ? normalizeWindowsPath(header.linkpath) : void 0, this.uname = header.uname, this.gname = header.gname, ex && this.#slurp(ex), gex && this.#slurp(gex, !0);
  }
  write(data) {
    let writeLen = data.length;
    if (writeLen > this.blockRemain)
      throw new Error("writing more to entry than is appropriate");
    let r = this.remain, br = this.blockRemain;
    return this.remain = Math.max(0, r - writeLen), this.blockRemain = Math.max(0, br - writeLen), this.ignore ? !0 : r >= writeLen ? super.write(data) : super.write(data.subarray(0, r));
  }
  #slurp(ex, gex = !1) {
    ex.path && (ex.path = normalizeWindowsPath(ex.path)), ex.linkpath && (ex.linkpath = normalizeWindowsPath(ex.linkpath)), Object.assign(this, Object.fromEntries(Object.entries(ex).filter(([k, v]) => !(v == null || k === "path" && gex))));
  }
};

// node_modules/tar/dist/esm/warn-method.js
var warnMethod = (self2, code2, message, data = {}) => {
  self2.file && (data.file = self2.file), self2.cwd && (data.cwd = self2.cwd), data.code = message instanceof Error && message.code || code2, data.tarCode = code2, !self2.strict && data.recoverable !== !1 ? (message instanceof Error && (data = Object.assign(message, data), message = message.message), self2.emit("warn", code2, message, data)) : message instanceof Error ? self2.emit("error", Object.assign(message, data)) : self2.emit("error", Object.assign(new Error(`${code2}: ${message}`), data));
};

// node_modules/tar/dist/esm/parse.js
var maxMetaEntrySize = 1024 * 1024, gzipHeader = Buffer.from([31, 139]), STATE = Symbol("state"), WRITEENTRY = Symbol("writeEntry"), READENTRY = Symbol("readEntry"), NEXTENTRY = Symbol("nextEntry"), PROCESSENTRY = Symbol("processEntry"), EX = Symbol("extendedHeader"), GEX = Symbol("globalExtendedHeader"), META = Symbol("meta"), EMITMETA = Symbol("emitMeta"), BUFFER2 = Symbol("buffer"), QUEUE = Symbol("queue"), ENDED = Symbol("ended"), EMITTEDEND = Symbol("emittedEnd"), EMIT = Symbol("emit"), UNZIP = Symbol("unzip"), CONSUMECHUNK = Symbol("consumeChunk"), CONSUMECHUNKSUB = Symbol("consumeChunkSub"), CONSUMEBODY = Symbol("consumeBody"), CONSUMEMETA = Symbol("consumeMeta"), CONSUMEHEADER = Symbol("consumeHeader"), CONSUMING = Symbol("consuming"), BUFFERCONCAT = Symbol("bufferConcat"), MAYBEEND = Symbol("maybeEnd"), WRITING = Symbol("writing"), ABORTED2 = Symbol("aborted"), DONE = Symbol("onDone"), SAW_VALID_ENTRY = Symbol("sawValidEntry"), SAW_NULL_BLOCK = Symbol("sawNullBlock"), SAW_EOF = Symbol("sawEOF"), CLOSESTREAM = Symbol("closeStream"), noop = () => !0, Parser = class extends import_events2.EventEmitter {
  file;
  strict;
  maxMetaEntrySize;
  filter;
  brotli;
  writable = !0;
  readable = !1;
  [QUEUE] = new Yallist();
  [BUFFER2];
  [READENTRY];
  [WRITEENTRY];
  [STATE] = "begin";
  [META] = "";
  [EX];
  [GEX];
  [ENDED] = !1;
  [UNZIP];
  [ABORTED2] = !1;
  [SAW_VALID_ENTRY];
  [SAW_NULL_BLOCK] = !1;
  [SAW_EOF] = !1;
  [WRITING] = !1;
  [CONSUMING] = !1;
  [EMITTEDEND] = !1;
  constructor(opt = {}) {
    super(), this.file = opt.file || "", this.on(DONE, () => {
      (this[STATE] === "begin" || this[SAW_VALID_ENTRY] === !1) && this.warn("TAR_BAD_ARCHIVE", "Unrecognized archive format");
    }), opt.ondone ? this.on(DONE, opt.ondone) : this.on(DONE, () => {
      this.emit("prefinish"), this.emit("finish"), this.emit("end");
    }), this.strict = !!opt.strict, this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize, this.filter = typeof opt.filter == "function" ? opt.filter : noop;
    let isTBR = opt.file && (opt.file.endsWith(".tar.br") || opt.file.endsWith(".tbr"));
    this.brotli = !opt.gzip && opt.brotli !== void 0 ? opt.brotli : isTBR ? void 0 : !1, this.on("end", () => this[CLOSESTREAM]()), typeof opt.onwarn == "function" && this.on("warn", opt.onwarn), typeof opt.onReadEntry == "function" && this.on("entry", opt.onReadEntry);
  }
  warn(code2, message, data = {}) {
    warnMethod(this, code2, message, data);
  }
  [CONSUMEHEADER](chunk, position) {
    this[SAW_VALID_ENTRY] === void 0 && (this[SAW_VALID_ENTRY] = !1);
    let header;
    try {
      header = new Header(chunk, position, this[EX], this[GEX]);
    } catch (er) {
      return this.warn("TAR_ENTRY_INVALID", er);
    }
    if (header.nullBlock)
      this[SAW_NULL_BLOCK] ? (this[SAW_EOF] = !0, this[STATE] === "begin" && (this[STATE] = "header"), this[EMIT]("eof")) : (this[SAW_NULL_BLOCK] = !0, this[EMIT]("nullBlock"));
    else if (this[SAW_NULL_BLOCK] = !1, !header.cksumValid)
      this.warn("TAR_ENTRY_INVALID", "checksum failure", { header });
    else if (!header.path)
      this.warn("TAR_ENTRY_INVALID", "path is required", { header });
    else {
      let type = header.type;
      if (/^(Symbolic)?Link$/.test(type) && !header.linkpath)
        this.warn("TAR_ENTRY_INVALID", "linkpath required", {
          header
        });
      else if (!/^(Symbolic)?Link$/.test(type) && !/^(Global)?ExtendedHeader$/.test(type) && header.linkpath)
        this.warn("TAR_ENTRY_INVALID", "linkpath forbidden", {
          header
        });
      else {
        let entry = this[WRITEENTRY] = new ReadEntry(header, this[EX], this[GEX]);
        if (!this[SAW_VALID_ENTRY])
          if (entry.remain) {
            let onend = () => {
              entry.invalid || (this[SAW_VALID_ENTRY] = !0);
            };
            entry.on("end", onend);
          } else
            this[SAW_VALID_ENTRY] = !0;
        entry.meta ? entry.size > this.maxMetaEntrySize ? (entry.ignore = !0, this[EMIT]("ignoredEntry", entry), this[STATE] = "ignore", entry.resume()) : entry.size > 0 && (this[META] = "", entry.on("data", (c) => this[META] += c), this[STATE] = "meta") : (this[EX] = void 0, entry.ignore = entry.ignore || !this.filter(entry.path, entry), entry.ignore ? (this[EMIT]("ignoredEntry", entry), this[STATE] = entry.remain ? "ignore" : "header", entry.resume()) : (entry.remain ? this[STATE] = "body" : (this[STATE] = "header", entry.end()), this[READENTRY] ? this[QUEUE].push(entry) : (this[QUEUE].push(entry), this[NEXTENTRY]())));
      }
    }
  }
  [CLOSESTREAM]() {
    queueMicrotask(() => this.emit("close"));
  }
  [PROCESSENTRY](entry) {
    let go = !0;
    if (!entry)
      this[READENTRY] = void 0, go = !1;
    else if (Array.isArray(entry)) {
      let [ev, ...args] = entry;
      this.emit(ev, ...args);
    } else
      this[READENTRY] = entry, this.emit("entry", entry), entry.emittedEnd || (entry.on("end", () => this[NEXTENTRY]()), go = !1);
    return go;
  }
  [NEXTENTRY]() {
    do
      ;
    while (this[PROCESSENTRY](this[QUEUE].shift()));
    if (!this[QUEUE].length) {
      let re = this[READENTRY];
      !re || re.flowing || re.size === re.remain ? this[WRITING] || this.emit("drain") : re.once("drain", () => this.emit("drain"));
    }
  }
  [CONSUMEBODY](chunk, position) {
    let entry = this[WRITEENTRY];
    if (!entry)
      throw new Error("attempt to consume body without entry??");
    let br = entry.blockRemain ?? 0, c = br >= chunk.length && position === 0 ? chunk : chunk.subarray(position, position + br);
    return entry.write(c), entry.blockRemain || (this[STATE] = "header", this[WRITEENTRY] = void 0, entry.end()), c.length;
  }
  [CONSUMEMETA](chunk, position) {
    let entry = this[WRITEENTRY], ret = this[CONSUMEBODY](chunk, position);
    return !this[WRITEENTRY] && entry && this[EMITMETA](entry), ret;
  }
  [EMIT](ev, data, extra) {
    !this[QUEUE].length && !this[READENTRY] ? this.emit(ev, data, extra) : this[QUEUE].push([ev, data, extra]);
  }
  [EMITMETA](entry) {
    switch (this[EMIT]("meta", this[META]), entry.type) {
      case "ExtendedHeader":
      case "OldExtendedHeader":
        this[EX] = Pax.parse(this[META], this[EX], !1);
        break;
      case "GlobalExtendedHeader":
        this[GEX] = Pax.parse(this[META], this[GEX], !0);
        break;
      case "NextFileHasLongPath":
      case "OldGnuLongPath": {
        let ex = this[EX] ?? /* @__PURE__ */ Object.create(null);
        this[EX] = ex, ex.path = this[META].replace(/\0.*/, "");
        break;
      }
      case "NextFileHasLongLinkpath": {
        let ex = this[EX] || /* @__PURE__ */ Object.create(null);
        this[EX] = ex, ex.linkpath = this[META].replace(/\0.*/, "");
        break;
      }
      /* c8 ignore start */
      default:
        throw new Error("unknown meta: " + entry.type);
    }
  }
  abort(error) {
    this[ABORTED2] = !0, this.emit("abort", error), this.warn("TAR_ABORT", error, { recoverable: !1 });
  }
  write(chunk, encoding, cb) {
    if (typeof encoding == "function" && (cb = encoding, encoding = void 0), typeof chunk == "string" && (chunk = Buffer.from(
      chunk,
      /* c8 ignore next */
      typeof encoding == "string" ? encoding : "utf8"
    )), this[ABORTED2])
      return cb?.(), !1;
    if ((this[UNZIP] === void 0 || this.brotli === void 0 && this[UNZIP] === !1) && chunk) {
      if (this[BUFFER2] && (chunk = Buffer.concat([this[BUFFER2], chunk]), this[BUFFER2] = void 0), chunk.length < gzipHeader.length)
        return this[BUFFER2] = chunk, cb?.(), !0;
      for (let i = 0; this[UNZIP] === void 0 && i < gzipHeader.length; i++)
        chunk[i] !== gzipHeader[i] && (this[UNZIP] = !1);
      let maybeBrotli = this.brotli === void 0;
      if (this[UNZIP] === !1 && maybeBrotli)
        if (chunk.length < 512)
          if (this[ENDED])
            this.brotli = !0;
          else
            return this[BUFFER2] = chunk, cb?.(), !0;
        else
          try {
            new Header(chunk.subarray(0, 512)), this.brotli = !1;
          } catch {
            this.brotli = !0;
          }
      if (this[UNZIP] === void 0 || this[UNZIP] === !1 && this.brotli) {
        let ended = this[ENDED];
        this[ENDED] = !1, this[UNZIP] = this[UNZIP] === void 0 ? new Unzip({}) : new BrotliDecompress({}), this[UNZIP].on("data", (chunk2) => this[CONSUMECHUNK](chunk2)), this[UNZIP].on("error", (er) => this.abort(er)), this[UNZIP].on("end", () => {
          this[ENDED] = !0, this[CONSUMECHUNK]();
        }), this[WRITING] = !0;
        let ret2 = !!this[UNZIP][ended ? "end" : "write"](chunk);
        return this[WRITING] = !1, cb?.(), ret2;
      }
    }
    this[WRITING] = !0, this[UNZIP] ? this[UNZIP].write(chunk) : this[CONSUMECHUNK](chunk), this[WRITING] = !1;
    let ret = this[QUEUE].length ? !1 : this[READENTRY] ? this[READENTRY].flowing : !0;
    return !ret && !this[QUEUE].length && this[READENTRY]?.once("drain", () => this.emit("drain")), cb?.(), ret;
  }
  [BUFFERCONCAT](c) {
    c && !this[ABORTED2] && (this[BUFFER2] = this[BUFFER2] ? Buffer.concat([this[BUFFER2], c]) : c);
  }
  [MAYBEEND]() {
    if (this[ENDED] && !this[EMITTEDEND] && !this[ABORTED2] && !this[CONSUMING]) {
      this[EMITTEDEND] = !0;
      let entry = this[WRITEENTRY];
      if (entry && entry.blockRemain) {
        let have = this[BUFFER2] ? this[BUFFER2].length : 0;
        this.warn("TAR_BAD_ARCHIVE", `Truncated input (needed ${entry.blockRemain} more bytes, only ${have} available)`, { entry }), this[BUFFER2] && entry.write(this[BUFFER2]), entry.end();
      }
      this[EMIT](DONE);
    }
  }
  [CONSUMECHUNK](chunk) {
    if (this[CONSUMING] && chunk)
      this[BUFFERCONCAT](chunk);
    else if (!chunk && !this[BUFFER2])
      this[MAYBEEND]();
    else if (chunk) {
      if (this[CONSUMING] = !0, this[BUFFER2]) {
        this[BUFFERCONCAT](chunk);
        let c = this[BUFFER2];
        this[BUFFER2] = void 0, this[CONSUMECHUNKSUB](c);
      } else
        this[CONSUMECHUNKSUB](chunk);
      for (; this[BUFFER2] && this[BUFFER2]?.length >= 512 && !this[ABORTED2] && !this[SAW_EOF]; ) {
        let c = this[BUFFER2];
        this[BUFFER2] = void 0, this[CONSUMECHUNKSUB](c);
      }
      this[CONSUMING] = !1;
    }
    (!this[BUFFER2] || this[ENDED]) && this[MAYBEEND]();
  }
  [CONSUMECHUNKSUB](chunk) {
    let position = 0, length = chunk.length;
    for (; position + 512 <= length && !this[ABORTED2] && !this[SAW_EOF]; )
      switch (this[STATE]) {
        case "begin":
        case "header":
          this[CONSUMEHEADER](chunk, position), position += 512;
          break;
        case "ignore":
        case "body":
          position += this[CONSUMEBODY](chunk, position);
          break;
        case "meta":
          position += this[CONSUMEMETA](chunk, position);
          break;
        /* c8 ignore start */
        default:
          throw new Error("invalid state: " + this[STATE]);
      }
    position < length && (this[BUFFER2] ? this[BUFFER2] = Buffer.concat([
      chunk.subarray(position),
      this[BUFFER2]
    ]) : this[BUFFER2] = chunk.subarray(position));
  }
  end(chunk, encoding, cb) {
    return typeof chunk == "function" && (cb = chunk, encoding = void 0, chunk = void 0), typeof encoding == "function" && (cb = encoding, encoding = void 0), typeof chunk == "string" && (chunk = Buffer.from(chunk, encoding)), cb && this.once("finish", cb), this[ABORTED2] || (this[UNZIP] ? (chunk && this[UNZIP].write(chunk), this[UNZIP].end()) : (this[ENDED] = !0, this.brotli === void 0 && (chunk = chunk || Buffer.alloc(0)), chunk && this.write(chunk), this[MAYBEEND]())), this;
  }
};

// node_modules/tar/dist/esm/strip-trailing-slashes.js
var stripTrailingSlashes = (str) => {
  let i = str.length - 1, slashesStart = -1;
  for (; i > -1 && str.charAt(i) === "/"; )
    slashesStart = i, i--;
  return slashesStart === -1 ? str : str.slice(0, slashesStart);
};

// node_modules/tar/dist/esm/list.js
var onReadEntryFunction = (opt) => {
  let onReadEntry = opt.onReadEntry;
  opt.onReadEntry = onReadEntry ? (e) => {
    onReadEntry(e), e.resume();
  } : (e) => e.resume();
}, filesFilter = (opt, files) => {
  let map = new Map(files.map((f) => [stripTrailingSlashes(f), !0])), filter = opt.filter, mapHas = (file, r = "") => {
    let root = r || (0, import_path.parse)(file).root || ".", ret;
    if (file === root)
      ret = !1;
    else {
      let m = map.get(file);
      m !== void 0 ? ret = m : ret = mapHas((0, import_path.dirname)(file), root);
    }
    return map.set(file, ret), ret;
  };
  opt.filter = filter ? (file, entry) => filter(file, entry) && mapHas(stripTrailingSlashes(file)) : (file) => mapHas(stripTrailingSlashes(file));
}, listFileSync = (opt) => {
  let p = new Parser(opt), file = opt.file, fd;
  try {
    let stat2 = import_node_fs2.default.statSync(file), readSize = opt.maxReadSize || 16 * 1024 * 1024;
    if (stat2.size < readSize)
      p.end(import_node_fs2.default.readFileSync(file));
    else {
      let pos2 = 0, buf = Buffer.allocUnsafe(readSize);
      for (fd = import_node_fs2.default.openSync(file, "r"); pos2 < stat2.size; ) {
        let bytesRead = import_node_fs2.default.readSync(fd, buf, 0, readSize, pos2);
        pos2 += bytesRead, p.write(buf.subarray(0, bytesRead));
      }
      p.end();
    }
  } finally {
    if (typeof fd == "number")
      try {
        import_node_fs2.default.closeSync(fd);
      } catch {
      }
  }
}, listFile = (opt, _files) => {
  let parse5 = new Parser(opt), readSize = opt.maxReadSize || 16 * 1024 * 1024, file = opt.file;
  return new Promise((resolve2, reject) => {
    parse5.on("error", reject), parse5.on("end", resolve2), import_node_fs2.default.stat(file, (er, stat2) => {
      if (er)
        reject(er);
      else {
        let stream = new ReadStream(file, {
          readSize,
          size: stat2.size
        });
        stream.on("error", reject), stream.pipe(parse5);
      }
    });
  });
}, list = makeCommand(listFileSync, listFile, (opt) => new Parser(opt), (opt) => new Parser(opt), (opt, files) => {
  files?.length && filesFilter(opt, files), opt.noResume || onReadEntryFunction(opt);
});

// node_modules/tar/dist/esm/pack.js
var import_fs3 = __toESM(require("fs"), 1);

// node_modules/tar/dist/esm/write-entry.js
var import_fs2 = __toESM(require("fs"), 1);
var import_path2 = __toESM(require("path"), 1);

// node_modules/tar/dist/esm/mode-fix.js
var modeFix = (mode, isDir, portable) => (mode &= 4095, portable && (mode = (mode | 384) & -19), isDir && (mode & 256 && (mode |= 64), mode & 32 && (mode |= 8), mode & 4 && (mode |= 1)), mode);

// node_modules/tar/dist/esm/strip-absolute-path.js
var import_node_path4 = require("node:path"), { isAbsolute, parse: parse3 } = import_node_path4.win32, stripAbsolutePath = (path8) => {
  let r = "", parsed = parse3(path8);
  for (; isAbsolute(path8) || parsed.root; ) {
    let root = path8.charAt(0) === "/" && path8.slice(0, 4) !== "//?/" ? "/" : parsed.root;
    path8 = path8.slice(root.length), r += root, parsed = parse3(path8);
  }
  return [r, path8];
};

// node_modules/tar/dist/esm/winchars.js
var raw = ["|", "<", ">", "?", ":"], win = raw.map((char) => String.fromCharCode(61440 + char.charCodeAt(0))), toWin = new Map(raw.map((char, i) => [char, win[i]])), toRaw = new Map(win.map((char, i) => [char, raw[i]])), encode2 = (s) => raw.reduce((s2, c) => s2.split(c).join(toWin.get(c)), s), decode = (s) => win.reduce((s2, c) => s2.split(c).join(toRaw.get(c)), s);

// node_modules/tar/dist/esm/write-entry.js
var prefixPath = (path8, prefix) => prefix ? (path8 = normalizeWindowsPath(path8).replace(/^\.(\/|$)/, ""), stripTrailingSlashes(prefix) + "/" + path8) : normalizeWindowsPath(path8), maxReadSize = 16 * 1024 * 1024, PROCESS = Symbol("process"), FILE = Symbol("file"), DIRECTORY = Symbol("directory"), SYMLINK = Symbol("symlink"), HARDLINK = Symbol("hardlink"), HEADER = Symbol("header"), READ2 = Symbol("read"), LSTAT = Symbol("lstat"), ONLSTAT = Symbol("onlstat"), ONREAD = Symbol("onread"), ONREADLINK = Symbol("onreadlink"), OPENFILE = Symbol("openfile"), ONOPENFILE = Symbol("onopenfile"), CLOSE = Symbol("close"), MODE = Symbol("mode"), AWAITDRAIN = Symbol("awaitDrain"), ONDRAIN = Symbol("ondrain"), PREFIX = Symbol("prefix"), WriteEntry = class extends Minipass {
  path;
  portable;
  myuid = process.getuid && process.getuid() || 0;
  // until node has builtin pwnam functions, this'll have to do
  myuser = process.env.USER || "";
  maxReadSize;
  linkCache;
  statCache;
  preservePaths;
  cwd;
  strict;
  mtime;
  noPax;
  noMtime;
  prefix;
  fd;
  blockLen = 0;
  blockRemain = 0;
  buf;
  pos = 0;
  remain = 0;
  length = 0;
  offset = 0;
  win32;
  absolute;
  header;
  type;
  linkpath;
  stat;
  onWriteEntry;
  #hadError = !1;
  constructor(p, opt_ = {}) {
    let opt = dealias(opt_);
    super(), this.path = normalizeWindowsPath(p), this.portable = !!opt.portable, this.maxReadSize = opt.maxReadSize || maxReadSize, this.linkCache = opt.linkCache || /* @__PURE__ */ new Map(), this.statCache = opt.statCache || /* @__PURE__ */ new Map(), this.preservePaths = !!opt.preservePaths, this.cwd = normalizeWindowsPath(opt.cwd || process.cwd()), this.strict = !!opt.strict, this.noPax = !!opt.noPax, this.noMtime = !!opt.noMtime, this.mtime = opt.mtime, this.prefix = opt.prefix ? normalizeWindowsPath(opt.prefix) : void 0, this.onWriteEntry = opt.onWriteEntry, typeof opt.onwarn == "function" && this.on("warn", opt.onwarn);
    let pathWarn = !1;
    if (!this.preservePaths) {
      let [root, stripped] = stripAbsolutePath(this.path);
      root && typeof stripped == "string" && (this.path = stripped, pathWarn = root);
    }
    this.win32 = !!opt.win32 || process.platform === "win32", this.win32 && (this.path = decode(this.path.replace(/\\/g, "/")), p = p.replace(/\\/g, "/")), this.absolute = normalizeWindowsPath(opt.absolute || import_path2.default.resolve(this.cwd, p)), this.path === "" && (this.path = "./"), pathWarn && this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
      entry: this,
      path: pathWarn + this.path
    });
    let cs = this.statCache.get(this.absolute);
    cs ? this[ONLSTAT](cs) : this[LSTAT]();
  }
  warn(code2, message, data = {}) {
    return warnMethod(this, code2, message, data);
  }
  emit(ev, ...data) {
    return ev === "error" && (this.#hadError = !0), super.emit(ev, ...data);
  }
  [LSTAT]() {
    import_fs2.default.lstat(this.absolute, (er, stat2) => {
      if (er)
        return this.emit("error", er);
      this[ONLSTAT](stat2);
    });
  }
  [ONLSTAT](stat2) {
    this.statCache.set(this.absolute, stat2), this.stat = stat2, stat2.isFile() || (stat2.size = 0), this.type = getType(stat2), this.emit("stat", stat2), this[PROCESS]();
  }
  [PROCESS]() {
    switch (this.type) {
      case "File":
        return this[FILE]();
      case "Directory":
        return this[DIRECTORY]();
      case "SymbolicLink":
        return this[SYMLINK]();
      // unsupported types are ignored.
      default:
        return this.end();
    }
  }
  [MODE](mode) {
    return modeFix(mode, this.type === "Directory", this.portable);
  }
  [PREFIX](path8) {
    return prefixPath(path8, this.prefix);
  }
  [HEADER]() {
    if (!this.stat)
      throw new Error("cannot write header before stat");
    this.type === "Directory" && this.portable && (this.noMtime = !0), this.onWriteEntry?.(this), this.header = new Header({
      path: this[PREFIX](this.path),
      // only apply the prefix to hard links.
      linkpath: this.type === "Link" && this.linkpath !== void 0 ? this[PREFIX](this.linkpath) : this.linkpath,
      // only the permissions and setuid/setgid/sticky bitflags
      // not the higher-order bits that specify file type
      mode: this[MODE](this.stat.mode),
      uid: this.portable ? void 0 : this.stat.uid,
      gid: this.portable ? void 0 : this.stat.gid,
      size: this.stat.size,
      mtime: this.noMtime ? void 0 : this.mtime || this.stat.mtime,
      /* c8 ignore next */
      type: this.type === "Unsupported" ? void 0 : this.type,
      uname: this.portable ? void 0 : this.stat.uid === this.myuid ? this.myuser : "",
      atime: this.portable ? void 0 : this.stat.atime,
      ctime: this.portable ? void 0 : this.stat.ctime
    }), this.header.encode() && !this.noPax && super.write(new Pax({
      atime: this.portable ? void 0 : this.header.atime,
      ctime: this.portable ? void 0 : this.header.ctime,
      gid: this.portable ? void 0 : this.header.gid,
      mtime: this.noMtime ? void 0 : this.mtime || this.header.mtime,
      path: this[PREFIX](this.path),
      linkpath: this.type === "Link" && this.linkpath !== void 0 ? this[PREFIX](this.linkpath) : this.linkpath,
      size: this.header.size,
      uid: this.portable ? void 0 : this.header.uid,
      uname: this.portable ? void 0 : this.header.uname,
      dev: this.portable ? void 0 : this.stat.dev,
      ino: this.portable ? void 0 : this.stat.ino,
      nlink: this.portable ? void 0 : this.stat.nlink
    }).encode());
    let block = this.header?.block;
    if (!block)
      throw new Error("failed to encode header");
    super.write(block);
  }
  [DIRECTORY]() {
    if (!this.stat)
      throw new Error("cannot create directory entry without stat");
    this.path.slice(-1) !== "/" && (this.path += "/"), this.stat.size = 0, this[HEADER](), this.end();
  }
  [SYMLINK]() {
    import_fs2.default.readlink(this.absolute, (er, linkpath) => {
      if (er)
        return this.emit("error", er);
      this[ONREADLINK](linkpath);
    });
  }
  [ONREADLINK](linkpath) {
    this.linkpath = normalizeWindowsPath(linkpath), this[HEADER](), this.end();
  }
  [HARDLINK](linkpath) {
    if (!this.stat)
      throw new Error("cannot create link entry without stat");
    this.type = "Link", this.linkpath = normalizeWindowsPath(import_path2.default.relative(this.cwd, linkpath)), this.stat.size = 0, this[HEADER](), this.end();
  }
  [FILE]() {
    if (!this.stat)
      throw new Error("cannot create file entry without stat");
    if (this.stat.nlink > 1) {
      let linkKey = `${this.stat.dev}:${this.stat.ino}`, linkpath = this.linkCache.get(linkKey);
      if (linkpath?.indexOf(this.cwd) === 0)
        return this[HARDLINK](linkpath);
      this.linkCache.set(linkKey, this.absolute);
    }
    if (this[HEADER](), this.stat.size === 0)
      return this.end();
    this[OPENFILE]();
  }
  [OPENFILE]() {
    import_fs2.default.open(this.absolute, "r", (er, fd) => {
      if (er)
        return this.emit("error", er);
      this[ONOPENFILE](fd);
    });
  }
  [ONOPENFILE](fd) {
    if (this.fd = fd, this.#hadError)
      return this[CLOSE]();
    if (!this.stat)
      throw new Error("should stat before calling onopenfile");
    this.blockLen = 512 * Math.ceil(this.stat.size / 512), this.blockRemain = this.blockLen;
    let bufLen = Math.min(this.blockLen, this.maxReadSize);
    this.buf = Buffer.allocUnsafe(bufLen), this.offset = 0, this.pos = 0, this.remain = this.stat.size, this.length = this.buf.length, this[READ2]();
  }
  [READ2]() {
    let { fd, buf, offset, length, pos: pos2 } = this;
    if (fd === void 0 || buf === void 0)
      throw new Error("cannot read file without first opening");
    import_fs2.default.read(fd, buf, offset, length, pos2, (er, bytesRead) => {
      if (er)
        return this[CLOSE](() => this.emit("error", er));
      this[ONREAD](bytesRead);
    });
  }
  /* c8 ignore start */
  [CLOSE](cb = () => {
  }) {
    this.fd !== void 0 && import_fs2.default.close(this.fd, cb);
  }
  [ONREAD](bytesRead) {
    if (bytesRead <= 0 && this.remain > 0) {
      let er = Object.assign(new Error("encountered unexpected EOF"), {
        path: this.absolute,
        syscall: "read",
        code: "EOF"
      });
      return this[CLOSE](() => this.emit("error", er));
    }
    if (bytesRead > this.remain) {
      let er = Object.assign(new Error("did not encounter expected EOF"), {
        path: this.absolute,
        syscall: "read",
        code: "EOF"
      });
      return this[CLOSE](() => this.emit("error", er));
    }
    if (!this.buf)
      throw new Error("should have created buffer prior to reading");
    if (bytesRead === this.remain)
      for (let i = bytesRead; i < this.length && bytesRead < this.blockRemain; i++)
        this.buf[i + this.offset] = 0, bytesRead++, this.remain++;
    let chunk = this.offset === 0 && bytesRead === this.buf.length ? this.buf : this.buf.subarray(this.offset, this.offset + bytesRead);
    this.write(chunk) ? this[ONDRAIN]() : this[AWAITDRAIN](() => this[ONDRAIN]());
  }
  [AWAITDRAIN](cb) {
    this.once("drain", cb);
  }
  write(chunk, encoding, cb) {
    if (typeof encoding == "function" && (cb = encoding, encoding = void 0), typeof chunk == "string" && (chunk = Buffer.from(chunk, typeof encoding == "string" ? encoding : "utf8")), this.blockRemain < chunk.length) {
      let er = Object.assign(new Error("writing more data than expected"), {
        path: this.absolute
      });
      return this.emit("error", er);
    }
    return this.remain -= chunk.length, this.blockRemain -= chunk.length, this.pos += chunk.length, this.offset += chunk.length, super.write(chunk, null, cb);
  }
  [ONDRAIN]() {
    if (!this.remain)
      return this.blockRemain && super.write(Buffer.alloc(this.blockRemain)), this[CLOSE]((er) => er ? this.emit("error", er) : this.end());
    if (!this.buf)
      throw new Error("buffer lost somehow in ONDRAIN");
    this.offset >= this.length && (this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length)), this.offset = 0), this.length = this.buf.length - this.offset, this[READ2]();
  }
}, WriteEntrySync = class extends WriteEntry {
  sync = !0;
  [LSTAT]() {
    this[ONLSTAT](import_fs2.default.lstatSync(this.absolute));
  }
  [SYMLINK]() {
    this[ONREADLINK](import_fs2.default.readlinkSync(this.absolute));
  }
  [OPENFILE]() {
    this[ONOPENFILE](import_fs2.default.openSync(this.absolute, "r"));
  }
  [READ2]() {
    let threw = !0;
    try {
      let { fd, buf, offset, length, pos: pos2 } = this;
      if (fd === void 0 || buf === void 0)
        throw new Error("fd and buf must be set in READ method");
      let bytesRead = import_fs2.default.readSync(fd, buf, offset, length, pos2);
      this[ONREAD](bytesRead), threw = !1;
    } finally {
      if (threw)
        try {
          this[CLOSE](() => {
          });
        } catch {
        }
    }
  }
  [AWAITDRAIN](cb) {
    cb();
  }
  /* c8 ignore start */
  [CLOSE](cb = () => {
  }) {
    this.fd !== void 0 && import_fs2.default.closeSync(this.fd), cb();
  }
}, WriteEntryTar = class extends Minipass {
  blockLen = 0;
  blockRemain = 0;
  buf = 0;
  pos = 0;
  remain = 0;
  length = 0;
  preservePaths;
  portable;
  strict;
  noPax;
  noMtime;
  readEntry;
  type;
  prefix;
  path;
  mode;
  uid;
  gid;
  uname;
  gname;
  header;
  mtime;
  atime;
  ctime;
  linkpath;
  size;
  onWriteEntry;
  warn(code2, message, data = {}) {
    return warnMethod(this, code2, message, data);
  }
  constructor(readEntry, opt_ = {}) {
    let opt = dealias(opt_);
    super(), this.preservePaths = !!opt.preservePaths, this.portable = !!opt.portable, this.strict = !!opt.strict, this.noPax = !!opt.noPax, this.noMtime = !!opt.noMtime, this.onWriteEntry = opt.onWriteEntry, this.readEntry = readEntry;
    let { type } = readEntry;
    if (type === "Unsupported")
      throw new Error("writing entry that should be ignored");
    this.type = type, this.type === "Directory" && this.portable && (this.noMtime = !0), this.prefix = opt.prefix, this.path = normalizeWindowsPath(readEntry.path), this.mode = readEntry.mode !== void 0 ? this[MODE](readEntry.mode) : void 0, this.uid = this.portable ? void 0 : readEntry.uid, this.gid = this.portable ? void 0 : readEntry.gid, this.uname = this.portable ? void 0 : readEntry.uname, this.gname = this.portable ? void 0 : readEntry.gname, this.size = readEntry.size, this.mtime = this.noMtime ? void 0 : opt.mtime || readEntry.mtime, this.atime = this.portable ? void 0 : readEntry.atime, this.ctime = this.portable ? void 0 : readEntry.ctime, this.linkpath = readEntry.linkpath !== void 0 ? normalizeWindowsPath(readEntry.linkpath) : void 0, typeof opt.onwarn == "function" && this.on("warn", opt.onwarn);
    let pathWarn = !1;
    if (!this.preservePaths) {
      let [root, stripped] = stripAbsolutePath(this.path);
      root && typeof stripped == "string" && (this.path = stripped, pathWarn = root);
    }
    this.remain = readEntry.size, this.blockRemain = readEntry.startBlockSize, this.onWriteEntry?.(this), this.header = new Header({
      path: this[PREFIX](this.path),
      linkpath: this.type === "Link" && this.linkpath !== void 0 ? this[PREFIX](this.linkpath) : this.linkpath,
      // only the permissions and setuid/setgid/sticky bitflags
      // not the higher-order bits that specify file type
      mode: this.mode,
      uid: this.portable ? void 0 : this.uid,
      gid: this.portable ? void 0 : this.gid,
      size: this.size,
      mtime: this.noMtime ? void 0 : this.mtime,
      type: this.type,
      uname: this.portable ? void 0 : this.uname,
      atime: this.portable ? void 0 : this.atime,
      ctime: this.portable ? void 0 : this.ctime
    }), pathWarn && this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
      entry: this,
      path: pathWarn + this.path
    }), this.header.encode() && !this.noPax && super.write(new Pax({
      atime: this.portable ? void 0 : this.atime,
      ctime: this.portable ? void 0 : this.ctime,
      gid: this.portable ? void 0 : this.gid,
      mtime: this.noMtime ? void 0 : this.mtime,
      path: this[PREFIX](this.path),
      linkpath: this.type === "Link" && this.linkpath !== void 0 ? this[PREFIX](this.linkpath) : this.linkpath,
      size: this.size,
      uid: this.portable ? void 0 : this.uid,
      uname: this.portable ? void 0 : this.uname,
      dev: this.portable ? void 0 : this.readEntry.dev,
      ino: this.portable ? void 0 : this.readEntry.ino,
      nlink: this.portable ? void 0 : this.readEntry.nlink
    }).encode());
    let b = this.header?.block;
    if (!b)
      throw new Error("failed to encode header");
    super.write(b), readEntry.pipe(this);
  }
  [PREFIX](path8) {
    return prefixPath(path8, this.prefix);
  }
  [MODE](mode) {
    return modeFix(mode, this.type === "Directory", this.portable);
  }
  write(chunk, encoding, cb) {
    typeof encoding == "function" && (cb = encoding, encoding = void 0), typeof chunk == "string" && (chunk = Buffer.from(chunk, typeof encoding == "string" ? encoding : "utf8"));
    let writeLen = chunk.length;
    if (writeLen > this.blockRemain)
      throw new Error("writing more to entry than is appropriate");
    return this.blockRemain -= writeLen, super.write(chunk, cb);
  }
  end(chunk, encoding, cb) {
    return this.blockRemain && super.write(Buffer.alloc(this.blockRemain)), typeof chunk == "function" && (cb = chunk, encoding = void 0, chunk = void 0), typeof encoding == "function" && (cb = encoding, encoding = void 0), typeof chunk == "string" && (chunk = Buffer.from(chunk, encoding ?? "utf8")), cb && this.once("finish", cb), chunk ? super.end(chunk, cb) : super.end(cb), this;
  }
}, getType = (stat2) => stat2.isFile() ? "File" : stat2.isDirectory() ? "Directory" : stat2.isSymbolicLink() ? "SymbolicLink" : "Unsupported";

// node_modules/tar/dist/esm/pack.js
var import_path3 = __toESM(require("path"), 1);
var PackJob = class {
  path;
  absolute;
  entry;
  stat;
  readdir;
  pending = !1;
  ignore = !1;
  piped = !1;
  constructor(path8, absolute) {
    this.path = path8 || "./", this.absolute = absolute;
  }
}, EOF2 = Buffer.alloc(1024), ONSTAT = Symbol("onStat"), ENDED2 = Symbol("ended"), QUEUE2 = Symbol("queue"), CURRENT = Symbol("current"), PROCESS2 = Symbol("process"), PROCESSING = Symbol("processing"), PROCESSJOB = Symbol("processJob"), JOBS = Symbol("jobs"), JOBDONE = Symbol("jobDone"), ADDFSENTRY = Symbol("addFSEntry"), ADDTARENTRY = Symbol("addTarEntry"), STAT = Symbol("stat"), READDIR = Symbol("readdir"), ONREADDIR = Symbol("onreaddir"), PIPE = Symbol("pipe"), ENTRY = Symbol("entry"), ENTRYOPT = Symbol("entryOpt"), WRITEENTRYCLASS = Symbol("writeEntryClass"), WRITE = Symbol("write"), ONDRAIN2 = Symbol("ondrain"), Pack = class extends Minipass {
  opt;
  cwd;
  maxReadSize;
  preservePaths;
  strict;
  noPax;
  prefix;
  linkCache;
  statCache;
  file;
  portable;
  zip;
  readdirCache;
  noDirRecurse;
  follow;
  noMtime;
  mtime;
  filter;
  jobs;
  [WRITEENTRYCLASS];
  onWriteEntry;
  [QUEUE2];
  [JOBS] = 0;
  [PROCESSING] = !1;
  [ENDED2] = !1;
  constructor(opt = {}) {
    if (super(), this.opt = opt, this.file = opt.file || "", this.cwd = opt.cwd || process.cwd(), this.maxReadSize = opt.maxReadSize, this.preservePaths = !!opt.preservePaths, this.strict = !!opt.strict, this.noPax = !!opt.noPax, this.prefix = normalizeWindowsPath(opt.prefix || ""), this.linkCache = opt.linkCache || /* @__PURE__ */ new Map(), this.statCache = opt.statCache || /* @__PURE__ */ new Map(), this.readdirCache = opt.readdirCache || /* @__PURE__ */ new Map(), this.onWriteEntry = opt.onWriteEntry, this[WRITEENTRYCLASS] = WriteEntry, typeof opt.onwarn == "function" && this.on("warn", opt.onwarn), this.portable = !!opt.portable, opt.gzip || opt.brotli) {
      if (opt.gzip && opt.brotli)
        throw new TypeError("gzip and brotli are mutually exclusive");
      if (opt.gzip && (typeof opt.gzip != "object" && (opt.gzip = {}), this.portable && (opt.gzip.portable = !0), this.zip = new Gzip(opt.gzip)), opt.brotli && (typeof opt.brotli != "object" && (opt.brotli = {}), this.zip = new BrotliCompress(opt.brotli)), !this.zip)
        throw new Error("impossible");
      let zip = this.zip;
      zip.on("data", (chunk) => super.write(chunk)), zip.on("end", () => super.end()), zip.on("drain", () => this[ONDRAIN2]()), this.on("resume", () => zip.resume());
    } else
      this.on("drain", this[ONDRAIN2]);
    this.noDirRecurse = !!opt.noDirRecurse, this.follow = !!opt.follow, this.noMtime = !!opt.noMtime, opt.mtime && (this.mtime = opt.mtime), this.filter = typeof opt.filter == "function" ? opt.filter : () => !0, this[QUEUE2] = new Yallist(), this[JOBS] = 0, this.jobs = Number(opt.jobs) || 4, this[PROCESSING] = !1, this[ENDED2] = !1;
  }
  [WRITE](chunk) {
    return super.write(chunk);
  }
  add(path8) {
    return this.write(path8), this;
  }
  end(path8, encoding, cb) {
    return typeof path8 == "function" && (cb = path8, path8 = void 0), typeof encoding == "function" && (cb = encoding, encoding = void 0), path8 && this.add(path8), this[ENDED2] = !0, this[PROCESS2](), cb && cb(), this;
  }
  write(path8) {
    if (this[ENDED2])
      throw new Error("write after end");
    return path8 instanceof ReadEntry ? this[ADDTARENTRY](path8) : this[ADDFSENTRY](path8), this.flowing;
  }
  [ADDTARENTRY](p) {
    let absolute = normalizeWindowsPath(import_path3.default.resolve(this.cwd, p.path));
    if (!this.filter(p.path, p))
      p.resume();
    else {
      let job = new PackJob(p.path, absolute);
      job.entry = new WriteEntryTar(p, this[ENTRYOPT](job)), job.entry.on("end", () => this[JOBDONE](job)), this[JOBS] += 1, this[QUEUE2].push(job);
    }
    this[PROCESS2]();
  }
  [ADDFSENTRY](p) {
    let absolute = normalizeWindowsPath(import_path3.default.resolve(this.cwd, p));
    this[QUEUE2].push(new PackJob(p, absolute)), this[PROCESS2]();
  }
  [STAT](job) {
    job.pending = !0, this[JOBS] += 1;
    let stat2 = this.follow ? "stat" : "lstat";
    import_fs3.default[stat2](job.absolute, (er, stat3) => {
      job.pending = !1, this[JOBS] -= 1, er ? this.emit("error", er) : this[ONSTAT](job, stat3);
    });
  }
  [ONSTAT](job, stat2) {
    this.statCache.set(job.absolute, stat2), job.stat = stat2, this.filter(job.path, stat2) || (job.ignore = !0), this[PROCESS2]();
  }
  [READDIR](job) {
    job.pending = !0, this[JOBS] += 1, import_fs3.default.readdir(job.absolute, (er, entries) => {
      if (job.pending = !1, this[JOBS] -= 1, er)
        return this.emit("error", er);
      this[ONREADDIR](job, entries);
    });
  }
  [ONREADDIR](job, entries) {
    this.readdirCache.set(job.absolute, entries), job.readdir = entries, this[PROCESS2]();
  }
  [PROCESS2]() {
    if (!this[PROCESSING]) {
      this[PROCESSING] = !0;
      for (let w = this[QUEUE2].head; w && this[JOBS] < this.jobs; w = w.next)
        if (this[PROCESSJOB](w.value), w.value.ignore) {
          let p = w.next;
          this[QUEUE2].removeNode(w), w.next = p;
        }
      this[PROCESSING] = !1, this[ENDED2] && !this[QUEUE2].length && this[JOBS] === 0 && (this.zip ? this.zip.end(EOF2) : (super.write(EOF2), super.end()));
    }
  }
  get [CURRENT]() {
    return this[QUEUE2] && this[QUEUE2].head && this[QUEUE2].head.value;
  }
  [JOBDONE](_job) {
    this[QUEUE2].shift(), this[JOBS] -= 1, this[PROCESS2]();
  }
  [PROCESSJOB](job) {
    if (!job.pending) {
      if (job.entry) {
        job === this[CURRENT] && !job.piped && this[PIPE](job);
        return;
      }
      if (!job.stat) {
        let sc = this.statCache.get(job.absolute);
        sc ? this[ONSTAT](job, sc) : this[STAT](job);
      }
      if (job.stat && !job.ignore) {
        if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {
          let rc = this.readdirCache.get(job.absolute);
          if (rc ? this[ONREADDIR](job, rc) : this[READDIR](job), !job.readdir)
            return;
        }
        if (job.entry = this[ENTRY](job), !job.entry) {
          job.ignore = !0;
          return;
        }
        job === this[CURRENT] && !job.piped && this[PIPE](job);
      }
    }
  }
  [ENTRYOPT](job) {
    return {
      onwarn: (code2, msg, data) => this.warn(code2, msg, data),
      noPax: this.noPax,
      cwd: this.cwd,
      absolute: job.absolute,
      preservePaths: this.preservePaths,
      maxReadSize: this.maxReadSize,
      strict: this.strict,
      portable: this.portable,
      linkCache: this.linkCache,
      statCache: this.statCache,
      noMtime: this.noMtime,
      mtime: this.mtime,
      prefix: this.prefix,
      onWriteEntry: this.onWriteEntry
    };
  }
  [ENTRY](job) {
    this[JOBS] += 1;
    try {
      return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job)).on("end", () => this[JOBDONE](job)).on("error", (er) => this.emit("error", er));
    } catch (er) {
      this.emit("error", er);
    }
  }
  [ONDRAIN2]() {
    this[CURRENT] && this[CURRENT].entry && this[CURRENT].entry.resume();
  }
  // like .pipe() but using super, because our write() is special
  [PIPE](job) {
    job.piped = !0, job.readdir && job.readdir.forEach((entry) => {
      let p = job.path, base = p === "./" ? "" : p.replace(/\/*$/, "/");
      this[ADDFSENTRY](base + entry);
    });
    let source = job.entry, zip = this.zip;
    if (!source)
      throw new Error("cannot pipe without source");
    zip ? source.on("data", (chunk) => {
      zip.write(chunk) || source.pause();
    }) : source.on("data", (chunk) => {
      super.write(chunk) || source.pause();
    });
  }
  pause() {
    return this.zip && this.zip.pause(), super.pause();
  }
  warn(code2, message, data = {}) {
    warnMethod(this, code2, message, data);
  }
}, PackSync = class extends Pack {
  sync = !0;
  constructor(opt) {
    super(opt), this[WRITEENTRYCLASS] = WriteEntrySync;
  }
  // pause/resume are no-ops in sync streams.
  pause() {
  }
  resume() {
  }
  [STAT](job) {
    let stat2 = this.follow ? "statSync" : "lstatSync";
    this[ONSTAT](job, import_fs3.default[stat2](job.absolute));
  }
  [READDIR](job) {
    this[ONREADDIR](job, import_fs3.default.readdirSync(job.absolute));
  }
  // gotta get it all in this tick
  [PIPE](job) {
    let source = job.entry, zip = this.zip;
    if (job.readdir && job.readdir.forEach((entry) => {
      let p = job.path, base = p === "./" ? "" : p.replace(/\/*$/, "/");
      this[ADDFSENTRY](base + entry);
    }), !source)
      throw new Error("Cannot pipe without source");
    zip ? source.on("data", (chunk) => {
      zip.write(chunk);
    }) : source.on("data", (chunk) => {
      super[WRITE](chunk);
    });
  }
};

// node_modules/tar/dist/esm/create.js
var createFileSync = (opt, files) => {
  let p = new PackSync(opt), stream = new WriteStreamSync(opt.file, {
    mode: opt.mode || 438
  });
  p.pipe(stream), addFilesSync(p, files);
}, createFile = (opt, files) => {
  let p = new Pack(opt), stream = new WriteStream(opt.file, {
    mode: opt.mode || 438
  });
  p.pipe(stream);
  let promise = new Promise((res, rej) => {
    stream.on("error", rej), stream.on("close", res), p.on("error", rej);
  });
  return addFilesAsync(p, files), promise;
}, addFilesSync = (p, files) => {
  files.forEach((file) => {
    file.charAt(0) === "@" ? list({
      file: import_node_path5.default.resolve(p.cwd, file.slice(1)),
      sync: !0,
      noResume: !0,
      onReadEntry: (entry) => p.add(entry)
    }) : p.add(file);
  }), p.end();
}, addFilesAsync = async (p, files) => {
  for (let i = 0; i < files.length; i++) {
    let file = String(files[i]);
    file.charAt(0) === "@" ? await list({
      file: import_node_path5.default.resolve(String(p.cwd), file.slice(1)),
      noResume: !0,
      onReadEntry: (entry) => {
        p.add(entry);
      }
    }) : p.add(file);
  }
  p.end();
}, createSync = (opt, files) => {
  let p = new PackSync(opt);
  return addFilesSync(p, files), p;
}, createAsync = (opt, files) => {
  let p = new Pack(opt);
  return addFilesAsync(p, files), p;
}, create = makeCommand(createFileSync, createFile, createSync, createAsync, (_opt, files) => {
  if (!files?.length)
    throw new TypeError("no paths specified to add to archive");
});

// node_modules/tar/dist/esm/extract.js
var import_node_fs5 = __toESM(require("node:fs"), 1);

// node_modules/tar/dist/esm/unpack.js
var import_node_assert = __toESM(require("node:assert"), 1), import_node_crypto = require("node:crypto"), import_node_fs4 = __toESM(require("node:fs"), 1), import_node_path9 = __toESM(require("node:path"), 1);

// node_modules/tar/dist/esm/get-write-flag.js
var import_fs4 = __toESM(require("fs"), 1), platform2 = process.env.__FAKE_PLATFORM__ || process.platform, isWindows = platform2 === "win32", { O_CREAT, O_TRUNC, O_WRONLY } = import_fs4.default.constants, UV_FS_O_FILEMAP = Number(process.env.__FAKE_FS_O_FILENAME__) || import_fs4.default.constants.UV_FS_O_FILEMAP || 0, fMapEnabled = isWindows && !!UV_FS_O_FILEMAP, fMapLimit = 512 * 1024, fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY, getWriteFlag = fMapEnabled ? (size) => size < fMapLimit ? fMapFlag : "w" : () => "w";

// node_modules/chownr/dist/esm/index.js
var import_node_fs3 = __toESM(require("node:fs"), 1), import_node_path6 = __toESM(require("node:path"), 1), lchownSync = (path8, uid, gid) => {
  try {
    return import_node_fs3.default.lchownSync(path8, uid, gid);
  } catch (er) {
    if (er?.code !== "ENOENT")
      throw er;
  }
}, chown = (cpath, uid, gid, cb) => {
  import_node_fs3.default.lchown(cpath, uid, gid, (er) => {
    cb(er && er?.code !== "ENOENT" ? er : null);
  });
}, chownrKid = (p, child, uid, gid, cb) => {
  if (child.isDirectory())
    chownr(import_node_path6.default.resolve(p, child.name), uid, gid, (er) => {
      if (er)
        return cb(er);
      let cpath = import_node_path6.default.resolve(p, child.name);
      chown(cpath, uid, gid, cb);
    });
  else {
    let cpath = import_node_path6.default.resolve(p, child.name);
    chown(cpath, uid, gid, cb);
  }
}, chownr = (p, uid, gid, cb) => {
  import_node_fs3.default.readdir(p, { withFileTypes: !0 }, (er, children) => {
    if (er) {
      if (er.code === "ENOENT")
        return cb();
      if (er.code !== "ENOTDIR" && er.code !== "ENOTSUP")
        return cb(er);
    }
    if (er || !children.length)
      return chown(p, uid, gid, cb);
    let len = children.length, errState = null, then = (er2) => {
      if (!errState) {
        if (er2)
          return cb(errState = er2);
        if (--len === 0)
          return chown(p, uid, gid, cb);
      }
    };
    for (let child of children)
      chownrKid(p, child, uid, gid, then);
  });
}, chownrKidSync = (p, child, uid, gid) => {
  child.isDirectory() && chownrSync(import_node_path6.default.resolve(p, child.name), uid, gid), lchownSync(import_node_path6.default.resolve(p, child.name), uid, gid);
}, chownrSync = (p, uid, gid) => {
  let children;
  try {
    children = import_node_fs3.default.readdirSync(p, { withFileTypes: !0 });
  } catch (er) {
    let e = er;
    if (e?.code === "ENOENT")
      return;
    if (e?.code === "ENOTDIR" || e?.code === "ENOTSUP")
      return lchownSync(p, uid, gid);
    throw e;
  }
  for (let child of children)
    chownrKidSync(p, child, uid, gid);
  return lchownSync(p, uid, gid);
};

// node_modules/tar/dist/esm/mkdir.js
var import_fs7 = __toESM(require("fs"), 1);

// node_modules/mkdirp/dist/mjs/mkdirp-manual.js
var import_path4 = require("path");

// node_modules/mkdirp/dist/mjs/opts-arg.js
var import_fs5 = require("fs"), optsArg = (opts) => {
  if (!opts)
    opts = { mode: 511 };
  else if (typeof opts == "object")
    opts = { mode: 511, ...opts };
  else if (typeof opts == "number")
    opts = { mode: opts };
  else if (typeof opts == "string")
    opts = { mode: parseInt(opts, 8) };
  else
    throw new TypeError("invalid options argument");
  let resolved = opts, optsFs = opts.fs || {};
  return opts.mkdir = opts.mkdir || optsFs.mkdir || import_fs5.mkdir, opts.mkdirAsync = opts.mkdirAsync ? opts.mkdirAsync : async (path8, options) => new Promise((res, rej) => resolved.mkdir(path8, options, (er, made) => er ? rej(er) : res(made))), opts.stat = opts.stat || optsFs.stat || import_fs5.stat, opts.statAsync = opts.statAsync ? opts.statAsync : async (path8) => new Promise((res, rej) => resolved.stat(path8, (err, stats) => err ? rej(err) : res(stats))), opts.statSync = opts.statSync || optsFs.statSync || import_fs5.statSync, opts.mkdirSync = opts.mkdirSync || optsFs.mkdirSync || import_fs5.mkdirSync, resolved;
};

// node_modules/mkdirp/dist/mjs/mkdirp-manual.js
var mkdirpManualSync = (path8, options, made) => {
  let parent = (0, import_path4.dirname)(path8), opts = { ...optsArg(options), recursive: !1 };
  if (parent === path8)
    try {
      return opts.mkdirSync(path8, opts);
    } catch (er) {
      let fer = er;
      if (fer && fer.code !== "EISDIR")
        throw er;
      return;
    }
  try {
    return opts.mkdirSync(path8, opts), made || path8;
  } catch (er) {
    let fer = er;
    if (fer && fer.code === "ENOENT")
      return mkdirpManualSync(path8, opts, mkdirpManualSync(parent, opts, made));
    if (fer && fer.code !== "EEXIST" && fer && fer.code !== "EROFS")
      throw er;
    try {
      if (!opts.statSync(path8).isDirectory())
        throw er;
    } catch {
      throw er;
    }
  }
}, mkdirpManual = Object.assign(async (path8, options, made) => {
  let opts = optsArg(options);
  opts.recursive = !1;
  let parent = (0, import_path4.dirname)(path8);
  return parent === path8 ? opts.mkdirAsync(path8, opts).catch((er) => {
    let fer = er;
    if (fer && fer.code !== "EISDIR")
      throw er;
  }) : opts.mkdirAsync(path8, opts).then(() => made || path8, async (er) => {
    let fer = er;
    if (fer && fer.code === "ENOENT")
      return mkdirpManual(parent, opts).then((made2) => mkdirpManual(path8, opts, made2));
    if (fer && fer.code !== "EEXIST" && fer.code !== "EROFS")
      throw er;
    return opts.statAsync(path8).then((st) => {
      if (st.isDirectory())
        return made;
      throw er;
    }, () => {
      throw er;
    });
  });
}, { sync: mkdirpManualSync });

// node_modules/mkdirp/dist/mjs/mkdirp-native.js
var import_path6 = require("path");

// node_modules/mkdirp/dist/mjs/find-made.js
var import_path5 = require("path"), findMade = async (opts, parent, path8) => {
  if (path8 !== parent)
    return opts.statAsync(parent).then(
      (st) => st.isDirectory() ? path8 : void 0,
      // will fail later
      // will fail later
      (er) => {
        let fer = er;
        return fer && fer.code === "ENOENT" ? findMade(opts, (0, import_path5.dirname)(parent), parent) : void 0;
      }
    );
}, findMadeSync = (opts, parent, path8) => {
  if (path8 !== parent)
    try {
      return opts.statSync(parent).isDirectory() ? path8 : void 0;
    } catch (er) {
      let fer = er;
      return fer && fer.code === "ENOENT" ? findMadeSync(opts, (0, import_path5.dirname)(parent), parent) : void 0;
    }
};

// node_modules/mkdirp/dist/mjs/mkdirp-native.js
var mkdirpNativeSync = (path8, options) => {
  let opts = optsArg(options);
  if (opts.recursive = !0, (0, import_path6.dirname)(path8) === path8)
    return opts.mkdirSync(path8, opts);
  let made = findMadeSync(opts, path8);
  try {
    return opts.mkdirSync(path8, opts), made;
  } catch (er) {
    let fer = er;
    if (fer && fer.code === "ENOENT")
      return mkdirpManualSync(path8, opts);
    throw er;
  }
}, mkdirpNative = Object.assign(async (path8, options) => {
  let opts = { ...optsArg(options), recursive: !0 };
  return (0, import_path6.dirname)(path8) === path8 ? await opts.mkdirAsync(path8, opts) : findMade(opts, path8).then((made) => opts.mkdirAsync(path8, opts).then((m) => made || m).catch((er) => {
    let fer = er;
    if (fer && fer.code === "ENOENT")
      return mkdirpManual(path8, opts);
    throw er;
  }));
}, { sync: mkdirpNativeSync });

// node_modules/mkdirp/dist/mjs/path-arg.js
var import_path7 = require("path"), platform3 = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform, pathArg = (path8) => {
  if (/\0/.test(path8))
    throw Object.assign(new TypeError("path must be a string without null bytes"), {
      path: path8,
      code: "ERR_INVALID_ARG_VALUE"
    });
  if (path8 = (0, import_path7.resolve)(path8), platform3 === "win32") {
    let badWinChars = /[*|"<>?:]/, { root } = (0, import_path7.parse)(path8);
    if (badWinChars.test(path8.substring(root.length)))
      throw Object.assign(new Error("Illegal characters in path."), {
        path: path8,
        code: "EINVAL"
      });
  }
  return path8;
};

// node_modules/mkdirp/dist/mjs/use-native.js
var import_fs6 = require("fs");
var version = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version, versArr = version.replace(/^v/, "").split("."), hasNative = +versArr[0] > 10 || +versArr[0] == 10 && +versArr[1] >= 12, useNativeSync = hasNative ? (opts) => optsArg(opts).mkdirSync === import_fs6.mkdirSync : () => !1, useNative = Object.assign(hasNative ? (opts) => optsArg(opts).mkdir === import_fs6.mkdir : () => !1, {
  sync: useNativeSync
});

// node_modules/mkdirp/dist/mjs/index.js
var mkdirpSync = (path8, opts) => {
  path8 = pathArg(path8);
  let resolved = optsArg(opts);
  return useNativeSync(resolved) ? mkdirpNativeSync(path8, resolved) : mkdirpManualSync(path8, resolved);
};
var mkdirp = Object.assign(async (path8, opts) => {
  path8 = pathArg(path8);
  let resolved = optsArg(opts);
  return useNative(resolved) ? mkdirpNative(path8, resolved) : mkdirpManual(path8, resolved);
}, {
  mkdirpSync,
  mkdirpNative,
  mkdirpNativeSync,
  mkdirpManual,
  mkdirpManualSync,
  sync: mkdirpSync,
  native: mkdirpNative,
  nativeSync: mkdirpNativeSync,
  manual: mkdirpManual,
  manualSync: mkdirpManualSync,
  useNative,
  useNativeSync
});

// node_modules/tar/dist/esm/mkdir.js
var import_node_path7 = __toESM(require("node:path"), 1);

// node_modules/tar/dist/esm/cwd-error.js
var CwdError = class extends Error {
  path;
  code;
  syscall = "chdir";
  constructor(path8, code2) {
    super(`${code2}: Cannot cd into '${path8}'`), this.path = path8, this.code = code2;
  }
  get name() {
    return "CwdError";
  }
};

// node_modules/tar/dist/esm/symlink-error.js
var SymlinkError = class extends Error {
  path;
  symlink;
  syscall = "symlink";
  code = "TAR_SYMLINK_ERROR";
  constructor(symlink, path8) {
    super("TAR_SYMLINK_ERROR: Cannot extract through symbolic link"), this.symlink = symlink, this.path = path8;
  }
  get name() {
    return "SymlinkError";
  }
};

// node_modules/tar/dist/esm/mkdir.js
var cGet = (cache, key) => cache.get(normalizeWindowsPath(key)), cSet = (cache, key, val) => cache.set(normalizeWindowsPath(key), val), checkCwd = (dir, cb) => {
  import_fs7.default.stat(dir, (er, st) => {
    (er || !st.isDirectory()) && (er = new CwdError(dir, er?.code || "ENOTDIR")), cb(er);
  });
}, mkdir3 = (dir, opt, cb) => {
  dir = normalizeWindowsPath(dir);
  let umask = opt.umask ?? 18, mode = opt.mode | 448, needChmod = (mode & umask) !== 0, uid = opt.uid, gid = opt.gid, doChown = typeof uid == "number" && typeof gid == "number" && (uid !== opt.processUid || gid !== opt.processGid), preserve = opt.preserve, unlink = opt.unlink, cache = opt.cache, cwd = normalizeWindowsPath(opt.cwd), done = (er, created) => {
    er ? cb(er) : (cSet(cache, dir, !0), created && doChown ? chownr(created, uid, gid, (er2) => done(er2)) : needChmod ? import_fs7.default.chmod(dir, mode, cb) : cb());
  };
  if (cache && cGet(cache, dir) === !0)
    return done();
  if (dir === cwd)
    return checkCwd(dir, done);
  if (preserve)
    return mkdirp(dir, { mode }).then(
      (made) => done(null, made ?? void 0),
      // oh, ts
      done
    );
  let parts = normalizeWindowsPath(import_node_path7.default.relative(cwd, dir)).split("/");
  mkdir_(cwd, parts, mode, cache, unlink, cwd, void 0, done);
}, mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {
  if (!parts.length)
    return cb(null, created);
  let p = parts.shift(), part = normalizeWindowsPath(import_node_path7.default.resolve(base + "/" + p));
  if (cGet(cache, part))
    return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);
  import_fs7.default.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));
}, onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => (er) => {
  er ? import_fs7.default.lstat(part, (statEr, st) => {
    if (statEr)
      statEr.path = statEr.path && normalizeWindowsPath(statEr.path), cb(statEr);
    else if (st.isDirectory())
      mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);
    else if (unlink)
      import_fs7.default.unlink(part, (er2) => {
        if (er2)
          return cb(er2);
        import_fs7.default.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));
      });
    else {
      if (st.isSymbolicLink())
        return cb(new SymlinkError(part, part + "/" + parts.join("/")));
      cb(er);
    }
  }) : (created = created || part, mkdir_(part, parts, mode, cache, unlink, cwd, created, cb));
}, checkCwdSync = (dir) => {
  let ok = !1, code2;
  try {
    ok = import_fs7.default.statSync(dir).isDirectory();
  } catch (er) {
    code2 = er?.code;
  } finally {
    if (!ok)
      throw new CwdError(dir, code2 ?? "ENOTDIR");
  }
}, mkdirSync3 = (dir, opt) => {
  dir = normalizeWindowsPath(dir);
  let umask = opt.umask ?? 18, mode = opt.mode | 448, needChmod = (mode & umask) !== 0, uid = opt.uid, gid = opt.gid, doChown = typeof uid == "number" && typeof gid == "number" && (uid !== opt.processUid || gid !== opt.processGid), preserve = opt.preserve, unlink = opt.unlink, cache = opt.cache, cwd = normalizeWindowsPath(opt.cwd), done = (created2) => {
    cSet(cache, dir, !0), created2 && doChown && chownrSync(created2, uid, gid), needChmod && import_fs7.default.chmodSync(dir, mode);
  };
  if (cache && cGet(cache, dir) === !0)
    return done();
  if (dir === cwd)
    return checkCwdSync(cwd), done();
  if (preserve)
    return done(mkdirpSync(dir, mode) ?? void 0);
  let parts = normalizeWindowsPath(import_node_path7.default.relative(cwd, dir)).split("/"), created;
  for (let p = parts.shift(), part = cwd; p && (part += "/" + p); p = parts.shift())
    if (part = normalizeWindowsPath(import_node_path7.default.resolve(part)), !cGet(cache, part))
      try {
        import_fs7.default.mkdirSync(part, mode), created = created || part, cSet(cache, part, !0);
      } catch {
        let st = import_fs7.default.lstatSync(part);
        if (st.isDirectory()) {
          cSet(cache, part, !0);
          continue;
        } else if (unlink) {
          import_fs7.default.unlinkSync(part), import_fs7.default.mkdirSync(part, mode), created = created || part, cSet(cache, part, !0);
          continue;
        } else if (st.isSymbolicLink())
          return new SymlinkError(part, part + "/" + parts.join("/"));
      }
  return done(created);
};

// node_modules/tar/dist/esm/normalize-unicode.js
var normalizeCache = /* @__PURE__ */ Object.create(null), { hasOwnProperty } = Object.prototype, normalizeUnicode = (s) => (hasOwnProperty.call(normalizeCache, s) || (normalizeCache[s] = s.normalize("NFD")), normalizeCache[s]);

// node_modules/tar/dist/esm/path-reservations.js
var import_node_path8 = require("node:path");
var platform4 = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform, isWindows2 = platform4 === "win32", getDirs = (path8) => path8.split("/").slice(0, -1).reduce((set, path9) => {
  let s = set[set.length - 1];
  return s !== void 0 && (path9 = (0, import_node_path8.join)(s, path9)), set.push(path9 || "/"), set;
}, []), PathReservations = class {
  // path => [function or Set]
  // A Set object means a directory reservation
  // A fn is a direct reservation on that path
  #queues = /* @__PURE__ */ new Map();
  // fn => {paths:[path,...], dirs:[path, ...]}
  #reservations = /* @__PURE__ */ new Map();
  // functions currently running
  #running = /* @__PURE__ */ new Set();
  reserve(paths, fn) {
    paths = isWindows2 ? ["win32 parallelization disabled"] : paths.map((p) => stripTrailingSlashes((0, import_node_path8.join)(normalizeUnicode(p))).toLowerCase());
    let dirs = new Set(paths.map((path8) => getDirs(path8)).reduce((a, b) => a.concat(b)));
    this.#reservations.set(fn, { dirs, paths });
    for (let p of paths) {
      let q = this.#queues.get(p);
      q ? q.push(fn) : this.#queues.set(p, [fn]);
    }
    for (let dir of dirs) {
      let q = this.#queues.get(dir);
      if (!q)
        this.#queues.set(dir, [/* @__PURE__ */ new Set([fn])]);
      else {
        let l = q[q.length - 1];
        l instanceof Set ? l.add(fn) : q.push(/* @__PURE__ */ new Set([fn]));
      }
    }
    return this.#run(fn);
  }
  // return the queues for each path the function cares about
  // fn => {paths, dirs}
  #getQueues(fn) {
    let res = this.#reservations.get(fn);
    if (!res)
      throw new Error("function does not have any path reservations");
    return {
      paths: res.paths.map((path8) => this.#queues.get(path8)),
      dirs: [...res.dirs].map((path8) => this.#queues.get(path8))
    };
  }
  // check if fn is first in line for all its paths, and is
  // included in the first set for all its dir queues
  check(fn) {
    let { paths, dirs } = this.#getQueues(fn);
    return paths.every((q) => q && q[0] === fn) && dirs.every((q) => q && q[0] instanceof Set && q[0].has(fn));
  }
  // run the function if it's first in line and not already running
  #run(fn) {
    return this.#running.has(fn) || !this.check(fn) ? !1 : (this.#running.add(fn), fn(() => this.#clear(fn)), !0);
  }
  #clear(fn) {
    if (!this.#running.has(fn))
      return !1;
    let res = this.#reservations.get(fn);
    if (!res)
      throw new Error("invalid reservation");
    let { paths, dirs } = res, next = /* @__PURE__ */ new Set();
    for (let path8 of paths) {
      let q = this.#queues.get(path8);
      if (!q || q?.[0] !== fn)
        continue;
      let q0 = q[1];
      if (!q0) {
        this.#queues.delete(path8);
        continue;
      }
      if (q.shift(), typeof q0 == "function")
        next.add(q0);
      else
        for (let f of q0)
          next.add(f);
    }
    for (let dir of dirs) {
      let q = this.#queues.get(dir), q0 = q?.[0];
      if (!(!q || !(q0 instanceof Set)))
        if (q0.size === 1 && q.length === 1) {
          this.#queues.delete(dir);
          continue;
        } else if (q0.size === 1) {
          q.shift();
          let n = q[0];
          typeof n == "function" && next.add(n);
        } else
          q0.delete(fn);
    }
    return this.#running.delete(fn), next.forEach((fn2) => this.#run(fn2)), !0;
  }
};

// node_modules/tar/dist/esm/unpack.js
var ONENTRY = Symbol("onEntry"), CHECKFS = Symbol("checkFs"), CHECKFS2 = Symbol("checkFs2"), PRUNECACHE = Symbol("pruneCache"), ISREUSABLE = Symbol("isReusable"), MAKEFS = Symbol("makeFs"), FILE2 = Symbol("file"), DIRECTORY2 = Symbol("directory"), LINK = Symbol("link"), SYMLINK2 = Symbol("symlink"), HARDLINK2 = Symbol("hardlink"), UNSUPPORTED = Symbol("unsupported"), CHECKPATH = Symbol("checkPath"), MKDIR = Symbol("mkdir"), ONERROR = Symbol("onError"), PENDING = Symbol("pending"), PEND = Symbol("pend"), UNPEND = Symbol("unpend"), ENDED3 = Symbol("ended"), MAYBECLOSE = Symbol("maybeClose"), SKIP = Symbol("skip"), DOCHOWN = Symbol("doChown"), UID = Symbol("uid"), GID = Symbol("gid"), CHECKED_CWD = Symbol("checkedCwd"), platform5 = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform, isWindows3 = platform5 === "win32", DEFAULT_MAX_DEPTH = 1024, unlinkFile = (path8, cb) => {
  if (!isWindows3)
    return import_node_fs4.default.unlink(path8, cb);
  let name2 = path8 + ".DELETE." + (0, import_node_crypto.randomBytes)(16).toString("hex");
  import_node_fs4.default.rename(path8, name2, (er) => {
    if (er)
      return cb(er);
    import_node_fs4.default.unlink(name2, cb);
  });
}, unlinkFileSync = (path8) => {
  if (!isWindows3)
    return import_node_fs4.default.unlinkSync(path8);
  let name2 = path8 + ".DELETE." + (0, import_node_crypto.randomBytes)(16).toString("hex");
  import_node_fs4.default.renameSync(path8, name2), import_node_fs4.default.unlinkSync(name2);
}, uint32 = (a, b, c) => a !== void 0 && a === a >>> 0 ? a : b !== void 0 && b === b >>> 0 ? b : c, cacheKeyNormalize = (path8) => stripTrailingSlashes(normalizeWindowsPath(normalizeUnicode(path8))).toLowerCase(), pruneCache = (cache, abs) => {
  abs = cacheKeyNormalize(abs);
  for (let path8 of cache.keys()) {
    let pnorm = cacheKeyNormalize(path8);
    (pnorm === abs || pnorm.indexOf(abs + "/") === 0) && cache.delete(path8);
  }
}, dropCache = (cache) => {
  for (let key of cache.keys())
    cache.delete(key);
}, Unpack = class extends Parser {
  [ENDED3] = !1;
  [CHECKED_CWD] = !1;
  [PENDING] = 0;
  reservations = new PathReservations();
  transform;
  writable = !0;
  readable = !1;
  dirCache;
  uid;
  gid;
  setOwner;
  preserveOwner;
  processGid;
  processUid;
  maxDepth;
  forceChown;
  win32;
  newer;
  keep;
  noMtime;
  preservePaths;
  unlink;
  cwd;
  strip;
  processUmask;
  umask;
  dmode;
  fmode;
  chmod;
  constructor(opt = {}) {
    if (opt.ondone = () => {
      this[ENDED3] = !0, this[MAYBECLOSE]();
    }, super(opt), this.transform = opt.transform, this.dirCache = opt.dirCache || /* @__PURE__ */ new Map(), this.chmod = !!opt.chmod, typeof opt.uid == "number" || typeof opt.gid == "number") {
      if (typeof opt.uid != "number" || typeof opt.gid != "number")
        throw new TypeError("cannot set owner without number uid and gid");
      if (opt.preserveOwner)
        throw new TypeError("cannot preserve owner in archive and also set owner explicitly");
      this.uid = opt.uid, this.gid = opt.gid, this.setOwner = !0;
    } else
      this.uid = void 0, this.gid = void 0, this.setOwner = !1;
    opt.preserveOwner === void 0 && typeof opt.uid != "number" ? this.preserveOwner = !!(process.getuid && process.getuid() === 0) : this.preserveOwner = !!opt.preserveOwner, this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ? process.getuid() : void 0, this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ? process.getgid() : void 0, this.maxDepth = typeof opt.maxDepth == "number" ? opt.maxDepth : DEFAULT_MAX_DEPTH, this.forceChown = opt.forceChown === !0, this.win32 = !!opt.win32 || isWindows3, this.newer = !!opt.newer, this.keep = !!opt.keep, this.noMtime = !!opt.noMtime, this.preservePaths = !!opt.preservePaths, this.unlink = !!opt.unlink, this.cwd = normalizeWindowsPath(import_node_path9.default.resolve(opt.cwd || process.cwd())), this.strip = Number(opt.strip) || 0, this.processUmask = this.chmod ? typeof opt.processUmask == "number" ? opt.processUmask : process.umask() : 0, this.umask = typeof opt.umask == "number" ? opt.umask : this.processUmask, this.dmode = opt.dmode || 511 & ~this.umask, this.fmode = opt.fmode || 438 & ~this.umask, this.on("entry", (entry) => this[ONENTRY](entry));
  }
  // a bad or damaged archive is a warning for Parser, but an error
  // when extracting.  Mark those errors as unrecoverable, because
  // the Unpack contract cannot be met.
  warn(code2, msg, data = {}) {
    return (code2 === "TAR_BAD_ARCHIVE" || code2 === "TAR_ABORT") && (data.recoverable = !1), super.warn(code2, msg, data);
  }
  [MAYBECLOSE]() {
    this[ENDED3] && this[PENDING] === 0 && (this.emit("prefinish"), this.emit("finish"), this.emit("end"));
  }
  [CHECKPATH](entry) {
    let p = normalizeWindowsPath(entry.path), parts = p.split("/");
    if (this.strip) {
      if (parts.length < this.strip)
        return !1;
      if (entry.type === "Link") {
        let linkparts = normalizeWindowsPath(String(entry.linkpath)).split("/");
        if (linkparts.length >= this.strip)
          entry.linkpath = linkparts.slice(this.strip).join("/");
        else
          return !1;
      }
      parts.splice(0, this.strip), entry.path = parts.join("/");
    }
    if (isFinite(this.maxDepth) && parts.length > this.maxDepth)
      return this.warn("TAR_ENTRY_ERROR", "path excessively deep", {
        entry,
        path: p,
        depth: parts.length,
        maxDepth: this.maxDepth
      }), !1;
    if (!this.preservePaths) {
      if (parts.includes("..") || /* c8 ignore next */
      isWindows3 && /^[a-z]:\.\.$/i.test(parts[0] ?? ""))
        return this.warn("TAR_ENTRY_ERROR", "path contains '..'", {
          entry,
          path: p
        }), !1;
      let [root, stripped] = stripAbsolutePath(p);
      root && (entry.path = String(stripped), this.warn("TAR_ENTRY_INFO", `stripping ${root} from absolute path`, {
        entry,
        path: p
      }));
    }
    if (import_node_path9.default.isAbsolute(entry.path) ? entry.absolute = normalizeWindowsPath(import_node_path9.default.resolve(entry.path)) : entry.absolute = normalizeWindowsPath(import_node_path9.default.resolve(this.cwd, entry.path)), !this.preservePaths && typeof entry.absolute == "string" && entry.absolute.indexOf(this.cwd + "/") !== 0 && entry.absolute !== this.cwd)
      return this.warn("TAR_ENTRY_ERROR", "path escaped extraction target", {
        entry,
        path: normalizeWindowsPath(entry.path),
        resolvedPath: entry.absolute,
        cwd: this.cwd
      }), !1;
    if (entry.absolute === this.cwd && entry.type !== "Directory" && entry.type !== "GNUDumpDir")
      return !1;
    if (this.win32) {
      let { root: aRoot } = import_node_path9.default.win32.parse(String(entry.absolute));
      entry.absolute = aRoot + encode2(String(entry.absolute).slice(aRoot.length));
      let { root: pRoot } = import_node_path9.default.win32.parse(entry.path);
      entry.path = pRoot + encode2(entry.path.slice(pRoot.length));
    }
    return !0;
  }
  [ONENTRY](entry) {
    if (!this[CHECKPATH](entry))
      return entry.resume();
    switch (import_node_assert.default.equal(typeof entry.absolute, "string"), entry.type) {
      case "Directory":
      case "GNUDumpDir":
        entry.mode && (entry.mode = entry.mode | 448);
      // eslint-disable-next-line no-fallthrough
      case "File":
      case "OldFile":
      case "ContiguousFile":
      case "Link":
      case "SymbolicLink":
        return this[CHECKFS](entry);
      case "CharacterDevice":
      case "BlockDevice":
      case "FIFO":
      default:
        return this[UNSUPPORTED](entry);
    }
  }
  [ONERROR](er, entry) {
    er.name === "CwdError" ? this.emit("error", er) : (this.warn("TAR_ENTRY_ERROR", er, { entry }), this[UNPEND](), entry.resume());
  }
  [MKDIR](dir, mode, cb) {
    mkdir3(normalizeWindowsPath(dir), {
      uid: this.uid,
      gid: this.gid,
      processUid: this.processUid,
      processGid: this.processGid,
      umask: this.processUmask,
      preserve: this.preservePaths,
      unlink: this.unlink,
      cache: this.dirCache,
      cwd: this.cwd,
      mode
    }, cb);
  }
  [DOCHOWN](entry) {
    return this.forceChown || this.preserveOwner && (typeof entry.uid == "number" && entry.uid !== this.processUid || typeof entry.gid == "number" && entry.gid !== this.processGid) || typeof this.uid == "number" && this.uid !== this.processUid || typeof this.gid == "number" && this.gid !== this.processGid;
  }
  [UID](entry) {
    return uint32(this.uid, entry.uid, this.processUid);
  }
  [GID](entry) {
    return uint32(this.gid, entry.gid, this.processGid);
  }
  [FILE2](entry, fullyDone) {
    let mode = typeof entry.mode == "number" ? entry.mode & 4095 : this.fmode, stream = new WriteStream(String(entry.absolute), {
      // slight lie, but it can be numeric flags
      flags: getWriteFlag(entry.size),
      mode,
      autoClose: !1
    });
    stream.on("error", (er) => {
      stream.fd && import_node_fs4.default.close(stream.fd, () => {
      }), stream.write = () => !0, this[ONERROR](er, entry), fullyDone();
    });
    let actions = 1, done = (er) => {
      if (er) {
        stream.fd && import_node_fs4.default.close(stream.fd, () => {
        }), this[ONERROR](er, entry), fullyDone();
        return;
      }
      --actions === 0 && stream.fd !== void 0 && import_node_fs4.default.close(stream.fd, (er2) => {
        er2 ? this[ONERROR](er2, entry) : this[UNPEND](), fullyDone();
      });
    };
    stream.on("finish", () => {
      let abs = String(entry.absolute), fd = stream.fd;
      if (typeof fd == "number" && entry.mtime && !this.noMtime) {
        actions++;
        let atime = entry.atime || /* @__PURE__ */ new Date(), mtime = entry.mtime;
        import_node_fs4.default.futimes(fd, atime, mtime, (er) => er ? import_node_fs4.default.utimes(abs, atime, mtime, (er2) => done(er2 && er)) : done());
      }
      if (typeof fd == "number" && this[DOCHOWN](entry)) {
        actions++;
        let uid = this[UID](entry), gid = this[GID](entry);
        typeof uid == "number" && typeof gid == "number" && import_node_fs4.default.fchown(fd, uid, gid, (er) => er ? import_node_fs4.default.chown(abs, uid, gid, (er2) => done(er2 && er)) : done());
      }
      done();
    });
    let tx = this.transform && this.transform(entry) || entry;
    tx !== entry && (tx.on("error", (er) => {
      this[ONERROR](er, entry), fullyDone();
    }), entry.pipe(tx)), tx.pipe(stream);
  }
  [DIRECTORY2](entry, fullyDone) {
    let mode = typeof entry.mode == "number" ? entry.mode & 4095 : this.dmode;
    this[MKDIR](String(entry.absolute), mode, (er) => {
      if (er) {
        this[ONERROR](er, entry), fullyDone();
        return;
      }
      let actions = 1, done = () => {
        --actions === 0 && (fullyDone(), this[UNPEND](), entry.resume());
      };
      entry.mtime && !this.noMtime && (actions++, import_node_fs4.default.utimes(String(entry.absolute), entry.atime || /* @__PURE__ */ new Date(), entry.mtime, done)), this[DOCHOWN](entry) && (actions++, import_node_fs4.default.chown(String(entry.absolute), Number(this[UID](entry)), Number(this[GID](entry)), done)), done();
    });
  }
  [UNSUPPORTED](entry) {
    entry.unsupported = !0, this.warn("TAR_ENTRY_UNSUPPORTED", `unsupported entry type: ${entry.type}`, { entry }), entry.resume();
  }
  [SYMLINK2](entry, done) {
    this[LINK](entry, String(entry.linkpath), "symlink", done);
  }
  [HARDLINK2](entry, done) {
    let linkpath = normalizeWindowsPath(import_node_path9.default.resolve(this.cwd, String(entry.linkpath)));
    this[LINK](entry, linkpath, "link", done);
  }
  [PEND]() {
    this[PENDING]++;
  }
  [UNPEND]() {
    this[PENDING]--, this[MAYBECLOSE]();
  }
  [SKIP](entry) {
    this[UNPEND](), entry.resume();
  }
  // Check if we can reuse an existing filesystem entry safely and
  // overwrite it, rather than unlinking and recreating
  // Windows doesn't report a useful nlink, so we just never reuse entries
  [ISREUSABLE](entry, st) {
    return entry.type === "File" && !this.unlink && st.isFile() && st.nlink <= 1 && !isWindows3;
  }
  // check if a thing is there, and if so, try to clobber it
  [CHECKFS](entry) {
    this[PEND]();
    let paths = [entry.path];
    entry.linkpath && paths.push(entry.linkpath), this.reservations.reserve(paths, (done) => this[CHECKFS2](entry, done));
  }
  [PRUNECACHE](entry) {
    entry.type === "SymbolicLink" ? dropCache(this.dirCache) : entry.type !== "Directory" && pruneCache(this.dirCache, String(entry.absolute));
  }
  [CHECKFS2](entry, fullyDone) {
    this[PRUNECACHE](entry);
    let done = (er) => {
      this[PRUNECACHE](entry), fullyDone(er);
    }, checkCwd2 = () => {
      this[MKDIR](this.cwd, this.dmode, (er) => {
        if (er) {
          this[ONERROR](er, entry), done();
          return;
        }
        this[CHECKED_CWD] = !0, start();
      });
    }, start = () => {
      if (entry.absolute !== this.cwd) {
        let parent = normalizeWindowsPath(import_node_path9.default.dirname(String(entry.absolute)));
        if (parent !== this.cwd)
          return this[MKDIR](parent, this.dmode, (er) => {
            if (er) {
              this[ONERROR](er, entry), done();
              return;
            }
            afterMakeParent();
          });
      }
      afterMakeParent();
    }, afterMakeParent = () => {
      import_node_fs4.default.lstat(String(entry.absolute), (lstatEr, st) => {
        if (st && (this.keep || /* c8 ignore next */
        this.newer && st.mtime > (entry.mtime ?? st.mtime))) {
          this[SKIP](entry), done();
          return;
        }
        if (lstatEr || this[ISREUSABLE](entry, st))
          return this[MAKEFS](null, entry, done);
        if (st.isDirectory()) {
          if (entry.type === "Directory") {
            let needChmod = this.chmod && entry.mode && (st.mode & 4095) !== entry.mode, afterChmod = (er) => this[MAKEFS](er ?? null, entry, done);
            return needChmod ? import_node_fs4.default.chmod(String(entry.absolute), Number(entry.mode), afterChmod) : afterChmod();
          }
          if (entry.absolute !== this.cwd)
            return import_node_fs4.default.rmdir(String(entry.absolute), (er) => this[MAKEFS](er ?? null, entry, done));
        }
        if (entry.absolute === this.cwd)
          return this[MAKEFS](null, entry, done);
        unlinkFile(String(entry.absolute), (er) => this[MAKEFS](er ?? null, entry, done));
      });
    };
    this[CHECKED_CWD] ? start() : checkCwd2();
  }
  [MAKEFS](er, entry, done) {
    if (er) {
      this[ONERROR](er, entry), done();
      return;
    }
    switch (entry.type) {
      case "File":
      case "OldFile":
      case "ContiguousFile":
        return this[FILE2](entry, done);
      case "Link":
        return this[HARDLINK2](entry, done);
      case "SymbolicLink":
        return this[SYMLINK2](entry, done);
      case "Directory":
      case "GNUDumpDir":
        return this[DIRECTORY2](entry, done);
    }
  }
  [LINK](entry, linkpath, link, done) {
    import_node_fs4.default[link](linkpath, String(entry.absolute), (er) => {
      er ? this[ONERROR](er, entry) : (this[UNPEND](), entry.resume()), done();
    });
  }
}, callSync = (fn) => {
  try {
    return [null, fn()];
  } catch (er) {
    return [er, null];
  }
}, UnpackSync = class extends Unpack {
  sync = !0;
  [MAKEFS](er, entry) {
    return super[MAKEFS](er, entry, () => {
    });
  }
  [CHECKFS](entry) {
    if (this[PRUNECACHE](entry), !this[CHECKED_CWD]) {
      let er2 = this[MKDIR](this.cwd, this.dmode);
      if (er2)
        return this[ONERROR](er2, entry);
      this[CHECKED_CWD] = !0;
    }
    if (entry.absolute !== this.cwd) {
      let parent = normalizeWindowsPath(import_node_path9.default.dirname(String(entry.absolute)));
      if (parent !== this.cwd) {
        let mkParent = this[MKDIR](parent, this.dmode);
        if (mkParent)
          return this[ONERROR](mkParent, entry);
      }
    }
    let [lstatEr, st] = callSync(() => import_node_fs4.default.lstatSync(String(entry.absolute)));
    if (st && (this.keep || /* c8 ignore next */
    this.newer && st.mtime > (entry.mtime ?? st.mtime)))
      return this[SKIP](entry);
    if (lstatEr || this[ISREUSABLE](entry, st))
      return this[MAKEFS](null, entry);
    if (st.isDirectory()) {
      if (entry.type === "Directory") {
        let needChmod = this.chmod && entry.mode && (st.mode & 4095) !== entry.mode, [er3] = needChmod ? callSync(() => {
          import_node_fs4.default.chmodSync(String(entry.absolute), Number(entry.mode));
        }) : [];
        return this[MAKEFS](er3, entry);
      }
      let [er2] = callSync(() => import_node_fs4.default.rmdirSync(String(entry.absolute)));
      this[MAKEFS](er2, entry);
    }
    let [er] = entry.absolute === this.cwd ? [] : callSync(() => unlinkFileSync(String(entry.absolute)));
    this[MAKEFS](er, entry);
  }
  [FILE2](entry, done) {
    let mode = typeof entry.mode == "number" ? entry.mode & 4095 : this.fmode, oner = (er) => {
      let closeError;
      try {
        import_node_fs4.default.closeSync(fd);
      } catch (e) {
        closeError = e;
      }
      (er || closeError) && this[ONERROR](er || closeError, entry), done();
    }, fd;
    try {
      fd = import_node_fs4.default.openSync(String(entry.absolute), getWriteFlag(entry.size), mode);
    } catch (er) {
      return oner(er);
    }
    let tx = this.transform && this.transform(entry) || entry;
    tx !== entry && (tx.on("error", (er) => this[ONERROR](er, entry)), entry.pipe(tx)), tx.on("data", (chunk) => {
      try {
        import_node_fs4.default.writeSync(fd, chunk, 0, chunk.length);
      } catch (er) {
        oner(er);
      }
    }), tx.on("end", () => {
      let er = null;
      if (entry.mtime && !this.noMtime) {
        let atime = entry.atime || /* @__PURE__ */ new Date(), mtime = entry.mtime;
        try {
          import_node_fs4.default.futimesSync(fd, atime, mtime);
        } catch (futimeser) {
          try {
            import_node_fs4.default.utimesSync(String(entry.absolute), atime, mtime);
          } catch {
            er = futimeser;
          }
        }
      }
      if (this[DOCHOWN](entry)) {
        let uid = this[UID](entry), gid = this[GID](entry);
        try {
          import_node_fs4.default.fchownSync(fd, Number(uid), Number(gid));
        } catch (fchowner) {
          try {
            import_node_fs4.default.chownSync(String(entry.absolute), Number(uid), Number(gid));
          } catch {
            er = er || fchowner;
          }
        }
      }
      oner(er);
    });
  }
  [DIRECTORY2](entry, done) {
    let mode = typeof entry.mode == "number" ? entry.mode & 4095 : this.dmode, er = this[MKDIR](String(entry.absolute), mode);
    if (er) {
      this[ONERROR](er, entry), done();
      return;
    }
    if (entry.mtime && !this.noMtime)
      try {
        import_node_fs4.default.utimesSync(String(entry.absolute), entry.atime || /* @__PURE__ */ new Date(), entry.mtime);
      } catch {
      }
    if (this[DOCHOWN](entry))
      try {
        import_node_fs4.default.chownSync(String(entry.absolute), Number(this[UID](entry)), Number(this[GID](entry)));
      } catch {
      }
    done(), entry.resume();
  }
  [MKDIR](dir, mode) {
    try {
      return mkdirSync3(normalizeWindowsPath(dir), {
        uid: this.uid,
        gid: this.gid,
        processUid: this.processUid,
        processGid: this.processGid,
        umask: this.processUmask,
        preserve: this.preservePaths,
        unlink: this.unlink,
        cache: this.dirCache,
        cwd: this.cwd,
        mode
      });
    } catch (er) {
      return er;
    }
  }
  [LINK](entry, linkpath, link, done) {
    let ls = `${link}Sync`;
    try {
      import_node_fs4.default[ls](linkpath, String(entry.absolute)), done(), entry.resume();
    } catch (er) {
      return this[ONERROR](er, entry);
    }
  }
};

// node_modules/tar/dist/esm/extract.js
var extractFileSync = (opt) => {
  let u = new UnpackSync(opt), file = opt.file, stat2 = import_node_fs5.default.statSync(file), readSize = opt.maxReadSize || 16 * 1024 * 1024;
  new ReadStreamSync(file, {
    readSize,
    size: stat2.size
  }).pipe(u);
}, extractFile = (opt, _) => {
  let u = new Unpack(opt), readSize = opt.maxReadSize || 16 * 1024 * 1024, file = opt.file;
  return new Promise((resolve2, reject) => {
    u.on("error", reject), u.on("close", resolve2), import_node_fs5.default.stat(file, (er, stat2) => {
      if (er)
        reject(er);
      else {
        let stream = new ReadStream(file, {
          readSize,
          size: stat2.size
        });
        stream.on("error", reject), stream.pipe(u);
      }
    });
  });
}, extract = makeCommand(extractFileSync, extractFile, (opt) => new UnpackSync(opt), (opt) => new Unpack(opt), (opt, files) => {
  files?.length && filesFilter(opt, files);
});

// node_modules/tar/dist/esm/replace.js
var import_node_fs6 = __toESM(require("node:fs"), 1), import_node_path10 = __toESM(require("node:path"), 1);
var replaceSync = (opt, files) => {
  let p = new PackSync(opt), threw = !0, fd, position;
  try {
    try {
      fd = import_node_fs6.default.openSync(opt.file, "r+");
    } catch (er) {
      if (er?.code === "ENOENT")
        fd = import_node_fs6.default.openSync(opt.file, "w+");
      else
        throw er;
    }
    let st = import_node_fs6.default.fstatSync(fd), headBuf = Buffer.alloc(512);
    POSITION: for (position = 0; position < st.size; position += 512) {
      for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {
        if (bytes = import_node_fs6.default.readSync(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos), position === 0 && headBuf[0] === 31 && headBuf[1] === 139)
          throw new Error("cannot append to compressed archives");
        if (!bytes)
          break POSITION;
      }
      let h = new Header(headBuf);
      if (!h.cksumValid)
        break;
      let entryBlockSize = 512 * Math.ceil((h.size || 0) / 512);
      if (position + entryBlockSize + 512 > st.size)
        break;
      position += entryBlockSize, opt.mtimeCache && h.mtime && opt.mtimeCache.set(String(h.path), h.mtime);
    }
    threw = !1, streamSync(opt, p, position, fd, files);
  } finally {
    if (threw)
      try {
        import_node_fs6.default.closeSync(fd);
      } catch {
      }
  }
}, streamSync = (opt, p, position, fd, files) => {
  let stream = new WriteStreamSync(opt.file, {
    fd,
    start: position
  });
  p.pipe(stream), addFilesSync2(p, files);
}, replaceAsync = (opt, files) => {
  files = Array.from(files);
  let p = new Pack(opt), getPos = (fd, size, cb_) => {
    let cb = (er, pos2) => {
      er ? import_node_fs6.default.close(fd, (_) => cb_(er)) : cb_(null, pos2);
    }, position = 0;
    if (size === 0)
      return cb(null, 0);
    let bufPos = 0, headBuf = Buffer.alloc(512), onread = (er, bytes) => {
      if (er || typeof bytes > "u")
        return cb(er);
      if (bufPos += bytes, bufPos < 512 && bytes)
        return import_node_fs6.default.read(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos, onread);
      if (position === 0 && headBuf[0] === 31 && headBuf[1] === 139)
        return cb(new Error("cannot append to compressed archives"));
      if (bufPos < 512)
        return cb(null, position);
      let h = new Header(headBuf);
      if (!h.cksumValid)
        return cb(null, position);
      let entryBlockSize = 512 * Math.ceil((h.size ?? 0) / 512);
      if (position + entryBlockSize + 512 > size || (position += entryBlockSize + 512, position >= size))
        return cb(null, position);
      opt.mtimeCache && h.mtime && opt.mtimeCache.set(String(h.path), h.mtime), bufPos = 0, import_node_fs6.default.read(fd, headBuf, 0, 512, position, onread);
    };
    import_node_fs6.default.read(fd, headBuf, 0, 512, position, onread);
  };
  return new Promise((resolve2, reject) => {
    p.on("error", reject);
    let flag = "r+", onopen = (er, fd) => {
      if (er && er.code === "ENOENT" && flag === "r+")
        return flag = "w+", import_node_fs6.default.open(opt.file, flag, onopen);
      if (er || !fd)
        return reject(er);
      import_node_fs6.default.fstat(fd, (er2, st) => {
        if (er2)
          return import_node_fs6.default.close(fd, () => reject(er2));
        getPos(fd, st.size, (er3, position) => {
          if (er3)
            return reject(er3);
          let stream = new WriteStream(opt.file, {
            fd,
            start: position
          });
          p.pipe(stream), stream.on("error", reject), stream.on("close", resolve2), addFilesAsync2(p, files);
        });
      });
    };
    import_node_fs6.default.open(opt.file, flag, onopen);
  });
}, addFilesSync2 = (p, files) => {
  files.forEach((file) => {
    file.charAt(0) === "@" ? list({
      file: import_node_path10.default.resolve(p.cwd, file.slice(1)),
      sync: !0,
      noResume: !0,
      onReadEntry: (entry) => p.add(entry)
    }) : p.add(file);
  }), p.end();
}, addFilesAsync2 = async (p, files) => {
  for (let i = 0; i < files.length; i++) {
    let file = String(files[i]);
    file.charAt(0) === "@" ? await list({
      file: import_node_path10.default.resolve(String(p.cwd), file.slice(1)),
      noResume: !0,
      onReadEntry: (entry) => p.add(entry)
    }) : p.add(file);
  }
  p.end();
}, replace = makeCommand(
  replaceSync,
  replaceAsync,
  /* c8 ignore start */
  () => {
    throw new TypeError("file is required");
  },
  () => {
    throw new TypeError("file is required");
  },
  /* c8 ignore stop */
  (opt, entries) => {
    if (!isFile(opt))
      throw new TypeError("file is required");
    if (opt.gzip || opt.brotli || opt.file.endsWith(".br") || opt.file.endsWith(".tbr"))
      throw new TypeError("cannot append to compressed archives");
    if (!entries?.length)
      throw new TypeError("no paths specified to add/replace");
  }
);

// node_modules/tar/dist/esm/update.js
var update = makeCommand(replace.syncFile, replace.asyncFile, replace.syncNoFile, replace.asyncNoFile, (opt, entries = []) => {
  replace.validate?.(opt, entries), mtimeFilter(opt);
}), mtimeFilter = (opt) => {
  let filter = opt.filter;
  opt.mtimeCache || (opt.mtimeCache = /* @__PURE__ */ new Map()), opt.filter = filter ? (path8, stat2) => filter(path8, stat2) && !/* c8 ignore start */
  ((opt.mtimeCache?.get(path8) ?? stat2.mtime ?? 0) > (stat2.mtime ?? 0)) : (path8, stat2) => !/* c8 ignore start */
  ((opt.mtimeCache?.get(path8) ?? stat2.mtime ?? 0) > (stat2.mtime ?? 0));
};

// src/cache/SpigotArtifactArchiver.ts
var SpigotArtifactArchiver = class _SpigotArtifactArchiver {
  static ARTIFACT_DIRS = [
    "org/spigotmc/minecraft-server/",
    "org/spigotmc/spigot-api/",
    "org/spigotmc/spigot/"
  ];
  async createCacheArchiveForVersion(version2, destFilePath) {
    if (!import_node_path11.default.isAbsolute(destFilePath))
      throw new Error("Destination path must be absolute");
    let localMavenRepo = _SpigotArtifactArchiver.determineLocalMavenRepositoryPath(), files = await this.collectFilesFromMavenRepo(localMavenRepo, version2);
    if (files.length === 0)
      throw new Error("No files found in local Maven repository");
    await create(
      {
        file: destFilePath,
        gzip: !0,
        cwd: localMavenRepo
      },
      files.map((file) => import_node_path11.default.relative(localMavenRepo, file))
    );
  }
  async extractCacheArchive(filePath) {
    if (!import_node_path11.default.isAbsolute(filePath))
      throw new Error("File path must be absolute");
    let localMavenRepo = _SpigotArtifactArchiver.determineLocalMavenRepositoryPath();
    await import_node_fs7.default.promises.mkdir(localMavenRepo, { recursive: !0 }), await extract({
      file: filePath,
      cwd: localMavenRepo
    });
  }
  async collectFilesFromMavenRepo(localMavenRepo, version2) {
    let files = [];
    for (let artifactDir of _SpigotArtifactArchiver.ARTIFACT_DIRS) {
      let artifactPath = import_node_path11.default.join(localMavenRepo, artifactDir, version2);
      import_node_fs7.default.existsSync(artifactPath) && files.push(artifactPath);
    }
    let spigotParentArtifactDir = import_node_path11.default.join(localMavenRepo, "org", "spigotmc", "spigot-parent", "dev-SNAPSHOT");
    return import_node_fs7.default.existsSync(spigotParentArtifactDir) && files.push(spigotParentArtifactDir), files;
  }
  static determineLocalMavenRepositoryPath() {
    return import_node_path11.default.join(import_node_os2.default.homedir(), ".m2", "repository");
  }
};

// src/cache/SpigotArtifactCache.ts
var SpigotArtifactCache = class _SpigotArtifactCache {
  artifactArchiver = new SpigotArtifactArchiver();
  sftpCache;
  constructor(host, port, username, privateKey, expectedHostKey) {
    host === "" ? this.sftpCache = null : this.sftpCache = new SFTPCache(host, port, username, privateKey, expectedHostKey);
  }
  async shutdown() {
    await this.sftpCache?.shutdown();
  }
  isSftpAvailable() {
    return this.sftpCache != null;
  }
  async fetchAndExtractCacheForVersionIfExists(version2, tmpDir, logInfo2, logError2) {
    if (this.sftpCache == null)
      throw new Error("Cache is not available");
    let cacheTmpFile = import_node_path12.default.join(tmpDir, `cache-${version2}`);
    try {
      let cacheFileSize = await this.sftpCache.getSizeOfCacheForVersion(version2);
      if (cacheFileSize !== null && logInfo2(`Downloading cache for version ${version2} from SFTP-Server (${_SpigotArtifactCache.prettifyFileSize(cacheFileSize)})...`), await this.sftpCache.fetchCacheForVersion(version2, cacheTmpFile))
        return await this.artifactArchiver.extractCacheArchive(cacheTmpFile), !0;
    } catch (err) {
      logError2(`Failed to fetch cache from SFTP-Server (version=${version2}): ${err?.toString()}`);
    } finally {
      await import_node_fs8.default.promises.rm(cacheTmpFile, { force: !0 });
    }
    return !1;
  }
  async createAndUploadCacheForVersion(version2, tmpDir, logInfo2, logError2) {
    if (this.sftpCache == null)
      throw new Error("Cache is not available");
    let cacheTmpFile = import_node_path12.default.join(tmpDir, `cache-${version2}`);
    try {
      return await this.artifactArchiver.createCacheArchiveForVersion(version2, cacheTmpFile), logInfo2(`Uploading cache for version ${version2} to SFTP-Server (${_SpigotArtifactCache.prettifyFileSize((await import_node_fs8.default.promises.stat(cacheTmpFile)).size)})...`), await this.sftpCache.uploadCacheForVersion(version2, cacheTmpFile), !0;
    } catch (err) {
      return logError2(`Failed to upload cache to SFTP-Server (version=${version2}): ${err?.toString()}`), !1;
    } finally {
      await import_node_fs8.default.promises.rm(cacheTmpFile, { force: !0 });
    }
  }
  static prettifyFileSize(bytes) {
    if (bytes < 0 || !Number.isFinite(bytes))
      throw new Error("The given bytes need to be a positive number");
    let base = 1024, units = ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"], i = Math.floor(Math.log(bytes) / Math.log(base));
    return i < 0 ? i = 0 : i >= units.length && (i = units.length - 1), (bytes / Math.pow(base, i)).toFixed(i > 0 ? 2 : 0) + " " + units[i];
  }
};

// src/utils.ts
var import_n_readlines = __toESM(require_readlines()), import_node_child_process2 = __toESM(require("node:child_process")), import_node_fs9 = __toESM(require("node:fs")), import_node_http = __toESM(require("node:http")), import_node_https = __toESM(require("node:https")), import_node_os3 = __toESM(require("node:os")), import_node_path13 = __toESM(require("node:path"));
var packageJson = JSON.parse(import_node_fs9.default.readFileSync(import_node_path13.default.join(__dirname, "..", "package.json"), "utf-8")), userAgent = `${packageJson.name || "Action-SpigotMC"}/${packageJson.version || "UNKNOWN_VERSION"} (+${packageJson.homepage || "https://github.com/SpraxDev/Action-SpigotMC"})`;
function fixArgArr(arr) {
  let result = [];
  for (let element of arr) {
    let newValue = element.trim();
    newValue && !result.includes(newValue) && result.push(newValue);
  }
  return result;
}
function isNumeric(str) {
  return /^[0-9]+$/.test(str);
}
async function runCmd(cmd, args, workingDir2, logStreamOrFile, silent = !1) {
  return new Promise((resolve2, reject) => {
    let closeLogStream = typeof logStreamOrFile == "string", logStream = typeof logStreamOrFile != "string" ? logStreamOrFile : import_node_fs9.default.createWriteStream(logStreamOrFile, { encoding: "utf-8", flags: "a" }), runningProcess = import_node_child_process2.default.spawn(cmd, args, { shell: !0, cwd: workingDir2, env: process.env });
    runningProcess.stdout.on("data", (data) => {
      logStream.write(data), silent || process.stdout.write(data);
    }), runningProcess.stderr.on("data", (data) => {
      logStream.write(data), silent || process.stderr.write(data);
    }), runningProcess.on("close", (code2) => {
      if (closeLogStream && logStream.close(), code2 != 0)
        return reject({ err: new Error(`process exited with code ${code2}`), cmd, workingDir: workingDir2 });
      resolve2();
    });
  });
}
async function downloadFile(url, dest, currRedirectDepth = 0) {
  let doGetRequest = url.toLowerCase().startsWith("http://") ? import_node_http.default.get : import_node_https.default.get;
  return new Promise((resolve2, reject) => {
    let writeStream = null, done = function(errored) {
      writeStream && (writeStream.close(), writeStream = null, errored && dest != null && import_node_fs9.default.rmSync(dest, { recursive: !0 }));
    };
    doGetRequest(url, {
      headers: {
        "User-Agent": userAgent
      }
    }, (httpRes) => {
      if (httpRes.statusCode != 200) {
        let locHeader = httpRes.headers.location;
        return currRedirectDepth < 12 && locHeader && (httpRes.statusCode == 301 || httpRes.statusCode == 302 || httpRes.statusCode == 303 || httpRes.statusCode == 307 || httpRes.statusCode == 308) ? (done(!1), /https?:\/\//g.test(locHeader) ? downloadFile(locHeader, dest, ++currRedirectDepth).then(resolve2).catch(reject) : reject(new Error(`Server responded with ${httpRes.statusCode} and a relative Location-Header value (${locHeader})`))) : (done(!0), reject(new Error(`Server responded with ${httpRes.statusCode}`)));
      }
      if (dest != null)
        writeStream = import_node_fs9.default.createWriteStream(dest, { encoding: "binary" }).on("finish", () => (done(!1), resolve2())).on("error", (err) => (done(!0), reject(err))), httpRes.pipe(writeStream);
      else {
        let chunks = [];
        httpRes.on("data", (chunk) => {
          chunks.push(Buffer.from(chunk, "binary"));
        }), httpRes.on("end", () => {
          resolve2(Buffer.concat(chunks));
        });
      }
    }).on("error", (err) => (done(!0), reject(err)));
  });
}
function readLastLines(file, lineCount, encoding = "utf-8") {
  let result = [], reader = new import_n_readlines.default(file), line;
  for (; line = reader.next(); )
    result.push(line.toString(encoding)), result.length > lineCount && result.shift();
  return result;
}
function resetWorkingDir() {
  let baseDir = import_node_path13.default.join(import_node_os3.default.tmpdir(), "SpraxDev-Action-SpigotMC"), cacheDir = import_node_path13.default.join(baseDir, "cache"), logDir = import_node_path13.default.join(baseDir, "logs");
  return import_node_fs9.default.rmSync(baseDir, { recursive: !0, force: !0 }), import_node_fs9.default.mkdirSync(cacheDir, { recursive: !0 }), import_node_fs9.default.mkdirSync(logDir, { recursive: !0 }), { base: baseDir, cache: cacheDir, logs: logDir };
}
function exit(code2, msg) {
  return msg && (typeof msg == "string" ? logInfo(msg) : logError(msg)), process.exit(code2);
}

// src/index.ts
var supportedBuildTools = {
  spigotmc: {
    url: "https://hub.spigotmc.org/jenkins/job/BuildTools/lastSuccessfulBuild/artifact/target/BuildTools.jar"
  }
}, buildToolProvider = (ActionsCore.getInput("buildToolProvider") || "SpigotMC").toLowerCase(), versions = fixArgArr((ActionsCore.getInput("versions") || "latest").toLowerCase().split(",")), generateSrc = ActionsCore.getInput("generateSrc") == "true", generateDoc = ActionsCore.getInput("generateDoc") == "true", disableJavaCheck = ActionsCore.getInput("disableJavaCheck") == "true", remapped = ActionsCore.getInput("remapped") == "true", finalJarOutputDir = ActionsCore.getInput("finalJarOutputDir") || "", forceRun = ActionsCore.getInput("forceRun") == "true", threadCount = isNumeric(ActionsCore.getInput("threads")) ? parseInt(ActionsCore.getInput("threads"), 10) : import_node_os4.default.cpus().length, sftpCacheHost = ActionsCore.getInput("sftpCacheHost") || "", sftpCachePort = isNumeric(ActionsCore.getInput("sftpCachePort")) ? parseInt(ActionsCore.getInput("sftpCachePort"), 10) : 22, sftpCacheUser = ActionsCore.getInput("sftpCacheUser") || "", sftpCachePrivateKey = ActionsCore.getInput("sftpCachePrivateKey") || "", sftpCacheExpectedHostKey = ActionsCore.getInput("sftpCacheExpectedHostKey")?.trim() || null, workingDir = resetWorkingDir(), appLogFile = import_node_path14.default.join(workingDir.logs, "SpraxDev_Actions-SpigotMC.log"), appLogStream = import_node_fs10.default.createWriteStream(appLogFile, {
  encoding: "utf-8",
  flags: "a"
  /* append */
}), spigotArtifactCache, requestedVersionToArtifactVersionMap = /* @__PURE__ */ new Map();
async function run() {
  return spigotArtifactCache = new SpigotArtifactCache(sftpCacheHost, sftpCachePort, sftpCacheUser, sftpCachePrivateKey, sftpCacheExpectedHostKey), spigotArtifactCache.isSftpAvailable() ? logInfo("SFTP-Cache is configured and will be used") : logInfo("SFTP-Cache is not configured and will not be used"), new Promise(async (resolve2, reject) => {
    try {
      if (versions.length == 0) return resolve2({ code: 0, msg: "No version(s) provided to build" });
      if (!Object.keys(supportedBuildTools).includes(buildToolProvider))
        return reject(new Error(`'${buildToolProvider}' is not a valid BuildTool-Provider (${Object.keys(supportedBuildTools).join(", ")})`));
      if (!forceRun && (versions = await removeExistingVersionsAndRestoreFromSftpCacheIfPossible(versions, remapped, (ver, jarPath) => {
        logInfo(`Skipping version '${ver}' because it has been found in the local maven repository: ${jarPath}`);
      }), versions.length == 0))
        return resolve2({ code: 0, msg: "No new versions to build" });
      let buildTool = supportedBuildTools[buildToolProvider];
      logInfo("Installed Java-Version:"), await runCmd("java", ["-version"], workingDir.base, appLogStream), logInfo(`
Downloading '${buildTool.url}'...`), await downloadFile(buildTool.url, import_node_path14.default.join(workingDir.cache, "BuildTools.jar"));
      let gotTemplateDirectory = versions.length != 1, buildToolsArgs = ["-jar", "BuildTools.jar", "--compile", "Spigot", "--nogui"];
      if (generateSrc && buildToolsArgs.push("--generate-source"), generateDoc && buildToolsArgs.push("--generate-docs"), disableJavaCheck && buildToolsArgs.push("--disable-java-check"), remapped && buildToolsArgs.push("--remapped"), finalJarOutputDir) {
        let outputDir = import_node_path14.default.isAbsolute(finalJarOutputDir) ? finalJarOutputDir : import_node_path14.default.resolve(finalJarOutputDir);
        import_node_fs10.default.existsSync(outputDir) || import_node_fs10.default.mkdirSync(outputDir, { recursive: !0 }), buildToolsArgs.push("--output-dir"), buildToolsArgs.push(import_node_path14.default.isAbsolute(finalJarOutputDir) ? finalJarOutputDir : import_node_path14.default.resolve(finalJarOutputDir));
      }
      let tasks = [];
      for (let ver of versions)
        tasks.push(async () => new Promise(async (resolveTask, rejectTask) => {
          let start = Date.now(), logFile = import_node_path14.default.join(workingDir.logs, `${ver}.log`);
          logInfo(`Building version '${ver}'...`);
          let versionDir = gotTemplateDirectory ? import_node_path14.default.join(workingDir.base, `${ver}`) : workingDir.cache;
          gotTemplateDirectory && await import_fs_extra.default.copy(workingDir.cache, versionDir);
          try {
            await runCmd("java", [...buildToolsArgs, "--rev", ver], versionDir, logFile, !0), gotTemplateDirectory && import_node_fs10.default.rmSync(versionDir, { recursive: !0 });
            let end = Date.now();
            if (logInfo(`Finished '${ver}' (${requestedVersionToArtifactVersionMap.get(ver)}) in ${((end - start) / 6e4).toFixed(2)} minutes`), spigotArtifactCache.isSftpAvailable() && requestedVersionToArtifactVersionMap.has(ver)) {
              let artifactVersion = requestedVersionToArtifactVersionMap.get(ver);
              await spigotArtifactCache.createAndUploadCacheForVersion(artifactVersion, workingDir.cache, logInfo, logError) && logInfo(`Uploaded cache for version '${ver}' (${artifactVersion}) to SFTP-Server`);
            }
            resolveTask();
          } catch (err) {
            logInfo(`An error occurred while building '${ver}'`), logError(err), logError(`
Printing last 30 lines from '${import_node_path14.default.resolve(logFile)}':`);
            for (let line of readLastLines(logFile, 30))
              logError(line);
            rejectTask(err);
          }
        }));
      import_async.default.parallelLimit(tasks, threadCount, (err) => {
        if (err) return reject(err);
        resolve2({ code: 0 });
      });
    } catch (err) {
      reject(err);
    }
  });
}
async function removeExistingVersionsAndRestoreFromSftpCacheIfPossible(versionArr, remapped2, onExist) {
  return new Promise(async (resolve2, _reject) => {
    let result = [];
    for (let ver of versionArr) {
      let skipVersion = !1, versionToCheck = ver != "latest" ? ver : null;
      try {
        let verJsonBuff = await downloadFile(`https://hub.spigotmc.org/versions/${ver}.json`, null), bukkitRef = (verJsonBuff instanceof Buffer ? JSON.parse(verJsonBuff.toString("utf-8")) : null)?.refs?.Bukkit;
        if (bukkitRef) {
          let verPomBuff = await downloadFile(`https://hub.spigotmc.org/stash/projects/SPIGOT/repos/bukkit/raw/pom.xml?at=${bukkitRef}`, null);
          verPomBuff instanceof Buffer && (versionToCheck = import_xml_js.default.xml2js(verPomBuff.toString("utf-8"), {
            compact: !0,
            ignoreComment: !0,
            ignoreAttributes: !0
          }).project?.version?._text, versionToCheck != null && requestedVersionToArtifactVersionMap.set(ver, versionToCheck));
        }
      } catch (err) {
        logError(err);
      }
      let jarPath = import_node_path14.default.resolve(import_node_path14.default.join(import_node_os4.default.homedir(), `/.m2/repository/org/spigotmc/spigot/${versionToCheck}/spigot-${versionToCheck}${remapped2 ? "-remapped-mojang" : ""}.jar`));
      versionToCheck && (skipVersion = import_node_fs10.default.existsSync(jarPath)), !skipVersion && spigotArtifactCache.isSftpAvailable() && (await spigotArtifactCache.fetchAndExtractCacheForVersionIfExists(versionToCheck ?? ver, workingDir.cache, logInfo, logError) ? (logInfo(`Restored version '${versionToCheck ?? ver}' (${ver}) from SFTP-Cache`), skipVersion = import_node_fs10.default.existsSync(jarPath)) : logInfo(`Version '${versionToCheck ?? ver}' (${ver}) not found in SFTP-Cache`)), skipVersion ? onExist(ver, jarPath) : result.push(ver);
    }
    resolve2(result);
  });
}
function logInfo(msg) {
  console.log(msg), appLogStream.write(msg + `
`);
}
function logError(msg) {
  typeof msg != "string" && (msg = JSON.stringify(msg, null, 2)), console.error(msg), appLogStream.write(msg + `
`);
}
var exitCode = 2, exitMessage;
run().then((result) => {
  exitCode = result.code, exitMessage = result.msg;
}).catch((err) => {
  exitCode = 1, exitMessage = err;
}).finally(async () => {
  await spigotArtifactCache?.shutdown(), exit(exitCode, exitMessage);
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  logError,
  logInfo
});
/*! Bundled license information:

undici/lib/fetch/body.js:
  (*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> *)

undici/lib/websocket/frame.js:
  (*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> *)

sax/lib/sax.js:
  (*! http://mths.be/fromcodepoint v0.1.0 by @mathias *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=index.js.map
